import { HttpClient } from "@effect/platform";
import * as effect from "effect/Effect";
import * as redacted from "effect/Redacted";
import * as S from "effect/Schema";
import * as stream from "effect/Stream";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { Credentials as Creds } from "../credentials.ts";
import type { CommonErrors } from "../errors.ts";
import type { Region } from "../region.ts";
import { SensitiveString, SensitiveBlob } from "../sensitive.ts";
const svc = T.AwsApiService({
  sdkId: "Connect",
  serviceShapeName: "AmazonConnectService",
});
const auth = T.AwsAuthSigv4({ name: "connect" });
const ver = T.ServiceVersion("2017-08-08");
const proto = T.AwsProtocolsRestJson1();
const rules = T.EndpointResolver((p, _) => {
  const { Region, UseDualStack = false, UseFIPS = false, Endpoint } = p;
  const e = (u: unknown, p = {}, h = {}): T.EndpointResolverResult => ({
    type: "endpoint" as const,
    endpoint: { url: u as string, properties: p, headers: h },
  });
  const err = (m: unknown): T.EndpointResolverResult => ({
    type: "error" as const,
    message: m as string,
  });
  if (Endpoint != null) {
    if (UseFIPS === true) {
      return err(
        "Invalid Configuration: FIPS and custom endpoint are not supported",
      );
    }
    if (UseDualStack === true) {
      return err(
        "Invalid Configuration: Dualstack and custom endpoint are not supported",
      );
    }
    return e(Endpoint);
  }
  if (Region != null) {
    {
      const PartitionResult = _.partition(Region);
      if (PartitionResult != null && PartitionResult !== false) {
        if (UseFIPS === true && UseDualStack === true) {
          if (
            true === _.getAttr(PartitionResult, "supportsFIPS") &&
            true === _.getAttr(PartitionResult, "supportsDualStack")
          ) {
            return e(
              `https://connect-fips.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "FIPS and DualStack are enabled, but this partition does not support one or both",
          );
        }
        if (UseFIPS === true) {
          if (_.getAttr(PartitionResult, "supportsFIPS") === true) {
            if (_.getAttr(PartitionResult, "name") === "aws-us-gov") {
              return e(`https://connect.${Region}.amazonaws.com`);
            }
            return e(
              `https://connect-fips.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
            );
          }
          return err(
            "FIPS is enabled but this partition does not support FIPS",
          );
        }
        if (UseDualStack === true) {
          if (true === _.getAttr(PartitionResult, "supportsDualStack")) {
            return e(
              `https://connect.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "DualStack is enabled but this partition does not support DualStack",
          );
        }
        return e(
          `https://connect.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
        );
      }
    }
  }
  return err("Invalid Configuration: Missing Region");
});

//# Newtypes
export type InstanceId = string;
export type ResourceId = string;
export type VersionNumber = number;
export type DataSetId = string;
export type AWSAccountId = string;
export type Origin = string;
export type ClientToken = string;
export type ContactId = string;
export type AgentResourceId = string;
export type VocabularyId = string;
export type EmailAddressId = string;
export type ARN = string;
export type FunctionArn = string;
export type PhoneNumberId = string;
export type ContactFlowId = string;
export type QueueId = string;
export type QuickConnectId = string;
export type RoutingProfileId = string;
export type PEM = string;
export type EntityArn = string;
export type TrafficDistributionGroupIdOrArn = string;
export type UserId = string;
export type WorkspaceId = string;
export type DataTableId = string;
export type FileId = string;
export type PhoneNumber = string;
export type PhoneNumberDescription = string;
export type AgentStatusName = string;
export type AgentStatusDescription = string;
export type AgentStatusOrderNumber = number;
export type ExpiryDurationInMinutes = number;
export type Name = string | redacted.Redacted<string>;
export type Description = string | redacted.Redacted<string>;
export type ContactFlowName = string;
export type ContactFlowDescription = string;
export type ContactFlowContent = string;
export type ContactFlowModuleName = string;
export type ContactFlowModuleDescription = string;
export type ContactFlowModuleContent = string;
export type FlowModuleSettings = string;
export type InstanceIdOrArn = string;
export type ContactFlowModuleId = string;
export type ResourceVersion = number;
export type ContactFlowModuleAlias = string;
export type FlowModuleContentSha256 = string;
export type FlowContentSha256 = string;
export type RegionName = string;
export type DataTableName = string;
export type DataTableDescription = string;
export type TimeZone = string;
export type EmailAddress = string | redacted.Redacted<string>;
export type EmailAddressDisplayName = string | redacted.Redacted<string>;
export type EvaluationFormTitle = string;
export type EvaluationFormDescription = string;
export type BoxedBoolean = boolean;
export type CommonNameLength127 = string;
export type HoursOfOperationDescription = string;
export type HoursOfOperationId = string;
export type CommonHumanReadableName = string;
export type CommonHumanReadableDescription = string;
export type HoursOfOperationOverrideYearMonthDayDateFormat = string;
export type DirectoryAlias = string | redacted.Redacted<string>;
export type DirectoryId = string;
export type InboundCallsEnabled = boolean;
export type OutboundCallsEnabled = boolean;
export type URI = string;
export type SourceApplicationName = string;
export type PredefinedAttributeName = string;
export type PredefinedAttributePurposeName = string;
export type PromptDescription = string;
export type S3Uri = string;
export type DeviceToken = string;
export type QueueDescription = string;
export type QueueMaxContacts = number;
export type QuickConnectName = string;
export type QuickConnectDescription = string;
export type RoutingProfileName = string;
export type RoutingProfileDescription = string;
export type RuleName = string;
export type RuleFunction = string;
export type CreateSecurityProfileName = string;
export type SecurityProfileDescription = string;
export type SecurityProfilePermission = string;
export type TagRestrictedResourceName = string;
export type HierarchyRestrictedResourceName = string;
export type HierarchyGroupId = string;
export type TaskTemplateName = string;
export type TaskTemplateDescription = string;
export type Name128 = string;
export type Description250 = string;
export type IntegrationAssociationId = string;
export type AgentUsername = string;
export type Password = string | redacted.Redacted<string>;
export type DirectoryUserId = string;
export type SecurityProfileId = string;
export type HierarchyGroupName = string;
export type ViewsInstanceId = string;
export type ViewsClientToken = string;
export type ViewDescription = string;
export type ViewName = string | redacted.Redacted<string>;
export type ViewId = string;
export type ViewContentSha256 = string;
export type VocabularyName = string;
export type VocabularyContent = string;
export type WorkspaceName = string;
export type WorkspaceDescription = string;
export type WorkspaceTitle = string;
export type Page = string;
export type Slug = string;
export type InputData = string;
export type HoursOfOperationOverrideId = string;
export type PromptId = string;
export type RegistrationId = string;
export type RuleId = string;
export type TaskTemplateId = string;
export type UseCaseId = string;
export type ViewVersion = number;
export type AgentStatusId = string;
export type AuthenticationProfileId = string;
export type AssociationId = string;
export type BotName = string;
export type LexRegion = string;
export type NextToken = string;
export type MaxResult100 = number;
export type URLExpiryInSeconds = number;
export type GroupingV2 = string;
export type NextToken2500 = string;
export type SnapshotVersion = string;
export type MediaSource = string;
export type MaxResult1000 = number;
export type MaxResult25 = number;
export type ListAssociatedContactsRequestMaxResults = number;
export type VocabularyNextToken = string;
export type MaxResult7 = number;
export type MaxResult10 = number;
export type LargeNextToken = string;
export type PhoneNumberPrefix = string;
export type MaxResult200 = number;
export type MaxResult2 = number;
export type ViewsNextToken = string;
export type MaxResults = number;
export type AwsRegion = string;
export type MaxResult500 = number;
export type SourceId = string;
export type DestinationId = string;
export type Subtype = string;
export type FileName = string;
export type FileSizeInBytes = number;
export type ChatDurationInMinutes = number;
export type SupportedMessagingContentType = string;
export type CustomerIdNonEmpty = string | redacted.Redacted<string>;
export type CampaignId = string;
export type RingTimeoutInSeconds = number;
export type StreamingId = string;
export type ContactTagKey = string;
export type TagKey = string;
export type UpdateAgentStatusDescription = string;
export type AuthenticationProfileName = string;
export type AuthenticationProfileDescription = string;
export type IpCidr = string;
export type AccessTokenDuration = number;
export type InactivityDuration = number;
export type QueueTimeAdjustmentSeconds = number;
export type QueuePriority = number;
export type UpdateHoursOfOperationDescription = string;
export type InstanceAttributeValue = string;
export type ParticipantToken = string;
export type AuthorizationCode = string | redacted.Redacted<string>;
export type AuthenticationError = string | redacted.Redacted<string>;
export type AuthenticationErrorDescription = string | redacted.Redacted<string>;
export type UpdateQuickConnectDescription = string;
export type AliasArn = string;
export type Priority = number;
export type Delay = number;
export type PredefinedAttributeStringValue = string;
export type ProficiencyLevel = number;
export type RequestIdentifier = string;
export type TagValue = string;
export type AttributeName = string;
export type AttributeValue = string;
export type ReferenceKey = string;
export type SegmentAttributeName = string;
export type LengthBoundary = number;
export type ValueBoundary = number;
export type PositiveAndNegativeDouble = number;
export type PositiveDouble = number;
export type DisplayName = string;
export type EnableValueValidationOnAssociation = boolean;
export type IncludeRawMessage = boolean;
export type OutboundCallerIdName = string;
export type Concurrency = number;
export type SecurityProfilePolicyKey = string;
export type SecurityProfilePolicyValue = string;
export type Namespace = string;
export type Permission = string;
export type FlowModuleId = string;
export type TaskTemplateFieldDescription = string;
export type TaskTemplateSingleSelectOption = string;
export type AgentFirstName = string | redacted.Redacted<string>;
export type AgentLastName = string | redacted.Redacted<string>;
export type Email = string | redacted.Redacted<string>;
export type AutoAccept = boolean;
export type AfterContactWorkTimeLimit = number;
export type PersistentConnection = boolean;
export type ViewTemplate = string;
export type ViewAction = string | redacted.Redacted<string>;
export type RoutingExpression = string;
export type ValidationTestType = string;
export type CurrentMetricId = string;
export type ResourceArnOrId = string;
export type MetricNameV2 = string;
export type MetricId = string;
export type ChatContentType = string;
export type ChatContent = string;
export type OutboundRequestId = string;
export type ChatStreamingEndpointARN = string;
export type PreSignedAttachmentUrl = string;
export type EndpointAddress = string;
export type MessageTemplateKnowledgeBaseId = string;
export type MessageTemplateId = string;
export type DisconnectReasonCode = string;
export type ContactTagValue = string;
export type Message = string;
export type EmailAddressArn = string;
export type TrafficDistributionGroupId = string;
export type TrafficDistributionGroupArn = string;
export type ISO8601Datetime = string;
export type Url = string;
export type PromptPresignedUrl = string;
export type TaskTemplateArn = string;
export type BucketName = string;
export type Prefix = string;
export type Hours = number;
export type ReferenceValue = string;
export type ReferenceArn = string;
export type ReferenceStatusReason = string;
export type SegmentAttributeValueString = string;
export type SegmentAttributeValueInteger = number;
export type EvaluationFormSectionTitle = string;
export type ReferenceId = string;
export type EvaluationFormQuestionInstructions = string;
export type EvaluationFormItemWeight = number;
export type EvaluationFormQuestionTitle = string;
export type Hours24Format = number;
export type MinutesLimit60 = number;
export type TaskNameExpression = string;
export type TaskDescriptionExpression = string;
export type EventBridgeActionName = string;
export type Subject = string;
export type Content = string;
export type TemplateId = string;
export type EvaluationFormId = string;
export type TaskTemplateFieldValue = string;
export type TaskTemplateFieldName = string;
export type ThresholdValue = number;
export type NullableProficiencyLimitValue = number;
export type DateTimeFormat = string;
export type SearchText = string | redacted.Redacted<string>;
export type DateYearMonthDayFormat = string;
export type TagKeyString = string;
export type TagValueString = string;
export type OutboundSubject = string | redacted.Redacted<string>;
export type Body = string | redacted.Redacted<string>;
export type EmailMessageContentType = string;
export type InboundSubject = string | redacted.Redacted<string>;
export type CustomerProfileAttributesSerialized = string;
export type EvaluationNoteString = string;
export type Percentage = number;
export type HierarchyLevelName = string;
export type WorkspaceErrorCode = string;
export type WorkspaceBatchErrorMessage = string;
export type ErrorCode = string;
export type ErrorMessage = string;
export type RefreshTokenDuration = number;
export type TotalPauseCount = number;
export type TotalPauseDurationInSeconds = number;
export type CustomerId = string;
export type DataTableVersion = string;
export type EvaluationFormVersionIsLocked = boolean;
export type GlobalSignInEndpoint = string;
export type SecurityProfileName = string;
export type InstanceArn = string;
export type HierarchyLevelId = string;
export type VocabularyLastModifiedTime = Date;
export type VocabularyFailureReason = string;
export type MetadataUrl = string;
export type SecurityToken = string | redacted.Redacted<string>;
export type HoursOfOperationName = string;
export type PromptName = string;
export type QueueName = string;
export type KeyId = string;
export type FieldValueId = string;
export type SlaName = string;
export type TargetSlaMinutes = number;
export type SearchableContactAttributeKey = string | redacted.Redacted<string>;
export type SearchableContactAttributeValue =
  | string
  | redacted.Redacted<string>;
export type SearchableSegmentAttributeKey = string | redacted.Redacted<string>;
export type SearchableSegmentAttributeValue =
  | string
  | redacted.Redacted<string>;
export type EmailHeaderValue = string;
export type EvaluationAnswerDataStringValue = string;
export type EvaluationAnswerDataNumericValue = number;
export type DurationInSeconds = number;
export type ApproximateTotalCount = number;
export type NewChatCreated = boolean;
export type ParticipantId = string;
export type ViewInputSchema = string | redacted.Redacted<string>;
export type AgentPauseDurationInSeconds = number;
export type Duration = number;
export type EndpointDisplayName = string;
export type Index = number;
export type PotentialDisconnectIssue = string;
export type RecordingLocation = string;
export type FragmentNumber = string;
export type RecordingDeletionReason = string;
export type UnprocessedTranscriptLocation = string;
export type EvaluationId = string;
export type ContactDetailName = string;
export type ContactDetailDescription = string;
export type ActiveRegion = string;
export type OriginRegion = string;
export type ReplicationStatusReason = string;
export type PhoneNumberWorkflowMessage = string;
export type IsReadOnly = boolean;
export type EvaluationScorePercentage = number;
export type EvaluationAcknowledgerCommentString = string;
export type RealTimeContactAnalysisId256 = string;
export type RealTimeContactAnalysisTranscriptContent = string;
export type RealTimeContactAnalysisContentType = string;
export type RealTimeContactAnalysisEventType = string;
export type RealTimeContactAnalysisPostContactSummaryContent = string;
export type FieldStringValue = string;
export type PrimaryAttributeContextKeyName = string;
export type IAMRestrictedPrimaryValue = string;
export type ThemeString = string;
export type ThemeImageLink = string;
export type ProficiencyValue = string;
export type NullableProficiencyLevel = number;
export type ComparisonOperator = string;
export type ParticipantTimerDurationInMinutes = number;
export type WorkspaceAssociatedResourceId = string;
export type WorkspaceAssociatedResourceType = string;
export type WorkspaceAssociatedResourceName = string;
export type ProblemMessageString = string;
export type PlatformName = string;
export type PlatformVersion = string;
export type OperatingSystem = string;
export type AiAgentVersionId = string;
export type Count = number;
export type DurationMillis = number;
export type FormId = string;
export type EvaluationArn = string;
export type ExportLocation = string;
export type RealTimeContactAnalysisTimeInstant = Date;
export type RealTimeContactAnalysisCategoryName = string;
export type AttachmentName = string;
export type ContentType = string;
export type ArtifactId = string;
export type EvaluationFormQuestionAnswerScore = number;
export type EvaluationFormSingleSelectQuestionOptionText = string;
export type EvaluationFormMultiSelectQuestionOptionText = string;
export type PostAcceptPreviewTimeoutDurationInSeconds = number;
export type Value = number;
export type UrlMetadataSignedHeadersKey = string;
export type UrlMetadataSignedHeadersValue = string;
export type AttendeeId = string;
export type JoinToken = string | redacted.Redacted<string>;
export type MediaRegion = string;
export type MeetingId = string;
export type AudioQualityScore = number;
export type PotentialAudioQualityIssue = string;
export type RealTimeContactAnalysisOffset = number;
export type AgentId = string;
export type SingleSelectQuestionRuleCategoryAutomationLabel = string;
export type MultiSelectQuestionRuleCategoryAutomationLabel = string;
export type IntegerCount = number;
export type DimensionsV2Key = string;
export type DimensionsV2Value = string;
export type EvaluationSuggestedAnswerJustification = string;
export type TotalCount = number;
export type EvaluationSuggestedAnswerTranscriptSegment = string;
export type QuestionRuleCategoryAutomationLabel = string;
export type EvaluationSuggestedAnswerTranscriptMillisOffset = number;

//# Schemas
export type VocabularyLanguageCode =
  | "ar-AE"
  | "de-CH"
  | "de-DE"
  | "en-AB"
  | "en-AU"
  | "en-GB"
  | "en-IE"
  | "en-IN"
  | "en-US"
  | "en-WL"
  | "es-ES"
  | "es-US"
  | "fr-CA"
  | "fr-FR"
  | "hi-IN"
  | "it-IT"
  | "ja-JP"
  | "ko-KR"
  | "pt-BR"
  | "pt-PT"
  | "zh-CN"
  | "en-NZ"
  | "en-ZA"
  | "ca-ES"
  | "da-DK"
  | "fi-FI"
  | "id-ID"
  | "ms-MY"
  | "nl-NL"
  | "no-NO"
  | "pl-PL"
  | "sv-SE"
  | "tl-PH"
  | (string & {});
export const VocabularyLanguageCode = S.String;
export type FlowAssociationResourceType =
  | "SMS_PHONE_NUMBER"
  | "INBOUND_EMAIL"
  | "OUTBOUND_EMAIL"
  | "ANALYTICS_CONNECTOR"
  | "WHATSAPP_MESSAGING_PHONE_NUMBER"
  | (string & {});
export const FlowAssociationResourceType = S.String;
export type InstanceStorageResourceType =
  | "CHAT_TRANSCRIPTS"
  | "CALL_RECORDINGS"
  | "SCHEDULED_REPORTS"
  | "MEDIA_STREAMS"
  | "CONTACT_TRACE_RECORDS"
  | "AGENT_EVENTS"
  | "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
  | "ATTACHMENTS"
  | "CONTACT_EVALUATIONS"
  | "SCREEN_RECORDINGS"
  | "REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS"
  | "REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS"
  | "EMAIL_MESSAGES"
  | (string & {});
export const InstanceStorageResourceType = S.String;
export type QuickConnectsList = string[];
export const QuickConnectsList = S.Array(S.String);
export type EntityType = "USER" | "AI_AGENT" | (string & {});
export const EntityType = S.String;
export type WorkspaceResourceArnList = string[];
export const WorkspaceResourceArnList = S.Array(S.String);
export type DataSetIds = string[];
export const DataSetIds = S.Array(S.String);
export type FileIdList = string[];
export const FileIdList = S.Array(S.String);
export type ResourceArnListMaxLimit100 = string[];
export const ResourceArnListMaxLimit100 = S.Array(S.String);
export type ListFlowAssociationResourceType =
  | "WHATSAPP_MESSAGING_PHONE_NUMBER"
  | "VOICE_PHONE_NUMBER"
  | "INBOUND_EMAIL"
  | "OUTBOUND_EMAIL"
  | "ANALYTICS_CONNECTOR"
  | (string & {});
export const ListFlowAssociationResourceType = S.String;
export type AgentStatusState = "ENABLED" | "DISABLED" | (string & {});
export const AgentStatusState = S.String;
export type Channel = "VOICE" | "CHAT" | "TASK" | "EMAIL" | (string & {});
export const Channel = S.String;
export type ContactInitiationMethod =
  | "INBOUND"
  | "OUTBOUND"
  | "TRANSFER"
  | "QUEUE_TRANSFER"
  | "CALLBACK"
  | "API"
  | "DISCONNECT"
  | "MONITOR"
  | "EXTERNAL_OUTBOUND"
  | "WEBRTC_API"
  | "AGENT_REPLY"
  | "FLOW"
  | (string & {});
export const ContactInitiationMethod = S.String;
export type InitiateAs = "CONNECTED_TO_USER" | "COMPLETED" | (string & {});
export const InitiateAs = S.String;
export type ContactFlowType =
  | "CONTACT_FLOW"
  | "CUSTOMER_QUEUE"
  | "CUSTOMER_HOLD"
  | "CUSTOMER_WHISPER"
  | "AGENT_HOLD"
  | "AGENT_WHISPER"
  | "OUTBOUND_WHISPER"
  | "AGENT_TRANSFER"
  | "QUEUE_TRANSFER"
  | "CAMPAIGN"
  | (string & {});
export const ContactFlowType = S.String;
export type ContactFlowStatus = "PUBLISHED" | "SAVED" | (string & {});
export const ContactFlowStatus = S.String;
export type DataTableLockLevel =
  | "NONE"
  | "DATA_TABLE"
  | "PRIMARY_VALUE"
  | "ATTRIBUTE"
  | "VALUE"
  | (string & {});
export const DataTableLockLevel = S.String;
export type DataTableStatus = "PUBLISHED" | (string & {});
export const DataTableStatus = S.String;
export type DataTableAttributeValueType =
  | "TEXT"
  | "NUMBER"
  | "BOOLEAN"
  | "TEXT_LIST"
  | "NUMBER_LIST"
  | (string & {});
export const DataTableAttributeValueType = S.String;
export type DirectoryType =
  | "SAML"
  | "CONNECT_MANAGED"
  | "EXISTING_DIRECTORY"
  | (string & {});
export const DirectoryType = S.String;
export type IntegrationType =
  | "EVENT"
  | "VOICE_ID"
  | "PINPOINT_APP"
  | "WISDOM_ASSISTANT"
  | "WISDOM_KNOWLEDGE_BASE"
  | "WISDOM_QUICK_RESPONSES"
  | "Q_MESSAGE_TEMPLATES"
  | "CASES_DOMAIN"
  | "APPLICATION"
  | "FILE_SCANNER"
  | "SES_IDENTITY"
  | "ANALYTICS_CONNECTOR"
  | "CALL_TRANSFER_CONNECTOR"
  | "COGNITO_USER_POOL"
  | "MESSAGE_PROCESSOR"
  | (string & {});
export const IntegrationType = S.String;
export type SourceType = "SALESFORCE" | "ZENDESK" | "CASES" | (string & {});
export const SourceType = S.String;
export type RehydrationType =
  | "ENTIRE_PAST_SESSION"
  | "FROM_SEGMENT"
  | (string & {});
export const RehydrationType = S.String;
export type PredefinedAttributePurposeNameList = string[];
export const PredefinedAttributePurposeNameList = S.Array(S.String);
export type DeviceType = "GCM" | "APNS" | "APNS_SANDBOX" | (string & {});
export const DeviceType = S.String;
export type AgentAvailabilityTimer =
  | "TIME_SINCE_LAST_ACTIVITY"
  | "TIME_SINCE_LAST_INBOUND"
  | (string & {});
export const AgentAvailabilityTimer = S.String;
export type RulePublishStatus = "DRAFT" | "PUBLISHED" | (string & {});
export const RulePublishStatus = S.String;
export type PermissionsList = string[];
export const PermissionsList = S.Array(S.String);
export type TagRestrictedResourceList = string[];
export const TagRestrictedResourceList = S.Array(S.String);
export type HierarchyRestrictedResourceList = string[];
export const HierarchyRestrictedResourceList = S.Array(S.String);
export type TaskTemplateStatus = "ACTIVE" | "INACTIVE" | (string & {});
export const TaskTemplateStatus = S.String;
export type UseCaseType =
  | "RULES_EVALUATION"
  | "CONNECT_CAMPAIGNS"
  | (string & {});
export const UseCaseType = S.String;
export type SecurityProfileIds = string[];
export const SecurityProfileIds = S.Array(S.String);
export type ViewStatus = "PUBLISHED" | "SAVED" | (string & {});
export const ViewStatus = S.String;
export type MediaType =
  | "IMAGE_LOGO_LIGHT_FAVICON"
  | "IMAGE_LOGO_DARK_FAVICON"
  | "IMAGE_LOGO_LIGHT_HORIZONTAL"
  | "IMAGE_LOGO_DARK_HORIZONTAL"
  | (string & {});
export const MediaType = S.String;
export type InstanceAttributeType =
  | "INBOUND_CALLS"
  | "OUTBOUND_CALLS"
  | "CONTACTFLOW_LOGS"
  | "CONTACT_LENS"
  | "AUTO_RESOLVE_BEST_VOICES"
  | "USE_CUSTOM_TTS_VOICES"
  | "EARLY_MEDIA"
  | "MULTI_PARTY_CONFERENCE"
  | "HIGH_VOLUME_OUTBOUND"
  | "ENHANCED_CONTACT_MONITORING"
  | "ENHANCED_CHAT_MONITORING"
  | "MULTI_PARTY_CHAT_CONFERENCE"
  | "MESSAGE_STREAMING"
  | (string & {});
export const InstanceAttributeType = S.String;
export type Grouping =
  | "QUEUE"
  | "CHANNEL"
  | "ROUTING_PROFILE"
  | "ROUTING_STEP_EXPRESSION"
  | "AGENT_STATUS"
  | "SUBTYPE"
  | "VALIDATION_TEST_TYPE"
  | (string & {});
export const Grouping = S.String;
export type Groupings = Grouping[];
export const Groupings = S.Array(Grouping);
export type GroupingsV2 = string[];
export const GroupingsV2 = S.Array(S.String);
export type AgentStatusType = "ROUTABLE" | "CUSTOM" | "OFFLINE" | (string & {});
export const AgentStatusType = S.String;
export type AgentStatusTypes = AgentStatusType[];
export const AgentStatusTypes = S.Array(AgentStatusType);
export type LexVersion = "V1" | "V2" | (string & {});
export const LexVersion = S.String;
export type ContactFlowModuleState = "ACTIVE" | "ARCHIVED" | (string & {});
export const ContactFlowModuleState = S.String;
export type ContactFlowTypes = ContactFlowType[];
export const ContactFlowTypes = S.Array(ContactFlowType);
export type ReferenceType =
  | "URL"
  | "ATTACHMENT"
  | "CONTACT_ANALYSIS"
  | "NUMBER"
  | "STRING"
  | "DATE"
  | "EMAIL"
  | "EMAIL_MESSAGE"
  | "EMAIL_MESSAGE_PLAIN_TEXT"
  | (string & {});
export const ReferenceType = S.String;
export type ReferenceTypes = ReferenceType[];
export const ReferenceTypes = S.Array(ReferenceType);
export type AttributeIds = string[];
export const AttributeIds = S.Array(S.String);
export type RecordIds = string[];
export const RecordIds = S.Array(S.String);
export type PhoneNumberType =
  | "TOLL_FREE"
  | "DID"
  | "UIFN"
  | "SHARED"
  | "THIRD_PARTY_TF"
  | "THIRD_PARTY_DID"
  | "SHORT_CODE"
  | (string & {});
export const PhoneNumberType = S.String;
export type PhoneNumberTypes = PhoneNumberType[];
export const PhoneNumberTypes = S.Array(PhoneNumberType);
export type PhoneNumberCountryCode =
  | "AF"
  | "AL"
  | "DZ"
  | "AS"
  | "AD"
  | "AO"
  | "AI"
  | "AQ"
  | "AG"
  | "AR"
  | "AM"
  | "AW"
  | "AU"
  | "AT"
  | "AZ"
  | "BS"
  | "BH"
  | "BD"
  | "BB"
  | "BY"
  | "BE"
  | "BZ"
  | "BJ"
  | "BM"
  | "BT"
  | "BO"
  | "BA"
  | "BW"
  | "BR"
  | "IO"
  | "VG"
  | "BN"
  | "BG"
  | "BF"
  | "BI"
  | "KH"
  | "CM"
  | "CA"
  | "CV"
  | "KY"
  | "CF"
  | "TD"
  | "CL"
  | "CN"
  | "CX"
  | "CC"
  | "CO"
  | "KM"
  | "CK"
  | "CR"
  | "HR"
  | "CU"
  | "CW"
  | "CY"
  | "CZ"
  | "CD"
  | "DK"
  | "DJ"
  | "DM"
  | "DO"
  | "TL"
  | "EC"
  | "EG"
  | "SV"
  | "GQ"
  | "ER"
  | "EE"
  | "ET"
  | "FK"
  | "FO"
  | "FJ"
  | "FI"
  | "FR"
  | "PF"
  | "GA"
  | "GM"
  | "GE"
  | "DE"
  | "GH"
  | "GI"
  | "GR"
  | "GL"
  | "GD"
  | "GU"
  | "GT"
  | "GG"
  | "GN"
  | "GW"
  | "GY"
  | "HT"
  | "HN"
  | "HK"
  | "HU"
  | "IS"
  | "IN"
  | "ID"
  | "IR"
  | "IQ"
  | "IE"
  | "IM"
  | "IL"
  | "IT"
  | "CI"
  | "JM"
  | "JP"
  | "JE"
  | "JO"
  | "KZ"
  | "KE"
  | "KI"
  | "KW"
  | "KG"
  | "LA"
  | "LV"
  | "LB"
  | "LS"
  | "LR"
  | "LY"
  | "LI"
  | "LT"
  | "LU"
  | "MO"
  | "MK"
  | "MG"
  | "MW"
  | "MY"
  | "MV"
  | "ML"
  | "MT"
  | "MH"
  | "MR"
  | "MU"
  | "YT"
  | "MX"
  | "FM"
  | "MD"
  | "MC"
  | "MN"
  | "ME"
  | "MS"
  | "MA"
  | "MZ"
  | "MM"
  | "NA"
  | "NR"
  | "NP"
  | "NL"
  | "AN"
  | "NC"
  | "NZ"
  | "NI"
  | "NE"
  | "NG"
  | "NU"
  | "KP"
  | "MP"
  | "NO"
  | "OM"
  | "PK"
  | "PW"
  | "PA"
  | "PG"
  | "PY"
  | "PE"
  | "PH"
  | "PN"
  | "PL"
  | "PT"
  | "PR"
  | "QA"
  | "CG"
  | "RE"
  | "RO"
  | "RU"
  | "RW"
  | "BL"
  | "SH"
  | "KN"
  | "LC"
  | "MF"
  | "PM"
  | "VC"
  | "WS"
  | "SM"
  | "ST"
  | "SA"
  | "SN"
  | "RS"
  | "SC"
  | "SL"
  | "SG"
  | "SX"
  | "SK"
  | "SI"
  | "SB"
  | "SO"
  | "ZA"
  | "KR"
  | "ES"
  | "LK"
  | "SD"
  | "SR"
  | "SJ"
  | "SZ"
  | "SE"
  | "CH"
  | "SY"
  | "TW"
  | "TJ"
  | "TZ"
  | "TH"
  | "TG"
  | "TK"
  | "TO"
  | "TT"
  | "TN"
  | "TR"
  | "TM"
  | "TC"
  | "TV"
  | "VI"
  | "UG"
  | "UA"
  | "AE"
  | "GB"
  | "US"
  | "UY"
  | "UZ"
  | "VU"
  | "VA"
  | "VE"
  | "VN"
  | "WF"
  | "EH"
  | "YE"
  | "ZM"
  | "ZW"
  | (string & {});
export const PhoneNumberCountryCode = S.String;
export type PhoneNumberCountryCodes = PhoneNumberCountryCode[];
export const PhoneNumberCountryCodes = S.Array(PhoneNumberCountryCode);
export type QueueType = "STANDARD" | "AGENT" | (string & {});
export const QueueType = S.String;
export type QueueTypes = QueueType[];
export const QueueTypes = S.Array(QueueType);
export type QuickConnectType =
  | "USER"
  | "QUEUE"
  | "PHONE_NUMBER"
  | "FLOW"
  | (string & {});
export const QuickConnectType = S.String;
export type QuickConnectTypes = QuickConnectType[];
export const QuickConnectTypes = S.Array(QuickConnectType);
export type RealTimeContactAnalysisOutputType =
  | "Raw"
  | "Redacted"
  | (string & {});
export const RealTimeContactAnalysisOutputType = S.String;
export type RealTimeContactAnalysisSegmentType =
  | "Transcript"
  | "Categories"
  | "Issues"
  | "Event"
  | "Attachments"
  | "PostContactSummary"
  | (string & {});
export const RealTimeContactAnalysisSegmentType = S.String;
export type RealTimeContactAnalysisSegmentTypes =
  RealTimeContactAnalysisSegmentType[];
export const RealTimeContactAnalysisSegmentTypes = S.Array(
  RealTimeContactAnalysisSegmentType,
);
export type EventSourceName =
  | "OnPostCallAnalysisAvailable"
  | "OnRealTimeCallAnalysisAvailable"
  | "OnRealTimeChatAnalysisAvailable"
  | "OnPostChatAnalysisAvailable"
  | "OnZendeskTicketCreate"
  | "OnZendeskTicketStatusUpdate"
  | "OnSalesforceCaseCreate"
  | "OnContactEvaluationSubmit"
  | "OnMetricDataUpdate"
  | "OnCaseCreate"
  | "OnCaseUpdate"
  | "OnSlaBreach"
  | (string & {});
export const EventSourceName = S.String;
export type ViewType = "CUSTOMER_MANAGED" | "AWS_MANAGED" | (string & {});
export const ViewType = S.String;
export type MonitorCapability = "SILENT_MONITOR" | "BARGE" | (string & {});
export const MonitorCapability = S.String;
export type AllowedMonitorCapabilities = MonitorCapability[];
export const AllowedMonitorCapabilities = S.Array(MonitorCapability);
export type ContactRecordingType = "AGENT" | "IVR" | "SCREEN" | (string & {});
export const ContactRecordingType = S.String;
export type ResourceTypeList = string[];
export const ResourceTypeList = S.Array(S.String);
export type VocabularyState =
  | "CREATION_IN_PROGRESS"
  | "ACTIVE"
  | "CREATION_FAILED"
  | "DELETE_IN_PROGRESS"
  | (string & {});
export const VocabularyState = S.String;
export type TrafficType = "GENERAL" | "CAMPAIGN" | (string & {});
export const TrafficType = S.String;
export type FileUseCaseType = "EMAIL_MESSAGE" | "ATTACHMENT" | (string & {});
export const FileUseCaseType = S.String;
export type SupportedMessagingContentTypes = string[];
export const SupportedMessagingContentTypes = S.Array(S.String);
export type DisconnectOnCustomerExitParticipantType = "AGENT" | (string & {});
export const DisconnectOnCustomerExitParticipantType = S.String;
export type DisconnectOnCustomerExit =
  DisconnectOnCustomerExitParticipantType[];
export const DisconnectOnCustomerExit = S.Array(
  DisconnectOnCustomerExitParticipantType,
);
export type ContactMediaProcessingFailureMode =
  | "DELIVER_UNPROCESSED_MESSAGE"
  | "DO_NOT_DELIVER_UNPROCESSED_MESSAGE"
  | (string & {});
export const ContactMediaProcessingFailureMode = S.String;
export type ContactTagKeys = string[];
export const ContactTagKeys = S.Array(S.String);
export type TagKeyList = string[];
export const TagKeyList = S.Array(S.String);
export type IpCidrList = string[];
export const IpCidrList = S.Array(S.String);
export type ContactFlowState = "ACTIVE" | "ARCHIVED" | (string & {});
export const ContactFlowState = S.String;
export type QueueStatus = "ENABLED" | "DISABLED" | (string & {});
export const QueueStatus = S.String;
export type Visibility = "ALL" | "ASSIGNED" | "NONE" | (string & {});
export const Visibility = S.String;
export interface ActivateEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
}
export const ActivateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}/activate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ActivateEvaluationFormRequest",
}) as any as S.Schema<ActivateEvaluationFormRequest>;
export interface AssociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetId: string;
  TargetAccountId?: string;
}
export const AssociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetId: S.String,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/analytics-data/instance/{InstanceId}/association",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateAnalyticsDataSetRequest",
}) as any as S.Schema<AssociateAnalyticsDataSetRequest>;
export interface AssociateApprovedOriginRequest {
  InstanceId: string;
  Origin: string;
  ClientToken?: string;
}
export const AssociateApprovedOriginRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Origin: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/approved-origin" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateApprovedOriginRequest",
}) as any as S.Schema<AssociateApprovedOriginRequest>;
export interface AssociateApprovedOriginResponse {}
export const AssociateApprovedOriginResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateApprovedOriginResponse",
}) as any as S.Schema<AssociateApprovedOriginResponse>;
export interface AssociateContactWithUserRequest {
  InstanceId: string;
  ContactId: string;
  UserId: string;
}
export const AssociateContactWithUserRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    UserId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contacts/{InstanceId}/{ContactId}/associate-user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateContactWithUserRequest",
}) as any as S.Schema<AssociateContactWithUserRequest>;
export interface AssociateContactWithUserResponse {}
export const AssociateContactWithUserResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateContactWithUserResponse",
}) as any as S.Schema<AssociateContactWithUserResponse>;
export interface AssociateDefaultVocabularyRequest {
  InstanceId: string;
  LanguageCode: VocabularyLanguageCode;
  VocabularyId?: string;
}
export const AssociateDefaultVocabularyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LanguageCode: VocabularyLanguageCode.pipe(T.HttpLabel("LanguageCode")),
    VocabularyId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/default-vocabulary/{InstanceId}/{LanguageCode}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateDefaultVocabularyRequest",
}) as any as S.Schema<AssociateDefaultVocabularyRequest>;
export interface AssociateDefaultVocabularyResponse {}
export const AssociateDefaultVocabularyResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateDefaultVocabularyResponse",
}) as any as S.Schema<AssociateDefaultVocabularyResponse>;
export interface AssociateFlowRequest {
  InstanceId: string;
  ResourceId: string;
  FlowId: string;
  ResourceType: FlowAssociationResourceType;
}
export const AssociateFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceId: S.String,
    FlowId: S.String,
    ResourceType: FlowAssociationResourceType,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/flow-associations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateFlowRequest",
}) as any as S.Schema<AssociateFlowRequest>;
export interface AssociateFlowResponse {}
export const AssociateFlowResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "AssociateFlowResponse",
}) as any as S.Schema<AssociateFlowResponse>;
export interface AssociateLambdaFunctionRequest {
  InstanceId: string;
  FunctionArn: string;
  ClientToken?: string;
}
export const AssociateLambdaFunctionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FunctionArn: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/lambda-function" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateLambdaFunctionRequest",
}) as any as S.Schema<AssociateLambdaFunctionRequest>;
export interface AssociateLambdaFunctionResponse {}
export const AssociateLambdaFunctionResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateLambdaFunctionResponse",
}) as any as S.Schema<AssociateLambdaFunctionResponse>;
export interface LexBot {
  Name: string;
  LexRegion: string;
}
export const LexBot = S.suspend(() =>
  S.Struct({ Name: S.String, LexRegion: S.String }),
).annotations({ identifier: "LexBot" }) as any as S.Schema<LexBot>;
export interface AssociateLexBotRequest {
  InstanceId: string;
  LexBot: LexBot;
  ClientToken?: string;
}
export const AssociateLexBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LexBot: LexBot,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/lex-bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateLexBotRequest",
}) as any as S.Schema<AssociateLexBotRequest>;
export interface AssociateLexBotResponse {}
export const AssociateLexBotResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateLexBotResponse",
}) as any as S.Schema<AssociateLexBotResponse>;
export interface AssociatePhoneNumberContactFlowRequest {
  PhoneNumberId: string;
  InstanceId: string;
  ContactFlowId: string;
}
export const AssociatePhoneNumberContactFlowRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    InstanceId: S.String,
    ContactFlowId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/phone-number/{PhoneNumberId}/contact-flow",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociatePhoneNumberContactFlowRequest",
}) as any as S.Schema<AssociatePhoneNumberContactFlowRequest>;
export interface AssociatePhoneNumberContactFlowResponse {}
export const AssociatePhoneNumberContactFlowResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociatePhoneNumberContactFlowResponse",
}) as any as S.Schema<AssociatePhoneNumberContactFlowResponse>;
export interface AssociateQueueQuickConnectsRequest {
  InstanceId: string;
  QueueId: string;
  QuickConnectIds: string[];
}
export const AssociateQueueQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    QuickConnectIds: QuickConnectsList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/associate-quick-connects",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateQueueQuickConnectsRequest",
}) as any as S.Schema<AssociateQueueQuickConnectsRequest>;
export interface AssociateQueueQuickConnectsResponse {}
export const AssociateQueueQuickConnectsResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateQueueQuickConnectsResponse",
}) as any as S.Schema<AssociateQueueQuickConnectsResponse>;
export interface AssociateSecurityKeyRequest {
  InstanceId: string;
  Key: string;
  ClientToken?: string;
}
export const AssociateSecurityKeyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Key: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/security-key" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateSecurityKeyRequest",
}) as any as S.Schema<AssociateSecurityKeyRequest>;
export interface AssociateTrafficDistributionGroupUserRequest {
  TrafficDistributionGroupId: string;
  UserId: string;
  InstanceId: string;
}
export const AssociateTrafficDistributionGroupUserRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
    UserId: S.String,
    InstanceId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}/user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateTrafficDistributionGroupUserRequest",
}) as any as S.Schema<AssociateTrafficDistributionGroupUserRequest>;
export interface AssociateTrafficDistributionGroupUserResponse {}
export const AssociateTrafficDistributionGroupUserResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateTrafficDistributionGroupUserResponse",
}) as any as S.Schema<AssociateTrafficDistributionGroupUserResponse>;
export interface AssociateWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
  ResourceArns: string[];
}
export const AssociateWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    ResourceArns: WorkspaceResourceArnList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/associate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateWorkspaceRequest",
}) as any as S.Schema<AssociateWorkspaceRequest>;
export interface BatchAssociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetIds: string[];
  TargetAccountId?: string;
}
export const BatchAssociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetIds: DataSetIds,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/analytics-data/instance/{InstanceId}/associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchAssociateAnalyticsDataSetRequest",
}) as any as S.Schema<BatchAssociateAnalyticsDataSetRequest>;
export interface BatchDisassociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetIds: string[];
  TargetAccountId?: string;
}
export const BatchDisassociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetIds: DataSetIds,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/analytics-data/instance/{InstanceId}/associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchDisassociateAnalyticsDataSetRequest",
}) as any as S.Schema<BatchDisassociateAnalyticsDataSetRequest>;
export interface BatchGetAttachedFileMetadataRequest {
  FileIds: string[];
  InstanceId: string;
  AssociatedResourceArn: string;
}
export const BatchGetAttachedFileMetadataRequest = S.suspend(() =>
  S.Struct({
    FileIds: FileIdList,
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/attached-files/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchGetAttachedFileMetadataRequest",
}) as any as S.Schema<BatchGetAttachedFileMetadataRequest>;
export interface BatchGetFlowAssociationRequest {
  InstanceId: string;
  ResourceIds: string[];
  ResourceType?: ListFlowAssociationResourceType;
}
export const BatchGetFlowAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceIds: ResourceArnListMaxLimit100,
    ResourceType: S.optional(ListFlowAssociationResourceType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/flow-associations-batch/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchGetFlowAssociationRequest",
}) as any as S.Schema<BatchGetFlowAssociationRequest>;
export interface PrimaryValue {
  AttributeName: string;
  Value: string;
}
export const PrimaryValue = S.suspend(() =>
  S.Struct({ AttributeName: S.String, Value: S.String }),
).annotations({ identifier: "PrimaryValue" }) as any as S.Schema<PrimaryValue>;
export type PrimaryValuesSet = PrimaryValue[];
export const PrimaryValuesSet = S.Array(PrimaryValue);
export interface DataTableLockVersion {
  DataTable?: string;
  Attribute?: string;
  PrimaryValues?: string;
  Value?: string;
}
export const DataTableLockVersion = S.suspend(() =>
  S.Struct({
    DataTable: S.optional(S.String),
    Attribute: S.optional(S.String),
    PrimaryValues: S.optional(S.String),
    Value: S.optional(S.String),
  }),
).annotations({
  identifier: "DataTableLockVersion",
}) as any as S.Schema<DataTableLockVersion>;
export interface DataTableValue {
  PrimaryValues?: PrimaryValue[];
  AttributeName: string;
  Value: string;
  LockVersion?: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const DataTableValue = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeName: S.String,
    Value: S.String,
    LockVersion: S.optional(DataTableLockVersion),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "DataTableValue",
}) as any as S.Schema<DataTableValue>;
export type DataTableValueList = DataTableValue[];
export const DataTableValueList = S.Array(DataTableValue);
export interface BatchUpdateDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValue[];
}
export const BatchUpdateDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/update",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchUpdateDataTableValueRequest",
}) as any as S.Schema<BatchUpdateDataTableValueRequest>;
export interface CompleteAttachedFileUploadRequest {
  InstanceId: string;
  FileId: string;
  AssociatedResourceArn: string;
}
export const CompleteAttachedFileUploadRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileId: S.String.pipe(T.HttpLabel("FileId")),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/attached-files/{InstanceId}/{FileId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CompleteAttachedFileUploadRequest",
}) as any as S.Schema<CompleteAttachedFileUploadRequest>;
export interface CompleteAttachedFileUploadResponse {}
export const CompleteAttachedFileUploadResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "CompleteAttachedFileUploadResponse",
}) as any as S.Schema<CompleteAttachedFileUploadResponse>;
export type TagMap = { [key: string]: string | undefined };
export const TagMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(S.String),
});
export interface CreateAgentStatusRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  State: AgentStatusState;
  DisplayOrder?: number;
  Tags?: { [key: string]: string | undefined };
}
export const CreateAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    State: AgentStatusState,
    DisplayOrder: S.optional(S.Number),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/agent-status/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateAgentStatusRequest",
}) as any as S.Schema<CreateAgentStatusRequest>;
export interface CreateContactFlowRequest {
  InstanceId: string;
  Name: string;
  Type: ContactFlowType;
  Description?: string;
  Content: string;
  Status?: ContactFlowStatus;
  Tags?: { [key: string]: string | undefined };
}
export const CreateContactFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Type: ContactFlowType,
    Description: S.optional(S.String),
    Content: S.String,
    Status: S.optional(ContactFlowStatus),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact-flows/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateContactFlowRequest",
}) as any as S.Schema<CreateContactFlowRequest>;
export interface CreateContactFlowModuleAliasRequest {
  InstanceId: string;
  Description?: string;
  ContactFlowModuleId: string;
  ContactFlowModuleVersion: number;
  AliasName: string;
}
export const CreateContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Description: S.optional(S.String),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    ContactFlowModuleVersion: S.Number,
    AliasName: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateContactFlowModuleAliasRequest",
}) as any as S.Schema<CreateContactFlowModuleAliasRequest>;
export interface CreateContactFlowModuleVersionRequest {
  InstanceId: string;
  Description?: string;
  ContactFlowModuleId: string;
  FlowModuleContentSha256?: string;
}
export const CreateContactFlowModuleVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Description: S.optional(S.String),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    FlowModuleContentSha256: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/version",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateContactFlowModuleVersionRequest",
}) as any as S.Schema<CreateContactFlowModuleVersionRequest>;
export interface CreateContactFlowVersionRequest {
  InstanceId: string;
  Description?: string;
  ContactFlowId: string;
  FlowContentSha256?: string;
  ContactFlowVersion?: number;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const CreateContactFlowVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Description: S.optional(S.String),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    FlowContentSha256: S.optional(S.String),
    ContactFlowVersion: S.optional(S.Number),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/version",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateContactFlowVersionRequest",
}) as any as S.Schema<CreateContactFlowVersionRequest>;
export interface CreateDataTableRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  TimeZone: string;
  ValueLockLevel: DataTableLockLevel;
  Status: DataTableStatus;
  Tags?: { [key: string]: string | undefined };
}
export const CreateDataTableRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    TimeZone: S.String,
    ValueLockLevel: DataTableLockLevel,
    Status: DataTableStatus,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/data-tables/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateDataTableRequest",
}) as any as S.Schema<CreateDataTableRequest>;
export interface CreateEmailAddressRequest {
  Description?: string | redacted.Redacted<string>;
  InstanceId: string;
  EmailAddress: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
}
export const CreateEmailAddressRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(SensitiveString),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddress: SensitiveString,
    DisplayName: S.optional(SensitiveString),
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/email-addresses/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateEmailAddressRequest",
}) as any as S.Schema<CreateEmailAddressRequest>;
export interface CreateInstanceRequest {
  ClientToken?: string;
  IdentityManagementType: DirectoryType;
  InstanceAlias?: string | redacted.Redacted<string>;
  DirectoryId?: string;
  InboundCallsEnabled: boolean;
  OutboundCallsEnabled: boolean;
  Tags?: { [key: string]: string | undefined };
}
export const CreateInstanceRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    IdentityManagementType: DirectoryType,
    InstanceAlias: S.optional(SensitiveString),
    DirectoryId: S.optional(S.String),
    InboundCallsEnabled: S.Boolean,
    OutboundCallsEnabled: S.Boolean,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateInstanceRequest",
}) as any as S.Schema<CreateInstanceRequest>;
export interface CreateIntegrationAssociationRequest {
  InstanceId: string;
  IntegrationType: IntegrationType;
  IntegrationArn: string;
  SourceApplicationUrl?: string;
  SourceApplicationName?: string;
  SourceType?: SourceType;
  Tags?: { [key: string]: string | undefined };
}
export const CreateIntegrationAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationType: IntegrationType,
    IntegrationArn: S.String,
    SourceApplicationUrl: S.optional(S.String),
    SourceApplicationName: S.optional(S.String),
    SourceType: S.optional(SourceType),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/instance/{InstanceId}/integration-associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateIntegrationAssociationRequest",
}) as any as S.Schema<CreateIntegrationAssociationRequest>;
export interface CreatePersistentContactAssociationRequest {
  InstanceId: string;
  InitialContactId: string;
  RehydrationType: RehydrationType;
  SourceContactId: string;
  ClientToken?: string;
}
export const CreatePersistentContactAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    InitialContactId: S.String.pipe(T.HttpLabel("InitialContactId")),
    RehydrationType: RehydrationType,
    SourceContactId: S.String,
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/persistent-contact-association/{InstanceId}/{InitialContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreatePersistentContactAssociationRequest",
}) as any as S.Schema<CreatePersistentContactAssociationRequest>;
export interface CreatePromptRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  S3Uri: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreatePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    S3Uri: S.String,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/prompts/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreatePromptRequest",
}) as any as S.Schema<CreatePromptRequest>;
export interface CreateTrafficDistributionGroupRequest {
  Name: string;
  Description?: string;
  InstanceId: string;
  ClientToken?: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateTrafficDistributionGroupRequest = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Description: S.optional(S.String),
    InstanceId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/traffic-distribution-group" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateTrafficDistributionGroupRequest",
}) as any as S.Schema<CreateTrafficDistributionGroupRequest>;
export interface CreateUseCaseRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
  UseCaseType: UseCaseType;
  Tags?: { [key: string]: string | undefined };
}
export const CreateUseCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
    UseCaseType: UseCaseType,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateUseCaseRequest",
}) as any as S.Schema<CreateUseCaseRequest>;
export interface CreateUserHierarchyGroupRequest {
  Name: string;
  ParentGroupId?: string;
  InstanceId: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateUserHierarchyGroupRequest = S.suspend(() =>
  S.Struct({
    Name: S.String,
    ParentGroupId: S.optional(S.String),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/user-hierarchy-groups/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateUserHierarchyGroupRequest",
}) as any as S.Schema<CreateUserHierarchyGroupRequest>;
export interface CreateViewVersionRequest {
  InstanceId: string;
  ViewId: string;
  VersionDescription?: string;
  ViewContentSha256?: string;
}
export const CreateViewVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    VersionDescription: S.optional(S.String),
    ViewContentSha256: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/views/{InstanceId}/{ViewId}/versions" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateViewVersionRequest",
}) as any as S.Schema<CreateViewVersionRequest>;
export interface CreateVocabularyRequest {
  ClientToken?: string;
  InstanceId: string;
  VocabularyName: string;
  LanguageCode: VocabularyLanguageCode;
  Content: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateVocabularyRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    VocabularyName: S.String,
    LanguageCode: VocabularyLanguageCode,
    Content: S.String,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/vocabulary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateVocabularyRequest",
}) as any as S.Schema<CreateVocabularyRequest>;
export interface CreateWorkspacePageRequest {
  InstanceId: string;
  WorkspaceId: string;
  ResourceArn: string;
  Page: string;
  Slug?: string;
  InputData?: string;
}
export const CreateWorkspacePageRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    ResourceArn: S.String,
    Page: S.String,
    Slug: S.optional(S.String),
    InputData: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateWorkspacePageRequest",
}) as any as S.Schema<CreateWorkspacePageRequest>;
export interface CreateWorkspacePageResponse {}
export const CreateWorkspacePageResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "CreateWorkspacePageResponse",
}) as any as S.Schema<CreateWorkspacePageResponse>;
export interface DeactivateEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
}
export const DeactivateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}/deactivate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeactivateEvaluationFormRequest",
}) as any as S.Schema<DeactivateEvaluationFormRequest>;
export interface DeleteAttachedFileRequest {
  InstanceId: string;
  FileId: string;
  AssociatedResourceArn: string;
}
export const DeleteAttachedFileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileId: S.String.pipe(T.HttpLabel("FileId")),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/attached-files/{InstanceId}/{FileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteAttachedFileRequest",
}) as any as S.Schema<DeleteAttachedFileRequest>;
export interface DeleteAttachedFileResponse {}
export const DeleteAttachedFileResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteAttachedFileResponse",
}) as any as S.Schema<DeleteAttachedFileResponse>;
export interface DeleteContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
}
export const DeleteContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteContactEvaluationRequest",
}) as any as S.Schema<DeleteContactEvaluationRequest>;
export interface DeleteContactEvaluationResponse {}
export const DeleteContactEvaluationResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteContactEvaluationResponse",
}) as any as S.Schema<DeleteContactEvaluationResponse>;
export interface DeleteContactFlowRequest {
  InstanceId: string;
  ContactFlowId: string;
}
export const DeleteContactFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteContactFlowRequest",
}) as any as S.Schema<DeleteContactFlowRequest>;
export interface DeleteContactFlowResponse {}
export const DeleteContactFlowResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteContactFlowResponse",
}) as any as S.Schema<DeleteContactFlowResponse>;
export interface DeleteContactFlowModuleRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
}
export const DeleteContactFlowModuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteContactFlowModuleRequest",
}) as any as S.Schema<DeleteContactFlowModuleRequest>;
export interface DeleteContactFlowModuleResponse {}
export const DeleteContactFlowModuleResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteContactFlowModuleResponse",
}) as any as S.Schema<DeleteContactFlowModuleResponse>;
export interface DeleteContactFlowModuleAliasRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  AliasId: string;
}
export const DeleteContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    AliasId: S.String.pipe(T.HttpLabel("AliasId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias/{AliasId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteContactFlowModuleAliasRequest",
}) as any as S.Schema<DeleteContactFlowModuleAliasRequest>;
export interface DeleteContactFlowModuleAliasResponse {}
export const DeleteContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteContactFlowModuleAliasResponse",
}) as any as S.Schema<DeleteContactFlowModuleAliasResponse>;
export interface DeleteContactFlowModuleVersionRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  ContactFlowModuleVersion: number;
}
export const DeleteContactFlowModuleVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    ContactFlowModuleVersion: S.Number.pipe(
      T.HttpLabel("ContactFlowModuleVersion"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/version/{ContactFlowModuleVersion}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteContactFlowModuleVersionRequest",
}) as any as S.Schema<DeleteContactFlowModuleVersionRequest>;
export interface DeleteContactFlowModuleVersionResponse {}
export const DeleteContactFlowModuleVersionResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteContactFlowModuleVersionResponse",
}) as any as S.Schema<DeleteContactFlowModuleVersionResponse>;
export interface DeleteContactFlowVersionRequest {
  InstanceId: string;
  ContactFlowId: string;
  ContactFlowVersion: number;
}
export const DeleteContactFlowVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    ContactFlowVersion: S.Number.pipe(T.HttpLabel("ContactFlowVersion")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/version/{ContactFlowVersion}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteContactFlowVersionRequest",
}) as any as S.Schema<DeleteContactFlowVersionRequest>;
export interface DeleteContactFlowVersionResponse {}
export const DeleteContactFlowVersionResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteContactFlowVersionResponse",
}) as any as S.Schema<DeleteContactFlowVersionResponse>;
export interface DeleteDataTableRequest {
  InstanceId: string;
  DataTableId: string;
}
export const DeleteDataTableRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/data-tables/{InstanceId}/{DataTableId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteDataTableRequest",
}) as any as S.Schema<DeleteDataTableRequest>;
export interface DeleteDataTableResponse {}
export const DeleteDataTableResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteDataTableResponse",
}) as any as S.Schema<DeleteDataTableResponse>;
export interface DeleteDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeName: string;
}
export const DeleteDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeName: S.String.pipe(T.HttpLabel("AttributeName")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes/{AttributeName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteDataTableAttributeRequest",
}) as any as S.Schema<DeleteDataTableAttributeRequest>;
export interface DeleteEmailAddressRequest {
  InstanceId: string;
  EmailAddressId: string;
}
export const DeleteEmailAddressRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteEmailAddressRequest",
}) as any as S.Schema<DeleteEmailAddressRequest>;
export interface DeleteEmailAddressResponse {}
export const DeleteEmailAddressResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteEmailAddressResponse",
}) as any as S.Schema<DeleteEmailAddressResponse>;
export interface DeleteEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion?: number;
}
export const DeleteEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.optional(S.Number).pipe(T.HttpQuery("version")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteEvaluationFormRequest",
}) as any as S.Schema<DeleteEvaluationFormRequest>;
export interface DeleteEvaluationFormResponse {}
export const DeleteEvaluationFormResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteEvaluationFormResponse",
}) as any as S.Schema<DeleteEvaluationFormResponse>;
export interface DeleteHoursOfOperationRequest {
  InstanceId: string;
  HoursOfOperationId: string;
}
export const DeleteHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteHoursOfOperationRequest",
}) as any as S.Schema<DeleteHoursOfOperationRequest>;
export interface DeleteHoursOfOperationResponse {}
export const DeleteHoursOfOperationResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteHoursOfOperationResponse",
}) as any as S.Schema<DeleteHoursOfOperationResponse>;
export interface DeleteHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  HoursOfOperationOverrideId: string;
}
export const DeleteHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    HoursOfOperationOverrideId: S.String.pipe(
      T.HttpLabel("HoursOfOperationOverrideId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides/{HoursOfOperationOverrideId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteHoursOfOperationOverrideRequest",
}) as any as S.Schema<DeleteHoursOfOperationOverrideRequest>;
export interface DeleteHoursOfOperationOverrideResponse {}
export const DeleteHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteHoursOfOperationOverrideResponse",
}) as any as S.Schema<DeleteHoursOfOperationOverrideResponse>;
export interface DeleteInstanceRequest {
  InstanceId: string;
  ClientToken?: string;
}
export const DeleteInstanceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/instance/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteInstanceRequest",
}) as any as S.Schema<DeleteInstanceRequest>;
export interface DeleteInstanceResponse {}
export const DeleteInstanceResponse = S.suspend(() => S.Struct({})).annotations(
  { identifier: "DeleteInstanceResponse" },
) as any as S.Schema<DeleteInstanceResponse>;
export interface DeleteIntegrationAssociationRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
}
export const DeleteIntegrationAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteIntegrationAssociationRequest",
}) as any as S.Schema<DeleteIntegrationAssociationRequest>;
export interface DeleteIntegrationAssociationResponse {}
export const DeleteIntegrationAssociationResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteIntegrationAssociationResponse",
}) as any as S.Schema<DeleteIntegrationAssociationResponse>;
export interface DeletePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
}
export const DeletePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String.pipe(T.HttpLabel("Name")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/predefined-attributes/{InstanceId}/{Name}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeletePredefinedAttributeRequest",
}) as any as S.Schema<DeletePredefinedAttributeRequest>;
export interface DeletePredefinedAttributeResponse {}
export const DeletePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeletePredefinedAttributeResponse",
}) as any as S.Schema<DeletePredefinedAttributeResponse>;
export interface DeletePromptRequest {
  InstanceId: string;
  PromptId: string;
}
export const DeletePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/prompts/{InstanceId}/{PromptId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeletePromptRequest",
}) as any as S.Schema<DeletePromptRequest>;
export interface DeletePromptResponse {}
export const DeletePromptResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "DeletePromptResponse",
}) as any as S.Schema<DeletePromptResponse>;
export interface DeletePushNotificationRegistrationRequest {
  InstanceId: string;
  RegistrationId: string;
  ContactId: string;
}
export const DeletePushNotificationRegistrationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RegistrationId: S.String.pipe(T.HttpLabel("RegistrationId")),
    ContactId: S.String.pipe(T.HttpQuery("contactId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/push-notification/{InstanceId}/registrations/{RegistrationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeletePushNotificationRegistrationRequest",
}) as any as S.Schema<DeletePushNotificationRegistrationRequest>;
export interface DeletePushNotificationRegistrationResponse {}
export const DeletePushNotificationRegistrationResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeletePushNotificationRegistrationResponse",
}) as any as S.Schema<DeletePushNotificationRegistrationResponse>;
export interface DeleteQueueRequest {
  InstanceId: string;
  QueueId: string;
}
export const DeleteQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/queues/{InstanceId}/{QueueId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteQueueRequest",
}) as any as S.Schema<DeleteQueueRequest>;
export interface DeleteQueueResponse {}
export const DeleteQueueResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "DeleteQueueResponse",
}) as any as S.Schema<DeleteQueueResponse>;
export interface DeleteQuickConnectRequest {
  InstanceId: string;
  QuickConnectId: string;
}
export const DeleteQuickConnectRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteQuickConnectRequest",
}) as any as S.Schema<DeleteQuickConnectRequest>;
export interface DeleteQuickConnectResponse {}
export const DeleteQuickConnectResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteQuickConnectResponse",
}) as any as S.Schema<DeleteQuickConnectResponse>;
export interface DeleteRoutingProfileRequest {
  InstanceId: string;
  RoutingProfileId: string;
}
export const DeleteRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteRoutingProfileRequest",
}) as any as S.Schema<DeleteRoutingProfileRequest>;
export interface DeleteRoutingProfileResponse {}
export const DeleteRoutingProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteRoutingProfileResponse",
}) as any as S.Schema<DeleteRoutingProfileResponse>;
export interface DeleteRuleRequest {
  InstanceId: string;
  RuleId: string;
}
export const DeleteRuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RuleId: S.String.pipe(T.HttpLabel("RuleId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/rules/{InstanceId}/{RuleId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteRuleRequest",
}) as any as S.Schema<DeleteRuleRequest>;
export interface DeleteRuleResponse {}
export const DeleteRuleResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "DeleteRuleResponse",
}) as any as S.Schema<DeleteRuleResponse>;
export interface DeleteSecurityProfileRequest {
  InstanceId: string;
  SecurityProfileId: string;
}
export const DeleteSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/security-profiles/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteSecurityProfileRequest",
}) as any as S.Schema<DeleteSecurityProfileRequest>;
export interface DeleteSecurityProfileResponse {}
export const DeleteSecurityProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteSecurityProfileResponse",
}) as any as S.Schema<DeleteSecurityProfileResponse>;
export interface DeleteTaskTemplateRequest {
  InstanceId: string;
  TaskTemplateId: string;
}
export const DeleteTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TaskTemplateId: S.String.pipe(T.HttpLabel("TaskTemplateId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/task/template/{TaskTemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteTaskTemplateRequest",
}) as any as S.Schema<DeleteTaskTemplateRequest>;
export interface DeleteTaskTemplateResponse {}
export const DeleteTaskTemplateResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteTaskTemplateResponse",
}) as any as S.Schema<DeleteTaskTemplateResponse>;
export interface DeleteTrafficDistributionGroupRequest {
  TrafficDistributionGroupId: string;
}
export const DeleteTrafficDistributionGroupRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteTrafficDistributionGroupRequest",
}) as any as S.Schema<DeleteTrafficDistributionGroupRequest>;
export interface DeleteTrafficDistributionGroupResponse {}
export const DeleteTrafficDistributionGroupResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteTrafficDistributionGroupResponse",
}) as any as S.Schema<DeleteTrafficDistributionGroupResponse>;
export interface DeleteUseCaseRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
  UseCaseId: string;
}
export const DeleteUseCaseRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
    UseCaseId: S.String.pipe(T.HttpLabel("UseCaseId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases/{UseCaseId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteUseCaseRequest",
}) as any as S.Schema<DeleteUseCaseRequest>;
export interface DeleteUseCaseResponse {}
export const DeleteUseCaseResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "DeleteUseCaseResponse",
}) as any as S.Schema<DeleteUseCaseResponse>;
export interface DeleteUserRequest {
  InstanceId: string;
  UserId: string;
}
export const DeleteUserRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/users/{InstanceId}/{UserId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteUserRequest",
}) as any as S.Schema<DeleteUserRequest>;
export interface DeleteUserResponse {}
export const DeleteUserResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "DeleteUserResponse",
}) as any as S.Schema<DeleteUserResponse>;
export interface DeleteUserHierarchyGroupRequest {
  HierarchyGroupId: string;
  InstanceId: string;
}
export const DeleteUserHierarchyGroupRequest = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.String.pipe(T.HttpLabel("HierarchyGroupId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteUserHierarchyGroupRequest",
}) as any as S.Schema<DeleteUserHierarchyGroupRequest>;
export interface DeleteUserHierarchyGroupResponse {}
export const DeleteUserHierarchyGroupResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteUserHierarchyGroupResponse",
}) as any as S.Schema<DeleteUserHierarchyGroupResponse>;
export interface DeleteViewRequest {
  InstanceId: string;
  ViewId: string;
}
export const DeleteViewRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/views/{InstanceId}/{ViewId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteViewRequest",
}) as any as S.Schema<DeleteViewRequest>;
export interface DeleteViewResponse {}
export const DeleteViewResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "DeleteViewResponse",
}) as any as S.Schema<DeleteViewResponse>;
export interface DeleteViewVersionRequest {
  InstanceId: string;
  ViewId: string;
  ViewVersion: number;
}
export const DeleteViewVersionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    ViewVersion: S.Number.pipe(T.HttpLabel("ViewVersion")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/views/{InstanceId}/{ViewId}/versions/{ViewVersion}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteViewVersionRequest",
}) as any as S.Schema<DeleteViewVersionRequest>;
export interface DeleteViewVersionResponse {}
export const DeleteViewVersionResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteViewVersionResponse",
}) as any as S.Schema<DeleteViewVersionResponse>;
export interface DeleteVocabularyRequest {
  InstanceId: string;
  VocabularyId: string;
}
export const DeleteVocabularyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    VocabularyId: S.String.pipe(T.HttpLabel("VocabularyId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/vocabulary-remove/{InstanceId}/{VocabularyId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteVocabularyRequest",
}) as any as S.Schema<DeleteVocabularyRequest>;
export interface DeleteWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
}
export const DeleteWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteWorkspaceRequest",
}) as any as S.Schema<DeleteWorkspaceRequest>;
export interface DeleteWorkspaceResponse {}
export const DeleteWorkspaceResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteWorkspaceResponse",
}) as any as S.Schema<DeleteWorkspaceResponse>;
export interface DeleteWorkspaceMediaRequest {
  InstanceId: string;
  WorkspaceId: string;
  MediaType: MediaType;
}
export const DeleteWorkspaceMediaRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    MediaType: MediaType.pipe(T.HttpQuery("mediaType")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/media",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteWorkspaceMediaRequest",
}) as any as S.Schema<DeleteWorkspaceMediaRequest>;
export interface DeleteWorkspaceMediaResponse {}
export const DeleteWorkspaceMediaResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteWorkspaceMediaResponse",
}) as any as S.Schema<DeleteWorkspaceMediaResponse>;
export interface DeleteWorkspacePageRequest {
  InstanceId: string;
  WorkspaceId: string;
  Page: string;
}
export const DeleteWorkspacePageRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Page: S.String.pipe(T.HttpLabel("Page")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages/{Page}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteWorkspacePageRequest",
}) as any as S.Schema<DeleteWorkspacePageRequest>;
export interface DeleteWorkspacePageResponse {}
export const DeleteWorkspacePageResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DeleteWorkspacePageResponse",
}) as any as S.Schema<DeleteWorkspacePageResponse>;
export interface DescribeAgentStatusRequest {
  InstanceId: string;
  AgentStatusId: string;
}
export const DescribeAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AgentStatusId: S.String.pipe(T.HttpLabel("AgentStatusId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/agent-status/{InstanceId}/{AgentStatusId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAgentStatusRequest",
}) as any as S.Schema<DescribeAgentStatusRequest>;
export interface DescribeAuthenticationProfileRequest {
  AuthenticationProfileId: string;
  InstanceId: string;
}
export const DescribeAuthenticationProfileRequest = S.suspend(() =>
  S.Struct({
    AuthenticationProfileId: S.String.pipe(
      T.HttpLabel("AuthenticationProfileId"),
    ),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/authentication-profiles/{InstanceId}/{AuthenticationProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAuthenticationProfileRequest",
}) as any as S.Schema<DescribeAuthenticationProfileRequest>;
export interface DescribeContactRequest {
  InstanceId: string;
  ContactId: string;
}
export const DescribeContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contacts/{InstanceId}/{ContactId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeContactRequest",
}) as any as S.Schema<DescribeContactRequest>;
export interface DescribeContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
}
export const DescribeContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeContactEvaluationRequest",
}) as any as S.Schema<DescribeContactEvaluationRequest>;
export interface DescribeContactFlowRequest {
  InstanceId: string;
  ContactFlowId: string;
}
export const DescribeContactFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeContactFlowRequest",
}) as any as S.Schema<DescribeContactFlowRequest>;
export interface DescribeContactFlowModuleRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
}
export const DescribeContactFlowModuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeContactFlowModuleRequest",
}) as any as S.Schema<DescribeContactFlowModuleRequest>;
export interface DescribeContactFlowModuleAliasRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  AliasId: string;
}
export const DescribeContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    AliasId: S.String.pipe(T.HttpLabel("AliasId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias/{AliasId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeContactFlowModuleAliasRequest",
}) as any as S.Schema<DescribeContactFlowModuleAliasRequest>;
export interface DescribeDataTableRequest {
  InstanceId: string;
  DataTableId: string;
}
export const DescribeDataTableRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/data-tables/{InstanceId}/{DataTableId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDataTableRequest",
}) as any as S.Schema<DescribeDataTableRequest>;
export interface DescribeDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeName: string;
}
export const DescribeDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeName: S.String.pipe(T.HttpLabel("AttributeName")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes/{AttributeName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDataTableAttributeRequest",
}) as any as S.Schema<DescribeDataTableAttributeRequest>;
export interface DescribeEmailAddressRequest {
  InstanceId: string;
  EmailAddressId: string;
}
export const DescribeEmailAddressRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeEmailAddressRequest",
}) as any as S.Schema<DescribeEmailAddressRequest>;
export interface DescribeEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion?: number;
}
export const DescribeEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.optional(S.Number).pipe(T.HttpQuery("version")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeEvaluationFormRequest",
}) as any as S.Schema<DescribeEvaluationFormRequest>;
export interface DescribeHoursOfOperationRequest {
  InstanceId: string;
  HoursOfOperationId: string;
}
export const DescribeHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeHoursOfOperationRequest",
}) as any as S.Schema<DescribeHoursOfOperationRequest>;
export interface DescribeHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  HoursOfOperationOverrideId: string;
}
export const DescribeHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    HoursOfOperationOverrideId: S.String.pipe(
      T.HttpLabel("HoursOfOperationOverrideId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides/{HoursOfOperationOverrideId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeHoursOfOperationOverrideRequest",
}) as any as S.Schema<DescribeHoursOfOperationOverrideRequest>;
export interface DescribeInstanceRequest {
  InstanceId: string;
}
export const DescribeInstanceRequest = S.suspend(() =>
  S.Struct({ InstanceId: S.String.pipe(T.HttpLabel("InstanceId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeInstanceRequest",
}) as any as S.Schema<DescribeInstanceRequest>;
export interface DescribeInstanceAttributeRequest {
  InstanceId: string;
  AttributeType: InstanceAttributeType;
}
export const DescribeInstanceAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AttributeType: InstanceAttributeType.pipe(T.HttpLabel("AttributeType")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/attribute/{AttributeType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeInstanceAttributeRequest",
}) as any as S.Schema<DescribeInstanceAttributeRequest>;
export interface DescribeInstanceStorageConfigRequest {
  InstanceId: string;
  AssociationId: string;
  ResourceType: InstanceStorageResourceType;
}
export const DescribeInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/storage-config/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeInstanceStorageConfigRequest",
}) as any as S.Schema<DescribeInstanceStorageConfigRequest>;
export interface DescribePhoneNumberRequest {
  PhoneNumberId: string;
}
export const DescribePhoneNumberRequest = S.suspend(() =>
  S.Struct({ PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/phone-number/{PhoneNumberId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribePhoneNumberRequest",
}) as any as S.Schema<DescribePhoneNumberRequest>;
export interface DescribePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
}
export const DescribePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String.pipe(T.HttpLabel("Name")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/predefined-attributes/{InstanceId}/{Name}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribePredefinedAttributeRequest",
}) as any as S.Schema<DescribePredefinedAttributeRequest>;
export interface DescribePromptRequest {
  InstanceId: string;
  PromptId: string;
}
export const DescribePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/prompts/{InstanceId}/{PromptId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribePromptRequest",
}) as any as S.Schema<DescribePromptRequest>;
export interface DescribeQueueRequest {
  InstanceId: string;
  QueueId: string;
}
export const DescribeQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/queues/{InstanceId}/{QueueId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeQueueRequest",
}) as any as S.Schema<DescribeQueueRequest>;
export interface DescribeQuickConnectRequest {
  InstanceId: string;
  QuickConnectId: string;
}
export const DescribeQuickConnectRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeQuickConnectRequest",
}) as any as S.Schema<DescribeQuickConnectRequest>;
export interface DescribeRoutingProfileRequest {
  InstanceId: string;
  RoutingProfileId: string;
}
export const DescribeRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeRoutingProfileRequest",
}) as any as S.Schema<DescribeRoutingProfileRequest>;
export interface DescribeRuleRequest {
  InstanceId: string;
  RuleId: string;
}
export const DescribeRuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RuleId: S.String.pipe(T.HttpLabel("RuleId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/rules/{InstanceId}/{RuleId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeRuleRequest",
}) as any as S.Schema<DescribeRuleRequest>;
export interface DescribeSecurityProfileRequest {
  SecurityProfileId: string;
  InstanceId: string;
}
export const DescribeSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeSecurityProfileRequest",
}) as any as S.Schema<DescribeSecurityProfileRequest>;
export interface DescribeTrafficDistributionGroupRequest {
  TrafficDistributionGroupId: string;
}
export const DescribeTrafficDistributionGroupRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTrafficDistributionGroupRequest",
}) as any as S.Schema<DescribeTrafficDistributionGroupRequest>;
export interface DescribeUserRequest {
  UserId: string;
  InstanceId: string;
}
export const DescribeUserRequest = S.suspend(() =>
  S.Struct({
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/users/{InstanceId}/{UserId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeUserRequest",
}) as any as S.Schema<DescribeUserRequest>;
export interface DescribeUserHierarchyGroupRequest {
  HierarchyGroupId: string;
  InstanceId: string;
}
export const DescribeUserHierarchyGroupRequest = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.String.pipe(T.HttpLabel("HierarchyGroupId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeUserHierarchyGroupRequest",
}) as any as S.Schema<DescribeUserHierarchyGroupRequest>;
export interface DescribeUserHierarchyStructureRequest {
  InstanceId: string;
}
export const DescribeUserHierarchyStructureRequest = S.suspend(() =>
  S.Struct({ InstanceId: S.String.pipe(T.HttpLabel("InstanceId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/user-hierarchy-structure/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeUserHierarchyStructureRequest",
}) as any as S.Schema<DescribeUserHierarchyStructureRequest>;
export interface DescribeViewRequest {
  InstanceId: string;
  ViewId: string;
}
export const DescribeViewRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/views/{InstanceId}/{ViewId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeViewRequest",
}) as any as S.Schema<DescribeViewRequest>;
export interface DescribeVocabularyRequest {
  InstanceId: string;
  VocabularyId: string;
}
export const DescribeVocabularyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    VocabularyId: S.String.pipe(T.HttpLabel("VocabularyId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/vocabulary/{InstanceId}/{VocabularyId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeVocabularyRequest",
}) as any as S.Schema<DescribeVocabularyRequest>;
export interface DescribeWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
}
export const DescribeWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/workspaces/{InstanceId}/{WorkspaceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeWorkspaceRequest",
}) as any as S.Schema<DescribeWorkspaceRequest>;
export interface DisassociateAnalyticsDataSetRequest {
  InstanceId: string;
  DataSetId: string;
  TargetAccountId?: string;
}
export const DisassociateAnalyticsDataSetRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetId: S.String,
    TargetAccountId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/analytics-data/instance/{InstanceId}/association",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateAnalyticsDataSetRequest",
}) as any as S.Schema<DisassociateAnalyticsDataSetRequest>;
export interface DisassociateAnalyticsDataSetResponse {}
export const DisassociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateAnalyticsDataSetResponse",
}) as any as S.Schema<DisassociateAnalyticsDataSetResponse>;
export interface DisassociateApprovedOriginRequest {
  InstanceId: string;
  Origin: string;
  ClientToken?: string;
}
export const DisassociateApprovedOriginRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Origin: S.String.pipe(T.HttpQuery("origin")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/approved-origin",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateApprovedOriginRequest",
}) as any as S.Schema<DisassociateApprovedOriginRequest>;
export interface DisassociateApprovedOriginResponse {}
export const DisassociateApprovedOriginResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateApprovedOriginResponse",
}) as any as S.Schema<DisassociateApprovedOriginResponse>;
export interface LexV2Bot {
  AliasArn?: string;
}
export const LexV2Bot = S.suspend(() =>
  S.Struct({ AliasArn: S.optional(S.String) }),
).annotations({ identifier: "LexV2Bot" }) as any as S.Schema<LexV2Bot>;
export interface DisassociateBotRequest {
  InstanceId: string;
  LexBot?: LexBot;
  LexV2Bot?: LexV2Bot;
  ClientToken?: string;
}
export const DisassociateBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LexBot: S.optional(LexBot),
    LexV2Bot: S.optional(LexV2Bot),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/instance/{InstanceId}/bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateBotRequest",
}) as any as S.Schema<DisassociateBotRequest>;
export interface DisassociateBotResponse {}
export const DisassociateBotResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateBotResponse",
}) as any as S.Schema<DisassociateBotResponse>;
export interface AliasConfiguration {
  EmailAddressId: string;
}
export const AliasConfiguration = S.suspend(() =>
  S.Struct({ EmailAddressId: S.String }),
).annotations({
  identifier: "AliasConfiguration",
}) as any as S.Schema<AliasConfiguration>;
export interface DisassociateEmailAddressAliasRequest {
  EmailAddressId: string;
  InstanceId: string;
  AliasConfiguration: AliasConfiguration;
  ClientToken?: string;
}
export const DisassociateEmailAddressAliasRequest = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AliasConfiguration: AliasConfiguration,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}/disassociate-alias",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateEmailAddressAliasRequest",
}) as any as S.Schema<DisassociateEmailAddressAliasRequest>;
export interface DisassociateEmailAddressAliasResponse {}
export const DisassociateEmailAddressAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateEmailAddressAliasResponse",
}) as any as S.Schema<DisassociateEmailAddressAliasResponse>;
export interface DisassociateFlowRequest {
  InstanceId: string;
  ResourceId: string;
  ResourceType: FlowAssociationResourceType;
}
export const DisassociateFlowRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceId: S.String.pipe(T.HttpLabel("ResourceId")),
    ResourceType: FlowAssociationResourceType.pipe(T.HttpLabel("ResourceType")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/flow-associations/{InstanceId}/{ResourceId}/{ResourceType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateFlowRequest",
}) as any as S.Schema<DisassociateFlowRequest>;
export interface DisassociateFlowResponse {}
export const DisassociateFlowResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateFlowResponse",
}) as any as S.Schema<DisassociateFlowResponse>;
export interface DisassociateInstanceStorageConfigRequest {
  InstanceId: string;
  AssociationId: string;
  ResourceType: InstanceStorageResourceType;
  ClientToken?: string;
}
export const DisassociateInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/storage-config/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateInstanceStorageConfigRequest",
}) as any as S.Schema<DisassociateInstanceStorageConfigRequest>;
export interface DisassociateInstanceStorageConfigResponse {}
export const DisassociateInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateInstanceStorageConfigResponse",
}) as any as S.Schema<DisassociateInstanceStorageConfigResponse>;
export interface DisassociateLambdaFunctionRequest {
  InstanceId: string;
  FunctionArn: string;
  ClientToken?: string;
}
export const DisassociateLambdaFunctionRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FunctionArn: S.String.pipe(T.HttpQuery("functionArn")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/lambda-function",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateLambdaFunctionRequest",
}) as any as S.Schema<DisassociateLambdaFunctionRequest>;
export interface DisassociateLambdaFunctionResponse {}
export const DisassociateLambdaFunctionResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateLambdaFunctionResponse",
}) as any as S.Schema<DisassociateLambdaFunctionResponse>;
export interface DisassociateLexBotRequest {
  InstanceId: string;
  BotName: string;
  LexRegion: string;
  ClientToken?: string;
}
export const DisassociateLexBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    BotName: S.String.pipe(T.HttpQuery("botName")),
    LexRegion: S.String.pipe(T.HttpQuery("lexRegion")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/instance/{InstanceId}/lex-bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateLexBotRequest",
}) as any as S.Schema<DisassociateLexBotRequest>;
export interface DisassociateLexBotResponse {}
export const DisassociateLexBotResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateLexBotResponse",
}) as any as S.Schema<DisassociateLexBotResponse>;
export interface DisassociatePhoneNumberContactFlowRequest {
  PhoneNumberId: string;
  InstanceId: string;
}
export const DisassociatePhoneNumberContactFlowRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    InstanceId: S.String.pipe(T.HttpQuery("instanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/phone-number/{PhoneNumberId}/contact-flow",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociatePhoneNumberContactFlowRequest",
}) as any as S.Schema<DisassociatePhoneNumberContactFlowRequest>;
export interface DisassociatePhoneNumberContactFlowResponse {}
export const DisassociatePhoneNumberContactFlowResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociatePhoneNumberContactFlowResponse",
}) as any as S.Schema<DisassociatePhoneNumberContactFlowResponse>;
export interface DisassociateQueueQuickConnectsRequest {
  InstanceId: string;
  QueueId: string;
  QuickConnectIds: string[];
}
export const DisassociateQueueQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    QuickConnectIds: QuickConnectsList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/disassociate-quick-connects",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateQueueQuickConnectsRequest",
}) as any as S.Schema<DisassociateQueueQuickConnectsRequest>;
export interface DisassociateQueueQuickConnectsResponse {}
export const DisassociateQueueQuickConnectsResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateQueueQuickConnectsResponse",
}) as any as S.Schema<DisassociateQueueQuickConnectsResponse>;
export interface DisassociateSecurityKeyRequest {
  InstanceId: string;
  AssociationId: string;
  ClientToken?: string;
}
export const DisassociateSecurityKeyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/instance/{InstanceId}/security-key/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateSecurityKeyRequest",
}) as any as S.Schema<DisassociateSecurityKeyRequest>;
export interface DisassociateSecurityKeyResponse {}
export const DisassociateSecurityKeyResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateSecurityKeyResponse",
}) as any as S.Schema<DisassociateSecurityKeyResponse>;
export interface SecurityProfileItem {
  Id?: string;
}
export const SecurityProfileItem = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String) }),
).annotations({
  identifier: "SecurityProfileItem",
}) as any as S.Schema<SecurityProfileItem>;
export type SecurityProfiles = SecurityProfileItem[];
export const SecurityProfiles = S.Array(SecurityProfileItem);
export interface DisassociateSecurityProfilesRequest {
  InstanceId: string;
  SecurityProfiles: SecurityProfileItem[];
  EntityType: EntityType;
  EntityArn: string;
}
export const DisassociateSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    SecurityProfiles: SecurityProfiles,
    EntityType: EntityType,
    EntityArn: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/disassociate-security-profiles/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateSecurityProfilesRequest",
}) as any as S.Schema<DisassociateSecurityProfilesRequest>;
export interface DisassociateSecurityProfilesResponse {}
export const DisassociateSecurityProfilesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateSecurityProfilesResponse",
}) as any as S.Schema<DisassociateSecurityProfilesResponse>;
export interface DisassociateTrafficDistributionGroupUserRequest {
  TrafficDistributionGroupId: string;
  UserId: string;
  InstanceId: string;
}
export const DisassociateTrafficDistributionGroupUserRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
    UserId: S.String.pipe(T.HttpQuery("UserId")),
    InstanceId: S.String.pipe(T.HttpQuery("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}/user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateTrafficDistributionGroupUserRequest",
}) as any as S.Schema<DisassociateTrafficDistributionGroupUserRequest>;
export interface DisassociateTrafficDistributionGroupUserResponse {}
export const DisassociateTrafficDistributionGroupUserResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateTrafficDistributionGroupUserResponse",
}) as any as S.Schema<DisassociateTrafficDistributionGroupUserResponse>;
export interface DisassociateWorkspaceRequest {
  InstanceId: string;
  WorkspaceId: string;
  ResourceArns: string[];
}
export const DisassociateWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    ResourceArns: WorkspaceResourceArnList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/disassociate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateWorkspaceRequest",
}) as any as S.Schema<DisassociateWorkspaceRequest>;
export interface DismissUserContactRequest {
  UserId: string;
  InstanceId: string;
  ContactId: string;
}
export const DismissUserContactRequest = S.suspend(() =>
  S.Struct({
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/users/{InstanceId}/{UserId}/contact" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DismissUserContactRequest",
}) as any as S.Schema<DismissUserContactRequest>;
export interface DismissUserContactResponse {}
export const DismissUserContactResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DismissUserContactResponse",
}) as any as S.Schema<DismissUserContactResponse>;
export interface GetAttachedFileRequest {
  InstanceId: string;
  FileId: string;
  UrlExpiryInSeconds?: number;
  AssociatedResourceArn: string;
}
export const GetAttachedFileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileId: S.String.pipe(T.HttpLabel("FileId")),
    UrlExpiryInSeconds: S.optional(S.Number).pipe(
      T.HttpQuery("urlExpiryInSeconds"),
    ),
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/attached-files/{InstanceId}/{FileId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetAttachedFileRequest",
}) as any as S.Schema<GetAttachedFileRequest>;
export interface GetContactAttributesRequest {
  InstanceId: string;
  InitialContactId: string;
}
export const GetContactAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    InitialContactId: S.String.pipe(T.HttpLabel("InitialContactId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact/attributes/{InstanceId}/{InitialContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetContactAttributesRequest",
}) as any as S.Schema<GetContactAttributesRequest>;
export interface GetEffectiveHoursOfOperationsRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  FromDate: string;
  ToDate: string;
}
export const GetEffectiveHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    FromDate: S.String.pipe(T.HttpQuery("fromDate")),
    ToDate: S.String.pipe(T.HttpQuery("toDate")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/effective-hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetEffectiveHoursOfOperationsRequest",
}) as any as S.Schema<GetEffectiveHoursOfOperationsRequest>;
export interface GetFederationTokenRequest {
  InstanceId: string;
}
export const GetFederationTokenRequest = S.suspend(() =>
  S.Struct({ InstanceId: S.String.pipe(T.HttpLabel("InstanceId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/user/federate/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetFederationTokenRequest",
}) as any as S.Schema<GetFederationTokenRequest>;
export interface GetFlowAssociationRequest {
  InstanceId: string;
  ResourceId: string;
  ResourceType: FlowAssociationResourceType;
}
export const GetFlowAssociationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceId: S.String.pipe(T.HttpLabel("ResourceId")),
    ResourceType: FlowAssociationResourceType.pipe(T.HttpLabel("ResourceType")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/flow-associations/{InstanceId}/{ResourceId}/{ResourceType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetFlowAssociationRequest",
}) as any as S.Schema<GetFlowAssociationRequest>;
export interface GetPromptFileRequest {
  InstanceId: string;
  PromptId: string;
}
export const GetPromptFileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/prompts/{InstanceId}/{PromptId}/file" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetPromptFileRequest",
}) as any as S.Schema<GetPromptFileRequest>;
export interface GetTaskTemplateRequest {
  InstanceId: string;
  TaskTemplateId: string;
  SnapshotVersion?: string;
}
export const GetTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TaskTemplateId: S.String.pipe(T.HttpLabel("TaskTemplateId")),
    SnapshotVersion: S.optional(S.String).pipe(T.HttpQuery("snapshotVersion")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/task/template/{TaskTemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetTaskTemplateRequest",
}) as any as S.Schema<GetTaskTemplateRequest>;
export interface GetTrafficDistributionRequest {
  Id: string;
}
export const GetTrafficDistributionRequest = S.suspend(() =>
  S.Struct({ Id: S.String.pipe(T.HttpLabel("Id")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/traffic-distribution/{Id}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetTrafficDistributionRequest",
}) as any as S.Schema<GetTrafficDistributionRequest>;
export interface ImportPhoneNumberRequest {
  InstanceId: string;
  SourcePhoneNumberArn: string;
  PhoneNumberDescription?: string;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
}
export const ImportPhoneNumberRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    SourcePhoneNumberArn: S.String,
    PhoneNumberDescription: S.optional(S.String),
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/import" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ImportPhoneNumberRequest",
}) as any as S.Schema<ImportPhoneNumberRequest>;
export interface ImportWorkspaceMediaRequest {
  InstanceId: string;
  WorkspaceId: string;
  MediaType: MediaType;
  MediaSource: string;
}
export const ImportWorkspaceMediaRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    MediaType: MediaType,
    MediaSource: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/media",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ImportWorkspaceMediaRequest",
}) as any as S.Schema<ImportWorkspaceMediaRequest>;
export interface ImportWorkspaceMediaResponse {}
export const ImportWorkspaceMediaResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "ImportWorkspaceMediaResponse",
}) as any as S.Schema<ImportWorkspaceMediaResponse>;
export interface ListAgentStatusRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  AgentStatusTypes?: AgentStatusType[];
}
export const ListAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    AgentStatusTypes: S.optional(AgentStatusTypes).pipe(
      T.HttpQuery("AgentStatusTypes"),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/agent-status/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAgentStatusRequest",
}) as any as S.Schema<ListAgentStatusRequest>;
export interface ListAnalyticsDataAssociationsRequest {
  InstanceId: string;
  DataSetId?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAnalyticsDataAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataSetId: S.optional(S.String).pipe(T.HttpQuery("DataSetId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/analytics-data/instance/{InstanceId}/association",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAnalyticsDataAssociationsRequest",
}) as any as S.Schema<ListAnalyticsDataAssociationsRequest>;
export interface ListAnalyticsDataLakeDataSetsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAnalyticsDataLakeDataSetsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/analytics-data/instance/{InstanceId}/datasets",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAnalyticsDataLakeDataSetsRequest",
}) as any as S.Schema<ListAnalyticsDataLakeDataSetsRequest>;
export interface ListApprovedOriginsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListApprovedOriginsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/approved-origins" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListApprovedOriginsRequest",
}) as any as S.Schema<ListApprovedOriginsRequest>;
export interface ListAssociatedContactsRequest {
  InstanceId: string;
  ContactId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListAssociatedContactsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpQuery("contactId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contact/associated/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAssociatedContactsRequest",
}) as any as S.Schema<ListAssociatedContactsRequest>;
export interface ListAuthenticationProfilesRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListAuthenticationProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/authentication-profiles-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAuthenticationProfilesRequest",
}) as any as S.Schema<ListAuthenticationProfilesRequest>;
export interface ListBotsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  LexVersion: LexVersion;
}
export const ListBotsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    LexVersion: LexVersion.pipe(T.HttpQuery("lexVersion")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/bots" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListBotsRequest",
}) as any as S.Schema<ListBotsRequest>;
export interface ListContactEvaluationsRequest {
  InstanceId: string;
  ContactId: string;
  NextToken?: string;
}
export const ListContactEvaluationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpQuery("contactId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contact-evaluations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListContactEvaluationsRequest",
}) as any as S.Schema<ListContactEvaluationsRequest>;
export interface ListContactFlowModuleAliasesRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowModuleAliasesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/aliases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListContactFlowModuleAliasesRequest",
}) as any as S.Schema<ListContactFlowModuleAliasesRequest>;
export interface ListContactFlowModulesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  ContactFlowModuleState?: ContactFlowModuleState;
}
export const ListContactFlowModulesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    ContactFlowModuleState: S.optional(ContactFlowModuleState).pipe(
      T.HttpQuery("state"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListContactFlowModulesRequest",
}) as any as S.Schema<ListContactFlowModulesRequest>;
export interface ListContactFlowModuleVersionsRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowModuleVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListContactFlowModuleVersionsRequest",
}) as any as S.Schema<ListContactFlowModuleVersionsRequest>;
export interface ListContactFlowsRequest {
  InstanceId: string;
  ContactFlowTypes?: ContactFlowType[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowTypes: S.optional(ContactFlowTypes).pipe(
      T.HttpQuery("contactFlowTypes"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/contact-flows-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListContactFlowsRequest",
}) as any as S.Schema<ListContactFlowsRequest>;
export interface ListContactFlowVersionsRequest {
  InstanceId: string;
  ContactFlowId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListContactFlowVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListContactFlowVersionsRequest",
}) as any as S.Schema<ListContactFlowVersionsRequest>;
export interface ListContactReferencesRequest {
  InstanceId: string;
  ContactId: string;
  ReferenceTypes: ReferenceType[];
  NextToken?: string;
}
export const ListContactReferencesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    ReferenceTypes: ReferenceTypes.pipe(T.HttpQuery("referenceTypes")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/contact/references/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListContactReferencesRequest",
}) as any as S.Schema<ListContactReferencesRequest>;
export interface ListDataTableAttributesRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeIds?: string[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTableAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeIds: S.optional(AttributeIds),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDataTableAttributesRequest",
}) as any as S.Schema<ListDataTableAttributesRequest>;
export interface ListDataTablesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTablesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/data-tables/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDataTablesRequest",
}) as any as S.Schema<ListDataTablesRequest>;
export type ValueList = string[];
export const ValueList = S.Array(S.String);
export interface PrimaryAttributeValueFilter {
  AttributeName: string;
  Values: string[];
}
export const PrimaryAttributeValueFilter = S.suspend(() =>
  S.Struct({ AttributeName: S.String, Values: ValueList }),
).annotations({
  identifier: "PrimaryAttributeValueFilter",
}) as any as S.Schema<PrimaryAttributeValueFilter>;
export type PrimaryAttributeValueFilters = PrimaryAttributeValueFilter[];
export const PrimaryAttributeValueFilters = S.Array(
  PrimaryAttributeValueFilter,
);
export interface ListDataTableValuesRequest {
  InstanceId: string;
  DataTableId: string;
  RecordIds?: string[];
  PrimaryAttributeValues?: PrimaryAttributeValueFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTableValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    RecordIds: S.optional(RecordIds),
    PrimaryAttributeValues: S.optional(PrimaryAttributeValueFilters),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/list",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDataTableValuesRequest",
}) as any as S.Schema<ListDataTableValuesRequest>;
export interface ListDefaultVocabulariesRequest {
  InstanceId: string;
  LanguageCode?: VocabularyLanguageCode;
  MaxResults?: number;
  NextToken?: string;
}
export const ListDefaultVocabulariesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LanguageCode: S.optional(VocabularyLanguageCode),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/default-vocabulary-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDefaultVocabulariesRequest",
}) as any as S.Schema<ListDefaultVocabulariesRequest>;
export interface ListEntitySecurityProfilesRequest {
  InstanceId: string;
  EntityType: EntityType;
  EntityArn: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListEntitySecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EntityType: EntityType,
    EntityArn: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/entity-security-profiles-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListEntitySecurityProfilesRequest",
}) as any as S.Schema<ListEntitySecurityProfilesRequest>;
export interface ListEvaluationFormsRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListEvaluationFormsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/evaluation-forms/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListEvaluationFormsRequest",
}) as any as S.Schema<ListEvaluationFormsRequest>;
export interface ListEvaluationFormVersionsRequest {
  InstanceId: string;
  EvaluationFormId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListEvaluationFormVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListEvaluationFormVersionsRequest",
}) as any as S.Schema<ListEvaluationFormVersionsRequest>;
export interface ListFlowAssociationsRequest {
  InstanceId: string;
  ResourceType?: ListFlowAssociationResourceType;
  NextToken?: string;
  MaxResults?: number;
}
export const ListFlowAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceType: S.optional(ListFlowAssociationResourceType).pipe(
      T.HttpQuery("ResourceType"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/flow-associations-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListFlowAssociationsRequest",
}) as any as S.Schema<ListFlowAssociationsRequest>;
export interface ListHoursOfOperationOverridesRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListHoursOfOperationOverridesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListHoursOfOperationOverridesRequest",
}) as any as S.Schema<ListHoursOfOperationOverridesRequest>;
export interface ListHoursOfOperationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/hours-of-operations-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListHoursOfOperationsRequest",
}) as any as S.Schema<ListHoursOfOperationsRequest>;
export interface ListInstanceAttributesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListInstanceAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/attributes" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListInstanceAttributesRequest",
}) as any as S.Schema<ListInstanceAttributesRequest>;
export interface ListInstancesRequest {
  NextToken?: string;
  MaxResults?: number;
}
export const ListInstancesRequest = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListInstancesRequest",
}) as any as S.Schema<ListInstancesRequest>;
export interface ListInstanceStorageConfigsRequest {
  InstanceId: string;
  ResourceType: InstanceStorageResourceType;
  NextToken?: string;
  MaxResults?: number;
}
export const ListInstanceStorageConfigsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/storage-configs" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListInstanceStorageConfigsRequest",
}) as any as S.Schema<ListInstanceStorageConfigsRequest>;
export interface ListIntegrationAssociationsRequest {
  InstanceId: string;
  IntegrationType?: IntegrationType;
  NextToken?: string;
  MaxResults?: number;
  IntegrationArn?: string;
}
export const ListIntegrationAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationType: S.optional(IntegrationType).pipe(
      T.HttpQuery("integrationType"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    IntegrationArn: S.optional(S.String).pipe(T.HttpQuery("integrationArn")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/integration-associations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListIntegrationAssociationsRequest",
}) as any as S.Schema<ListIntegrationAssociationsRequest>;
export interface ListLambdaFunctionsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListLambdaFunctionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/lambda-functions" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListLambdaFunctionsRequest",
}) as any as S.Schema<ListLambdaFunctionsRequest>;
export interface ListLexBotsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListLexBotsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/lex-bots" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListLexBotsRequest",
}) as any as S.Schema<ListLexBotsRequest>;
export interface ListPhoneNumbersRequest {
  InstanceId: string;
  PhoneNumberTypes?: PhoneNumberType[];
  PhoneNumberCountryCodes?: PhoneNumberCountryCode[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListPhoneNumbersRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PhoneNumberTypes: S.optional(PhoneNumberTypes).pipe(
      T.HttpQuery("phoneNumberTypes"),
    ),
    PhoneNumberCountryCodes: S.optional(PhoneNumberCountryCodes).pipe(
      T.HttpQuery("phoneNumberCountryCodes"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/phone-numbers-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListPhoneNumbersRequest",
}) as any as S.Schema<ListPhoneNumbersRequest>;
export interface ListPhoneNumbersV2Request {
  TargetArn?: string;
  InstanceId?: string;
  MaxResults?: number;
  NextToken?: string;
  PhoneNumberCountryCodes?: PhoneNumberCountryCode[];
  PhoneNumberTypes?: PhoneNumberType[];
  PhoneNumberPrefix?: string;
}
export const ListPhoneNumbersV2Request = S.suspend(() =>
  S.Struct({
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    PhoneNumberCountryCodes: S.optional(PhoneNumberCountryCodes),
    PhoneNumberTypes: S.optional(PhoneNumberTypes),
    PhoneNumberPrefix: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/list" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListPhoneNumbersV2Request",
}) as any as S.Schema<ListPhoneNumbersV2Request>;
export interface ListPredefinedAttributesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPredefinedAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/predefined-attributes/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListPredefinedAttributesRequest",
}) as any as S.Schema<ListPredefinedAttributesRequest>;
export interface ListPromptsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListPromptsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/prompts-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListPromptsRequest",
}) as any as S.Schema<ListPromptsRequest>;
export interface ListQueueQuickConnectsRequest {
  InstanceId: string;
  QueueId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListQueueQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/queues/{InstanceId}/{QueueId}/quick-connects",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListQueueQuickConnectsRequest",
}) as any as S.Schema<ListQueueQuickConnectsRequest>;
export interface ListQueuesRequest {
  InstanceId: string;
  QueueTypes?: QueueType[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueTypes: S.optional(QueueTypes).pipe(T.HttpQuery("queueTypes")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/queues-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListQueuesRequest",
}) as any as S.Schema<ListQueuesRequest>;
export interface ListQuickConnectsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  QuickConnectTypes?: QuickConnectType[];
}
export const ListQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    QuickConnectTypes: S.optional(QuickConnectTypes).pipe(
      T.HttpQuery("QuickConnectTypes"),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/quick-connects/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListQuickConnectsRequest",
}) as any as S.Schema<ListQuickConnectsRequest>;
export interface ListRealtimeContactAnalysisSegmentsV2Request {
  InstanceId: string;
  ContactId: string;
  MaxResults?: number;
  NextToken?: string;
  OutputType: RealTimeContactAnalysisOutputType;
  SegmentTypes: RealTimeContactAnalysisSegmentType[];
}
export const ListRealtimeContactAnalysisSegmentsV2Request = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    OutputType: RealTimeContactAnalysisOutputType,
    SegmentTypes: RealTimeContactAnalysisSegmentTypes,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/list-real-time-analysis-segments-v2/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListRealtimeContactAnalysisSegmentsV2Request",
}) as any as S.Schema<ListRealtimeContactAnalysisSegmentsV2Request>;
export interface ListRoutingProfileManualAssignmentQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListRoutingProfileManualAssignmentQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/manual-assignment-queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListRoutingProfileManualAssignmentQueuesRequest",
}) as any as S.Schema<ListRoutingProfileManualAssignmentQueuesRequest>;
export interface ListRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListRoutingProfileQueuesRequest",
}) as any as S.Schema<ListRoutingProfileQueuesRequest>;
export interface ListRoutingProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListRoutingProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/routing-profiles-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListRoutingProfilesRequest",
}) as any as S.Schema<ListRoutingProfilesRequest>;
export interface ListRulesRequest {
  InstanceId: string;
  PublishStatus?: RulePublishStatus;
  EventSourceName?: EventSourceName;
  MaxResults?: number;
  NextToken?: string;
}
export const ListRulesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PublishStatus: S.optional(RulePublishStatus).pipe(
      T.HttpQuery("publishStatus"),
    ),
    EventSourceName: S.optional(EventSourceName).pipe(
      T.HttpQuery("eventSourceName"),
    ),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/rules/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListRulesRequest",
}) as any as S.Schema<ListRulesRequest>;
export interface ListSecurityKeysRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityKeysRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/security-keys" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListSecurityKeysRequest",
}) as any as S.Schema<ListSecurityKeysRequest>;
export interface ListSecurityProfileApplicationsRequest {
  SecurityProfileId: string;
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfileApplicationsRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles-applications/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListSecurityProfileApplicationsRequest",
}) as any as S.Schema<ListSecurityProfileApplicationsRequest>;
export interface ListSecurityProfileFlowModulesRequest {
  SecurityProfileId: string;
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfileFlowModulesRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles-flow-modules/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListSecurityProfileFlowModulesRequest",
}) as any as S.Schema<ListSecurityProfileFlowModulesRequest>;
export interface ListSecurityProfilePermissionsRequest {
  SecurityProfileId: string;
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfilePermissionsRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/security-profiles-permissions/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListSecurityProfilePermissionsRequest",
}) as any as S.Schema<ListSecurityProfilePermissionsRequest>;
export interface ListSecurityProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/security-profiles-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListSecurityProfilesRequest",
}) as any as S.Schema<ListSecurityProfilesRequest>;
export interface ListTagsForResourceRequest {
  resourceArn: string;
}
export const ListTagsForResourceRequest = S.suspend(() =>
  S.Struct({ resourceArn: S.String.pipe(T.HttpLabel("resourceArn")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/tags/{resourceArn}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTagsForResourceRequest",
}) as any as S.Schema<ListTagsForResourceRequest>;
export interface ListTaskTemplatesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  Status?: TaskTemplateStatus;
  Name?: string;
}
export const ListTaskTemplatesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    Status: S.optional(TaskTemplateStatus).pipe(T.HttpQuery("status")),
    Name: S.optional(S.String).pipe(T.HttpQuery("name")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/instance/{InstanceId}/task/template" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTaskTemplatesRequest",
}) as any as S.Schema<ListTaskTemplatesRequest>;
export interface ListTrafficDistributionGroupsRequest {
  MaxResults?: number;
  NextToken?: string;
  InstanceId?: string;
}
export const ListTrafficDistributionGroupsRequest = S.suspend(() =>
  S.Struct({
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    InstanceId: S.optional(S.String).pipe(T.HttpQuery("instanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/traffic-distribution-groups" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTrafficDistributionGroupsRequest",
}) as any as S.Schema<ListTrafficDistributionGroupsRequest>;
export interface ListTrafficDistributionGroupUsersRequest {
  TrafficDistributionGroupId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListTrafficDistributionGroupUsersRequest = S.suspend(() =>
  S.Struct({
    TrafficDistributionGroupId: S.String.pipe(
      T.HttpLabel("TrafficDistributionGroupId"),
    ),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/traffic-distribution-group/{TrafficDistributionGroupId}/user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTrafficDistributionGroupUsersRequest",
}) as any as S.Schema<ListTrafficDistributionGroupUsersRequest>;
export interface ListUseCasesRequest {
  InstanceId: string;
  IntegrationAssociationId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUseCasesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    IntegrationAssociationId: S.String.pipe(
      T.HttpLabel("IntegrationAssociationId"),
    ),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/instance/{InstanceId}/integration-associations/{IntegrationAssociationId}/use-cases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListUseCasesRequest",
}) as any as S.Schema<ListUseCasesRequest>;
export interface ListUserHierarchyGroupsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUserHierarchyGroupsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/user-hierarchy-groups-summary/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListUserHierarchyGroupsRequest",
}) as any as S.Schema<ListUserHierarchyGroupsRequest>;
export interface ListUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/users/{InstanceId}/{UserId}/proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListUserProficienciesRequest",
}) as any as S.Schema<ListUserProficienciesRequest>;
export interface ListUsersRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUsersRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/users-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListUsersRequest",
}) as any as S.Schema<ListUsersRequest>;
export interface ListViewsRequest {
  InstanceId: string;
  Type?: ViewType;
  NextToken?: string;
  MaxResults?: number;
}
export const ListViewsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Type: S.optional(ViewType).pipe(T.HttpQuery("type")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/views/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListViewsRequest",
}) as any as S.Schema<ListViewsRequest>;
export interface ListViewVersionsRequest {
  InstanceId: string;
  ViewId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListViewVersionsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/views/{InstanceId}/{ViewId}/versions" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListViewVersionsRequest",
}) as any as S.Schema<ListViewVersionsRequest>;
export interface ListWorkspaceMediaRequest {
  InstanceId: string;
  WorkspaceId: string;
}
export const ListWorkspaceMediaRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/media",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListWorkspaceMediaRequest",
}) as any as S.Schema<ListWorkspaceMediaRequest>;
export interface ListWorkspacePagesRequest {
  InstanceId: string;
  WorkspaceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListWorkspacePagesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListWorkspacePagesRequest",
}) as any as S.Schema<ListWorkspacePagesRequest>;
export interface ListWorkspacesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListWorkspacesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/workspaces/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListWorkspacesRequest",
}) as any as S.Schema<ListWorkspacesRequest>;
export interface MonitorContactRequest {
  InstanceId: string;
  ContactId: string;
  UserId: string;
  AllowedMonitorCapabilities?: MonitorCapability[];
  ClientToken?: string;
}
export const MonitorContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    UserId: S.String,
    AllowedMonitorCapabilities: S.optional(AllowedMonitorCapabilities),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/monitor" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "MonitorContactRequest",
}) as any as S.Schema<MonitorContactRequest>;
export interface PauseContactRequest {
  ContactId: string;
  InstanceId: string;
  ContactFlowId?: string;
}
export const PauseContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    ContactFlowId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/pause" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "PauseContactRequest",
}) as any as S.Schema<PauseContactRequest>;
export interface PauseContactResponse {}
export const PauseContactResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "PauseContactResponse",
}) as any as S.Schema<PauseContactResponse>;
export interface PutUserStatusRequest {
  UserId: string;
  InstanceId: string;
  AgentStatusId: string;
}
export const PutUserStatusRequest = S.suspend(() =>
  S.Struct({
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AgentStatusId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/users/{InstanceId}/{UserId}/status" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "PutUserStatusRequest",
}) as any as S.Schema<PutUserStatusRequest>;
export interface PutUserStatusResponse {}
export const PutUserStatusResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "PutUserStatusResponse",
}) as any as S.Schema<PutUserStatusResponse>;
export interface ReleasePhoneNumberRequest {
  PhoneNumberId: string;
  ClientToken?: string;
}
export const ReleasePhoneNumberRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    ClientToken: S.optional(S.String).pipe(
      T.HttpQuery("clientToken"),
      T.IdempotencyToken(),
    ),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/phone-number/{PhoneNumberId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ReleasePhoneNumberRequest",
}) as any as S.Schema<ReleasePhoneNumberRequest>;
export interface ReleasePhoneNumberResponse {}
export const ReleasePhoneNumberResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "ReleasePhoneNumberResponse",
}) as any as S.Schema<ReleasePhoneNumberResponse>;
export interface ReplicateInstanceRequest {
  InstanceId: string;
  ReplicaRegion: string;
  ClientToken?: string;
  ReplicaAlias: string | redacted.Redacted<string>;
}
export const ReplicateInstanceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ReplicaRegion: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ReplicaAlias: SensitiveString,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/instance/{InstanceId}/replicate" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ReplicateInstanceRequest",
}) as any as S.Schema<ReplicateInstanceRequest>;
export interface ResumeContactRequest {
  ContactId: string;
  InstanceId: string;
  ContactFlowId?: string;
}
export const ResumeContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    ContactFlowId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/resume" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ResumeContactRequest",
}) as any as S.Schema<ResumeContactRequest>;
export interface ResumeContactResponse {}
export const ResumeContactResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "ResumeContactResponse",
}) as any as S.Schema<ResumeContactResponse>;
export interface ResumeContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  ContactRecordingType?: ContactRecordingType;
}
export const ResumeContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    ContactRecordingType: S.optional(ContactRecordingType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/resume-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ResumeContactRecordingRequest",
}) as any as S.Schema<ResumeContactRecordingRequest>;
export interface ResumeContactRecordingResponse {}
export const ResumeContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "ResumeContactRecordingResponse",
}) as any as S.Schema<ResumeContactRecordingResponse>;
export interface SearchAvailablePhoneNumbersRequest {
  TargetArn?: string;
  InstanceId?: string;
  PhoneNumberCountryCode: PhoneNumberCountryCode;
  PhoneNumberType: PhoneNumberType;
  PhoneNumberPrefix?: string;
  MaxResults?: number;
  NextToken?: string;
}
export const SearchAvailablePhoneNumbersRequest = S.suspend(() =>
  S.Struct({
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    PhoneNumberCountryCode: PhoneNumberCountryCode,
    PhoneNumberType: PhoneNumberType,
    PhoneNumberPrefix: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/search-available" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchAvailablePhoneNumbersRequest",
}) as any as S.Schema<SearchAvailablePhoneNumbersRequest>;
export interface SearchVocabulariesRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
  State?: VocabularyState;
  NameStartsWith?: string;
  LanguageCode?: VocabularyLanguageCode;
}
export const SearchVocabulariesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    State: S.optional(VocabularyState),
    NameStartsWith: S.optional(S.String),
    LanguageCode: S.optional(VocabularyLanguageCode),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/vocabulary-summary/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchVocabulariesRequest",
}) as any as S.Schema<SearchVocabulariesRequest>;
export interface StartContactMediaProcessingRequest {
  InstanceId?: string;
  ContactId?: string;
  ProcessorArn?: string;
  FailureMode?: ContactMediaProcessingFailureMode;
}
export const StartContactMediaProcessingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    ContactId: S.optional(S.String),
    ProcessorArn: S.optional(S.String),
    FailureMode: S.optional(ContactMediaProcessingFailureMode),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/start-contact-media-processing",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartContactMediaProcessingRequest",
}) as any as S.Schema<StartContactMediaProcessingRequest>;
export interface StartContactMediaProcessingResponse {}
export const StartContactMediaProcessingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "StartContactMediaProcessingResponse",
}) as any as S.Schema<StartContactMediaProcessingResponse>;
export interface EmailAddressInfo {
  EmailAddress: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
}
export const EmailAddressInfo = S.suspend(() =>
  S.Struct({
    EmailAddress: SensitiveString,
    DisplayName: S.optional(SensitiveString),
  }),
).annotations({
  identifier: "EmailAddressInfo",
}) as any as S.Schema<EmailAddressInfo>;
export type EmailAddressRecipientList = EmailAddressInfo[];
export const EmailAddressRecipientList = S.Array(EmailAddressInfo);
export interface OutboundAdditionalRecipients {
  CcEmailAddresses?: EmailAddressInfo[];
}
export const OutboundAdditionalRecipients = S.suspend(() =>
  S.Struct({ CcEmailAddresses: S.optional(EmailAddressRecipientList) }),
).annotations({
  identifier: "OutboundAdditionalRecipients",
}) as any as S.Schema<OutboundAdditionalRecipients>;
export type OutboundMessageSourceType = "TEMPLATE" | "RAW" | (string & {});
export const OutboundMessageSourceType = S.String;
export type Attributes = { [key: string]: string | undefined };
export const Attributes = S.Record({
  key: S.String,
  value: S.UndefinedOr(S.String),
});
export interface TemplateAttributes {
  CustomAttributes?: { [key: string]: string | undefined };
  CustomerProfileAttributes?: string;
}
export const TemplateAttributes = S.suspend(() =>
  S.Struct({
    CustomAttributes: S.optional(Attributes),
    CustomerProfileAttributes: S.optional(S.String),
  }),
).annotations({
  identifier: "TemplateAttributes",
}) as any as S.Schema<TemplateAttributes>;
export interface TemplatedMessageConfig {
  KnowledgeBaseId: string;
  MessageTemplateId: string;
  TemplateAttributes: TemplateAttributes;
}
export const TemplatedMessageConfig = S.suspend(() =>
  S.Struct({
    KnowledgeBaseId: S.String,
    MessageTemplateId: S.String,
    TemplateAttributes: TemplateAttributes,
  }),
).annotations({
  identifier: "TemplatedMessageConfig",
}) as any as S.Schema<TemplatedMessageConfig>;
export interface OutboundRawMessage {
  Subject: string | redacted.Redacted<string>;
  Body: string | redacted.Redacted<string>;
  ContentType: string;
}
export const OutboundRawMessage = S.suspend(() =>
  S.Struct({
    Subject: SensitiveString,
    Body: SensitiveString,
    ContentType: S.String,
  }),
).annotations({
  identifier: "OutboundRawMessage",
}) as any as S.Schema<OutboundRawMessage>;
export interface OutboundEmailContent {
  MessageSourceType: OutboundMessageSourceType;
  TemplatedMessageConfig?: TemplatedMessageConfig;
  RawMessage?: OutboundRawMessage;
}
export const OutboundEmailContent = S.suspend(() =>
  S.Struct({
    MessageSourceType: OutboundMessageSourceType,
    TemplatedMessageConfig: S.optional(TemplatedMessageConfig),
    RawMessage: S.optional(OutboundRawMessage),
  }),
).annotations({
  identifier: "OutboundEmailContent",
}) as any as S.Schema<OutboundEmailContent>;
export interface StartOutboundEmailContactRequest {
  InstanceId: string;
  ContactId: string;
  FromEmailAddress?: EmailAddressInfo;
  DestinationEmailAddress: EmailAddressInfo;
  AdditionalRecipients?: OutboundAdditionalRecipients;
  EmailMessage: OutboundEmailContent;
  ClientToken?: string;
}
export const StartOutboundEmailContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    FromEmailAddress: S.optional(EmailAddressInfo),
    DestinationEmailAddress: EmailAddressInfo,
    AdditionalRecipients: S.optional(OutboundAdditionalRecipients),
    EmailMessage: OutboundEmailContent,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/outbound-email" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartOutboundEmailContactRequest",
}) as any as S.Schema<StartOutboundEmailContactRequest>;
export interface StartScreenSharingRequest {
  ClientToken?: string;
  InstanceId: string;
  ContactId: string;
}
export const StartScreenSharingRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String,
    ContactId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/screen-sharing" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartScreenSharingRequest",
}) as any as S.Schema<StartScreenSharingRequest>;
export interface StartScreenSharingResponse {}
export const StartScreenSharingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "StartScreenSharingResponse",
}) as any as S.Schema<StartScreenSharingResponse>;
export type ReferenceStatus =
  | "AVAILABLE"
  | "DELETED"
  | "APPROVED"
  | "REJECTED"
  | "PROCESSING"
  | "FAILED"
  | (string & {});
export const ReferenceStatus = S.String;
export interface Reference {
  Value?: string;
  Type: ReferenceType;
  Status?: ReferenceStatus;
  Arn?: string;
  StatusReason?: string;
}
export const Reference = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String),
    Type: ReferenceType,
    Status: S.optional(ReferenceStatus),
    Arn: S.optional(S.String),
    StatusReason: S.optional(S.String),
  }),
).annotations({ identifier: "Reference" }) as any as S.Schema<Reference>;
export type ContactReferences = { [key: string]: Reference | undefined };
export const ContactReferences = S.Record({
  key: S.String,
  value: S.UndefinedOr(Reference),
});
export interface SegmentAttributeValue {
  ValueString?: string;
  ValueMap?: { [key: string]: SegmentAttributeValue | undefined };
  ValueInteger?: number;
  ValueList?: SegmentAttributeValue[];
  ValueArn?: string;
}
export const SegmentAttributeValue = S.suspend(() =>
  S.Struct({
    ValueString: S.optional(S.String),
    ValueMap: S.optional(
      S.suspend(() => SegmentAttributeValueMap).annotations({
        identifier: "SegmentAttributeValueMap",
      }),
    ),
    ValueInteger: S.optional(S.Number),
    ValueList: S.optional(
      S.suspend(() => SegmentAttributeValueList).annotations({
        identifier: "SegmentAttributeValueList",
      }),
    ),
    ValueArn: S.optional(S.String),
  }),
).annotations({
  identifier: "SegmentAttributeValue",
}) as any as S.Schema<SegmentAttributeValue>;
export type SegmentAttributes = {
  [key: string]: SegmentAttributeValue | undefined;
};
export const SegmentAttributes = S.Record({
  key: S.String,
  value: S.UndefinedOr(
    S.suspend(
      (): S.Schema<SegmentAttributeValue, any> => SegmentAttributeValue,
    ).annotations({ identifier: "SegmentAttributeValue" }),
  ),
});
export interface StartTaskContactRequest {
  InstanceId: string;
  PreviousContactId?: string;
  ContactFlowId?: string;
  Attributes?: { [key: string]: string | undefined };
  Name: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  Description?: string | redacted.Redacted<string>;
  ClientToken?: string;
  ScheduledTime?: Date;
  TaskTemplateId?: string;
  QuickConnectId?: string;
  RelatedContactId?: string;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
}
export const StartTaskContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    PreviousContactId: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    Name: SensitiveString,
    References: S.optional(ContactReferences),
    Description: S.optional(SensitiveString),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ScheduledTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    TaskTemplateId: S.optional(S.String),
    QuickConnectId: S.optional(S.String),
    RelatedContactId: S.optional(S.String),
    SegmentAttributes: S.optional(SegmentAttributes),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/task" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartTaskContactRequest",
}) as any as S.Schema<StartTaskContactRequest>;
export interface StopContactMediaProcessingRequest {
  InstanceId?: string;
  ContactId?: string;
}
export const StopContactMediaProcessingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    ContactId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop-contact-media-processing" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StopContactMediaProcessingRequest",
}) as any as S.Schema<StopContactMediaProcessingRequest>;
export interface StopContactMediaProcessingResponse {}
export const StopContactMediaProcessingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "StopContactMediaProcessingResponse",
}) as any as S.Schema<StopContactMediaProcessingResponse>;
export interface StopContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  ContactRecordingType?: ContactRecordingType;
}
export const StopContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    ContactRecordingType: S.optional(ContactRecordingType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StopContactRecordingRequest",
}) as any as S.Schema<StopContactRecordingRequest>;
export interface StopContactRecordingResponse {}
export const StopContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "StopContactRecordingResponse",
}) as any as S.Schema<StopContactRecordingResponse>;
export interface StopContactStreamingRequest {
  InstanceId: string;
  ContactId: string;
  StreamingId: string;
}
export const StopContactStreamingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    StreamingId: S.String,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop-streaming" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StopContactStreamingRequest",
}) as any as S.Schema<StopContactStreamingRequest>;
export interface StopContactStreamingResponse {}
export const StopContactStreamingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "StopContactStreamingResponse",
}) as any as S.Schema<StopContactStreamingResponse>;
export interface SuspendContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  ContactRecordingType?: ContactRecordingType;
}
export const SuspendContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    ContactRecordingType: S.optional(ContactRecordingType),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/suspend-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SuspendContactRecordingRequest",
}) as any as S.Schema<SuspendContactRecordingRequest>;
export interface SuspendContactRecordingResponse {}
export const SuspendContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "SuspendContactRecordingResponse",
}) as any as S.Schema<SuspendContactRecordingResponse>;
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | undefined };
}
export const TagResourceRequest = S.suspend(() =>
  S.Struct({
    resourceArn: S.String.pipe(T.HttpLabel("resourceArn")),
    tags: TagMap,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/tags/{resourceArn}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "TagResourceRequest",
}) as any as S.Schema<TagResourceRequest>;
export interface TagResourceResponse {}
export const TagResourceResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "TagResourceResponse",
}) as any as S.Schema<TagResourceResponse>;
export interface TransferContactRequest {
  InstanceId: string;
  ContactId: string;
  QueueId?: string;
  UserId?: string;
  ContactFlowId: string;
  ClientToken?: string;
}
export const TransferContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    QueueId: S.optional(S.String),
    UserId: S.optional(S.String),
    ContactFlowId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/transfer" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "TransferContactRequest",
}) as any as S.Schema<TransferContactRequest>;
export interface UntagContactRequest {
  ContactId: string;
  InstanceId: string;
  TagKeys: string[];
}
export const UntagContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    TagKeys: ContactTagKeys.pipe(T.HttpQuery("TagKeys")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/contact/tags/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UntagContactRequest",
}) as any as S.Schema<UntagContactRequest>;
export interface UntagContactResponse {}
export const UntagContactResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "UntagContactResponse",
}) as any as S.Schema<UntagContactResponse>;
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}
export const UntagResourceRequest = S.suspend(() =>
  S.Struct({
    resourceArn: S.String.pipe(T.HttpLabel("resourceArn")),
    tagKeys: TagKeyList.pipe(T.HttpQuery("tagKeys")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/tags/{resourceArn}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UntagResourceRequest",
}) as any as S.Schema<UntagResourceRequest>;
export interface UntagResourceResponse {}
export const UntagResourceResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "UntagResourceResponse",
}) as any as S.Schema<UntagResourceResponse>;
export interface UpdateAgentStatusRequest {
  InstanceId: string;
  AgentStatusId: string;
  Name?: string;
  Description?: string;
  State?: AgentStatusState;
  DisplayOrder?: number;
  ResetOrderNumber?: boolean;
}
export const UpdateAgentStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AgentStatusId: S.String.pipe(T.HttpLabel("AgentStatusId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    State: S.optional(AgentStatusState),
    DisplayOrder: S.optional(S.Number),
    ResetOrderNumber: S.optional(S.Boolean),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/agent-status/{InstanceId}/{AgentStatusId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateAgentStatusRequest",
}) as any as S.Schema<UpdateAgentStatusRequest>;
export interface UpdateAgentStatusResponse {}
export const UpdateAgentStatusResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateAgentStatusResponse",
}) as any as S.Schema<UpdateAgentStatusResponse>;
export interface UpdateAuthenticationProfileRequest {
  AuthenticationProfileId: string;
  InstanceId: string;
  Name?: string;
  Description?: string;
  AllowedIps?: string[];
  BlockedIps?: string[];
  PeriodicSessionDuration?: number;
  SessionInactivityDuration?: number;
  SessionInactivityHandlingEnabled?: boolean;
}
export const UpdateAuthenticationProfileRequest = S.suspend(() =>
  S.Struct({
    AuthenticationProfileId: S.String.pipe(
      T.HttpLabel("AuthenticationProfileId"),
    ),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    AllowedIps: S.optional(IpCidrList),
    BlockedIps: S.optional(IpCidrList),
    PeriodicSessionDuration: S.optional(S.Number),
    SessionInactivityDuration: S.optional(S.Number),
    SessionInactivityHandlingEnabled: S.optional(S.Boolean),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/authentication-profiles/{InstanceId}/{AuthenticationProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateAuthenticationProfileRequest",
}) as any as S.Schema<UpdateAuthenticationProfileRequest>;
export interface UpdateAuthenticationProfileResponse {}
export const UpdateAuthenticationProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateAuthenticationProfileResponse",
}) as any as S.Schema<UpdateAuthenticationProfileResponse>;
export interface UpdateContactAttributesRequest {
  InitialContactId: string;
  InstanceId: string;
  Attributes: { [key: string]: string | undefined };
}
export const UpdateContactAttributesRequest = S.suspend(() =>
  S.Struct({
    InitialContactId: S.String,
    InstanceId: S.String,
    Attributes: Attributes,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/attributes" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactAttributesRequest",
}) as any as S.Schema<UpdateContactAttributesRequest>;
export interface UpdateContactAttributesResponse {}
export const UpdateContactAttributesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactAttributesResponse",
}) as any as S.Schema<UpdateContactAttributesResponse>;
export type EvaluationAnswerDataStringValueList = string[];
export const EvaluationAnswerDataStringValueList = S.Array(S.String);
export type EvaluationAnswerData =
  | {
      StringValue: string;
      NumericValue?: never;
      StringValues?: never;
      DateTimeValue?: never;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue: number;
      StringValues?: never;
      DateTimeValue?: never;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue?: never;
      StringValues: string[];
      DateTimeValue?: never;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue?: never;
      StringValues?: never;
      DateTimeValue: string;
      NotApplicable?: never;
    }
  | {
      StringValue?: never;
      NumericValue?: never;
      StringValues?: never;
      DateTimeValue?: never;
      NotApplicable: boolean;
    };
export const EvaluationAnswerData = S.Union(
  S.Struct({ StringValue: S.String }),
  S.Struct({ NumericValue: S.Number }),
  S.Struct({ StringValues: EvaluationAnswerDataStringValueList }),
  S.Struct({ DateTimeValue: S.String }),
  S.Struct({ NotApplicable: S.Boolean }),
);
export interface EvaluationAnswerInput {
  Value?: EvaluationAnswerData;
}
export const EvaluationAnswerInput = S.suspend(() =>
  S.Struct({ Value: S.optional(EvaluationAnswerData) }),
).annotations({
  identifier: "EvaluationAnswerInput",
}) as any as S.Schema<EvaluationAnswerInput>;
export type EvaluationAnswersInputMap = {
  [key: string]: EvaluationAnswerInput | undefined;
};
export const EvaluationAnswersInputMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(EvaluationAnswerInput),
});
export interface EvaluationNote {
  Value?: string;
}
export const EvaluationNote = S.suspend(() =>
  S.Struct({ Value: S.optional(S.String) }),
).annotations({
  identifier: "EvaluationNote",
}) as any as S.Schema<EvaluationNote>;
export type EvaluationNotesMap = { [key: string]: EvaluationNote | undefined };
export const EvaluationNotesMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(EvaluationNote),
});
export type EvaluatorUserUnion = { ConnectUserArn: string };
export const EvaluatorUserUnion = S.Union(
  S.Struct({ ConnectUserArn: S.String }),
);
export interface UpdateContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
  Answers?: { [key: string]: EvaluationAnswerInput | undefined };
  Notes?: { [key: string]: EvaluationNote | undefined };
  UpdatedBy?: EvaluatorUserUnion;
}
export const UpdateContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
    Answers: S.optional(EvaluationAnswersInputMap),
    Notes: S.optional(EvaluationNotesMap),
    UpdatedBy: S.optional(EvaluatorUserUnion),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactEvaluationRequest",
}) as any as S.Schema<UpdateContactEvaluationRequest>;
export interface UpdateContactFlowContentRequest {
  InstanceId: string;
  ContactFlowId: string;
  Content: string;
}
export const UpdateContactFlowContentRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    Content: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/content",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactFlowContentRequest",
}) as any as S.Schema<UpdateContactFlowContentRequest>;
export interface UpdateContactFlowContentResponse {}
export const UpdateContactFlowContentResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactFlowContentResponse",
}) as any as S.Schema<UpdateContactFlowContentResponse>;
export interface UpdateContactFlowMetadataRequest {
  InstanceId: string;
  ContactFlowId: string;
  Name?: string;
  Description?: string;
  ContactFlowState?: ContactFlowState;
}
export const UpdateContactFlowMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowState: S.optional(ContactFlowState),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/metadata",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactFlowMetadataRequest",
}) as any as S.Schema<UpdateContactFlowMetadataRequest>;
export interface UpdateContactFlowMetadataResponse {}
export const UpdateContactFlowMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactFlowMetadataResponse",
}) as any as S.Schema<UpdateContactFlowMetadataResponse>;
export interface UpdateContactFlowModuleAliasRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  AliasId: string;
  Name?: string;
  Description?: string;
  ContactFlowModuleVersion?: number;
}
export const UpdateContactFlowModuleAliasRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    AliasId: S.String.pipe(T.HttpLabel("AliasId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowModuleVersion: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/alias/{AliasId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactFlowModuleAliasRequest",
}) as any as S.Schema<UpdateContactFlowModuleAliasRequest>;
export interface UpdateContactFlowModuleAliasResponse {}
export const UpdateContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactFlowModuleAliasResponse",
}) as any as S.Schema<UpdateContactFlowModuleAliasResponse>;
export interface UpdateContactFlowModuleContentRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  Content?: string;
  Settings?: string;
}
export const UpdateContactFlowModuleContentRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    Content: S.optional(S.String),
    Settings: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/content",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactFlowModuleContentRequest",
}) as any as S.Schema<UpdateContactFlowModuleContentRequest>;
export interface UpdateContactFlowModuleContentResponse {}
export const UpdateContactFlowModuleContentResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactFlowModuleContentResponse",
}) as any as S.Schema<UpdateContactFlowModuleContentResponse>;
export interface UpdateContactFlowModuleMetadataRequest {
  InstanceId: string;
  ContactFlowModuleId: string;
  Name?: string;
  Description?: string;
  State?: ContactFlowModuleState;
}
export const UpdateContactFlowModuleMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowModuleId: S.String.pipe(T.HttpLabel("ContactFlowModuleId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    State: S.optional(ContactFlowModuleState),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flow-modules/{InstanceId}/{ContactFlowModuleId}/metadata",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactFlowModuleMetadataRequest",
}) as any as S.Schema<UpdateContactFlowModuleMetadataRequest>;
export interface UpdateContactFlowModuleMetadataResponse {}
export const UpdateContactFlowModuleMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactFlowModuleMetadataResponse",
}) as any as S.Schema<UpdateContactFlowModuleMetadataResponse>;
export interface UpdateContactFlowNameRequest {
  InstanceId: string;
  ContactFlowId: string;
  Name?: string;
  Description?: string;
}
export const UpdateContactFlowNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactFlowId: S.String.pipe(T.HttpLabel("ContactFlowId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-flows/{InstanceId}/{ContactFlowId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactFlowNameRequest",
}) as any as S.Schema<UpdateContactFlowNameRequest>;
export interface UpdateContactFlowNameResponse {}
export const UpdateContactFlowNameResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactFlowNameResponse",
}) as any as S.Schema<UpdateContactFlowNameResponse>;
export interface UpdateContactScheduleRequest {
  InstanceId: string;
  ContactId: string;
  ScheduledTime: Date;
}
export const UpdateContactScheduleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    ScheduledTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/schedule" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactScheduleRequest",
}) as any as S.Schema<UpdateContactScheduleRequest>;
export interface UpdateContactScheduleResponse {}
export const UpdateContactScheduleResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactScheduleResponse",
}) as any as S.Schema<UpdateContactScheduleResponse>;
export type ValidationEnumValues = string[];
export const ValidationEnumValues = S.Array(S.String);
export interface ValidationEnum {
  Strict?: boolean;
  Values?: string[];
}
export const ValidationEnum = S.suspend(() =>
  S.Struct({
    Strict: S.optional(S.Boolean),
    Values: S.optional(ValidationEnumValues),
  }),
).annotations({
  identifier: "ValidationEnum",
}) as any as S.Schema<ValidationEnum>;
export interface Validation {
  MinLength?: number;
  MaxLength?: number;
  MinValues?: number;
  MaxValues?: number;
  IgnoreCase?: boolean;
  Minimum?: number;
  Maximum?: number;
  ExclusiveMinimum?: number;
  ExclusiveMaximum?: number;
  MultipleOf?: number;
  Enum?: ValidationEnum;
}
export const Validation = S.suspend(() =>
  S.Struct({
    MinLength: S.optional(S.Number),
    MaxLength: S.optional(S.Number),
    MinValues: S.optional(S.Number),
    MaxValues: S.optional(S.Number),
    IgnoreCase: S.optional(S.Boolean),
    Minimum: S.optional(S.Number),
    Maximum: S.optional(S.Number),
    ExclusiveMinimum: S.optional(S.Number),
    ExclusiveMaximum: S.optional(S.Number),
    MultipleOf: S.optional(S.Number),
    Enum: S.optional(ValidationEnum),
  }),
).annotations({ identifier: "Validation" }) as any as S.Schema<Validation>;
export interface UpdateDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  AttributeName: string;
  Name: string;
  ValueType: DataTableAttributeValueType;
  Description?: string;
  Primary?: boolean;
  Validation?: Validation;
}
export const UpdateDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    AttributeName: S.String.pipe(T.HttpLabel("AttributeName")),
    Name: S.String,
    ValueType: DataTableAttributeValueType,
    Description: S.optional(S.String),
    Primary: S.optional(S.Boolean),
    Validation: S.optional(Validation),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes/{AttributeName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDataTableAttributeRequest",
}) as any as S.Schema<UpdateDataTableAttributeRequest>;
export interface UpdateDataTableMetadataRequest {
  InstanceId: string;
  DataTableId: string;
  Name: string;
  Description?: string;
  ValueLockLevel: DataTableLockLevel;
  TimeZone: string;
}
export const UpdateDataTableMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Name: S.String,
    Description: S.optional(S.String),
    ValueLockLevel: DataTableLockLevel,
    TimeZone: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDataTableMetadataRequest",
}) as any as S.Schema<UpdateDataTableMetadataRequest>;
export interface UpdateEmailAddressMetadataRequest {
  InstanceId: string;
  EmailAddressId: string;
  Description?: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  ClientToken?: string;
}
export const UpdateEmailAddressMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
    Description: S.optional(SensitiveString),
    DisplayName: S.optional(SensitiveString),
    ClientToken: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateEmailAddressMetadataRequest",
}) as any as S.Schema<UpdateEmailAddressMetadataRequest>;
export type EvaluationFormItemsList = EvaluationFormItem[];
export const EvaluationFormItemsList = S.Array(
  S.suspend(() => EvaluationFormItem).annotations({
    identifier: "EvaluationFormItem",
  }),
) as any as S.Schema<EvaluationFormItemsList>;
export type EvaluationFormScoringMode =
  | "QUESTION_ONLY"
  | "SECTION_ONLY"
  | (string & {});
export const EvaluationFormScoringMode = S.String;
export type EvaluationFormScoringStatus =
  | "ENABLED"
  | "DISABLED"
  | (string & {});
export const EvaluationFormScoringStatus = S.String;
export interface EvaluationFormScoringStrategy {
  Mode: EvaluationFormScoringMode;
  Status: EvaluationFormScoringStatus;
}
export const EvaluationFormScoringStrategy = S.suspend(() =>
  S.Struct({
    Mode: EvaluationFormScoringMode,
    Status: EvaluationFormScoringStatus,
  }),
).annotations({
  identifier: "EvaluationFormScoringStrategy",
}) as any as S.Schema<EvaluationFormScoringStrategy>;
export interface EvaluationFormAutoEvaluationConfiguration {
  Enabled: boolean;
}
export const EvaluationFormAutoEvaluationConfiguration = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "EvaluationFormAutoEvaluationConfiguration",
}) as any as S.Schema<EvaluationFormAutoEvaluationConfiguration>;
export type ContactInteractionType = "AGENT" | "AUTOMATED" | (string & {});
export const ContactInteractionType = S.String;
export interface EvaluationFormTargetConfiguration {
  ContactInteractionType: ContactInteractionType;
}
export const EvaluationFormTargetConfiguration = S.suspend(() =>
  S.Struct({ ContactInteractionType: ContactInteractionType }),
).annotations({
  identifier: "EvaluationFormTargetConfiguration",
}) as any as S.Schema<EvaluationFormTargetConfiguration>;
export type EvaluationFormLanguageCode =
  | "de-DE"
  | "en-US"
  | "es-ES"
  | "fr-FR"
  | "it-IT"
  | "pt-BR"
  | (string & {});
export const EvaluationFormLanguageCode = S.String;
export interface EvaluationFormLanguageConfiguration {
  FormLanguage?: EvaluationFormLanguageCode;
}
export const EvaluationFormLanguageConfiguration = S.suspend(() =>
  S.Struct({ FormLanguage: S.optional(EvaluationFormLanguageCode) }),
).annotations({
  identifier: "EvaluationFormLanguageConfiguration",
}) as any as S.Schema<EvaluationFormLanguageConfiguration>;
export interface UpdateEvaluationFormRequest {
  InstanceId: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
  CreateNewVersion?: boolean;
  Title: string;
  Description?: string;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  AsDraft?: boolean;
  ClientToken?: string;
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
}
export const UpdateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationFormId: S.String.pipe(T.HttpLabel("EvaluationFormId")),
    EvaluationFormVersion: S.Number,
    CreateNewVersion: S.optional(S.Boolean),
    Title: S.String,
    Description: S.optional(S.String),
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    AsDraft: S.optional(S.Boolean),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/evaluation-forms/{InstanceId}/{EvaluationFormId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateEvaluationFormRequest",
}) as any as S.Schema<UpdateEvaluationFormRequest>;
export type HoursOfOperationDays =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY"
  | (string & {});
export const HoursOfOperationDays = S.String;
export interface HoursOfOperationTimeSlice {
  Hours: number;
  Minutes: number;
}
export const HoursOfOperationTimeSlice = S.suspend(() =>
  S.Struct({ Hours: S.Number, Minutes: S.Number }),
).annotations({
  identifier: "HoursOfOperationTimeSlice",
}) as any as S.Schema<HoursOfOperationTimeSlice>;
export interface HoursOfOperationConfig {
  Day: HoursOfOperationDays;
  StartTime: HoursOfOperationTimeSlice;
  EndTime: HoursOfOperationTimeSlice;
}
export const HoursOfOperationConfig = S.suspend(() =>
  S.Struct({
    Day: HoursOfOperationDays,
    StartTime: HoursOfOperationTimeSlice,
    EndTime: HoursOfOperationTimeSlice,
  }),
).annotations({
  identifier: "HoursOfOperationConfig",
}) as any as S.Schema<HoursOfOperationConfig>;
export type HoursOfOperationConfigList = HoursOfOperationConfig[];
export const HoursOfOperationConfigList = S.Array(HoursOfOperationConfig);
export interface UpdateHoursOfOperationRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  Name?: string;
  Description?: string;
  TimeZone?: string;
  Config?: HoursOfOperationConfig[];
}
export const UpdateHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    TimeZone: S.optional(S.String),
    Config: S.optional(HoursOfOperationConfigList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateHoursOfOperationRequest",
}) as any as S.Schema<UpdateHoursOfOperationRequest>;
export interface UpdateHoursOfOperationResponse {}
export const UpdateHoursOfOperationResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateHoursOfOperationResponse",
}) as any as S.Schema<UpdateHoursOfOperationResponse>;
export type OverrideDays =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY"
  | (string & {});
export const OverrideDays = S.String;
export interface OverrideTimeSlice {
  Hours: number;
  Minutes: number;
}
export const OverrideTimeSlice = S.suspend(() =>
  S.Struct({ Hours: S.Number, Minutes: S.Number }),
).annotations({
  identifier: "OverrideTimeSlice",
}) as any as S.Schema<OverrideTimeSlice>;
export interface HoursOfOperationOverrideConfig {
  Day?: OverrideDays;
  StartTime?: OverrideTimeSlice;
  EndTime?: OverrideTimeSlice;
}
export const HoursOfOperationOverrideConfig = S.suspend(() =>
  S.Struct({
    Day: S.optional(OverrideDays),
    StartTime: S.optional(OverrideTimeSlice),
    EndTime: S.optional(OverrideTimeSlice),
  }),
).annotations({
  identifier: "HoursOfOperationOverrideConfig",
}) as any as S.Schema<HoursOfOperationOverrideConfig>;
export type HoursOfOperationOverrideConfigList =
  HoursOfOperationOverrideConfig[];
export const HoursOfOperationOverrideConfigList = S.Array(
  HoursOfOperationOverrideConfig,
);
export interface UpdateHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  HoursOfOperationOverrideId: string;
  Name?: string;
  Description?: string;
  Config?: HoursOfOperationOverrideConfig[];
  EffectiveFrom?: string;
  EffectiveTill?: string;
}
export const UpdateHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    HoursOfOperationOverrideId: S.String.pipe(
      T.HttpLabel("HoursOfOperationOverrideId"),
    ),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Config: S.optional(HoursOfOperationOverrideConfigList),
    EffectiveFrom: S.optional(S.String),
    EffectiveTill: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides/{HoursOfOperationOverrideId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateHoursOfOperationOverrideRequest",
}) as any as S.Schema<UpdateHoursOfOperationOverrideRequest>;
export interface UpdateHoursOfOperationOverrideResponse {}
export const UpdateHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateHoursOfOperationOverrideResponse",
}) as any as S.Schema<UpdateHoursOfOperationOverrideResponse>;
export interface UpdateInstanceAttributeRequest {
  InstanceId: string;
  AttributeType: InstanceAttributeType;
  Value: string;
  ClientToken?: string;
}
export const UpdateInstanceAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AttributeType: InstanceAttributeType.pipe(T.HttpLabel("AttributeType")),
    Value: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/instance/{InstanceId}/attribute/{AttributeType}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateInstanceAttributeRequest",
}) as any as S.Schema<UpdateInstanceAttributeRequest>;
export interface UpdateInstanceAttributeResponse {}
export const UpdateInstanceAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateInstanceAttributeResponse",
}) as any as S.Schema<UpdateInstanceAttributeResponse>;
export type StorageType =
  | "S3"
  | "KINESIS_VIDEO_STREAM"
  | "KINESIS_STREAM"
  | "KINESIS_FIREHOSE"
  | (string & {});
export const StorageType = S.String;
export type EncryptionType = "KMS" | (string & {});
export const EncryptionType = S.String;
export interface EncryptionConfig {
  EncryptionType: EncryptionType;
  KeyId: string;
}
export const EncryptionConfig = S.suspend(() =>
  S.Struct({ EncryptionType: EncryptionType, KeyId: S.String }),
).annotations({
  identifier: "EncryptionConfig",
}) as any as S.Schema<EncryptionConfig>;
export interface S3Config {
  BucketName: string;
  BucketPrefix: string;
  EncryptionConfig?: EncryptionConfig;
}
export const S3Config = S.suspend(() =>
  S.Struct({
    BucketName: S.String,
    BucketPrefix: S.String,
    EncryptionConfig: S.optional(EncryptionConfig),
  }),
).annotations({ identifier: "S3Config" }) as any as S.Schema<S3Config>;
export interface KinesisVideoStreamConfig {
  Prefix: string;
  RetentionPeriodHours: number;
  EncryptionConfig: EncryptionConfig;
}
export const KinesisVideoStreamConfig = S.suspend(() =>
  S.Struct({
    Prefix: S.String,
    RetentionPeriodHours: S.Number,
    EncryptionConfig: EncryptionConfig,
  }),
).annotations({
  identifier: "KinesisVideoStreamConfig",
}) as any as S.Schema<KinesisVideoStreamConfig>;
export interface KinesisStreamConfig {
  StreamArn: string;
}
export const KinesisStreamConfig = S.suspend(() =>
  S.Struct({ StreamArn: S.String }),
).annotations({
  identifier: "KinesisStreamConfig",
}) as any as S.Schema<KinesisStreamConfig>;
export interface KinesisFirehoseConfig {
  FirehoseArn: string;
}
export const KinesisFirehoseConfig = S.suspend(() =>
  S.Struct({ FirehoseArn: S.String }),
).annotations({
  identifier: "KinesisFirehoseConfig",
}) as any as S.Schema<KinesisFirehoseConfig>;
export interface InstanceStorageConfig {
  AssociationId?: string;
  StorageType: StorageType;
  S3Config?: S3Config;
  KinesisVideoStreamConfig?: KinesisVideoStreamConfig;
  KinesisStreamConfig?: KinesisStreamConfig;
  KinesisFirehoseConfig?: KinesisFirehoseConfig;
}
export const InstanceStorageConfig = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String),
    StorageType: StorageType,
    S3Config: S.optional(S3Config),
    KinesisVideoStreamConfig: S.optional(KinesisVideoStreamConfig),
    KinesisStreamConfig: S.optional(KinesisStreamConfig),
    KinesisFirehoseConfig: S.optional(KinesisFirehoseConfig),
  }),
).annotations({
  identifier: "InstanceStorageConfig",
}) as any as S.Schema<InstanceStorageConfig>;
export interface UpdateInstanceStorageConfigRequest {
  InstanceId: string;
  AssociationId: string;
  ResourceType: InstanceStorageResourceType;
  StorageConfig: InstanceStorageConfig;
  ClientToken?: string;
}
export const UpdateInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AssociationId: S.String.pipe(T.HttpLabel("AssociationId")),
    ResourceType: InstanceStorageResourceType.pipe(T.HttpQuery("resourceType")),
    StorageConfig: InstanceStorageConfig,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/instance/{InstanceId}/storage-config/{AssociationId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateInstanceStorageConfigRequest",
}) as any as S.Schema<UpdateInstanceStorageConfigRequest>;
export interface UpdateInstanceStorageConfigResponse {}
export const UpdateInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateInstanceStorageConfigResponse",
}) as any as S.Schema<UpdateInstanceStorageConfigResponse>;
export interface UpdateParticipantAuthenticationRequest {
  State: string;
  InstanceId: string;
  Code?: string | redacted.Redacted<string>;
  Error?: string | redacted.Redacted<string>;
  ErrorDescription?: string | redacted.Redacted<string>;
}
export const UpdateParticipantAuthenticationRequest = S.suspend(() =>
  S.Struct({
    State: S.String,
    InstanceId: S.String,
    Code: S.optional(SensitiveString),
    Error: S.optional(SensitiveString),
    ErrorDescription: S.optional(SensitiveString),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact/update-participant-authentication",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateParticipantAuthenticationRequest",
}) as any as S.Schema<UpdateParticipantAuthenticationRequest>;
export interface UpdateParticipantAuthenticationResponse {}
export const UpdateParticipantAuthenticationResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateParticipantAuthenticationResponse",
}) as any as S.Schema<UpdateParticipantAuthenticationResponse>;
export interface UpdatePhoneNumberRequest {
  PhoneNumberId: string;
  TargetArn?: string;
  InstanceId?: string;
  ClientToken?: string;
}
export const UpdatePhoneNumberRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/phone-number/{PhoneNumberId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdatePhoneNumberRequest",
}) as any as S.Schema<UpdatePhoneNumberRequest>;
export interface UpdatePhoneNumberMetadataRequest {
  PhoneNumberId: string;
  PhoneNumberDescription?: string;
  ClientToken?: string;
}
export const UpdatePhoneNumberMetadataRequest = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.String.pipe(T.HttpLabel("PhoneNumberId")),
    PhoneNumberDescription: S.optional(S.String),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/phone-number/{PhoneNumberId}/metadata" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdatePhoneNumberMetadataRequest",
}) as any as S.Schema<UpdatePhoneNumberMetadataRequest>;
export interface UpdatePhoneNumberMetadataResponse {}
export const UpdatePhoneNumberMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdatePhoneNumberMetadataResponse",
}) as any as S.Schema<UpdatePhoneNumberMetadataResponse>;
export type PredefinedAttributeStringValuesList = string[];
export const PredefinedAttributeStringValuesList = S.Array(S.String);
export type PredefinedAttributeValues = { StringList: string[] };
export const PredefinedAttributeValues = S.Union(
  S.Struct({ StringList: PredefinedAttributeStringValuesList }),
);
export interface InputPredefinedAttributeConfiguration {
  EnableValueValidationOnAssociation?: boolean;
}
export const InputPredefinedAttributeConfiguration = S.suspend(() =>
  S.Struct({ EnableValueValidationOnAssociation: S.optional(S.Boolean) }),
).annotations({
  identifier: "InputPredefinedAttributeConfiguration",
}) as any as S.Schema<InputPredefinedAttributeConfiguration>;
export interface UpdatePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
  Values?: PredefinedAttributeValues;
  Purposes?: string[];
  AttributeConfiguration?: InputPredefinedAttributeConfiguration;
}
export const UpdatePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String.pipe(T.HttpLabel("Name")),
    Values: S.optional(PredefinedAttributeValues),
    Purposes: S.optional(PredefinedAttributePurposeNameList),
    AttributeConfiguration: S.optional(InputPredefinedAttributeConfiguration),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/predefined-attributes/{InstanceId}/{Name}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdatePredefinedAttributeRequest",
}) as any as S.Schema<UpdatePredefinedAttributeRequest>;
export interface UpdatePredefinedAttributeResponse {}
export const UpdatePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdatePredefinedAttributeResponse",
}) as any as S.Schema<UpdatePredefinedAttributeResponse>;
export interface UpdatePromptRequest {
  InstanceId: string;
  PromptId: string;
  Name?: string;
  Description?: string;
  S3Uri?: string;
}
export const UpdatePromptRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    PromptId: S.String.pipe(T.HttpLabel("PromptId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    S3Uri: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/prompts/{InstanceId}/{PromptId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdatePromptRequest",
}) as any as S.Schema<UpdatePromptRequest>;
export interface UpdateQueueHoursOfOperationRequest {
  InstanceId: string;
  QueueId: string;
  HoursOfOperationId: string;
}
export const UpdateQueueHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    HoursOfOperationId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/hours-of-operation",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQueueHoursOfOperationRequest",
}) as any as S.Schema<UpdateQueueHoursOfOperationRequest>;
export interface UpdateQueueHoursOfOperationResponse {}
export const UpdateQueueHoursOfOperationResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQueueHoursOfOperationResponse",
}) as any as S.Schema<UpdateQueueHoursOfOperationResponse>;
export interface UpdateQueueMaxContactsRequest {
  InstanceId: string;
  QueueId: string;
  MaxContacts?: number;
}
export const UpdateQueueMaxContactsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    MaxContacts: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/max-contacts",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQueueMaxContactsRequest",
}) as any as S.Schema<UpdateQueueMaxContactsRequest>;
export interface UpdateQueueMaxContactsResponse {}
export const UpdateQueueMaxContactsResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQueueMaxContactsResponse",
}) as any as S.Schema<UpdateQueueMaxContactsResponse>;
export interface UpdateQueueNameRequest {
  InstanceId: string;
  QueueId: string;
  Name?: string;
  Description?: string;
}
export const UpdateQueueNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/queues/{InstanceId}/{QueueId}/name" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQueueNameRequest",
}) as any as S.Schema<UpdateQueueNameRequest>;
export interface UpdateQueueNameResponse {}
export const UpdateQueueNameResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQueueNameResponse",
}) as any as S.Schema<UpdateQueueNameResponse>;
export interface OutboundCallerConfig {
  OutboundCallerIdName?: string;
  OutboundCallerIdNumberId?: string;
  OutboundFlowId?: string;
}
export const OutboundCallerConfig = S.suspend(() =>
  S.Struct({
    OutboundCallerIdName: S.optional(S.String),
    OutboundCallerIdNumberId: S.optional(S.String),
    OutboundFlowId: S.optional(S.String),
  }),
).annotations({
  identifier: "OutboundCallerConfig",
}) as any as S.Schema<OutboundCallerConfig>;
export interface UpdateQueueOutboundCallerConfigRequest {
  InstanceId: string;
  QueueId: string;
  OutboundCallerConfig: OutboundCallerConfig;
}
export const UpdateQueueOutboundCallerConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    OutboundCallerConfig: OutboundCallerConfig,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/outbound-caller-config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQueueOutboundCallerConfigRequest",
}) as any as S.Schema<UpdateQueueOutboundCallerConfigRequest>;
export interface UpdateQueueOutboundCallerConfigResponse {}
export const UpdateQueueOutboundCallerConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQueueOutboundCallerConfigResponse",
}) as any as S.Schema<UpdateQueueOutboundCallerConfigResponse>;
export interface OutboundEmailConfig {
  OutboundEmailAddressId?: string;
}
export const OutboundEmailConfig = S.suspend(() =>
  S.Struct({ OutboundEmailAddressId: S.optional(S.String) }),
).annotations({
  identifier: "OutboundEmailConfig",
}) as any as S.Schema<OutboundEmailConfig>;
export interface UpdateQueueOutboundEmailConfigRequest {
  InstanceId: string;
  QueueId: string;
  OutboundEmailConfig: OutboundEmailConfig;
}
export const UpdateQueueOutboundEmailConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    OutboundEmailConfig: OutboundEmailConfig,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/queues/{InstanceId}/{QueueId}/outbound-email-config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQueueOutboundEmailConfigRequest",
}) as any as S.Schema<UpdateQueueOutboundEmailConfigRequest>;
export interface UpdateQueueOutboundEmailConfigResponse {}
export const UpdateQueueOutboundEmailConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQueueOutboundEmailConfigResponse",
}) as any as S.Schema<UpdateQueueOutboundEmailConfigResponse>;
export interface UpdateQueueStatusRequest {
  InstanceId: string;
  QueueId: string;
  Status: QueueStatus;
}
export const UpdateQueueStatusRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QueueId: S.String.pipe(T.HttpLabel("QueueId")),
    Status: QueueStatus,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/queues/{InstanceId}/{QueueId}/status" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQueueStatusRequest",
}) as any as S.Schema<UpdateQueueStatusRequest>;
export interface UpdateQueueStatusResponse {}
export const UpdateQueueStatusResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQueueStatusResponse",
}) as any as S.Schema<UpdateQueueStatusResponse>;
export interface UserQuickConnectConfig {
  UserId: string;
  ContactFlowId: string;
}
export const UserQuickConnectConfig = S.suspend(() =>
  S.Struct({ UserId: S.String, ContactFlowId: S.String }),
).annotations({
  identifier: "UserQuickConnectConfig",
}) as any as S.Schema<UserQuickConnectConfig>;
export interface QueueQuickConnectConfig {
  QueueId: string;
  ContactFlowId: string;
}
export const QueueQuickConnectConfig = S.suspend(() =>
  S.Struct({ QueueId: S.String, ContactFlowId: S.String }),
).annotations({
  identifier: "QueueQuickConnectConfig",
}) as any as S.Schema<QueueQuickConnectConfig>;
export interface PhoneNumberQuickConnectConfig {
  PhoneNumber: string;
}
export const PhoneNumberQuickConnectConfig = S.suspend(() =>
  S.Struct({ PhoneNumber: S.String }),
).annotations({
  identifier: "PhoneNumberQuickConnectConfig",
}) as any as S.Schema<PhoneNumberQuickConnectConfig>;
export interface FlowQuickConnectConfig {
  ContactFlowId: string;
}
export const FlowQuickConnectConfig = S.suspend(() =>
  S.Struct({ ContactFlowId: S.String }),
).annotations({
  identifier: "FlowQuickConnectConfig",
}) as any as S.Schema<FlowQuickConnectConfig>;
export interface QuickConnectConfig {
  QuickConnectType: QuickConnectType;
  UserConfig?: UserQuickConnectConfig;
  QueueConfig?: QueueQuickConnectConfig;
  PhoneConfig?: PhoneNumberQuickConnectConfig;
  FlowConfig?: FlowQuickConnectConfig;
}
export const QuickConnectConfig = S.suspend(() =>
  S.Struct({
    QuickConnectType: QuickConnectType,
    UserConfig: S.optional(UserQuickConnectConfig),
    QueueConfig: S.optional(QueueQuickConnectConfig),
    PhoneConfig: S.optional(PhoneNumberQuickConnectConfig),
    FlowConfig: S.optional(FlowQuickConnectConfig),
  }),
).annotations({
  identifier: "QuickConnectConfig",
}) as any as S.Schema<QuickConnectConfig>;
export interface UpdateQuickConnectConfigRequest {
  InstanceId: string;
  QuickConnectId: string;
  QuickConnectConfig: QuickConnectConfig;
}
export const UpdateQuickConnectConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
    QuickConnectConfig: QuickConnectConfig,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}/config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQuickConnectConfigRequest",
}) as any as S.Schema<UpdateQuickConnectConfigRequest>;
export interface UpdateQuickConnectConfigResponse {}
export const UpdateQuickConnectConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQuickConnectConfigResponse",
}) as any as S.Schema<UpdateQuickConnectConfigResponse>;
export interface UpdateQuickConnectNameRequest {
  InstanceId: string;
  QuickConnectId: string;
  Name?: string;
  Description?: string;
}
export const UpdateQuickConnectNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    QuickConnectId: S.String.pipe(T.HttpLabel("QuickConnectId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/quick-connects/{InstanceId}/{QuickConnectId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQuickConnectNameRequest",
}) as any as S.Schema<UpdateQuickConnectNameRequest>;
export interface UpdateQuickConnectNameResponse {}
export const UpdateQuickConnectNameResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateQuickConnectNameResponse",
}) as any as S.Schema<UpdateQuickConnectNameResponse>;
export interface UpdateRoutingProfileAgentAvailabilityTimerRequest {
  InstanceId: string;
  RoutingProfileId: string;
  AgentAvailabilityTimer: AgentAvailabilityTimer;
}
export const UpdateRoutingProfileAgentAvailabilityTimerRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    AgentAvailabilityTimer: AgentAvailabilityTimer,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/agent-availability-timer",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRoutingProfileAgentAvailabilityTimerRequest",
}) as any as S.Schema<UpdateRoutingProfileAgentAvailabilityTimerRequest>;
export interface UpdateRoutingProfileAgentAvailabilityTimerResponse {}
export const UpdateRoutingProfileAgentAvailabilityTimerResponse = S.suspend(
  () => S.Struct({}),
).annotations({
  identifier: "UpdateRoutingProfileAgentAvailabilityTimerResponse",
}) as any as S.Schema<UpdateRoutingProfileAgentAvailabilityTimerResponse>;
export type BehaviorType =
  | "ROUTE_CURRENT_CHANNEL_ONLY"
  | "ROUTE_ANY_CHANNEL"
  | (string & {});
export const BehaviorType = S.String;
export interface CrossChannelBehavior {
  BehaviorType: BehaviorType;
}
export const CrossChannelBehavior = S.suspend(() =>
  S.Struct({ BehaviorType: BehaviorType }),
).annotations({
  identifier: "CrossChannelBehavior",
}) as any as S.Schema<CrossChannelBehavior>;
export interface MediaConcurrency {
  Channel: Channel;
  Concurrency: number;
  CrossChannelBehavior?: CrossChannelBehavior;
}
export const MediaConcurrency = S.suspend(() =>
  S.Struct({
    Channel: Channel,
    Concurrency: S.Number,
    CrossChannelBehavior: S.optional(CrossChannelBehavior),
  }),
).annotations({
  identifier: "MediaConcurrency",
}) as any as S.Schema<MediaConcurrency>;
export type MediaConcurrencies = MediaConcurrency[];
export const MediaConcurrencies = S.Array(MediaConcurrency);
export interface UpdateRoutingProfileConcurrencyRequest {
  InstanceId: string;
  RoutingProfileId: string;
  MediaConcurrencies: MediaConcurrency[];
}
export const UpdateRoutingProfileConcurrencyRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    MediaConcurrencies: MediaConcurrencies,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/concurrency",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRoutingProfileConcurrencyRequest",
}) as any as S.Schema<UpdateRoutingProfileConcurrencyRequest>;
export interface UpdateRoutingProfileConcurrencyResponse {}
export const UpdateRoutingProfileConcurrencyResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateRoutingProfileConcurrencyResponse",
}) as any as S.Schema<UpdateRoutingProfileConcurrencyResponse>;
export interface UpdateRoutingProfileDefaultOutboundQueueRequest {
  InstanceId: string;
  RoutingProfileId: string;
  DefaultOutboundQueueId: string;
}
export const UpdateRoutingProfileDefaultOutboundQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    DefaultOutboundQueueId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/default-outbound-queue",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRoutingProfileDefaultOutboundQueueRequest",
}) as any as S.Schema<UpdateRoutingProfileDefaultOutboundQueueRequest>;
export interface UpdateRoutingProfileDefaultOutboundQueueResponse {}
export const UpdateRoutingProfileDefaultOutboundQueueResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateRoutingProfileDefaultOutboundQueueResponse",
}) as any as S.Schema<UpdateRoutingProfileDefaultOutboundQueueResponse>;
export interface UpdateRoutingProfileNameRequest {
  InstanceId: string;
  RoutingProfileId: string;
  Name?: string;
  Description?: string;
}
export const UpdateRoutingProfileNameRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRoutingProfileNameRequest",
}) as any as S.Schema<UpdateRoutingProfileNameRequest>;
export interface UpdateRoutingProfileNameResponse {}
export const UpdateRoutingProfileNameResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateRoutingProfileNameResponse",
}) as any as S.Schema<UpdateRoutingProfileNameResponse>;
export interface RoutingProfileQueueReference {
  QueueId: string;
  Channel: Channel;
}
export const RoutingProfileQueueReference = S.suspend(() =>
  S.Struct({ QueueId: S.String, Channel: Channel }),
).annotations({
  identifier: "RoutingProfileQueueReference",
}) as any as S.Schema<RoutingProfileQueueReference>;
export interface RoutingProfileQueueConfig {
  QueueReference: RoutingProfileQueueReference;
  Priority: number;
  Delay: number;
}
export const RoutingProfileQueueConfig = S.suspend(() =>
  S.Struct({
    QueueReference: RoutingProfileQueueReference,
    Priority: S.Number,
    Delay: S.Number,
  }),
).annotations({
  identifier: "RoutingProfileQueueConfig",
}) as any as S.Schema<RoutingProfileQueueConfig>;
export type RoutingProfileQueueConfigList = RoutingProfileQueueConfig[];
export const RoutingProfileQueueConfigList = S.Array(RoutingProfileQueueConfig);
export interface UpdateRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  QueueConfigs: RoutingProfileQueueConfig[];
}
export const UpdateRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    QueueConfigs: RoutingProfileQueueConfigList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRoutingProfileQueuesRequest",
}) as any as S.Schema<UpdateRoutingProfileQueuesRequest>;
export interface UpdateRoutingProfileQueuesResponse {}
export const UpdateRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateRoutingProfileQueuesResponse",
}) as any as S.Schema<UpdateRoutingProfileQueuesResponse>;
export type ActionType =
  | "CREATE_TASK"
  | "ASSIGN_CONTACT_CATEGORY"
  | "GENERATE_EVENTBRIDGE_EVENT"
  | "SEND_NOTIFICATION"
  | "CREATE_CASE"
  | "UPDATE_CASE"
  | "ASSIGN_SLA"
  | "END_ASSOCIATED_TASKS"
  | "SUBMIT_AUTO_EVALUATION"
  | (string & {});
export const ActionType = S.String;
export interface TaskActionDefinition {
  Name: string;
  Description?: string;
  ContactFlowId: string;
  References?: { [key: string]: Reference | undefined };
}
export const TaskActionDefinition = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Description: S.optional(S.String),
    ContactFlowId: S.String,
    References: S.optional(ContactReferences),
  }),
).annotations({
  identifier: "TaskActionDefinition",
}) as any as S.Schema<TaskActionDefinition>;
export interface EventBridgeActionDefinition {
  Name: string;
}
export const EventBridgeActionDefinition = S.suspend(() =>
  S.Struct({ Name: S.String }),
).annotations({
  identifier: "EventBridgeActionDefinition",
}) as any as S.Schema<EventBridgeActionDefinition>;
export interface AssignContactCategoryActionDefinition {}
export const AssignContactCategoryActionDefinition = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssignContactCategoryActionDefinition",
}) as any as S.Schema<AssignContactCategoryActionDefinition>;
export type NotificationDeliveryType = "EMAIL" | (string & {});
export const NotificationDeliveryType = S.String;
export type NotificationContentType = "PLAIN_TEXT" | (string & {});
export const NotificationContentType = S.String;
export type UserTagMap = { [key: string]: string | undefined };
export const UserTagMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(S.String),
});
export type UserIdList = string[];
export const UserIdList = S.Array(S.String);
export interface NotificationRecipientType {
  UserTags?: { [key: string]: string | undefined };
  UserIds?: string[];
}
export const NotificationRecipientType = S.suspend(() =>
  S.Struct({
    UserTags: S.optional(UserTagMap),
    UserIds: S.optional(UserIdList),
  }),
).annotations({
  identifier: "NotificationRecipientType",
}) as any as S.Schema<NotificationRecipientType>;
export interface SendNotificationActionDefinition {
  DeliveryMethod: NotificationDeliveryType;
  Subject?: string;
  Content: string;
  ContentType: NotificationContentType;
  Recipient: NotificationRecipientType;
  Exclusion?: NotificationRecipientType;
}
export const SendNotificationActionDefinition = S.suspend(() =>
  S.Struct({
    DeliveryMethod: NotificationDeliveryType,
    Subject: S.optional(S.String),
    Content: S.String,
    ContentType: NotificationContentType,
    Recipient: NotificationRecipientType,
    Exclusion: S.optional(NotificationRecipientType),
  }),
).annotations({
  identifier: "SendNotificationActionDefinition",
}) as any as S.Schema<SendNotificationActionDefinition>;
export interface EmptyFieldValue {}
export const EmptyFieldValue = S.suspend(() => S.Struct({})).annotations({
  identifier: "EmptyFieldValue",
}) as any as S.Schema<EmptyFieldValue>;
export interface FieldValueUnion {
  BooleanValue?: boolean;
  DoubleValue?: number;
  EmptyValue?: EmptyFieldValue;
  StringValue?: string;
}
export const FieldValueUnion = S.suspend(() =>
  S.Struct({
    BooleanValue: S.optional(S.Boolean),
    DoubleValue: S.optional(S.Number),
    EmptyValue: S.optional(EmptyFieldValue),
    StringValue: S.optional(S.String),
  }),
).annotations({
  identifier: "FieldValueUnion",
}) as any as S.Schema<FieldValueUnion>;
export interface FieldValue {
  Id: string;
  Value: FieldValueUnion;
}
export const FieldValue = S.suspend(() =>
  S.Struct({ Id: S.String, Value: FieldValueUnion }),
).annotations({ identifier: "FieldValue" }) as any as S.Schema<FieldValue>;
export type FieldValues = FieldValue[];
export const FieldValues = S.Array(FieldValue);
export interface CreateCaseActionDefinition {
  Fields: FieldValue[];
  TemplateId: string;
}
export const CreateCaseActionDefinition = S.suspend(() =>
  S.Struct({ Fields: FieldValues, TemplateId: S.String }),
).annotations({
  identifier: "CreateCaseActionDefinition",
}) as any as S.Schema<CreateCaseActionDefinition>;
export interface UpdateCaseActionDefinition {
  Fields: FieldValue[];
}
export const UpdateCaseActionDefinition = S.suspend(() =>
  S.Struct({ Fields: FieldValues }),
).annotations({
  identifier: "UpdateCaseActionDefinition",
}) as any as S.Schema<UpdateCaseActionDefinition>;
export type SlaAssignmentType = "CASES" | (string & {});
export const SlaAssignmentType = S.String;
export type SlaType = "CaseField" | (string & {});
export const SlaType = S.String;
export type SlaFieldValueUnionList = FieldValueUnion[];
export const SlaFieldValueUnionList = S.Array(FieldValueUnion);
export interface CaseSlaConfiguration {
  Name: string;
  Type: SlaType;
  FieldId?: string;
  TargetFieldValues?: FieldValueUnion[];
  TargetSlaMinutes: number;
}
export const CaseSlaConfiguration = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Type: SlaType,
    FieldId: S.optional(S.String),
    TargetFieldValues: S.optional(SlaFieldValueUnionList),
    TargetSlaMinutes: S.Number,
  }),
).annotations({
  identifier: "CaseSlaConfiguration",
}) as any as S.Schema<CaseSlaConfiguration>;
export interface AssignSlaActionDefinition {
  SlaAssignmentType: SlaAssignmentType;
  CaseSlaConfiguration?: CaseSlaConfiguration;
}
export const AssignSlaActionDefinition = S.suspend(() =>
  S.Struct({
    SlaAssignmentType: SlaAssignmentType,
    CaseSlaConfiguration: S.optional(CaseSlaConfiguration),
  }),
).annotations({
  identifier: "AssignSlaActionDefinition",
}) as any as S.Schema<AssignSlaActionDefinition>;
export interface EndAssociatedTasksActionDefinition {}
export const EndAssociatedTasksActionDefinition = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "EndAssociatedTasksActionDefinition",
}) as any as S.Schema<EndAssociatedTasksActionDefinition>;
export interface SubmitAutoEvaluationActionDefinition {
  EvaluationFormId: string;
}
export const SubmitAutoEvaluationActionDefinition = S.suspend(() =>
  S.Struct({ EvaluationFormId: S.String }),
).annotations({
  identifier: "SubmitAutoEvaluationActionDefinition",
}) as any as S.Schema<SubmitAutoEvaluationActionDefinition>;
export interface RuleAction {
  ActionType: ActionType;
  TaskAction?: TaskActionDefinition;
  EventBridgeAction?: EventBridgeActionDefinition;
  AssignContactCategoryAction?: AssignContactCategoryActionDefinition;
  SendNotificationAction?: SendNotificationActionDefinition;
  CreateCaseAction?: CreateCaseActionDefinition;
  UpdateCaseAction?: UpdateCaseActionDefinition;
  AssignSlaAction?: AssignSlaActionDefinition;
  EndAssociatedTasksAction?: EndAssociatedTasksActionDefinition;
  SubmitAutoEvaluationAction?: SubmitAutoEvaluationActionDefinition;
}
export const RuleAction = S.suspend(() =>
  S.Struct({
    ActionType: ActionType,
    TaskAction: S.optional(TaskActionDefinition),
    EventBridgeAction: S.optional(EventBridgeActionDefinition),
    AssignContactCategoryAction: S.optional(
      AssignContactCategoryActionDefinition,
    ),
    SendNotificationAction: S.optional(SendNotificationActionDefinition),
    CreateCaseAction: S.optional(CreateCaseActionDefinition),
    UpdateCaseAction: S.optional(UpdateCaseActionDefinition),
    AssignSlaAction: S.optional(AssignSlaActionDefinition),
    EndAssociatedTasksAction: S.optional(EndAssociatedTasksActionDefinition),
    SubmitAutoEvaluationAction: S.optional(
      SubmitAutoEvaluationActionDefinition,
    ),
  }),
).annotations({ identifier: "RuleAction" }) as any as S.Schema<RuleAction>;
export type RuleActions = RuleAction[];
export const RuleActions = S.Array(RuleAction);
export interface UpdateRuleRequest {
  RuleId: string;
  InstanceId: string;
  Name: string;
  Function: string;
  Actions: RuleAction[];
  PublishStatus: RulePublishStatus;
}
export const UpdateRuleRequest = S.suspend(() =>
  S.Struct({
    RuleId: S.String.pipe(T.HttpLabel("RuleId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Function: S.String,
    Actions: RuleActions,
    PublishStatus: RulePublishStatus,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/rules/{InstanceId}/{RuleId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRuleRequest",
}) as any as S.Schema<UpdateRuleRequest>;
export interface UpdateRuleResponse {}
export const UpdateRuleResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "UpdateRuleResponse",
}) as any as S.Schema<UpdateRuleResponse>;
export type AllowedAccessControlTags = { [key: string]: string | undefined };
export const AllowedAccessControlTags = S.Record({
  key: S.String,
  value: S.UndefinedOr(S.String),
});
export type ApplicationPermissions = string[];
export const ApplicationPermissions = S.Array(S.String);
export type ApplicationType = "MCP" | "THIRD_PARTY_APPLICATION" | (string & {});
export const ApplicationType = S.String;
export interface Application {
  Namespace?: string;
  ApplicationPermissions?: string[];
  Type?: ApplicationType;
}
export const Application = S.suspend(() =>
  S.Struct({
    Namespace: S.optional(S.String),
    ApplicationPermissions: S.optional(ApplicationPermissions),
    Type: S.optional(ApplicationType),
  }),
).annotations({ identifier: "Application" }) as any as S.Schema<Application>;
export type Applications = Application[];
export const Applications = S.Array(Application);
export type FlowModuleType = "MCP" | (string & {});
export const FlowModuleType = S.String;
export interface FlowModule {
  Type?: FlowModuleType;
  FlowModuleId?: string;
}
export const FlowModule = S.suspend(() =>
  S.Struct({
    Type: S.optional(FlowModuleType),
    FlowModuleId: S.optional(S.String),
  }),
).annotations({ identifier: "FlowModule" }) as any as S.Schema<FlowModule>;
export type AllowedFlowModules = FlowModule[];
export const AllowedFlowModules = S.Array(FlowModule);
export type AccessType = "ALLOW" | (string & {});
export const AccessType = S.String;
export type PrimaryValueList = string[];
export const PrimaryValueList = S.Array(S.String);
export interface PrimaryAttributeValue {
  AccessType?: AccessType;
  AttributeName?: string;
  Values?: string[];
}
export const PrimaryAttributeValue = S.suspend(() =>
  S.Struct({
    AccessType: S.optional(AccessType),
    AttributeName: S.optional(S.String),
    Values: S.optional(PrimaryValueList),
  }),
).annotations({
  identifier: "PrimaryAttributeValue",
}) as any as S.Schema<PrimaryAttributeValue>;
export type PrimaryAttributeValuesSet = PrimaryAttributeValue[];
export const PrimaryAttributeValuesSet = S.Array(PrimaryAttributeValue);
export interface PrimaryAttributeAccessControlConfigurationItem {
  PrimaryAttributeValues?: PrimaryAttributeValue[];
}
export const PrimaryAttributeAccessControlConfigurationItem = S.suspend(() =>
  S.Struct({ PrimaryAttributeValues: S.optional(PrimaryAttributeValuesSet) }),
).annotations({
  identifier: "PrimaryAttributeAccessControlConfigurationItem",
}) as any as S.Schema<PrimaryAttributeAccessControlConfigurationItem>;
export interface DataTableAccessControlConfiguration {
  PrimaryAttributeAccessControlConfiguration?: PrimaryAttributeAccessControlConfigurationItem;
}
export const DataTableAccessControlConfiguration = S.suspend(() =>
  S.Struct({
    PrimaryAttributeAccessControlConfiguration: S.optional(
      PrimaryAttributeAccessControlConfigurationItem,
    ),
  }),
).annotations({
  identifier: "DataTableAccessControlConfiguration",
}) as any as S.Schema<DataTableAccessControlConfiguration>;
export interface GranularAccessControlConfiguration {
  DataTableAccessControlConfiguration?: DataTableAccessControlConfiguration;
}
export const GranularAccessControlConfiguration = S.suspend(() =>
  S.Struct({
    DataTableAccessControlConfiguration: S.optional(
      DataTableAccessControlConfiguration,
    ),
  }),
).annotations({
  identifier: "GranularAccessControlConfiguration",
}) as any as S.Schema<GranularAccessControlConfiguration>;
export interface UpdateSecurityProfileRequest {
  Description?: string;
  Permissions?: string[];
  SecurityProfileId: string;
  InstanceId: string;
  AllowedAccessControlTags?: { [key: string]: string | undefined };
  TagRestrictedResources?: string[];
  Applications?: Application[];
  HierarchyRestrictedResources?: string[];
  AllowedAccessControlHierarchyGroupId?: string;
  AllowedFlowModules?: FlowModule[];
  GranularAccessControlConfiguration?: GranularAccessControlConfiguration;
}
export const UpdateSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    Description: S.optional(S.String),
    Permissions: S.optional(PermissionsList),
    SecurityProfileId: S.String.pipe(T.HttpLabel("SecurityProfileId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AllowedAccessControlTags: S.optional(AllowedAccessControlTags),
    TagRestrictedResources: S.optional(TagRestrictedResourceList),
    Applications: S.optional(Applications),
    HierarchyRestrictedResources: S.optional(HierarchyRestrictedResourceList),
    AllowedAccessControlHierarchyGroupId: S.optional(S.String),
    AllowedFlowModules: S.optional(AllowedFlowModules),
    GranularAccessControlConfiguration: S.optional(
      GranularAccessControlConfiguration,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/security-profiles/{InstanceId}/{SecurityProfileId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateSecurityProfileRequest",
}) as any as S.Schema<UpdateSecurityProfileRequest>;
export interface UpdateSecurityProfileResponse {}
export const UpdateSecurityProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateSecurityProfileResponse",
}) as any as S.Schema<UpdateSecurityProfileResponse>;
export interface TaskTemplateFieldIdentifier {
  Name?: string;
}
export const TaskTemplateFieldIdentifier = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String) }),
).annotations({
  identifier: "TaskTemplateFieldIdentifier",
}) as any as S.Schema<TaskTemplateFieldIdentifier>;
export interface RequiredFieldInfo {
  Id?: TaskTemplateFieldIdentifier;
}
export const RequiredFieldInfo = S.suspend(() =>
  S.Struct({ Id: S.optional(TaskTemplateFieldIdentifier) }),
).annotations({
  identifier: "RequiredFieldInfo",
}) as any as S.Schema<RequiredFieldInfo>;
export type RequiredTaskTemplateFields = RequiredFieldInfo[];
export const RequiredTaskTemplateFields = S.Array(RequiredFieldInfo);
export interface ReadOnlyFieldInfo {
  Id?: TaskTemplateFieldIdentifier;
}
export const ReadOnlyFieldInfo = S.suspend(() =>
  S.Struct({ Id: S.optional(TaskTemplateFieldIdentifier) }),
).annotations({
  identifier: "ReadOnlyFieldInfo",
}) as any as S.Schema<ReadOnlyFieldInfo>;
export type ReadOnlyTaskTemplateFields = ReadOnlyFieldInfo[];
export const ReadOnlyTaskTemplateFields = S.Array(ReadOnlyFieldInfo);
export interface InvisibleFieldInfo {
  Id?: TaskTemplateFieldIdentifier;
}
export const InvisibleFieldInfo = S.suspend(() =>
  S.Struct({ Id: S.optional(TaskTemplateFieldIdentifier) }),
).annotations({
  identifier: "InvisibleFieldInfo",
}) as any as S.Schema<InvisibleFieldInfo>;
export type InvisibleTaskTemplateFields = InvisibleFieldInfo[];
export const InvisibleTaskTemplateFields = S.Array(InvisibleFieldInfo);
export interface TaskTemplateConstraints {
  RequiredFields?: RequiredFieldInfo[];
  ReadOnlyFields?: ReadOnlyFieldInfo[];
  InvisibleFields?: InvisibleFieldInfo[];
}
export const TaskTemplateConstraints = S.suspend(() =>
  S.Struct({
    RequiredFields: S.optional(RequiredTaskTemplateFields),
    ReadOnlyFields: S.optional(ReadOnlyTaskTemplateFields),
    InvisibleFields: S.optional(InvisibleTaskTemplateFields),
  }),
).annotations({
  identifier: "TaskTemplateConstraints",
}) as any as S.Schema<TaskTemplateConstraints>;
export interface TaskTemplateDefaultFieldValue {
  Id?: TaskTemplateFieldIdentifier;
  DefaultValue?: string;
}
export const TaskTemplateDefaultFieldValue = S.suspend(() =>
  S.Struct({
    Id: S.optional(TaskTemplateFieldIdentifier),
    DefaultValue: S.optional(S.String),
  }),
).annotations({
  identifier: "TaskTemplateDefaultFieldValue",
}) as any as S.Schema<TaskTemplateDefaultFieldValue>;
export type TaskTemplateDefaultFieldValueList = TaskTemplateDefaultFieldValue[];
export const TaskTemplateDefaultFieldValueList = S.Array(
  TaskTemplateDefaultFieldValue,
);
export interface TaskTemplateDefaults {
  DefaultFieldValues?: TaskTemplateDefaultFieldValue[];
}
export const TaskTemplateDefaults = S.suspend(() =>
  S.Struct({
    DefaultFieldValues: S.optional(TaskTemplateDefaultFieldValueList),
  }),
).annotations({
  identifier: "TaskTemplateDefaults",
}) as any as S.Schema<TaskTemplateDefaults>;
export type TaskTemplateFieldType =
  | "NAME"
  | "DESCRIPTION"
  | "SCHEDULED_TIME"
  | "QUICK_CONNECT"
  | "URL"
  | "NUMBER"
  | "TEXT"
  | "TEXT_AREA"
  | "DATE_TIME"
  | "BOOLEAN"
  | "SINGLE_SELECT"
  | "EMAIL"
  | "SELF_ASSIGN"
  | "EXPIRY_DURATION"
  | (string & {});
export const TaskTemplateFieldType = S.String;
export type SingleSelectOptions = string[];
export const SingleSelectOptions = S.Array(S.String);
export interface TaskTemplateField {
  Id: TaskTemplateFieldIdentifier;
  Description?: string;
  Type?: TaskTemplateFieldType;
  SingleSelectOptions?: string[];
}
export const TaskTemplateField = S.suspend(() =>
  S.Struct({
    Id: TaskTemplateFieldIdentifier,
    Description: S.optional(S.String),
    Type: S.optional(TaskTemplateFieldType),
    SingleSelectOptions: S.optional(SingleSelectOptions),
  }),
).annotations({
  identifier: "TaskTemplateField",
}) as any as S.Schema<TaskTemplateField>;
export type TaskTemplateFields = TaskTemplateField[];
export const TaskTemplateFields = S.Array(TaskTemplateField);
export interface UpdateTaskTemplateRequest {
  TaskTemplateId: string;
  InstanceId: string;
  Name?: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Status?: TaskTemplateStatus;
  Fields?: TaskTemplateField[];
}
export const UpdateTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    TaskTemplateId: S.String.pipe(T.HttpLabel("TaskTemplateId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Status: S.optional(TaskTemplateStatus),
    Fields: S.optional(TaskTemplateFields),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/instance/{InstanceId}/task/template/{TaskTemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTaskTemplateRequest",
}) as any as S.Schema<UpdateTaskTemplateRequest>;
export interface UpdateUserHierarchyRequest {
  HierarchyGroupId?: string;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserHierarchyRequest = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.optional(S.String),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/users/{InstanceId}/{UserId}/hierarchy" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserHierarchyRequest",
}) as any as S.Schema<UpdateUserHierarchyRequest>;
export interface UpdateUserHierarchyResponse {}
export const UpdateUserHierarchyResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserHierarchyResponse",
}) as any as S.Schema<UpdateUserHierarchyResponse>;
export interface UpdateUserHierarchyGroupNameRequest {
  Name: string;
  HierarchyGroupId: string;
  InstanceId: string;
}
export const UpdateUserHierarchyGroupNameRequest = S.suspend(() =>
  S.Struct({
    Name: S.String,
    HierarchyGroupId: S.String.pipe(T.HttpLabel("HierarchyGroupId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/user-hierarchy-groups/{InstanceId}/{HierarchyGroupId}/name",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserHierarchyGroupNameRequest",
}) as any as S.Schema<UpdateUserHierarchyGroupNameRequest>;
export interface UpdateUserHierarchyGroupNameResponse {}
export const UpdateUserHierarchyGroupNameResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserHierarchyGroupNameResponse",
}) as any as S.Schema<UpdateUserHierarchyGroupNameResponse>;
export interface UserIdentityInfo {
  FirstName?: string | redacted.Redacted<string>;
  LastName?: string | redacted.Redacted<string>;
  Email?: string | redacted.Redacted<string>;
  SecondaryEmail?: string | redacted.Redacted<string>;
  Mobile?: string;
}
export const UserIdentityInfo = S.suspend(() =>
  S.Struct({
    FirstName: S.optional(SensitiveString),
    LastName: S.optional(SensitiveString),
    Email: S.optional(SensitiveString),
    SecondaryEmail: S.optional(SensitiveString),
    Mobile: S.optional(S.String),
  }),
).annotations({
  identifier: "UserIdentityInfo",
}) as any as S.Schema<UserIdentityInfo>;
export interface UpdateUserIdentityInfoRequest {
  IdentityInfo: UserIdentityInfo;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserIdentityInfoRequest = S.suspend(() =>
  S.Struct({
    IdentityInfo: UserIdentityInfo,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/identity-info",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserIdentityInfoRequest",
}) as any as S.Schema<UpdateUserIdentityInfoRequest>;
export interface UpdateUserIdentityInfoResponse {}
export const UpdateUserIdentityInfoResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserIdentityInfoResponse",
}) as any as S.Schema<UpdateUserIdentityInfoResponse>;
export type PhoneType = "SOFT_PHONE" | "DESK_PHONE" | (string & {});
export const PhoneType = S.String;
export interface UserPhoneConfig {
  PhoneType: PhoneType;
  AutoAccept?: boolean;
  AfterContactWorkTimeLimit?: number;
  DeskPhoneNumber?: string;
  PersistentConnection?: boolean;
}
export const UserPhoneConfig = S.suspend(() =>
  S.Struct({
    PhoneType: PhoneType,
    AutoAccept: S.optional(S.Boolean),
    AfterContactWorkTimeLimit: S.optional(S.Number),
    DeskPhoneNumber: S.optional(S.String),
    PersistentConnection: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "UserPhoneConfig",
}) as any as S.Schema<UserPhoneConfig>;
export interface UpdateUserPhoneConfigRequest {
  PhoneConfig: UserPhoneConfig;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserPhoneConfigRequest = S.suspend(() =>
  S.Struct({
    PhoneConfig: UserPhoneConfig,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/phone-config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserPhoneConfigRequest",
}) as any as S.Schema<UpdateUserPhoneConfigRequest>;
export interface UpdateUserPhoneConfigResponse {}
export const UpdateUserPhoneConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserPhoneConfigResponse",
}) as any as S.Schema<UpdateUserPhoneConfigResponse>;
export interface UserProficiency {
  AttributeName: string;
  AttributeValue: string;
  Level: number;
}
export const UserProficiency = S.suspend(() =>
  S.Struct({
    AttributeName: S.String,
    AttributeValue: S.String,
    Level: S.Number,
  }),
).annotations({
  identifier: "UserProficiency",
}) as any as S.Schema<UserProficiency>;
export type UserProficiencyList = UserProficiency[];
export const UserProficiencyList = S.Array(UserProficiency);
export interface UpdateUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  UserProficiencies: UserProficiency[];
}
export const UpdateUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    UserProficiencies: UserProficiencyList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserProficienciesRequest",
}) as any as S.Schema<UpdateUserProficienciesRequest>;
export interface UpdateUserProficienciesResponse {}
export const UpdateUserProficienciesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserProficienciesResponse",
}) as any as S.Schema<UpdateUserProficienciesResponse>;
export interface UpdateUserRoutingProfileRequest {
  RoutingProfileId: string;
  UserId: string;
  InstanceId: string;
}
export const UpdateUserRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    RoutingProfileId: S.String,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/routing-profile",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserRoutingProfileRequest",
}) as any as S.Schema<UpdateUserRoutingProfileRequest>;
export interface UpdateUserRoutingProfileResponse {}
export const UpdateUserRoutingProfileResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserRoutingProfileResponse",
}) as any as S.Schema<UpdateUserRoutingProfileResponse>;
export interface UpdateUserSecurityProfilesRequest {
  SecurityProfileIds: string[];
  UserId: string;
  InstanceId: string;
}
export const UpdateUserSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileIds: SecurityProfileIds,
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/security-profiles",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserSecurityProfilesRequest",
}) as any as S.Schema<UpdateUserSecurityProfilesRequest>;
export interface UpdateUserSecurityProfilesResponse {}
export const UpdateUserSecurityProfilesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserSecurityProfilesResponse",
}) as any as S.Schema<UpdateUserSecurityProfilesResponse>;
export type ViewActions = string | redacted.Redacted<string>[];
export const ViewActions = S.Array(SensitiveString);
export interface ViewInputContent {
  Template?: string;
  Actions?: string | redacted.Redacted<string>[];
}
export const ViewInputContent = S.suspend(() =>
  S.Struct({
    Template: S.optional(S.String),
    Actions: S.optional(ViewActions),
  }),
).annotations({
  identifier: "ViewInputContent",
}) as any as S.Schema<ViewInputContent>;
export interface UpdateViewContentRequest {
  InstanceId: string;
  ViewId: string;
  Status: ViewStatus;
  Content: ViewInputContent;
}
export const UpdateViewContentRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    Status: ViewStatus,
    Content: ViewInputContent,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/views/{InstanceId}/{ViewId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateViewContentRequest",
}) as any as S.Schema<UpdateViewContentRequest>;
export interface UpdateViewMetadataRequest {
  InstanceId: string;
  ViewId: string;
  Name?: string | redacted.Redacted<string>;
  Description?: string;
}
export const UpdateViewMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ViewId: S.String.pipe(T.HttpLabel("ViewId")),
    Name: S.optional(SensitiveString),
    Description: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/views/{InstanceId}/{ViewId}/metadata" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateViewMetadataRequest",
}) as any as S.Schema<UpdateViewMetadataRequest>;
export interface UpdateViewMetadataResponse {}
export const UpdateViewMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateViewMetadataResponse",
}) as any as S.Schema<UpdateViewMetadataResponse>;
export interface UpdateWorkspaceMetadataRequest {
  InstanceId: string;
  WorkspaceId: string;
  Name?: string;
  Description?: string;
  Title?: string;
}
export const UpdateWorkspaceMetadataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Title: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/metadata",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateWorkspaceMetadataRequest",
}) as any as S.Schema<UpdateWorkspaceMetadataRequest>;
export interface UpdateWorkspaceMetadataResponse {}
export const UpdateWorkspaceMetadataResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateWorkspaceMetadataResponse",
}) as any as S.Schema<UpdateWorkspaceMetadataResponse>;
export interface UpdateWorkspacePageRequest {
  InstanceId: string;
  WorkspaceId: string;
  Page: string;
  NewPage?: string;
  ResourceArn?: string;
  Slug?: string;
  InputData?: string;
}
export const UpdateWorkspacePageRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Page: S.String.pipe(T.HttpLabel("Page")),
    NewPage: S.optional(S.String),
    ResourceArn: S.optional(S.String),
    Slug: S.optional(S.String),
    InputData: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/pages/{Page}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateWorkspacePageRequest",
}) as any as S.Schema<UpdateWorkspacePageRequest>;
export interface UpdateWorkspacePageResponse {}
export const UpdateWorkspacePageResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateWorkspacePageResponse",
}) as any as S.Schema<UpdateWorkspacePageResponse>;
export interface PaletteHeader {
  Background?: string;
  Text?: string;
  TextHover?: string;
  InvertActionsColors?: boolean;
}
export const PaletteHeader = S.suspend(() =>
  S.Struct({
    Background: S.optional(S.String),
    Text: S.optional(S.String),
    TextHover: S.optional(S.String),
    InvertActionsColors: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "PaletteHeader",
}) as any as S.Schema<PaletteHeader>;
export interface PaletteNavigation {
  Background?: string;
  TextBackgroundHover?: string;
  TextBackgroundActive?: string;
  Text?: string;
  TextHover?: string;
  TextActive?: string;
  InvertActionsColors?: boolean;
}
export const PaletteNavigation = S.suspend(() =>
  S.Struct({
    Background: S.optional(S.String),
    TextBackgroundHover: S.optional(S.String),
    TextBackgroundActive: S.optional(S.String),
    Text: S.optional(S.String),
    TextHover: S.optional(S.String),
    TextActive: S.optional(S.String),
    InvertActionsColors: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "PaletteNavigation",
}) as any as S.Schema<PaletteNavigation>;
export interface PaletteCanvas {
  ContainerBackground?: string;
  PageBackground?: string;
  ActiveBackground?: string;
}
export const PaletteCanvas = S.suspend(() =>
  S.Struct({
    ContainerBackground: S.optional(S.String),
    PageBackground: S.optional(S.String),
    ActiveBackground: S.optional(S.String),
  }),
).annotations({
  identifier: "PaletteCanvas",
}) as any as S.Schema<PaletteCanvas>;
export interface PalettePrimary {
  Default?: string;
  Active?: string;
  ContrastText?: string;
}
export const PalettePrimary = S.suspend(() =>
  S.Struct({
    Default: S.optional(S.String),
    Active: S.optional(S.String),
    ContrastText: S.optional(S.String),
  }),
).annotations({
  identifier: "PalettePrimary",
}) as any as S.Schema<PalettePrimary>;
export interface WorkspaceThemePalette {
  Header?: PaletteHeader;
  Navigation?: PaletteNavigation;
  Canvas?: PaletteCanvas;
  Primary?: PalettePrimary;
}
export const WorkspaceThemePalette = S.suspend(() =>
  S.Struct({
    Header: S.optional(PaletteHeader),
    Navigation: S.optional(PaletteNavigation),
    Canvas: S.optional(PaletteCanvas),
    Primary: S.optional(PalettePrimary),
  }),
).annotations({
  identifier: "WorkspaceThemePalette",
}) as any as S.Schema<WorkspaceThemePalette>;
export interface ImagesLogo {
  Default?: string;
  Favicon?: string;
}
export const ImagesLogo = S.suspend(() =>
  S.Struct({ Default: S.optional(S.String), Favicon: S.optional(S.String) }),
).annotations({ identifier: "ImagesLogo" }) as any as S.Schema<ImagesLogo>;
export interface WorkspaceThemeImages {
  Logo?: ImagesLogo;
}
export const WorkspaceThemeImages = S.suspend(() =>
  S.Struct({ Logo: S.optional(ImagesLogo) }),
).annotations({
  identifier: "WorkspaceThemeImages",
}) as any as S.Schema<WorkspaceThemeImages>;
export type WorkspaceFontFamily =
  | "Arial"
  | "Courier New"
  | "Georgia"
  | "Times New Roman"
  | "Trebuchet"
  | "Verdana"
  | (string & {});
export const WorkspaceFontFamily = S.String;
export interface FontFamily {
  Default?: WorkspaceFontFamily;
}
export const FontFamily = S.suspend(() =>
  S.Struct({ Default: S.optional(WorkspaceFontFamily) }),
).annotations({ identifier: "FontFamily" }) as any as S.Schema<FontFamily>;
export interface WorkspaceThemeTypography {
  FontFamily?: FontFamily;
}
export const WorkspaceThemeTypography = S.suspend(() =>
  S.Struct({ FontFamily: S.optional(FontFamily) }),
).annotations({
  identifier: "WorkspaceThemeTypography",
}) as any as S.Schema<WorkspaceThemeTypography>;
export interface WorkspaceThemeConfig {
  Palette?: WorkspaceThemePalette;
  Images?: WorkspaceThemeImages;
  Typography?: WorkspaceThemeTypography;
}
export const WorkspaceThemeConfig = S.suspend(() =>
  S.Struct({
    Palette: S.optional(WorkspaceThemePalette),
    Images: S.optional(WorkspaceThemeImages),
    Typography: S.optional(WorkspaceThemeTypography),
  }),
).annotations({
  identifier: "WorkspaceThemeConfig",
}) as any as S.Schema<WorkspaceThemeConfig>;
export interface WorkspaceTheme {
  Light?: WorkspaceThemeConfig;
  Dark?: WorkspaceThemeConfig;
}
export const WorkspaceTheme = S.suspend(() =>
  S.Struct({
    Light: S.optional(WorkspaceThemeConfig),
    Dark: S.optional(WorkspaceThemeConfig),
  }),
).annotations({
  identifier: "WorkspaceTheme",
}) as any as S.Schema<WorkspaceTheme>;
export interface UpdateWorkspaceThemeRequest {
  InstanceId: string;
  WorkspaceId: string;
  Theme?: WorkspaceTheme;
}
export const UpdateWorkspaceThemeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Theme: S.optional(WorkspaceTheme),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/theme",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateWorkspaceThemeRequest",
}) as any as S.Schema<UpdateWorkspaceThemeRequest>;
export interface UpdateWorkspaceThemeResponse {}
export const UpdateWorkspaceThemeResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateWorkspaceThemeResponse",
}) as any as S.Schema<UpdateWorkspaceThemeResponse>;
export interface UpdateWorkspaceVisibilityRequest {
  InstanceId: string;
  WorkspaceId: string;
  Visibility: Visibility;
}
export const UpdateWorkspaceVisibilityRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    WorkspaceId: S.String.pipe(T.HttpLabel("WorkspaceId")),
    Visibility: Visibility,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/workspaces/{InstanceId}/{WorkspaceId}/visibility",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateWorkspaceVisibilityRequest",
}) as any as S.Schema<UpdateWorkspaceVisibilityRequest>;
export interface UpdateWorkspaceVisibilityResponse {}
export const UpdateWorkspaceVisibilityResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateWorkspaceVisibilityResponse",
}) as any as S.Schema<UpdateWorkspaceVisibilityResponse>;
export type ParticipantRole =
  | "AGENT"
  | "CUSTOMER"
  | "SYSTEM"
  | "CUSTOM_BOT"
  | "SUPERVISOR"
  | (string & {});
export const ParticipantRole = S.String;
export type AttributeNameList = string[];
export const AttributeNameList = S.Array(S.String);
export type ContactMetricName = "POSITION_IN_QUEUE" | (string & {});
export const ContactMetricName = S.String;
export type Queues = string[];
export const Queues = S.Array(S.String);
export type Channels = Channel[];
export const Channels = S.Array(Channel);
export type RoutingProfiles = string[];
export const RoutingProfiles = S.Array(S.String);
export type RoutingExpressions = string[];
export const RoutingExpressions = S.Array(S.String);
export type AgentStatuses = string[];
export const AgentStatuses = S.Array(S.String);
export type Subtypes = string[];
export const Subtypes = S.Array(S.String);
export type ValidationTestTypes = string[];
export const ValidationTestTypes = S.Array(S.String);
export type CurrentMetricName =
  | "AGENTS_ONLINE"
  | "AGENTS_AVAILABLE"
  | "AGENTS_ON_CALL"
  | "AGENTS_NON_PRODUCTIVE"
  | "AGENTS_AFTER_CONTACT_WORK"
  | "AGENTS_ERROR"
  | "AGENTS_STAFFED"
  | "CONTACTS_IN_QUEUE"
  | "OLDEST_CONTACT_AGE"
  | "CONTACTS_SCHEDULED"
  | "AGENTS_ON_CONTACT"
  | "SLOTS_ACTIVE"
  | "SLOTS_AVAILABLE"
  | (string & {});
export const CurrentMetricName = S.String;
export type Unit = "SECONDS" | "COUNT" | "PERCENT" | (string & {});
export const Unit = S.String;
export type SortOrder = "ASCENDING" | "DESCENDING" | (string & {});
export const SortOrder = S.String;
export type AgentsMinOneMaxHundred = string[];
export const AgentsMinOneMaxHundred = S.Array(S.String);
export type UserDataHierarchyGroups = string[];
export const UserDataHierarchyGroups = S.Array(S.String);
export type HistoricalMetricName =
  | "CONTACTS_QUEUED"
  | "CONTACTS_HANDLED"
  | "CONTACTS_ABANDONED"
  | "CONTACTS_CONSULTED"
  | "CONTACTS_AGENT_HUNG_UP_FIRST"
  | "CONTACTS_HANDLED_INCOMING"
  | "CONTACTS_HANDLED_OUTBOUND"
  | "CONTACTS_HOLD_ABANDONS"
  | "CONTACTS_TRANSFERRED_IN"
  | "CONTACTS_TRANSFERRED_OUT"
  | "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
  | "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
  | "CONTACTS_MISSED"
  | "CALLBACK_CONTACTS_HANDLED"
  | "API_CONTACTS_HANDLED"
  | "OCCUPANCY"
  | "HANDLE_TIME"
  | "AFTER_CONTACT_WORK_TIME"
  | "QUEUED_TIME"
  | "ABANDON_TIME"
  | "QUEUE_ANSWER_TIME"
  | "HOLD_TIME"
  | "INTERACTION_TIME"
  | "INTERACTION_AND_HOLD_TIME"
  | "SERVICE_LEVEL"
  | (string & {});
export const HistoricalMetricName = S.String;
export type Statistic = "SUM" | "MAX" | "AVG" | (string & {});
export const Statistic = S.String;
export type IntervalPeriod =
  | "FIFTEEN_MIN"
  | "THIRTY_MIN"
  | "HOUR"
  | "DAY"
  | "WEEK"
  | "TOTAL"
  | (string & {});
export const IntervalPeriod = S.String;
export type FilterValueList = string[];
export const FilterValueList = S.Array(S.String);
export type AgentStatusSearchConditionList = AgentStatusSearchCriteria[];
export const AgentStatusSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<AgentStatusSearchCriteria, any> => AgentStatusSearchCriteria,
  ).annotations({ identifier: "AgentStatusSearchCriteria" }),
) as any as S.Schema<AgentStatusSearchConditionList>;
export type EvaluationSearchConditionList = EvaluationSearchCriteria[];
export const EvaluationSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<EvaluationSearchCriteria, any> => EvaluationSearchCriteria,
  ).annotations({ identifier: "EvaluationSearchCriteria" }),
) as any as S.Schema<EvaluationSearchConditionList>;
export type ContactFlowModuleSearchConditionList =
  ContactFlowModuleSearchCriteria[];
export const ContactFlowModuleSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<ContactFlowModuleSearchCriteria, any> =>
      ContactFlowModuleSearchCriteria,
  ).annotations({ identifier: "ContactFlowModuleSearchCriteria" }),
) as any as S.Schema<ContactFlowModuleSearchConditionList>;
export type ContactFlowModuleStatus = "PUBLISHED" | "SAVED" | (string & {});
export const ContactFlowModuleStatus = S.String;
export type ContactFlowSearchConditionList = ContactFlowSearchCriteria[];
export const ContactFlowSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<ContactFlowSearchCriteria, any> => ContactFlowSearchCriteria,
  ).annotations({ identifier: "ContactFlowSearchCriteria" }),
) as any as S.Schema<ContactFlowSearchConditionList>;
export type SearchContactsTimeRangeType =
  | "INITIATION_TIMESTAMP"
  | "SCHEDULED_TIMESTAMP"
  | "CONNECTED_TO_AGENT_TIMESTAMP"
  | "DISCONNECT_TIMESTAMP"
  | "ENQUEUE_TIMESTAMP"
  | (string & {});
export const SearchContactsTimeRangeType = S.String;
export type AgentResourceIdList = string[];
export const AgentResourceIdList = S.Array(S.String);
export type ChannelList = Channel[];
export const ChannelList = S.Array(Channel);
export type InitiationMethodList = ContactInitiationMethod[];
export const InitiationMethodList = S.Array(ContactInitiationMethod);
export type QueueIdList = string[];
export const QueueIdList = S.Array(S.String);
export type ActiveRegionList = string[];
export const ActiveRegionList = S.Array(S.String);
export type SortableFieldName =
  | "INITIATION_TIMESTAMP"
  | "SCHEDULED_TIMESTAMP"
  | "CONNECTED_TO_AGENT_TIMESTAMP"
  | "DISCONNECT_TIMESTAMP"
  | "INITIATION_METHOD"
  | "CHANNEL"
  | "EXPIRY_TIMESTAMP"
  | (string & {});
export const SortableFieldName = S.String;
export type DataTableSearchConditionList = DataTableSearchCriteria[];
export const DataTableSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<DataTableSearchCriteria, any> => DataTableSearchCriteria,
  ).annotations({ identifier: "DataTableSearchCriteria" }),
) as any as S.Schema<DataTableSearchConditionList>;
export type EmailAddressSearchConditionList = EmailAddressSearchCriteria[];
export const EmailAddressSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<EmailAddressSearchCriteria, any> => EmailAddressSearchCriteria,
  ).annotations({ identifier: "EmailAddressSearchCriteria" }),
) as any as S.Schema<EmailAddressSearchConditionList>;
export type EvaluationFormSearchConditionList = EvaluationFormSearchCriteria[];
export const EvaluationFormSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<EvaluationFormSearchCriteria, any> =>
      EvaluationFormSearchCriteria,
  ).annotations({ identifier: "EvaluationFormSearchCriteria" }),
) as any as S.Schema<EvaluationFormSearchConditionList>;
export type HoursOfOperationOverrideSearchConditionList =
  HoursOfOperationOverrideSearchCriteria[];
export const HoursOfOperationOverrideSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<HoursOfOperationOverrideSearchCriteria, any> =>
      HoursOfOperationOverrideSearchCriteria,
  ).annotations({ identifier: "HoursOfOperationOverrideSearchCriteria" }),
) as any as S.Schema<HoursOfOperationOverrideSearchConditionList>;
export type HoursOfOperationSearchConditionList =
  HoursOfOperationSearchCriteria[];
export const HoursOfOperationSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<HoursOfOperationSearchCriteria, any> =>
      HoursOfOperationSearchCriteria,
  ).annotations({ identifier: "HoursOfOperationSearchCriteria" }),
) as any as S.Schema<HoursOfOperationSearchConditionList>;
export type PredefinedAttributeSearchConditionList =
  PredefinedAttributeSearchCriteria[];
export const PredefinedAttributeSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<PredefinedAttributeSearchCriteria, any> =>
      PredefinedAttributeSearchCriteria,
  ).annotations({ identifier: "PredefinedAttributeSearchCriteria" }),
) as any as S.Schema<PredefinedAttributeSearchConditionList>;
export type PromptSearchConditionList = PromptSearchCriteria[];
export const PromptSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<PromptSearchCriteria, any> => PromptSearchCriteria,
  ).annotations({ identifier: "PromptSearchCriteria" }),
) as any as S.Schema<PromptSearchConditionList>;
export type QueueSearchConditionList = QueueSearchCriteria[];
export const QueueSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<QueueSearchCriteria, any> => QueueSearchCriteria,
  ).annotations({ identifier: "QueueSearchCriteria" }),
) as any as S.Schema<QueueSearchConditionList>;
export type SearchableQueueType = "STANDARD" | (string & {});
export const SearchableQueueType = S.String;
export type QuickConnectSearchConditionList = QuickConnectSearchCriteria[];
export const QuickConnectSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<QuickConnectSearchCriteria, any> => QuickConnectSearchCriteria,
  ).annotations({ identifier: "QuickConnectSearchCriteria" }),
) as any as S.Schema<QuickConnectSearchConditionList>;
export type RoutingProfileSearchConditionList = RoutingProfileSearchCriteria[];
export const RoutingProfileSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<RoutingProfileSearchCriteria, any> =>
      RoutingProfileSearchCriteria,
  ).annotations({ identifier: "RoutingProfileSearchCriteria" }),
) as any as S.Schema<RoutingProfileSearchConditionList>;
export type SecurityProfileSearchConditionList =
  SecurityProfileSearchCriteria[];
export const SecurityProfileSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<SecurityProfileSearchCriteria, any> =>
      SecurityProfileSearchCriteria,
  ).annotations({ identifier: "SecurityProfileSearchCriteria" }),
) as any as S.Schema<SecurityProfileSearchConditionList>;
export type UserHierarchyGroupSearchConditionList =
  UserHierarchyGroupSearchCriteria[];
export const UserHierarchyGroupSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<UserHierarchyGroupSearchCriteria, any> =>
      UserHierarchyGroupSearchCriteria,
  ).annotations({ identifier: "UserHierarchyGroupSearchCriteria" }),
) as any as S.Schema<UserHierarchyGroupSearchConditionList>;
export type UserSearchConditionList = UserSearchCriteria[];
export const UserSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<UserSearchCriteria, any> => UserSearchCriteria,
  ).annotations({ identifier: "UserSearchCriteria" }),
) as any as S.Schema<UserSearchConditionList>;
export type ViewSearchConditionList = ViewSearchCriteria[];
export const ViewSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<ViewSearchCriteria, any> => ViewSearchCriteria,
  ).annotations({ identifier: "ViewSearchCriteria" }),
) as any as S.Schema<ViewSearchConditionList>;
export type WorkspaceAssociationSearchConditionList =
  WorkspaceAssociationSearchCriteria[];
export const WorkspaceAssociationSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<WorkspaceAssociationSearchCriteria, any> =>
      WorkspaceAssociationSearchCriteria,
  ).annotations({ identifier: "WorkspaceAssociationSearchCriteria" }),
) as any as S.Schema<WorkspaceAssociationSearchConditionList>;
export type WorkspaceSearchConditionList = WorkspaceSearchCriteria[];
export const WorkspaceSearchConditionList = S.Array(
  S.suspend(
    (): S.Schema<WorkspaceSearchCriteria, any> => WorkspaceSearchCriteria,
  ).annotations({ identifier: "WorkspaceSearchCriteria" }),
) as any as S.Schema<WorkspaceSearchConditionList>;
export type ChatEventType = "DISCONNECT" | "MESSAGE" | "EVENT" | (string & {});
export const ChatEventType = S.String;
export type ResponseMode = "INCREMENTAL" | "COMPLETE" | (string & {});
export const ResponseMode = S.String;
export type VoiceRecordingTrack =
  | "FROM_AGENT"
  | "TO_AGENT"
  | "ALL"
  | (string & {});
export const VoiceRecordingTrack = S.String;
export type IvrRecordingTrack = "ALL" | (string & {});
export const IvrRecordingTrack = S.String;
export type InboundMessageSourceType = "RAW" | (string & {});
export const InboundMessageSourceType = S.String;
export type EndpointType =
  | "TELEPHONE_NUMBER"
  | "VOIP"
  | "CONTACT_FLOW"
  | "CONNECT_PHONENUMBER_ARN"
  | "EMAIL_ADDRESS"
  | (string & {});
export const EndpointType = S.String;
export type OutboundStrategyType = "AGENT_FIRST" | (string & {});
export const OutboundStrategyType = S.String;
export interface RoutingProfileManualAssignmentQueueConfig {
  QueueReference: RoutingProfileQueueReference;
}
export const RoutingProfileManualAssignmentQueueConfig = S.suspend(() =>
  S.Struct({ QueueReference: RoutingProfileQueueReference }),
).annotations({
  identifier: "RoutingProfileManualAssignmentQueueConfig",
}) as any as S.Schema<RoutingProfileManualAssignmentQueueConfig>;
export type RoutingProfileManualAssignmentQueueConfigList =
  RoutingProfileManualAssignmentQueueConfig[];
export const RoutingProfileManualAssignmentQueueConfigList = S.Array(
  RoutingProfileManualAssignmentQueueConfig,
);
export interface DataTableDeleteValueIdentifier {
  PrimaryValues?: PrimaryValue[];
  AttributeName: string;
  LockVersion: DataTableLockVersion;
}
export const DataTableDeleteValueIdentifier = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeName: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotations({
  identifier: "DataTableDeleteValueIdentifier",
}) as any as S.Schema<DataTableDeleteValueIdentifier>;
export type DataTableDeleteValueIdentifierList =
  DataTableDeleteValueIdentifier[];
export const DataTableDeleteValueIdentifierList = S.Array(
  DataTableDeleteValueIdentifier,
);
export interface DataTableValueIdentifier {
  PrimaryValues?: PrimaryValue[];
  AttributeName: string;
}
export const DataTableValueIdentifier = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeName: S.String,
  }),
).annotations({
  identifier: "DataTableValueIdentifier",
}) as any as S.Schema<DataTableValueIdentifier>;
export type DataTableValueIdentifierList = DataTableValueIdentifier[];
export const DataTableValueIdentifierList = S.Array(DataTableValueIdentifier);
export interface UserInfo {
  UserId?: string;
}
export const UserInfo = S.suspend(() =>
  S.Struct({ UserId: S.optional(S.String) }),
).annotations({ identifier: "UserInfo" }) as any as S.Schema<UserInfo>;
export interface ExternalInvocationConfiguration {
  Enabled?: boolean;
}
export const ExternalInvocationConfiguration = S.suspend(() =>
  S.Struct({ Enabled: S.optional(S.Boolean) }),
).annotations({
  identifier: "ExternalInvocationConfiguration",
}) as any as S.Schema<ExternalInvocationConfiguration>;
export interface ContactConfiguration {
  ContactId: string;
  ParticipantRole?: ParticipantRole;
  IncludeRawMessage?: boolean;
}
export const ContactConfiguration = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    ParticipantRole: S.optional(ParticipantRole),
    IncludeRawMessage: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "ContactConfiguration",
}) as any as S.Schema<ContactConfiguration>;
export interface RuleTriggerEventSource {
  EventSourceName: EventSourceName;
  IntegrationAssociationId?: string;
}
export const RuleTriggerEventSource = S.suspend(() =>
  S.Struct({
    EventSourceName: EventSourceName,
    IntegrationAssociationId: S.optional(S.String),
  }),
).annotations({
  identifier: "RuleTriggerEventSource",
}) as any as S.Schema<RuleTriggerEventSource>;
export type AliasConfigurationList = AliasConfiguration[];
export const AliasConfigurationList = S.Array(AliasConfiguration);
export type RoutingProfileQueueReferenceList = RoutingProfileQueueReference[];
export const RoutingProfileQueueReferenceList = S.Array(
  RoutingProfileQueueReference,
);
export interface UserProficiencyDisassociate {
  AttributeName: string;
  AttributeValue: string;
}
export const UserProficiencyDisassociate = S.suspend(() =>
  S.Struct({ AttributeName: S.String, AttributeValue: S.String }),
).annotations({
  identifier: "UserProficiencyDisassociate",
}) as any as S.Schema<UserProficiencyDisassociate>;
export type UserProficiencyDisassociateList = UserProficiencyDisassociate[];
export const UserProficiencyDisassociateList = S.Array(
  UserProficiencyDisassociate,
);
export interface DataTableValueEvaluationSet {
  PrimaryValues?: PrimaryValue[];
  AttributeNames: string[];
}
export const DataTableValueEvaluationSet = S.suspend(() =>
  S.Struct({
    PrimaryValues: S.optional(PrimaryValuesSet),
    AttributeNames: AttributeNameList,
  }),
).annotations({
  identifier: "DataTableValueEvaluationSet",
}) as any as S.Schema<DataTableValueEvaluationSet>;
export type DataTableValueEvaluationSetList = DataTableValueEvaluationSet[];
export const DataTableValueEvaluationSetList = S.Array(
  DataTableValueEvaluationSet,
);
export type FileStatusType =
  | "APPROVED"
  | "REJECTED"
  | "PROCESSING"
  | "FAILED"
  | (string & {});
export const FileStatusType = S.String;
export interface ContactMetricInfo {
  Name: ContactMetricName;
}
export const ContactMetricInfo = S.suspend(() =>
  S.Struct({ Name: ContactMetricName }),
).annotations({
  identifier: "ContactMetricInfo",
}) as any as S.Schema<ContactMetricInfo>;
export type ContactMetrics = ContactMetricInfo[];
export const ContactMetrics = S.Array(ContactMetricInfo);
export interface Filters {
  Queues?: string[];
  Channels?: Channel[];
  RoutingProfiles?: string[];
  RoutingStepExpressions?: string[];
  AgentStatuses?: string[];
  Subtypes?: string[];
  ValidationTestTypes?: string[];
}
export const Filters = S.suspend(() =>
  S.Struct({
    Queues: S.optional(Queues),
    Channels: S.optional(Channels),
    RoutingProfiles: S.optional(RoutingProfiles),
    RoutingStepExpressions: S.optional(RoutingExpressions),
    AgentStatuses: S.optional(AgentStatuses),
    Subtypes: S.optional(Subtypes),
    ValidationTestTypes: S.optional(ValidationTestTypes),
  }),
).annotations({ identifier: "Filters" }) as any as S.Schema<Filters>;
export interface CurrentMetric {
  Name?: CurrentMetricName;
  MetricId?: string;
  Unit?: Unit;
}
export const CurrentMetric = S.suspend(() =>
  S.Struct({
    Name: S.optional(CurrentMetricName),
    MetricId: S.optional(S.String),
    Unit: S.optional(Unit),
  }),
).annotations({
  identifier: "CurrentMetric",
}) as any as S.Schema<CurrentMetric>;
export type CurrentMetrics = CurrentMetric[];
export const CurrentMetrics = S.Array(CurrentMetric);
export interface CurrentMetricSortCriteria {
  SortByMetric?: CurrentMetricName;
  SortOrder?: SortOrder;
}
export const CurrentMetricSortCriteria = S.suspend(() =>
  S.Struct({
    SortByMetric: S.optional(CurrentMetricName),
    SortOrder: S.optional(SortOrder),
  }),
).annotations({
  identifier: "CurrentMetricSortCriteria",
}) as any as S.Schema<CurrentMetricSortCriteria>;
export type CurrentMetricSortCriteriaMaxOne = CurrentMetricSortCriteria[];
export const CurrentMetricSortCriteriaMaxOne = S.Array(
  CurrentMetricSortCriteria,
);
export interface IntervalDetails {
  TimeZone?: string;
  IntervalPeriod?: IntervalPeriod;
}
export const IntervalDetails = S.suspend(() =>
  S.Struct({
    TimeZone: S.optional(S.String),
    IntervalPeriod: S.optional(IntervalPeriod),
  }),
).annotations({
  identifier: "IntervalDetails",
}) as any as S.Schema<IntervalDetails>;
export type OriginsList = string[];
export const OriginsList = S.Array(S.String);
export interface DataTableAttribute {
  AttributeId?: string;
  Name: string;
  ValueType: DataTableAttributeValueType;
  Description?: string;
  DataTableId?: string;
  DataTableArn?: string;
  Primary?: boolean;
  Version?: string;
  LockVersion?: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  Validation?: Validation;
}
export const DataTableAttribute = S.suspend(() =>
  S.Struct({
    AttributeId: S.optional(S.String),
    Name: S.String,
    ValueType: DataTableAttributeValueType,
    Description: S.optional(S.String),
    DataTableId: S.optional(S.String),
    DataTableArn: S.optional(S.String),
    Primary: S.optional(S.Boolean),
    Version: S.optional(S.String),
    LockVersion: S.optional(DataTableLockVersion),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    Validation: S.optional(Validation),
  }),
).annotations({
  identifier: "DataTableAttribute",
}) as any as S.Schema<DataTableAttribute>;
export type AttributeList = DataTableAttribute[];
export const AttributeList = S.Array(DataTableAttribute);
export type SecurityProfiles100 = SecurityProfileItem[];
export const SecurityProfiles100 = S.Array(SecurityProfileItem);
export interface HoursOfOperationOverride {
  HoursOfOperationOverrideId?: string;
  HoursOfOperationId?: string;
  HoursOfOperationArn?: string;
  Name?: string;
  Description?: string;
  Config?: HoursOfOperationOverrideConfig[];
  EffectiveFrom?: string;
  EffectiveTill?: string;
}
export const HoursOfOperationOverride = S.suspend(() =>
  S.Struct({
    HoursOfOperationOverrideId: S.optional(S.String),
    HoursOfOperationId: S.optional(S.String),
    HoursOfOperationArn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Config: S.optional(HoursOfOperationOverrideConfigList),
    EffectiveFrom: S.optional(S.String),
    EffectiveTill: S.optional(S.String),
  }),
).annotations({
  identifier: "HoursOfOperationOverride",
}) as any as S.Schema<HoursOfOperationOverride>;
export type HoursOfOperationOverrideList = HoursOfOperationOverride[];
export const HoursOfOperationOverrideList = S.Array(HoursOfOperationOverride);
export interface Attribute {
  AttributeType?: InstanceAttributeType;
  Value?: string;
}
export const Attribute = S.suspend(() =>
  S.Struct({
    AttributeType: S.optional(InstanceAttributeType),
    Value: S.optional(S.String),
  }),
).annotations({ identifier: "Attribute" }) as any as S.Schema<Attribute>;
export type AttributesList = Attribute[];
export const AttributesList = S.Array(Attribute);
export type InstanceStorageConfigs = InstanceStorageConfig[];
export const InstanceStorageConfigs = S.Array(InstanceStorageConfig);
export type FunctionArnsList = string[];
export const FunctionArnsList = S.Array(S.String);
export type LexBotsList = LexBot[];
export const LexBotsList = S.Array(LexBot);
export type RealTimeContactAnalysisSupportedChannel =
  | "VOICE"
  | "CHAT"
  | (string & {});
export const RealTimeContactAnalysisSupportedChannel = S.String;
export type RealTimeContactAnalysisStatus =
  | "IN_PROGRESS"
  | "FAILED"
  | "COMPLETED"
  | (string & {});
export const RealTimeContactAnalysisStatus = S.String;
export interface TagCondition {
  TagKey?: string;
  TagValue?: string;
}
export const TagCondition = S.suspend(() =>
  S.Struct({ TagKey: S.optional(S.String), TagValue: S.optional(S.String) }),
).annotations({ identifier: "TagCondition" }) as any as S.Schema<TagCondition>;
export type TagAndConditionList = TagCondition[];
export const TagAndConditionList = S.Array(TagCondition);
export interface CommonAttributeAndCondition {
  TagConditions?: TagCondition[];
}
export const CommonAttributeAndCondition = S.suspend(() =>
  S.Struct({ TagConditions: S.optional(TagAndConditionList) }),
).annotations({
  identifier: "CommonAttributeAndCondition",
}) as any as S.Schema<CommonAttributeAndCondition>;
export type CommonAttributeOrConditionList = CommonAttributeAndCondition[];
export const CommonAttributeOrConditionList = S.Array(
  CommonAttributeAndCondition,
);
export interface ControlPlaneAttributeFilter {
  OrConditions?: CommonAttributeAndCondition[];
  AndCondition?: CommonAttributeAndCondition;
  TagCondition?: TagCondition;
}
export const ControlPlaneAttributeFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(CommonAttributeOrConditionList),
    AndCondition: S.optional(CommonAttributeAndCondition),
    TagCondition: S.optional(TagCondition),
  }),
).annotations({
  identifier: "ControlPlaneAttributeFilter",
}) as any as S.Schema<ControlPlaneAttributeFilter>;
export interface EvaluationSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const EvaluationSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "EvaluationSearchFilter",
}) as any as S.Schema<EvaluationSearchFilter>;
export type StringComparisonType =
  | "STARTS_WITH"
  | "CONTAINS"
  | "EXACT"
  | (string & {});
export const StringComparisonType = S.String;
export interface StringCondition {
  FieldName?: string;
  Value?: string;
  ComparisonType?: StringComparisonType;
}
export const StringCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    Value: S.optional(S.String),
    ComparisonType: S.optional(StringComparisonType),
  }),
).annotations({
  identifier: "StringCondition",
}) as any as S.Schema<StringCondition>;
export interface ContactFlowModuleSearchCriteria {
  OrConditions?: ContactFlowModuleSearchCriteria[];
  AndConditions?: ContactFlowModuleSearchCriteria[];
  StringCondition?: StringCondition;
  StateCondition?: ContactFlowModuleState;
  StatusCondition?: ContactFlowModuleStatus;
}
export const ContactFlowModuleSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => ContactFlowModuleSearchConditionList).annotations({
        identifier: "ContactFlowModuleSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => ContactFlowModuleSearchConditionList).annotations({
        identifier: "ContactFlowModuleSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    StateCondition: S.optional(ContactFlowModuleState),
    StatusCondition: S.optional(ContactFlowModuleStatus),
  }),
).annotations({
  identifier: "ContactFlowModuleSearchCriteria",
}) as any as S.Schema<ContactFlowModuleSearchCriteria>;
export interface ContactFlowSearchCriteria {
  OrConditions?: ContactFlowSearchCriteria[];
  AndConditions?: ContactFlowSearchCriteria[];
  StringCondition?: StringCondition;
  TypeCondition?: ContactFlowType;
  StateCondition?: ContactFlowState;
  StatusCondition?: ContactFlowStatus;
}
export const ContactFlowSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => ContactFlowSearchConditionList).annotations({
        identifier: "ContactFlowSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => ContactFlowSearchConditionList).annotations({
        identifier: "ContactFlowSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    TypeCondition: S.optional(ContactFlowType),
    StateCondition: S.optional(ContactFlowState),
    StatusCondition: S.optional(ContactFlowStatus),
  }),
).annotations({
  identifier: "ContactFlowSearchCriteria",
}) as any as S.Schema<ContactFlowSearchCriteria>;
export interface SearchContactsTimeRange {
  Type: SearchContactsTimeRangeType;
  StartTime: Date;
  EndTime: Date;
}
export const SearchContactsTimeRange = S.suspend(() =>
  S.Struct({
    Type: SearchContactsTimeRangeType,
    StartTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EndTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
  }),
).annotations({
  identifier: "SearchContactsTimeRange",
}) as any as S.Schema<SearchContactsTimeRange>;
export interface Sort {
  FieldName: SortableFieldName;
  Order: SortOrder;
}
export const Sort = S.suspend(() =>
  S.Struct({ FieldName: SortableFieldName, Order: SortOrder }),
).annotations({ identifier: "Sort" }) as any as S.Schema<Sort>;
export interface DataTableSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const DataTableSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "DataTableSearchFilter",
}) as any as S.Schema<DataTableSearchFilter>;
export interface DataTableSearchCriteria {
  OrConditions?: DataTableSearchCriteria[];
  AndConditions?: DataTableSearchCriteria[];
  StringCondition?: StringCondition;
}
export const DataTableSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => DataTableSearchConditionList).annotations({
        identifier: "DataTableSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => DataTableSearchConditionList).annotations({
        identifier: "DataTableSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "DataTableSearchCriteria",
}) as any as S.Schema<DataTableSearchCriteria>;
export interface EmailAddressSearchCriteria {
  OrConditions?: EmailAddressSearchCriteria[];
  AndConditions?: EmailAddressSearchCriteria[];
  StringCondition?: StringCondition;
}
export const EmailAddressSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => EmailAddressSearchConditionList).annotations({
        identifier: "EmailAddressSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => EmailAddressSearchConditionList).annotations({
        identifier: "EmailAddressSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "EmailAddressSearchCriteria",
}) as any as S.Schema<EmailAddressSearchCriteria>;
export type TagOrConditionList = TagCondition[][];
export const TagOrConditionList = S.Array(TagAndConditionList);
export interface ControlPlaneTagFilter {
  OrConditions?: TagCondition[][];
  AndConditions?: TagCondition[];
  TagCondition?: TagCondition;
}
export const ControlPlaneTagFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(TagOrConditionList),
    AndConditions: S.optional(TagAndConditionList),
    TagCondition: S.optional(TagCondition),
  }),
).annotations({
  identifier: "ControlPlaneTagFilter",
}) as any as S.Schema<ControlPlaneTagFilter>;
export interface EmailAddressSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const EmailAddressSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "EmailAddressSearchFilter",
}) as any as S.Schema<EmailAddressSearchFilter>;
export type NumberComparisonType =
  | "GREATER_OR_EQUAL"
  | "GREATER"
  | "LESSER_OR_EQUAL"
  | "LESSER"
  | "EQUAL"
  | "NOT_EQUAL"
  | "RANGE"
  | (string & {});
export const NumberComparisonType = S.String;
export interface NumberCondition {
  FieldName?: string;
  MinValue?: number;
  MaxValue?: number;
  ComparisonType?: NumberComparisonType;
}
export const NumberCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    MinValue: S.optional(S.Number),
    MaxValue: S.optional(S.Number),
    ComparisonType: S.optional(NumberComparisonType),
  }),
).annotations({
  identifier: "NumberCondition",
}) as any as S.Schema<NumberCondition>;
export type BooleanComparisonType = "IS_TRUE" | "IS_FALSE" | (string & {});
export const BooleanComparisonType = S.String;
export interface BooleanCondition {
  FieldName?: string;
  ComparisonType?: BooleanComparisonType;
}
export const BooleanCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    ComparisonType: S.optional(BooleanComparisonType),
  }),
).annotations({
  identifier: "BooleanCondition",
}) as any as S.Schema<BooleanCondition>;
export type DateTimeComparisonType =
  | "GREATER_THAN"
  | "LESS_THAN"
  | "GREATER_THAN_OR_EQUAL_TO"
  | "LESS_THAN_OR_EQUAL_TO"
  | "EQUAL_TO"
  | "RANGE"
  | (string & {});
export const DateTimeComparisonType = S.String;
export interface DateTimeCondition {
  FieldName?: string;
  MinValue?: string;
  MaxValue?: string;
  ComparisonType?: DateTimeComparisonType;
}
export const DateTimeCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    MinValue: S.optional(S.String),
    MaxValue: S.optional(S.String),
    ComparisonType: S.optional(DateTimeComparisonType),
  }),
).annotations({
  identifier: "DateTimeCondition",
}) as any as S.Schema<DateTimeCondition>;
export interface EvaluationFormSearchCriteria {
  OrConditions?: EvaluationFormSearchCriteria[];
  AndConditions?: EvaluationFormSearchCriteria[];
  StringCondition?: StringCondition;
  NumberCondition?: NumberCondition;
  BooleanCondition?: BooleanCondition;
  DateTimeCondition?: DateTimeCondition;
}
export const EvaluationFormSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => EvaluationFormSearchConditionList).annotations({
        identifier: "EvaluationFormSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => EvaluationFormSearchConditionList).annotations({
        identifier: "EvaluationFormSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    NumberCondition: S.optional(NumberCondition),
    BooleanCondition: S.optional(BooleanCondition),
    DateTimeCondition: S.optional(DateTimeCondition),
  }),
).annotations({
  identifier: "EvaluationFormSearchCriteria",
}) as any as S.Schema<EvaluationFormSearchCriteria>;
export interface EvaluationFormSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const EvaluationFormSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "EvaluationFormSearchFilter",
}) as any as S.Schema<EvaluationFormSearchFilter>;
export interface HoursOfOperationSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const HoursOfOperationSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "HoursOfOperationSearchFilter",
}) as any as S.Schema<HoursOfOperationSearchFilter>;
export interface HoursOfOperationSearchCriteria {
  OrConditions?: HoursOfOperationSearchCriteria[];
  AndConditions?: HoursOfOperationSearchCriteria[];
  StringCondition?: StringCondition;
}
export const HoursOfOperationSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => HoursOfOperationSearchConditionList).annotations({
        identifier: "HoursOfOperationSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => HoursOfOperationSearchConditionList).annotations({
        identifier: "HoursOfOperationSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "HoursOfOperationSearchCriteria",
}) as any as S.Schema<HoursOfOperationSearchCriteria>;
export interface PredefinedAttributeSearchCriteria {
  OrConditions?: PredefinedAttributeSearchCriteria[];
  AndConditions?: PredefinedAttributeSearchCriteria[];
  StringCondition?: StringCondition;
}
export const PredefinedAttributeSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => PredefinedAttributeSearchConditionList).annotations({
        identifier: "PredefinedAttributeSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => PredefinedAttributeSearchConditionList).annotations({
        identifier: "PredefinedAttributeSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "PredefinedAttributeSearchCriteria",
}) as any as S.Schema<PredefinedAttributeSearchCriteria>;
export interface PromptSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const PromptSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "PromptSearchFilter",
}) as any as S.Schema<PromptSearchFilter>;
export interface PromptSearchCriteria {
  OrConditions?: PromptSearchCriteria[];
  AndConditions?: PromptSearchCriteria[];
  StringCondition?: StringCondition;
}
export const PromptSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => PromptSearchConditionList).annotations({
        identifier: "PromptSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => PromptSearchConditionList).annotations({
        identifier: "PromptSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "PromptSearchCriteria",
}) as any as S.Schema<PromptSearchCriteria>;
export interface QueueSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const QueueSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "QueueSearchFilter",
}) as any as S.Schema<QueueSearchFilter>;
export interface QueueSearchCriteria {
  OrConditions?: QueueSearchCriteria[];
  AndConditions?: QueueSearchCriteria[];
  StringCondition?: StringCondition;
  QueueTypeCondition?: SearchableQueueType;
}
export const QueueSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => QueueSearchConditionList).annotations({
        identifier: "QueueSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => QueueSearchConditionList).annotations({
        identifier: "QueueSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    QueueTypeCondition: S.optional(SearchableQueueType),
  }),
).annotations({
  identifier: "QueueSearchCriteria",
}) as any as S.Schema<QueueSearchCriteria>;
export interface QuickConnectSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const QuickConnectSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "QuickConnectSearchFilter",
}) as any as S.Schema<QuickConnectSearchFilter>;
export interface QuickConnectSearchCriteria {
  OrConditions?: QuickConnectSearchCriteria[];
  AndConditions?: QuickConnectSearchCriteria[];
  StringCondition?: StringCondition;
}
export const QuickConnectSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => QuickConnectSearchConditionList).annotations({
        identifier: "QuickConnectSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => QuickConnectSearchConditionList).annotations({
        identifier: "QuickConnectSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "QuickConnectSearchCriteria",
}) as any as S.Schema<QuickConnectSearchCriteria>;
export interface RoutingProfileSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const RoutingProfileSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "RoutingProfileSearchFilter",
}) as any as S.Schema<RoutingProfileSearchFilter>;
export interface RoutingProfileSearchCriteria {
  OrConditions?: RoutingProfileSearchCriteria[];
  AndConditions?: RoutingProfileSearchCriteria[];
  StringCondition?: StringCondition;
}
export const RoutingProfileSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => RoutingProfileSearchConditionList).annotations({
        identifier: "RoutingProfileSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => RoutingProfileSearchConditionList).annotations({
        identifier: "RoutingProfileSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "RoutingProfileSearchCriteria",
}) as any as S.Schema<RoutingProfileSearchCriteria>;
export interface SecurityProfileSearchCriteria {
  OrConditions?: SecurityProfileSearchCriteria[];
  AndConditions?: SecurityProfileSearchCriteria[];
  StringCondition?: StringCondition;
}
export const SecurityProfileSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => SecurityProfileSearchConditionList).annotations({
        identifier: "SecurityProfileSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => SecurityProfileSearchConditionList).annotations({
        identifier: "SecurityProfileSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "SecurityProfileSearchCriteria",
}) as any as S.Schema<SecurityProfileSearchCriteria>;
export interface SecurityProfilesSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const SecurityProfilesSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "SecurityProfilesSearchFilter",
}) as any as S.Schema<SecurityProfilesSearchFilter>;
export interface UserHierarchyGroupSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const UserHierarchyGroupSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "UserHierarchyGroupSearchFilter",
}) as any as S.Schema<UserHierarchyGroupSearchFilter>;
export interface UserHierarchyGroupSearchCriteria {
  OrConditions?: UserHierarchyGroupSearchCriteria[];
  AndConditions?: UserHierarchyGroupSearchCriteria[];
  StringCondition?: StringCondition;
}
export const UserHierarchyGroupSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => UserHierarchyGroupSearchConditionList).annotations({
        identifier: "UserHierarchyGroupSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => UserHierarchyGroupSearchConditionList).annotations({
        identifier: "UserHierarchyGroupSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "UserHierarchyGroupSearchCriteria",
}) as any as S.Schema<UserHierarchyGroupSearchCriteria>;
export interface ViewSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const ViewSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "ViewSearchFilter",
}) as any as S.Schema<ViewSearchFilter>;
export interface ViewSearchCriteria {
  OrConditions?: ViewSearchCriteria[];
  AndConditions?: ViewSearchCriteria[];
  StringCondition?: StringCondition;
  ViewTypeCondition?: ViewType;
  ViewStatusCondition?: ViewStatus;
}
export const ViewSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => ViewSearchConditionList).annotations({
        identifier: "ViewSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => ViewSearchConditionList).annotations({
        identifier: "ViewSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    ViewTypeCondition: S.optional(ViewType),
    ViewStatusCondition: S.optional(ViewStatus),
  }),
).annotations({
  identifier: "ViewSearchCriteria",
}) as any as S.Schema<ViewSearchCriteria>;
export interface WorkspaceAssociationSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const WorkspaceAssociationSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "WorkspaceAssociationSearchFilter",
}) as any as S.Schema<WorkspaceAssociationSearchFilter>;
export interface WorkspaceAssociationSearchCriteria {
  OrConditions?: WorkspaceAssociationSearchCriteria[];
  AndConditions?: WorkspaceAssociationSearchCriteria[];
  StringCondition?: StringCondition;
}
export const WorkspaceAssociationSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => WorkspaceAssociationSearchConditionList).annotations({
        identifier: "WorkspaceAssociationSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => WorkspaceAssociationSearchConditionList).annotations({
        identifier: "WorkspaceAssociationSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "WorkspaceAssociationSearchCriteria",
}) as any as S.Schema<WorkspaceAssociationSearchCriteria>;
export interface WorkspaceSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const WorkspaceSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "WorkspaceSearchFilter",
}) as any as S.Schema<WorkspaceSearchFilter>;
export interface WorkspaceSearchCriteria {
  OrConditions?: WorkspaceSearchCriteria[];
  AndConditions?: WorkspaceSearchCriteria[];
  StringCondition?: StringCondition;
}
export const WorkspaceSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => WorkspaceSearchConditionList).annotations({
        identifier: "WorkspaceSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => WorkspaceSearchConditionList).annotations({
        identifier: "WorkspaceSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "WorkspaceSearchCriteria",
}) as any as S.Schema<WorkspaceSearchCriteria>;
export interface ChatEvent {
  Type: ChatEventType;
  ContentType?: string;
  Content?: string;
}
export const ChatEvent = S.suspend(() =>
  S.Struct({
    Type: ChatEventType,
    ContentType: S.optional(S.String),
    Content: S.optional(S.String),
  }),
).annotations({ identifier: "ChatEvent" }) as any as S.Schema<ChatEvent>;
export interface ParticipantDetails {
  DisplayName: string;
}
export const ParticipantDetails = S.suspend(() =>
  S.Struct({ DisplayName: S.String }),
).annotations({
  identifier: "ParticipantDetails",
}) as any as S.Schema<ParticipantDetails>;
export interface ChatStreamingConfiguration {
  StreamingEndpointArn: string;
}
export const ChatStreamingConfiguration = S.suspend(() =>
  S.Struct({ StreamingEndpointArn: S.String }),
).annotations({
  identifier: "ChatStreamingConfiguration",
}) as any as S.Schema<ChatStreamingConfiguration>;
export interface NewSessionDetails {
  SupportedMessagingContentTypes?: string[];
  ParticipantDetails?: ParticipantDetails;
  Attributes?: { [key: string]: string | undefined };
  StreamingConfiguration?: ChatStreamingConfiguration;
}
export const NewSessionDetails = S.suspend(() =>
  S.Struct({
    SupportedMessagingContentTypes: S.optional(SupportedMessagingContentTypes),
    ParticipantDetails: S.optional(ParticipantDetails),
    Attributes: S.optional(Attributes),
    StreamingConfiguration: S.optional(ChatStreamingConfiguration),
  }),
).annotations({
  identifier: "NewSessionDetails",
}) as any as S.Schema<NewSessionDetails>;
export interface SourceCampaign {
  CampaignId?: string;
  OutboundRequestId?: string;
}
export const SourceCampaign = S.suspend(() =>
  S.Struct({
    CampaignId: S.optional(S.String),
    OutboundRequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "SourceCampaign",
}) as any as S.Schema<SourceCampaign>;
export type CreatedByInfo =
  | { ConnectUserArn: string; AWSIdentityArn?: never }
  | { ConnectUserArn?: never; AWSIdentityArn: string };
export const CreatedByInfo = S.Union(
  S.Struct({ ConnectUserArn: S.String }),
  S.Struct({ AWSIdentityArn: S.String }),
);
export interface ParticipantConfiguration {
  ResponseMode?: ResponseMode;
}
export const ParticipantConfiguration = S.suspend(() =>
  S.Struct({ ResponseMode: S.optional(ResponseMode) }),
).annotations({
  identifier: "ParticipantConfiguration",
}) as any as S.Schema<ParticipantConfiguration>;
export interface ChatMessage {
  ContentType: string;
  Content: string;
}
export const ChatMessage = S.suspend(() =>
  S.Struct({ ContentType: S.String, Content: S.String }),
).annotations({ identifier: "ChatMessage" }) as any as S.Schema<ChatMessage>;
export interface PersistentChat {
  RehydrationType?: RehydrationType;
  SourceContactId?: string;
}
export const PersistentChat = S.suspend(() =>
  S.Struct({
    RehydrationType: S.optional(RehydrationType),
    SourceContactId: S.optional(S.String),
  }),
).annotations({
  identifier: "PersistentChat",
}) as any as S.Schema<PersistentChat>;
export interface AutoEvaluationConfiguration {
  Enabled: boolean;
}
export const AutoEvaluationConfiguration = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "AutoEvaluationConfiguration",
}) as any as S.Schema<AutoEvaluationConfiguration>;
export interface VoiceRecordingConfiguration {
  VoiceRecordingTrack?: VoiceRecordingTrack;
  IvrRecordingTrack?: IvrRecordingTrack;
}
export const VoiceRecordingConfiguration = S.suspend(() =>
  S.Struct({
    VoiceRecordingTrack: S.optional(VoiceRecordingTrack),
    IvrRecordingTrack: S.optional(IvrRecordingTrack),
  }),
).annotations({
  identifier: "VoiceRecordingConfiguration",
}) as any as S.Schema<VoiceRecordingConfiguration>;
export interface InboundAdditionalRecipients {
  ToAddresses?: EmailAddressInfo[];
  CcAddresses?: EmailAddressInfo[];
}
export const InboundAdditionalRecipients = S.suspend(() =>
  S.Struct({
    ToAddresses: S.optional(EmailAddressRecipientList),
    CcAddresses: S.optional(EmailAddressRecipientList),
  }),
).annotations({
  identifier: "InboundAdditionalRecipients",
}) as any as S.Schema<InboundAdditionalRecipients>;
export interface EmailAttachment {
  FileName: string;
  S3Url: string;
}
export const EmailAttachment = S.suspend(() =>
  S.Struct({ FileName: S.String, S3Url: S.String }),
).annotations({
  identifier: "EmailAttachment",
}) as any as S.Schema<EmailAttachment>;
export type EmailAttachments = EmailAttachment[];
export const EmailAttachments = S.Array(EmailAttachment);
export interface Endpoint {
  Type?: EndpointType;
  Address?: string;
}
export const Endpoint = S.suspend(() =>
  S.Struct({ Type: S.optional(EndpointType), Address: S.optional(S.String) }),
).annotations({ identifier: "Endpoint" }) as any as S.Schema<Endpoint>;
export interface AnswerMachineDetectionConfig {
  EnableAnswerMachineDetection?: boolean;
  AwaitAnswerMachinePrompt?: boolean;
}
export const AnswerMachineDetectionConfig = S.suspend(() =>
  S.Struct({
    EnableAnswerMachineDetection: S.optional(S.Boolean),
    AwaitAnswerMachinePrompt: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "AnswerMachineDetectionConfig",
}) as any as S.Schema<AnswerMachineDetectionConfig>;
export type VideoCapability = "SEND" | (string & {});
export const VideoCapability = S.String;
export type ScreenShareCapability = "SEND" | (string & {});
export const ScreenShareCapability = S.String;
export interface ParticipantCapabilities {
  Video?: VideoCapability;
  ScreenShare?: ScreenShareCapability;
}
export const ParticipantCapabilities = S.suspend(() =>
  S.Struct({
    Video: S.optional(VideoCapability),
    ScreenShare: S.optional(ScreenShareCapability),
  }),
).annotations({
  identifier: "ParticipantCapabilities",
}) as any as S.Schema<ParticipantCapabilities>;
export interface AllowedCapabilities {
  Customer?: ParticipantCapabilities;
  Agent?: ParticipantCapabilities;
}
export const AllowedCapabilities = S.suspend(() =>
  S.Struct({
    Customer: S.optional(ParticipantCapabilities),
    Agent: S.optional(ParticipantCapabilities),
  }),
).annotations({
  identifier: "AllowedCapabilities",
}) as any as S.Schema<AllowedCapabilities>;
export interface DisconnectReason {
  Code?: string;
}
export const DisconnectReason = S.suspend(() =>
  S.Struct({ Code: S.optional(S.String) }),
).annotations({
  identifier: "DisconnectReason",
}) as any as S.Schema<DisconnectReason>;
export type ContactTagMap = { [key: string]: string | undefined };
export const ContactTagMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(S.String),
});
export interface QueueInfoInput {
  Id?: string;
}
export const QueueInfoInput = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String) }),
).annotations({
  identifier: "QueueInfoInput",
}) as any as S.Schema<QueueInfoInput>;
export interface Distribution {
  Region: string;
  Percentage: number;
}
export const Distribution = S.suspend(() =>
  S.Struct({ Region: S.String, Percentage: S.Number }),
).annotations({ identifier: "Distribution" }) as any as S.Schema<Distribution>;
export type DistributionList = Distribution[];
export const DistributionList = S.Array(Distribution);
export interface AgentConfig {
  Distributions: Distribution[];
}
export const AgentConfig = S.suspend(() =>
  S.Struct({ Distributions: DistributionList }),
).annotations({ identifier: "AgentConfig" }) as any as S.Schema<AgentConfig>;
export type SegmentAttributeValueList = SegmentAttributeValue[];
export const SegmentAttributeValueList = S.Array(
  S.suspend(
    (): S.Schema<SegmentAttributeValue, any> => SegmentAttributeValue,
  ).annotations({ identifier: "SegmentAttributeValue" }),
) as any as S.Schema<SegmentAttributeValueList>;
export type EvaluationFormQuestionType =
  | "TEXT"
  | "SINGLESELECT"
  | "NUMERIC"
  | "MULTISELECT"
  | "DATETIME"
  | (string & {});
export const EvaluationFormQuestionType = S.String;
export type ContactState =
  | "INCOMING"
  | "PENDING"
  | "CONNECTING"
  | "CONNECTED"
  | "CONNECTED_ONHOLD"
  | "MISSED"
  | "ERROR"
  | "ENDED"
  | "REJECTED"
  | (string & {});
export const ContactState = S.String;
export type ContactStates = ContactState[];
export const ContactStates = S.Array(ContactState);
export type Comparison = "LT" | (string & {});
export const Comparison = S.String;
export type FilterV2StringConditionComparisonOperator =
  | "NOT_EXISTS"
  | (string & {});
export const FilterV2StringConditionComparisonOperator = S.String;
export type MetricFilterValueList = string[];
export const MetricFilterValueList = S.Array(S.String);
export type DecimalComparisonType =
  | "GREATER_OR_EQUAL"
  | "GREATER"
  | "LESSER_OR_EQUAL"
  | "LESSER"
  | "EQUAL"
  | "NOT_EQUAL"
  | "RANGE"
  | (string & {});
export const DecimalComparisonType = S.String;
export type SearchTextList = string | redacted.Redacted<string>[];
export const SearchTextList = S.Array(SensitiveString);
export type SearchContactsMatchType =
  | "MATCH_ALL"
  | "MATCH_ANY"
  | "MATCH_EXACT"
  | "MATCH_NONE"
  | (string & {});
export const SearchContactsMatchType = S.String;
export type HierarchyGroupIdList = string[];
export const HierarchyGroupIdList = S.Array(S.String);
export type DateComparisonType =
  | "GREATER_THAN"
  | "LESS_THAN"
  | "GREATER_THAN_OR_EQUAL_TO"
  | "LESS_THAN_OR_EQUAL_TO"
  | "EQUAL_TO"
  | (string & {});
export const DateComparisonType = S.String;
export type TargetListType = "PROFICIENCIES" | (string & {});
export const TargetListType = S.String;
export type HierarchyGroupMatchType =
  | "EXACT"
  | "WITH_CHILD_GROUPS"
  | (string & {});
export const HierarchyGroupMatchType = S.String;
export interface ActivateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  EvaluationFormVersion: number;
}
export const ActivateEvaluationFormResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    EvaluationFormVersion: S.Number,
  }),
).annotations({
  identifier: "ActivateEvaluationFormResponse",
}) as any as S.Schema<ActivateEvaluationFormResponse>;
export interface AssociateAnalyticsDataSetResponse {
  DataSetId?: string;
  TargetAccountId?: string;
  ResourceShareId?: string;
  ResourceShareArn?: string;
}
export const AssociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({
    DataSetId: S.optional(S.String),
    TargetAccountId: S.optional(S.String),
    ResourceShareId: S.optional(S.String),
    ResourceShareArn: S.optional(S.String),
  }),
).annotations({
  identifier: "AssociateAnalyticsDataSetResponse",
}) as any as S.Schema<AssociateAnalyticsDataSetResponse>;
export interface AssociateBotRequest {
  InstanceId: string;
  LexBot?: LexBot;
  LexV2Bot?: LexV2Bot;
  ClientToken?: string;
}
export const AssociateBotRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    LexBot: S.optional(LexBot),
    LexV2Bot: S.optional(LexV2Bot),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/bot" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateBotRequest",
}) as any as S.Schema<AssociateBotRequest>;
export interface AssociateBotResponse {}
export const AssociateBotResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "AssociateBotResponse",
}) as any as S.Schema<AssociateBotResponse>;
export interface AssociateEmailAddressAliasRequest {
  EmailAddressId: string;
  InstanceId: string;
  AliasConfiguration: AliasConfiguration;
  ClientToken?: string;
}
export const AssociateEmailAddressAliasRequest = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.String.pipe(T.HttpLabel("EmailAddressId")),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    AliasConfiguration: AliasConfiguration,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/email-addresses/{InstanceId}/{EmailAddressId}/associate-alias",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateEmailAddressAliasRequest",
}) as any as S.Schema<AssociateEmailAddressAliasRequest>;
export interface AssociateEmailAddressAliasResponse {}
export const AssociateEmailAddressAliasResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateEmailAddressAliasResponse",
}) as any as S.Schema<AssociateEmailAddressAliasResponse>;
export interface AssociateRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  QueueConfigs?: RoutingProfileQueueConfig[];
  ManualAssignmentQueueConfigs?: RoutingProfileManualAssignmentQueueConfig[];
}
export const AssociateRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    QueueConfigs: S.optional(RoutingProfileQueueConfigList),
    ManualAssignmentQueueConfigs: S.optional(
      RoutingProfileManualAssignmentQueueConfigList,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/associate-queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateRoutingProfileQueuesRequest",
}) as any as S.Schema<AssociateRoutingProfileQueuesRequest>;
export interface AssociateRoutingProfileQueuesResponse {}
export const AssociateRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateRoutingProfileQueuesResponse",
}) as any as S.Schema<AssociateRoutingProfileQueuesResponse>;
export interface AssociateSecurityKeyResponse {
  AssociationId?: string;
}
export const AssociateSecurityKeyResponse = S.suspend(() =>
  S.Struct({ AssociationId: S.optional(S.String) }),
).annotations({
  identifier: "AssociateSecurityKeyResponse",
}) as any as S.Schema<AssociateSecurityKeyResponse>;
export interface AssociateSecurityProfilesRequest {
  InstanceId: string;
  SecurityProfiles: SecurityProfileItem[];
  EntityType: EntityType;
  EntityArn: string;
}
export const AssociateSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    SecurityProfiles: SecurityProfiles,
    EntityType: EntityType,
    EntityArn: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/associate-security-profiles/{InstanceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateSecurityProfilesRequest",
}) as any as S.Schema<AssociateSecurityProfilesRequest>;
export interface AssociateSecurityProfilesResponse {}
export const AssociateSecurityProfilesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateSecurityProfilesResponse",
}) as any as S.Schema<AssociateSecurityProfilesResponse>;
export interface AssociateUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  UserProficiencies: UserProficiency[];
}
export const AssociateUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    UserProficiencies: UserProficiencyList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/associate-proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateUserProficienciesRequest",
}) as any as S.Schema<AssociateUserProficienciesRequest>;
export interface AssociateUserProficienciesResponse {}
export const AssociateUserProficienciesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AssociateUserProficienciesResponse",
}) as any as S.Schema<AssociateUserProficienciesResponse>;
export interface BatchCreateDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValue[];
}
export const BatchCreateDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/create",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchCreateDataTableValueRequest",
}) as any as S.Schema<BatchCreateDataTableValueRequest>;
export interface BatchDeleteDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableDeleteValueIdentifier[];
}
export const BatchDeleteDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableDeleteValueIdentifierList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/delete",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchDeleteDataTableValueRequest",
}) as any as S.Schema<BatchDeleteDataTableValueRequest>;
export interface BatchDescribeDataTableValueRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValueIdentifier[];
}
export const BatchDescribeDataTableValueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueIdentifierList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/describe",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchDescribeDataTableValueRequest",
}) as any as S.Schema<BatchDescribeDataTableValueRequest>;
export interface ErrorResult {
  ErrorCode?: string;
  ErrorMessage?: string;
}
export const ErrorResult = S.suspend(() =>
  S.Struct({
    ErrorCode: S.optional(S.String),
    ErrorMessage: S.optional(S.String),
  }),
).annotations({ identifier: "ErrorResult" }) as any as S.Schema<ErrorResult>;
export type ErrorResults = ErrorResult[];
export const ErrorResults = S.Array(ErrorResult);
export interface BatchDisassociateAnalyticsDataSetResponse {
  Deleted?: string[];
  Errors?: ErrorResult[];
}
export const BatchDisassociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({
    Deleted: S.optional(DataSetIds),
    Errors: S.optional(ErrorResults),
  }),
).annotations({
  identifier: "BatchDisassociateAnalyticsDataSetResponse",
}) as any as S.Schema<BatchDisassociateAnalyticsDataSetResponse>;
export interface ClaimPhoneNumberRequest {
  TargetArn?: string;
  InstanceId?: string;
  PhoneNumber: string;
  PhoneNumberDescription?: string;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
}
export const ClaimPhoneNumberRequest = S.suspend(() =>
  S.Struct({
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    PhoneNumber: S.String,
    PhoneNumberDescription: S.optional(S.String),
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/phone-number/claim" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ClaimPhoneNumberRequest",
}) as any as S.Schema<ClaimPhoneNumberRequest>;
export interface CreateAgentStatusResponse {
  AgentStatusARN?: string;
  AgentStatusId?: string;
}
export const CreateAgentStatusResponse = S.suspend(() =>
  S.Struct({
    AgentStatusARN: S.optional(S.String),
    AgentStatusId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateAgentStatusResponse",
}) as any as S.Schema<CreateAgentStatusResponse>;
export interface CreateContactFlowResponse {
  ContactFlowId?: string;
  ContactFlowArn?: string;
  FlowContentSha256?: string;
}
export const CreateContactFlowResponse = S.suspend(() =>
  S.Struct({
    ContactFlowId: S.optional(S.String),
    ContactFlowArn: S.optional(S.String),
    FlowContentSha256: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateContactFlowResponse",
}) as any as S.Schema<CreateContactFlowResponse>;
export interface CreateContactFlowModuleRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  Content: string;
  Tags?: { [key: string]: string | undefined };
  ClientToken?: string;
  Settings?: string;
  ExternalInvocationConfiguration?: ExternalInvocationConfiguration;
}
export const CreateContactFlowModuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    Content: S.String,
    Tags: S.optional(TagMap),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Settings: S.optional(S.String),
    ExternalInvocationConfiguration: S.optional(
      ExternalInvocationConfiguration,
    ),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact-flow-modules/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateContactFlowModuleRequest",
}) as any as S.Schema<CreateContactFlowModuleRequest>;
export interface CreateContactFlowModuleAliasResponse {
  ContactFlowModuleArn?: string;
  Id?: string;
}
export const CreateContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleArn: S.optional(S.String),
    Id: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateContactFlowModuleAliasResponse",
}) as any as S.Schema<CreateContactFlowModuleAliasResponse>;
export interface CreateContactFlowModuleVersionResponse {
  ContactFlowModuleArn?: string;
  Version?: number;
}
export const CreateContactFlowModuleVersionResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleArn: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotations({
  identifier: "CreateContactFlowModuleVersionResponse",
}) as any as S.Schema<CreateContactFlowModuleVersionResponse>;
export interface CreateContactFlowVersionResponse {
  ContactFlowArn?: string;
  Version?: number;
}
export const CreateContactFlowVersionResponse = S.suspend(() =>
  S.Struct({
    ContactFlowArn: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotations({
  identifier: "CreateContactFlowVersionResponse",
}) as any as S.Schema<CreateContactFlowVersionResponse>;
export interface CreateDataTableResponse {
  Id: string;
  Arn: string;
  LockVersion: DataTableLockVersion;
}
export const CreateDataTableResponse = S.suspend(() =>
  S.Struct({ Id: S.String, Arn: S.String, LockVersion: DataTableLockVersion }),
).annotations({
  identifier: "CreateDataTableResponse",
}) as any as S.Schema<CreateDataTableResponse>;
export interface CreateEmailAddressResponse {
  EmailAddressId?: string;
  EmailAddressArn?: string;
}
export const CreateEmailAddressResponse = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateEmailAddressResponse",
}) as any as S.Schema<CreateEmailAddressResponse>;
export interface CreateInstanceResponse {
  Id?: string;
  Arn?: string;
}
export const CreateInstanceResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "CreateInstanceResponse",
}) as any as S.Schema<CreateInstanceResponse>;
export interface CreateIntegrationAssociationResponse {
  IntegrationAssociationId?: string;
  IntegrationAssociationArn?: string;
}
export const CreateIntegrationAssociationResponse = S.suspend(() =>
  S.Struct({
    IntegrationAssociationId: S.optional(S.String),
    IntegrationAssociationArn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateIntegrationAssociationResponse",
}) as any as S.Schema<CreateIntegrationAssociationResponse>;
export interface CreatePersistentContactAssociationResponse {
  ContinuedFromContactId?: string;
}
export const CreatePersistentContactAssociationResponse = S.suspend(() =>
  S.Struct({ ContinuedFromContactId: S.optional(S.String) }),
).annotations({
  identifier: "CreatePersistentContactAssociationResponse",
}) as any as S.Schema<CreatePersistentContactAssociationResponse>;
export interface CreatePredefinedAttributeRequest {
  InstanceId: string;
  Name: string;
  Values?: PredefinedAttributeValues;
  Purposes?: string[];
  AttributeConfiguration?: InputPredefinedAttributeConfiguration;
}
export const CreatePredefinedAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Values: S.optional(PredefinedAttributeValues),
    Purposes: S.optional(PredefinedAttributePurposeNameList),
    AttributeConfiguration: S.optional(InputPredefinedAttributeConfiguration),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/predefined-attributes/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreatePredefinedAttributeRequest",
}) as any as S.Schema<CreatePredefinedAttributeRequest>;
export interface CreatePredefinedAttributeResponse {}
export const CreatePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "CreatePredefinedAttributeResponse",
}) as any as S.Schema<CreatePredefinedAttributeResponse>;
export interface CreatePromptResponse {
  PromptARN?: string;
  PromptId?: string;
}
export const CreatePromptResponse = S.suspend(() =>
  S.Struct({ PromptARN: S.optional(S.String), PromptId: S.optional(S.String) }),
).annotations({
  identifier: "CreatePromptResponse",
}) as any as S.Schema<CreatePromptResponse>;
export interface CreatePushNotificationRegistrationRequest {
  InstanceId: string;
  ClientToken?: string;
  PinpointAppArn: string;
  DeviceToken: string;
  DeviceType: DeviceType;
  ContactConfiguration: ContactConfiguration;
}
export const CreatePushNotificationRegistrationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    PinpointAppArn: S.String,
    DeviceToken: S.String,
    DeviceType: DeviceType,
    ContactConfiguration: ContactConfiguration,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/push-notification/{InstanceId}/registrations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreatePushNotificationRegistrationRequest",
}) as any as S.Schema<CreatePushNotificationRegistrationRequest>;
export interface CreateQueueRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  OutboundCallerConfig?: OutboundCallerConfig;
  OutboundEmailConfig?: OutboundEmailConfig;
  HoursOfOperationId: string;
  MaxContacts?: number;
  QuickConnectIds?: string[];
  Tags?: { [key: string]: string | undefined };
}
export const CreateQueueRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    OutboundCallerConfig: S.optional(OutboundCallerConfig),
    OutboundEmailConfig: S.optional(OutboundEmailConfig),
    HoursOfOperationId: S.String,
    MaxContacts: S.optional(S.Number),
    QuickConnectIds: S.optional(QuickConnectsList),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/queues/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateQueueRequest",
}) as any as S.Schema<CreateQueueRequest>;
export interface CreateTrafficDistributionGroupResponse {
  Id?: string;
  Arn?: string;
}
export const CreateTrafficDistributionGroupResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "CreateTrafficDistributionGroupResponse",
}) as any as S.Schema<CreateTrafficDistributionGroupResponse>;
export interface CreateUseCaseResponse {
  UseCaseId?: string;
  UseCaseArn?: string;
}
export const CreateUseCaseResponse = S.suspend(() =>
  S.Struct({
    UseCaseId: S.optional(S.String),
    UseCaseArn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateUseCaseResponse",
}) as any as S.Schema<CreateUseCaseResponse>;
export interface CreateUserRequest {
  Username: string;
  Password?: string | redacted.Redacted<string>;
  IdentityInfo?: UserIdentityInfo;
  PhoneConfig: UserPhoneConfig;
  DirectoryUserId?: string;
  SecurityProfileIds: string[];
  RoutingProfileId: string;
  HierarchyGroupId?: string;
  InstanceId: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateUserRequest = S.suspend(() =>
  S.Struct({
    Username: S.String,
    Password: S.optional(SensitiveString),
    IdentityInfo: S.optional(UserIdentityInfo),
    PhoneConfig: UserPhoneConfig,
    DirectoryUserId: S.optional(S.String),
    SecurityProfileIds: SecurityProfileIds,
    RoutingProfileId: S.String,
    HierarchyGroupId: S.optional(S.String),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/users/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateUserRequest",
}) as any as S.Schema<CreateUserRequest>;
export interface CreateUserHierarchyGroupResponse {
  HierarchyGroupId?: string;
  HierarchyGroupArn?: string;
}
export const CreateUserHierarchyGroupResponse = S.suspend(() =>
  S.Struct({
    HierarchyGroupId: S.optional(S.String),
    HierarchyGroupArn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateUserHierarchyGroupResponse",
}) as any as S.Schema<CreateUserHierarchyGroupResponse>;
export interface CreateViewRequest {
  InstanceId: string;
  ClientToken?: string;
  Status: ViewStatus;
  Content: ViewInputContent;
  Description?: string;
  Name: string | redacted.Redacted<string>;
  Tags?: { [key: string]: string | undefined };
}
export const CreateViewRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ClientToken: S.optional(S.String),
    Status: ViewStatus,
    Content: ViewInputContent,
    Description: S.optional(S.String),
    Name: SensitiveString,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/views/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateViewRequest",
}) as any as S.Schema<CreateViewRequest>;
export interface CreateVocabularyResponse {
  VocabularyArn: string;
  VocabularyId: string;
  State: VocabularyState;
}
export const CreateVocabularyResponse = S.suspend(() =>
  S.Struct({
    VocabularyArn: S.String,
    VocabularyId: S.String,
    State: VocabularyState,
  }),
).annotations({
  identifier: "CreateVocabularyResponse",
}) as any as S.Schema<CreateVocabularyResponse>;
export interface DeactivateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  EvaluationFormVersion: number;
}
export const DeactivateEvaluationFormResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    EvaluationFormVersion: S.Number,
  }),
).annotations({
  identifier: "DeactivateEvaluationFormResponse",
}) as any as S.Schema<DeactivateEvaluationFormResponse>;
export interface DeleteDataTableAttributeResponse {
  LockVersion: DataTableLockVersion;
}
export const DeleteDataTableAttributeResponse = S.suspend(() =>
  S.Struct({ LockVersion: DataTableLockVersion }),
).annotations({
  identifier: "DeleteDataTableAttributeResponse",
}) as any as S.Schema<DeleteDataTableAttributeResponse>;
export interface DeleteVocabularyResponse {
  VocabularyArn: string;
  VocabularyId: string;
  State: VocabularyState;
}
export const DeleteVocabularyResponse = S.suspend(() =>
  S.Struct({
    VocabularyArn: S.String,
    VocabularyId: S.String,
    State: VocabularyState,
  }),
).annotations({
  identifier: "DeleteVocabularyResponse",
}) as any as S.Schema<DeleteVocabularyResponse>;
export interface DescribeEmailAddressResponse {
  EmailAddressId?: string;
  EmailAddressArn?: string;
  EmailAddress?: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  CreateTimestamp?: string;
  ModifiedTimestamp?: string;
  AliasConfigurations?: AliasConfiguration[];
  Tags?: { [key: string]: string | undefined };
}
export const DescribeEmailAddressResponse = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
    EmailAddress: S.optional(SensitiveString),
    DisplayName: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    CreateTimestamp: S.optional(S.String),
    ModifiedTimestamp: S.optional(S.String),
    AliasConfigurations: S.optional(AliasConfigurationList),
    Tags: S.optional(TagMap),
  }),
).annotations({
  identifier: "DescribeEmailAddressResponse",
}) as any as S.Schema<DescribeEmailAddressResponse>;
export interface DescribeInstanceStorageConfigResponse {
  StorageConfig?: InstanceStorageConfig;
}
export const DescribeInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({ StorageConfig: S.optional(InstanceStorageConfig) }),
).annotations({
  identifier: "DescribeInstanceStorageConfigResponse",
}) as any as S.Schema<DescribeInstanceStorageConfigResponse>;
export interface ViewContent {
  InputSchema?: string | redacted.Redacted<string>;
  Template?: string;
  Actions?: string | redacted.Redacted<string>[];
}
export const ViewContent = S.suspend(() =>
  S.Struct({
    InputSchema: S.optional(SensitiveString),
    Template: S.optional(S.String),
    Actions: S.optional(ViewActions),
  }),
).annotations({ identifier: "ViewContent" }) as any as S.Schema<ViewContent>;
export interface View {
  Id?: string;
  Arn?: string;
  Name?: string | redacted.Redacted<string>;
  Status?: ViewStatus;
  Type?: ViewType;
  Description?: string;
  Version?: number;
  VersionDescription?: string;
  Content?: ViewContent;
  Tags?: { [key: string]: string | undefined };
  CreatedTime?: Date;
  LastModifiedTime?: Date;
  ViewContentSha256?: string;
}
export const View = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(SensitiveString),
    Status: S.optional(ViewStatus),
    Type: S.optional(ViewType),
    Description: S.optional(S.String),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
    Content: S.optional(ViewContent),
    Tags: S.optional(TagMap),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ViewContentSha256: S.optional(S.String),
  }),
).annotations({ identifier: "View" }) as any as S.Schema<View>;
export interface DescribeViewResponse {
  View?: View;
}
export const DescribeViewResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotations({
  identifier: "DescribeViewResponse",
}) as any as S.Schema<DescribeViewResponse>;
export interface DisassociateRoutingProfileQueuesRequest {
  InstanceId: string;
  RoutingProfileId: string;
  QueueReferences?: RoutingProfileQueueReference[];
  ManualAssignmentQueueReferences?: RoutingProfileQueueReference[];
}
export const DisassociateRoutingProfileQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    RoutingProfileId: S.String.pipe(T.HttpLabel("RoutingProfileId")),
    QueueReferences: S.optional(RoutingProfileQueueReferenceList),
    ManualAssignmentQueueReferences: S.optional(
      RoutingProfileQueueReferenceList,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/routing-profiles/{InstanceId}/{RoutingProfileId}/disassociate-queues",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateRoutingProfileQueuesRequest",
}) as any as S.Schema<DisassociateRoutingProfileQueuesRequest>;
export interface DisassociateRoutingProfileQueuesResponse {}
export const DisassociateRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateRoutingProfileQueuesResponse",
}) as any as S.Schema<DisassociateRoutingProfileQueuesResponse>;
export interface DisassociateUserProficienciesRequest {
  InstanceId: string;
  UserId: string;
  UserProficiencies: UserProficiencyDisassociate[];
}
export const DisassociateUserProficienciesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    UserId: S.String.pipe(T.HttpLabel("UserId")),
    UserProficiencies: UserProficiencyDisassociateList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/users/{InstanceId}/{UserId}/disassociate-proficiencies",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DisassociateUserProficienciesRequest",
}) as any as S.Schema<DisassociateUserProficienciesRequest>;
export interface DisassociateUserProficienciesResponse {}
export const DisassociateUserProficienciesResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "DisassociateUserProficienciesResponse",
}) as any as S.Schema<DisassociateUserProficienciesResponse>;
export interface SuccessfulBatchAssociationSummary {
  ResourceArn?: string;
}
export const SuccessfulBatchAssociationSummary = S.suspend(() =>
  S.Struct({ ResourceArn: S.optional(S.String) }),
).annotations({
  identifier: "SuccessfulBatchAssociationSummary",
}) as any as S.Schema<SuccessfulBatchAssociationSummary>;
export type SuccessfulBatchAssociationSummaryList =
  SuccessfulBatchAssociationSummary[];
export const SuccessfulBatchAssociationSummaryList = S.Array(
  SuccessfulBatchAssociationSummary,
);
export interface FailedBatchAssociationSummary {
  ResourceArn?: string;
  ErrorCode?: string;
  ErrorMessage?: string;
}
export const FailedBatchAssociationSummary = S.suspend(() =>
  S.Struct({
    ResourceArn: S.optional(S.String),
    ErrorCode: S.optional(S.String),
    ErrorMessage: S.optional(S.String),
  }),
).annotations({
  identifier: "FailedBatchAssociationSummary",
}) as any as S.Schema<FailedBatchAssociationSummary>;
export type FailedBatchAssociationSummaryList = FailedBatchAssociationSummary[];
export const FailedBatchAssociationSummaryList = S.Array(
  FailedBatchAssociationSummary,
);
export interface DisassociateWorkspaceResponse {
  SuccessfulList?: SuccessfulBatchAssociationSummary[];
  FailedList?: FailedBatchAssociationSummary[];
}
export const DisassociateWorkspaceResponse = S.suspend(() =>
  S.Struct({
    SuccessfulList: S.optional(SuccessfulBatchAssociationSummaryList),
    FailedList: S.optional(FailedBatchAssociationSummaryList),
  }),
).annotations({
  identifier: "DisassociateWorkspaceResponse",
}) as any as S.Schema<DisassociateWorkspaceResponse>;
export interface EvaluateDataTableValuesRequest {
  InstanceId: string;
  DataTableId: string;
  Values: DataTableValueEvaluationSet[];
  TimeZone?: string;
  NextToken?: string;
  MaxResults?: number;
}
export const EvaluateDataTableValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Values: DataTableValueEvaluationSetList,
    TimeZone: S.optional(S.String),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/evaluate",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "EvaluateDataTableValuesRequest",
}) as any as S.Schema<EvaluateDataTableValuesRequest>;
export interface GetContactAttributesResponse {
  Attributes?: { [key: string]: string | undefined };
}
export const GetContactAttributesResponse = S.suspend(() =>
  S.Struct({ Attributes: S.optional(Attributes) }),
).annotations({
  identifier: "GetContactAttributesResponse",
}) as any as S.Schema<GetContactAttributesResponse>;
export interface GetContactMetricsRequest {
  InstanceId: string;
  ContactId: string;
  Metrics: ContactMetricInfo[];
}
export const GetContactMetricsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    Metrics: ContactMetrics,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/contact" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetContactMetricsRequest",
}) as any as S.Schema<GetContactMetricsRequest>;
export interface GetCurrentMetricDataRequest {
  InstanceId: string;
  Filters: Filters;
  Groupings?: Grouping[];
  CurrentMetrics: CurrentMetric[];
  NextToken?: string;
  MaxResults?: number;
  SortCriteria?: CurrentMetricSortCriteria[];
}
export const GetCurrentMetricDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Filters: Filters,
    Groupings: S.optional(Groupings),
    CurrentMetrics: CurrentMetrics,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SortCriteria: S.optional(CurrentMetricSortCriteriaMaxOne),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/current/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetCurrentMetricDataRequest",
}) as any as S.Schema<GetCurrentMetricDataRequest>;
export interface GetFlowAssociationResponse {
  ResourceId?: string;
  FlowId?: string;
  ResourceType?: FlowAssociationResourceType;
}
export const GetFlowAssociationResponse = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String),
    FlowId: S.optional(S.String),
    ResourceType: S.optional(FlowAssociationResourceType),
  }),
).annotations({
  identifier: "GetFlowAssociationResponse",
}) as any as S.Schema<GetFlowAssociationResponse>;
export interface GetPromptFileResponse {
  PromptPresignedUrl?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const GetPromptFileResponse = S.suspend(() =>
  S.Struct({
    PromptPresignedUrl: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "GetPromptFileResponse",
}) as any as S.Schema<GetPromptFileResponse>;
export interface GetTaskTemplateResponse {
  InstanceId?: string;
  Id: string;
  Arn: string;
  Name: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Fields?: TaskTemplateField[];
  Status?: TaskTemplateStatus;
  LastModifiedTime?: Date;
  CreatedTime?: Date;
  Tags?: { [key: string]: string | undefined };
}
export const GetTaskTemplateResponse = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Id: S.String,
    Arn: S.String,
    Name: S.String,
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Fields: S.optional(TaskTemplateFields),
    Status: S.optional(TaskTemplateStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Tags: S.optional(TagMap),
  }),
).annotations({
  identifier: "GetTaskTemplateResponse",
}) as any as S.Schema<GetTaskTemplateResponse>;
export interface TelephonyConfig {
  Distributions: Distribution[];
}
export const TelephonyConfig = S.suspend(() =>
  S.Struct({ Distributions: DistributionList }),
).annotations({
  identifier: "TelephonyConfig",
}) as any as S.Schema<TelephonyConfig>;
export interface SignInDistribution {
  Region: string;
  Enabled: boolean;
}
export const SignInDistribution = S.suspend(() =>
  S.Struct({ Region: S.String, Enabled: S.Boolean }),
).annotations({
  identifier: "SignInDistribution",
}) as any as S.Schema<SignInDistribution>;
export type SignInDistributionList = SignInDistribution[];
export const SignInDistributionList = S.Array(SignInDistribution);
export interface SignInConfig {
  Distributions: SignInDistribution[];
}
export const SignInConfig = S.suspend(() =>
  S.Struct({ Distributions: SignInDistributionList }),
).annotations({ identifier: "SignInConfig" }) as any as S.Schema<SignInConfig>;
export interface GetTrafficDistributionResponse {
  TelephonyConfig?: TelephonyConfig;
  Id?: string;
  Arn?: string;
  SignInConfig?: SignInConfig;
  AgentConfig?: AgentConfig;
}
export const GetTrafficDistributionResponse = S.suspend(() =>
  S.Struct({
    TelephonyConfig: S.optional(TelephonyConfig),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    SignInConfig: S.optional(SignInConfig),
    AgentConfig: S.optional(AgentConfig),
  }),
).annotations({
  identifier: "GetTrafficDistributionResponse",
}) as any as S.Schema<GetTrafficDistributionResponse>;
export interface ImportPhoneNumberResponse {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
}
export const ImportPhoneNumberResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
  }),
).annotations({
  identifier: "ImportPhoneNumberResponse",
}) as any as S.Schema<ImportPhoneNumberResponse>;
export interface AnalyticsDataAssociationResult {
  DataSetId?: string;
  TargetAccountId?: string;
  ResourceShareId?: string;
  ResourceShareArn?: string;
  ResourceShareStatus?: string;
}
export const AnalyticsDataAssociationResult = S.suspend(() =>
  S.Struct({
    DataSetId: S.optional(S.String),
    TargetAccountId: S.optional(S.String),
    ResourceShareId: S.optional(S.String),
    ResourceShareArn: S.optional(S.String),
    ResourceShareStatus: S.optional(S.String),
  }),
).annotations({
  identifier: "AnalyticsDataAssociationResult",
}) as any as S.Schema<AnalyticsDataAssociationResult>;
export type AnalyticsDataAssociationResults = AnalyticsDataAssociationResult[];
export const AnalyticsDataAssociationResults = S.Array(
  AnalyticsDataAssociationResult,
);
export interface ListAnalyticsDataAssociationsResponse {
  Results?: AnalyticsDataAssociationResult[];
  NextToken?: string;
}
export const ListAnalyticsDataAssociationsResponse = S.suspend(() =>
  S.Struct({
    Results: S.optional(AnalyticsDataAssociationResults),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListAnalyticsDataAssociationsResponse",
}) as any as S.Schema<ListAnalyticsDataAssociationsResponse>;
export interface ListApprovedOriginsResponse {
  Origins?: string[];
  NextToken?: string;
}
export const ListApprovedOriginsResponse = S.suspend(() =>
  S.Struct({
    Origins: S.optional(OriginsList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListApprovedOriginsResponse",
}) as any as S.Schema<ListApprovedOriginsResponse>;
export interface ListDataTableAttributesResponse {
  NextToken?: string;
  Attributes: DataTableAttribute[];
}
export const ListDataTableAttributesResponse = S.suspend(() =>
  S.Struct({ NextToken: S.optional(S.String), Attributes: AttributeList }),
).annotations({
  identifier: "ListDataTableAttributesResponse",
}) as any as S.Schema<ListDataTableAttributesResponse>;
export interface ListDataTablePrimaryValuesRequest {
  InstanceId: string;
  DataTableId: string;
  RecordIds?: string[];
  PrimaryAttributeValues?: PrimaryAttributeValueFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataTablePrimaryValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    RecordIds: S.optional(RecordIds),
    PrimaryAttributeValues: S.optional(PrimaryAttributeValueFilters),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("nextToken")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("maxResults")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/list-primary",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDataTablePrimaryValuesRequest",
}) as any as S.Schema<ListDataTablePrimaryValuesRequest>;
export interface ListEntitySecurityProfilesResponse {
  SecurityProfiles?: SecurityProfileItem[];
  NextToken?: string;
}
export const ListEntitySecurityProfilesResponse = S.suspend(() =>
  S.Struct({
    SecurityProfiles: S.optional(SecurityProfiles100),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListEntitySecurityProfilesResponse",
}) as any as S.Schema<ListEntitySecurityProfilesResponse>;
export interface FlowAssociationSummary {
  ResourceId?: string;
  FlowId?: string;
  ResourceType?: ListFlowAssociationResourceType;
}
export const FlowAssociationSummary = S.suspend(() =>
  S.Struct({
    ResourceId: S.optional(S.String),
    FlowId: S.optional(S.String),
    ResourceType: S.optional(ListFlowAssociationResourceType),
  }),
).annotations({
  identifier: "FlowAssociationSummary",
}) as any as S.Schema<FlowAssociationSummary>;
export type FlowAssociationSummaryList = FlowAssociationSummary[];
export const FlowAssociationSummaryList = S.Array(FlowAssociationSummary);
export interface ListFlowAssociationsResponse {
  FlowAssociationSummaryList?: FlowAssociationSummary[];
  NextToken?: string;
}
export const ListFlowAssociationsResponse = S.suspend(() =>
  S.Struct({
    FlowAssociationSummaryList: S.optional(FlowAssociationSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListFlowAssociationsResponse",
}) as any as S.Schema<ListFlowAssociationsResponse>;
export interface ListHoursOfOperationOverridesResponse {
  NextToken?: string;
  HoursOfOperationOverrideList?: HoursOfOperationOverride[];
  LastModifiedRegion?: string;
  LastModifiedTime?: Date;
}
export const ListHoursOfOperationOverridesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    HoursOfOperationOverrideList: S.optional(HoursOfOperationOverrideList),
    LastModifiedRegion: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "ListHoursOfOperationOverridesResponse",
}) as any as S.Schema<ListHoursOfOperationOverridesResponse>;
export interface ListInstanceAttributesResponse {
  Attributes?: Attribute[];
  NextToken?: string;
}
export const ListInstanceAttributesResponse = S.suspend(() =>
  S.Struct({
    Attributes: S.optional(AttributesList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListInstanceAttributesResponse",
}) as any as S.Schema<ListInstanceAttributesResponse>;
export interface ListInstanceStorageConfigsResponse {
  StorageConfigs?: InstanceStorageConfig[];
  NextToken?: string;
}
export const ListInstanceStorageConfigsResponse = S.suspend(() =>
  S.Struct({
    StorageConfigs: S.optional(InstanceStorageConfigs),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListInstanceStorageConfigsResponse",
}) as any as S.Schema<ListInstanceStorageConfigsResponse>;
export interface ListLambdaFunctionsResponse {
  LambdaFunctions?: string[];
  NextToken?: string;
}
export const ListLambdaFunctionsResponse = S.suspend(() =>
  S.Struct({
    LambdaFunctions: S.optional(FunctionArnsList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListLambdaFunctionsResponse",
}) as any as S.Schema<ListLambdaFunctionsResponse>;
export interface ListLexBotsResponse {
  LexBots?: LexBot[];
  NextToken?: string;
}
export const ListLexBotsResponse = S.suspend(() =>
  S.Struct({
    LexBots: S.optional(LexBotsList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListLexBotsResponse",
}) as any as S.Schema<ListLexBotsResponse>;
export interface QuickConnectSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  QuickConnectType?: QuickConnectType;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const QuickConnectSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    QuickConnectType: S.optional(QuickConnectType),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "QuickConnectSummary",
}) as any as S.Schema<QuickConnectSummary>;
export type QuickConnectSummaryList = QuickConnectSummary[];
export const QuickConnectSummaryList = S.Array(QuickConnectSummary);
export interface ListQuickConnectsResponse {
  QuickConnectSummaryList?: QuickConnectSummary[];
  NextToken?: string;
}
export const ListQuickConnectsResponse = S.suspend(() =>
  S.Struct({
    QuickConnectSummaryList: S.optional(QuickConnectSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListQuickConnectsResponse",
}) as any as S.Schema<ListQuickConnectsResponse>;
export interface ListSecurityProfileApplicationsResponse {
  Applications?: Application[];
  NextToken?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListSecurityProfileApplicationsResponse = S.suspend(() =>
  S.Struct({
    Applications: S.optional(Applications),
    NextToken: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "ListSecurityProfileApplicationsResponse",
}) as any as S.Schema<ListSecurityProfileApplicationsResponse>;
export interface ListSecurityProfileFlowModulesResponse {
  AllowedFlowModules?: FlowModule[];
  NextToken?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListSecurityProfileFlowModulesResponse = S.suspend(() =>
  S.Struct({
    AllowedFlowModules: S.optional(AllowedFlowModules),
    NextToken: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "ListSecurityProfileFlowModulesResponse",
}) as any as S.Schema<ListSecurityProfileFlowModulesResponse>;
export interface ListSecurityProfilePermissionsResponse {
  Permissions?: string[];
  NextToken?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListSecurityProfilePermissionsResponse = S.suspend(() =>
  S.Struct({
    Permissions: S.optional(PermissionsList),
    NextToken: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "ListSecurityProfilePermissionsResponse",
}) as any as S.Schema<ListSecurityProfilePermissionsResponse>;
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | undefined };
}
export const ListTagsForResourceResponse = S.suspend(() =>
  S.Struct({ tags: S.optional(TagMap) }),
).annotations({
  identifier: "ListTagsForResourceResponse",
}) as any as S.Schema<ListTagsForResourceResponse>;
export interface ListUserProficienciesResponse {
  NextToken?: string;
  UserProficiencyList?: UserProficiency[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListUserProficienciesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    UserProficiencyList: S.optional(UserProficiencyList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "ListUserProficienciesResponse",
}) as any as S.Schema<ListUserProficienciesResponse>;
export interface MonitorContactResponse {
  ContactId?: string;
  ContactArn?: string;
}
export const MonitorContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
  }),
).annotations({
  identifier: "MonitorContactResponse",
}) as any as S.Schema<MonitorContactResponse>;
export interface ReplicateInstanceResponse {
  Id?: string;
  Arn?: string;
}
export const ReplicateInstanceResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "ReplicateInstanceResponse",
}) as any as S.Schema<ReplicateInstanceResponse>;
export interface SearchDataTablesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: DataTableSearchFilter;
  SearchCriteria?: DataTableSearchCriteria;
}
export const SearchDataTablesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(DataTableSearchFilter),
    SearchCriteria: S.optional(DataTableSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-data-tables" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchDataTablesRequest",
}) as any as S.Schema<SearchDataTablesRequest>;
export interface SearchEmailAddressesRequest {
  InstanceId: string;
  MaxResults?: number;
  NextToken?: string;
  SearchCriteria?: EmailAddressSearchCriteria;
  SearchFilter?: EmailAddressSearchFilter;
}
export const SearchEmailAddressesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    SearchCriteria: S.optional(EmailAddressSearchCriteria),
    SearchFilter: S.optional(EmailAddressSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-email-addresses" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchEmailAddressesRequest",
}) as any as S.Schema<SearchEmailAddressesRequest>;
export interface SearchEvaluationFormsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: EvaluationFormSearchCriteria;
  SearchFilter?: EvaluationFormSearchFilter;
}
export const SearchEvaluationFormsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(EvaluationFormSearchCriteria),
    SearchFilter: S.optional(EvaluationFormSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-evaluation-forms" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchEvaluationFormsRequest",
}) as any as S.Schema<SearchEvaluationFormsRequest>;
export interface SearchHoursOfOperationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: HoursOfOperationSearchFilter;
  SearchCriteria?: HoursOfOperationSearchCriteria;
}
export const SearchHoursOfOperationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(HoursOfOperationSearchFilter),
    SearchCriteria: S.optional(HoursOfOperationSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-hours-of-operations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchHoursOfOperationsRequest",
}) as any as S.Schema<SearchHoursOfOperationsRequest>;
export interface SearchPredefinedAttributesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: PredefinedAttributeSearchCriteria;
}
export const SearchPredefinedAttributesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(PredefinedAttributeSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-predefined-attributes" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchPredefinedAttributesRequest",
}) as any as S.Schema<SearchPredefinedAttributesRequest>;
export interface SearchPromptsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: PromptSearchFilter;
  SearchCriteria?: PromptSearchCriteria;
}
export const SearchPromptsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(PromptSearchFilter),
    SearchCriteria: S.optional(PromptSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-prompts" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchPromptsRequest",
}) as any as S.Schema<SearchPromptsRequest>;
export interface SearchQueuesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: QueueSearchFilter;
  SearchCriteria?: QueueSearchCriteria;
}
export const SearchQueuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(QueueSearchFilter),
    SearchCriteria: S.optional(QueueSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-queues" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchQueuesRequest",
}) as any as S.Schema<SearchQueuesRequest>;
export interface SearchQuickConnectsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: QuickConnectSearchFilter;
  SearchCriteria?: QuickConnectSearchCriteria;
}
export const SearchQuickConnectsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(QuickConnectSearchFilter),
    SearchCriteria: S.optional(QuickConnectSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-quick-connects" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchQuickConnectsRequest",
}) as any as S.Schema<SearchQuickConnectsRequest>;
export interface SearchRoutingProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: RoutingProfileSearchFilter;
  SearchCriteria?: RoutingProfileSearchCriteria;
}
export const SearchRoutingProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(RoutingProfileSearchFilter),
    SearchCriteria: S.optional(RoutingProfileSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-routing-profiles" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchRoutingProfilesRequest",
}) as any as S.Schema<SearchRoutingProfilesRequest>;
export interface SearchSecurityProfilesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: SecurityProfileSearchCriteria;
  SearchFilter?: SecurityProfilesSearchFilter;
}
export const SearchSecurityProfilesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(SecurityProfileSearchCriteria),
    SearchFilter: S.optional(SecurityProfilesSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-security-profiles" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchSecurityProfilesRequest",
}) as any as S.Schema<SearchSecurityProfilesRequest>;
export interface SearchUserHierarchyGroupsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: UserHierarchyGroupSearchFilter;
  SearchCriteria?: UserHierarchyGroupSearchCriteria;
}
export const SearchUserHierarchyGroupsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(UserHierarchyGroupSearchFilter),
    SearchCriteria: S.optional(UserHierarchyGroupSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-user-hierarchy-groups" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchUserHierarchyGroupsRequest",
}) as any as S.Schema<SearchUserHierarchyGroupsRequest>;
export interface SearchViewsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: ViewSearchFilter;
  SearchCriteria?: ViewSearchCriteria;
}
export const SearchViewsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(ViewSearchFilter),
    SearchCriteria: S.optional(ViewSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-views" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchViewsRequest",
}) as any as S.Schema<SearchViewsRequest>;
export interface SearchWorkspaceAssociationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: WorkspaceAssociationSearchFilter;
  SearchCriteria?: WorkspaceAssociationSearchCriteria;
}
export const SearchWorkspaceAssociationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(WorkspaceAssociationSearchFilter),
    SearchCriteria: S.optional(WorkspaceAssociationSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-workspace-associations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchWorkspaceAssociationsRequest",
}) as any as S.Schema<SearchWorkspaceAssociationsRequest>;
export interface SearchWorkspacesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: WorkspaceSearchFilter;
  SearchCriteria?: WorkspaceSearchCriteria;
}
export const SearchWorkspacesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(WorkspaceSearchFilter),
    SearchCriteria: S.optional(WorkspaceSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-workspaces" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchWorkspacesRequest",
}) as any as S.Schema<SearchWorkspacesRequest>;
export interface SendChatIntegrationEventRequest {
  SourceId: string;
  DestinationId: string;
  Subtype?: string;
  Event: ChatEvent;
  NewSessionDetails?: NewSessionDetails;
}
export const SendChatIntegrationEventRequest = S.suspend(() =>
  S.Struct({
    SourceId: S.String,
    DestinationId: S.String,
    Subtype: S.optional(S.String),
    Event: ChatEvent,
    NewSessionDetails: S.optional(NewSessionDetails),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/chat-integration-event" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SendChatIntegrationEventRequest",
}) as any as S.Schema<SendChatIntegrationEventRequest>;
export interface StartAttachedFileUploadRequest {
  ClientToken?: string;
  InstanceId: string;
  FileName: string;
  FileSizeInBytes: number;
  UrlExpiryInSeconds?: number;
  FileUseCaseType: FileUseCaseType;
  AssociatedResourceArn: string;
  CreatedBy?: CreatedByInfo;
  Tags?: { [key: string]: string | undefined };
}
export const StartAttachedFileUploadRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FileName: S.String,
    FileSizeInBytes: S.Number,
    UrlExpiryInSeconds: S.optional(S.Number),
    FileUseCaseType: FileUseCaseType,
    AssociatedResourceArn: S.String.pipe(T.HttpQuery("associatedResourceArn")),
    CreatedBy: S.optional(CreatedByInfo),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/attached-files/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartAttachedFileUploadRequest",
}) as any as S.Schema<StartAttachedFileUploadRequest>;
export interface StartChatContactRequest {
  InstanceId: string;
  ContactFlowId: string;
  Attributes?: { [key: string]: string | undefined };
  ParticipantDetails: ParticipantDetails;
  ParticipantConfiguration?: ParticipantConfiguration;
  InitialMessage?: ChatMessage;
  ClientToken?: string;
  ChatDurationInMinutes?: number;
  SupportedMessagingContentTypes?: string[];
  PersistentChat?: PersistentChat;
  RelatedContactId?: string;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  CustomerId?: string | redacted.Redacted<string>;
  DisconnectOnCustomerExit?: DisconnectOnCustomerExitParticipantType[];
}
export const StartChatContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactFlowId: S.String,
    Attributes: S.optional(Attributes),
    ParticipantDetails: ParticipantDetails,
    ParticipantConfiguration: S.optional(ParticipantConfiguration),
    InitialMessage: S.optional(ChatMessage),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ChatDurationInMinutes: S.optional(S.Number),
    SupportedMessagingContentTypes: S.optional(SupportedMessagingContentTypes),
    PersistentChat: S.optional(PersistentChat),
    RelatedContactId: S.optional(S.String),
    SegmentAttributes: S.optional(SegmentAttributes),
    CustomerId: S.optional(SensitiveString),
    DisconnectOnCustomerExit: S.optional(DisconnectOnCustomerExit),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/chat" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartChatContactRequest",
}) as any as S.Schema<StartChatContactRequest>;
export interface StartContactEvaluationRequest {
  InstanceId: string;
  ContactId: string;
  EvaluationFormId: string;
  AutoEvaluationConfiguration?: AutoEvaluationConfiguration;
  ClientToken?: string;
  Tags?: { [key: string]: string | undefined };
}
export const StartContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String,
    EvaluationFormId: S.String,
    AutoEvaluationConfiguration: S.optional(AutoEvaluationConfiguration),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact-evaluations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartContactEvaluationRequest",
}) as any as S.Schema<StartContactEvaluationRequest>;
export interface StartContactRecordingRequest {
  InstanceId: string;
  ContactId: string;
  InitialContactId: string;
  VoiceRecordingConfiguration: VoiceRecordingConfiguration;
}
export const StartContactRecordingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    InitialContactId: S.String,
    VoiceRecordingConfiguration: VoiceRecordingConfiguration,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/start-recording" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartContactRecordingRequest",
}) as any as S.Schema<StartContactRecordingRequest>;
export interface StartContactRecordingResponse {}
export const StartContactRecordingResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "StartContactRecordingResponse",
}) as any as S.Schema<StartContactRecordingResponse>;
export interface StartContactStreamingRequest {
  InstanceId: string;
  ContactId: string;
  ChatStreamingConfiguration: ChatStreamingConfiguration;
  ClientToken: string;
}
export const StartContactStreamingRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    ChatStreamingConfiguration: ChatStreamingConfiguration,
    ClientToken: S.String.pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/start-streaming" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartContactStreamingRequest",
}) as any as S.Schema<StartContactStreamingRequest>;
export interface StartOutboundEmailContactResponse {
  ContactId?: string;
}
export const StartOutboundEmailContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotations({
  identifier: "StartOutboundEmailContactResponse",
}) as any as S.Schema<StartOutboundEmailContactResponse>;
export interface StartTaskContactResponse {
  ContactId?: string;
}
export const StartTaskContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotations({
  identifier: "StartTaskContactResponse",
}) as any as S.Schema<StartTaskContactResponse>;
export interface StartWebRTCContactRequest {
  Attributes?: { [key: string]: string | undefined };
  ClientToken?: string;
  ContactFlowId: string;
  InstanceId: string;
  AllowedCapabilities?: AllowedCapabilities;
  ParticipantDetails: ParticipantDetails;
  RelatedContactId?: string;
  References?: { [key: string]: Reference | undefined };
  Description?: string | redacted.Redacted<string>;
}
export const StartWebRTCContactRequest = S.suspend(() =>
  S.Struct({
    Attributes: S.optional(Attributes),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ContactFlowId: S.String,
    InstanceId: S.String,
    AllowedCapabilities: S.optional(AllowedCapabilities),
    ParticipantDetails: ParticipantDetails,
    RelatedContactId: S.optional(S.String),
    References: S.optional(ContactReferences),
    Description: S.optional(SensitiveString),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/webrtc" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartWebRTCContactRequest",
}) as any as S.Schema<StartWebRTCContactRequest>;
export interface StopContactRequest {
  ContactId: string;
  InstanceId: string;
  DisconnectReason?: DisconnectReason;
}
export const StopContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    DisconnectReason: S.optional(DisconnectReason),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/stop" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StopContactRequest",
}) as any as S.Schema<StopContactRequest>;
export interface StopContactResponse {}
export const StopContactResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "StopContactResponse",
}) as any as S.Schema<StopContactResponse>;
export interface TagContactRequest {
  ContactId: string;
  InstanceId: string;
  Tags: { [key: string]: string | undefined };
}
export const TagContactRequest = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    InstanceId: S.String,
    Tags: ContactTagMap,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/tags" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "TagContactRequest",
}) as any as S.Schema<TagContactRequest>;
export interface TagContactResponse {}
export const TagContactResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "TagContactResponse",
}) as any as S.Schema<TagContactResponse>;
export interface TransferContactResponse {
  ContactId?: string;
  ContactArn?: string;
}
export const TransferContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
  }),
).annotations({
  identifier: "TransferContactResponse",
}) as any as S.Schema<TransferContactResponse>;
export interface UpdateContactRequest {
  InstanceId: string;
  ContactId: string;
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  QueueInfo?: QueueInfoInput;
  UserInfo?: UserInfo;
  CustomerEndpoint?: Endpoint;
  SystemEndpoint?: Endpoint;
}
export const UpdateContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    References: S.optional(ContactReferences),
    SegmentAttributes: S.optional(SegmentAttributes),
    QueueInfo: S.optional(QueueInfoInput),
    UserInfo: S.optional(UserInfo),
    CustomerEndpoint: S.optional(Endpoint),
    SystemEndpoint: S.optional(Endpoint),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contacts/{InstanceId}/{ContactId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactRequest",
}) as any as S.Schema<UpdateContactRequest>;
export interface UpdateContactResponse {}
export const UpdateContactResponse = S.suspend(() => S.Struct({})).annotations({
  identifier: "UpdateContactResponse",
}) as any as S.Schema<UpdateContactResponse>;
export interface UpdateContactEvaluationResponse {
  EvaluationId: string;
  EvaluationArn: string;
}
export const UpdateContactEvaluationResponse = S.suspend(() =>
  S.Struct({ EvaluationId: S.String, EvaluationArn: S.String }),
).annotations({
  identifier: "UpdateContactEvaluationResponse",
}) as any as S.Schema<UpdateContactEvaluationResponse>;
export interface UpdateDataTableAttributeResponse {
  Name: string;
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTableAttributeResponse = S.suspend(() =>
  S.Struct({ Name: S.String, LockVersion: DataTableLockVersion }),
).annotations({
  identifier: "UpdateDataTableAttributeResponse",
}) as any as S.Schema<UpdateDataTableAttributeResponse>;
export interface UpdateDataTableMetadataResponse {
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTableMetadataResponse = S.suspend(() =>
  S.Struct({ LockVersion: DataTableLockVersion }),
).annotations({
  identifier: "UpdateDataTableMetadataResponse",
}) as any as S.Schema<UpdateDataTableMetadataResponse>;
export interface UpdateDataTablePrimaryValuesRequest {
  InstanceId: string;
  DataTableId: string;
  PrimaryValues: PrimaryValue[];
  NewPrimaryValues: PrimaryValue[];
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTablePrimaryValuesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    PrimaryValues: PrimaryValuesSet,
    NewPrimaryValues: PrimaryValuesSet,
    LockVersion: DataTableLockVersion,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/data-tables/{InstanceId}/{DataTableId}/values/update-primary",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDataTablePrimaryValuesRequest",
}) as any as S.Schema<UpdateDataTablePrimaryValuesRequest>;
export interface UpdateEmailAddressMetadataResponse {
  EmailAddressId?: string;
  EmailAddressArn?: string;
}
export const UpdateEmailAddressMetadataResponse = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateEmailAddressMetadataResponse",
}) as any as S.Schema<UpdateEmailAddressMetadataResponse>;
export interface UpdateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  EvaluationFormVersion: number;
}
export const UpdateEvaluationFormResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    EvaluationFormVersion: S.Number,
  }),
).annotations({
  identifier: "UpdateEvaluationFormResponse",
}) as any as S.Schema<UpdateEvaluationFormResponse>;
export interface UpdatePhoneNumberResponse {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
}
export const UpdatePhoneNumberResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdatePhoneNumberResponse",
}) as any as S.Schema<UpdatePhoneNumberResponse>;
export interface UpdatePromptResponse {
  PromptARN?: string;
  PromptId?: string;
}
export const UpdatePromptResponse = S.suspend(() =>
  S.Struct({ PromptARN: S.optional(S.String), PromptId: S.optional(S.String) }),
).annotations({
  identifier: "UpdatePromptResponse",
}) as any as S.Schema<UpdatePromptResponse>;
export interface UpdateTaskTemplateResponse {
  InstanceId?: string;
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Fields?: TaskTemplateField[];
  Status?: TaskTemplateStatus;
  LastModifiedTime?: Date;
  CreatedTime?: Date;
}
export const UpdateTaskTemplateResponse = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Fields: S.optional(TaskTemplateFields),
    Status: S.optional(TaskTemplateStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotations({
  identifier: "UpdateTaskTemplateResponse",
}) as any as S.Schema<UpdateTaskTemplateResponse>;
export interface UpdateViewContentResponse {
  View?: View;
}
export const UpdateViewContentResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotations({
  identifier: "UpdateViewContentResponse",
}) as any as S.Schema<UpdateViewContentResponse>;
export interface Campaign {
  CampaignId?: string;
}
export const Campaign = S.suspend(() =>
  S.Struct({ CampaignId: S.optional(S.String) }),
).annotations({ identifier: "Campaign" }) as any as S.Schema<Campaign>;
export interface EvaluationFormSection {
  Title: string;
  RefId: string;
  Instructions?: string;
  Items: EvaluationFormItem[];
  Weight?: number;
}
export const EvaluationFormSection = S.suspend(() =>
  S.Struct({
    Title: S.String,
    RefId: S.String,
    Instructions: S.optional(S.String),
    Items: S.suspend(() => EvaluationFormItemsList).annotations({
      identifier: "EvaluationFormItemsList",
    }),
    Weight: S.optional(S.Number),
  }),
).annotations({
  identifier: "EvaluationFormSection",
}) as any as S.Schema<EvaluationFormSection>;
export type AnsweringMachineDetectionStatus =
  | "ANSWERED"
  | "UNDETECTED"
  | "ERROR"
  | "HUMAN_ANSWERED"
  | "SIT_TONE_DETECTED"
  | "SIT_TONE_BUSY"
  | "SIT_TONE_INVALID_NUMBER"
  | "FAX_MACHINE_DETECTED"
  | "VOICEMAIL_BEEP"
  | "VOICEMAIL_NO_BEEP"
  | "AMD_UNRESOLVED"
  | "AMD_UNANSWERED"
  | "AMD_ERROR"
  | "AMD_NOT_APPLICABLE"
  | (string & {});
export const AnsweringMachineDetectionStatus = S.String;
export type EvaluationStatus = "DRAFT" | "SUBMITTED" | (string & {});
export const EvaluationStatus = S.String;
export type EvaluationType = "STANDARD" | "CALIBRATION" | (string & {});
export const EvaluationType = S.String;
export type EvaluationFormVersionStatus = "DRAFT" | "ACTIVE" | (string & {});
export const EvaluationFormVersionStatus = S.String;
export type InstanceStatus =
  | "CREATION_IN_PROGRESS"
  | "ACTIVE"
  | "CREATION_FAILED"
  | (string & {});
export const InstanceStatus = S.String;
export type AssociatedQueueIdList = string[];
export const AssociatedQueueIdList = S.Array(S.String);
export type TrafficDistributionGroupStatus =
  | "CREATION_IN_PROGRESS"
  | "ACTIVE"
  | "CREATION_FAILED"
  | "PENDING_DELETION"
  | "DELETION_FAILED"
  | "UPDATE_IN_PROGRESS"
  | (string & {});
export const TrafficDistributionGroupStatus = S.String;
export interface ContactFilter {
  ContactStates?: ContactState[];
}
export const ContactFilter = S.suspend(() =>
  S.Struct({ ContactStates: S.optional(ContactStates) }),
).annotations({
  identifier: "ContactFilter",
}) as any as S.Schema<ContactFilter>;
export interface Threshold {
  Comparison?: Comparison;
  ThresholdValue?: number;
}
export const Threshold = S.suspend(() =>
  S.Struct({
    Comparison: S.optional(Comparison),
    ThresholdValue: S.optional(S.Number),
  }),
).annotations({ identifier: "Threshold" }) as any as S.Schema<Threshold>;
export interface FilterV2StringCondition {
  Comparison?: FilterV2StringConditionComparisonOperator;
}
export const FilterV2StringCondition = S.suspend(() =>
  S.Struct({
    Comparison: S.optional(FilterV2StringConditionComparisonOperator),
  }),
).annotations({
  identifier: "FilterV2StringCondition",
}) as any as S.Schema<FilterV2StringCondition>;
export interface ThresholdV2 {
  Comparison?: string;
  ThresholdValue?: number;
}
export const ThresholdV2 = S.suspend(() =>
  S.Struct({
    Comparison: S.optional(S.String),
    ThresholdValue: S.optional(S.Number),
  }),
).annotations({ identifier: "ThresholdV2" }) as any as S.Schema<ThresholdV2>;
export type ThresholdCollections = ThresholdV2[];
export const ThresholdCollections = S.Array(ThresholdV2);
export interface MetricFilterV2 {
  MetricFilterKey?: string;
  MetricFilterValues?: string[];
  Negate?: boolean;
}
export const MetricFilterV2 = S.suspend(() =>
  S.Struct({
    MetricFilterKey: S.optional(S.String),
    MetricFilterValues: S.optional(MetricFilterValueList),
    Negate: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "MetricFilterV2",
}) as any as S.Schema<MetricFilterV2>;
export type MetricFiltersV2List = MetricFilterV2[];
export const MetricFiltersV2List = S.Array(MetricFilterV2);
export type AutoEvaluationStatus =
  | "IN_PROGRESS"
  | "FAILED"
  | "SUCCEEDED"
  | (string & {});
export const AutoEvaluationStatus = S.String;
export interface DecimalCondition {
  FieldName?: string;
  MinValue?: number;
  MaxValue?: number;
  ComparisonType?: DecimalComparisonType;
}
export const DecimalCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    MinValue: S.optional(S.Number),
    MaxValue: S.optional(S.Number),
    ComparisonType: S.optional(DecimalComparisonType),
  }),
).annotations({
  identifier: "DecimalCondition",
}) as any as S.Schema<DecimalCondition>;
export interface NameCriteria {
  SearchText: string | redacted.Redacted<string>[];
  MatchType: SearchContactsMatchType;
}
export const NameCriteria = S.suspend(() =>
  S.Struct({ SearchText: SearchTextList, MatchType: SearchContactsMatchType }),
).annotations({ identifier: "NameCriteria" }) as any as S.Schema<NameCriteria>;
export interface AgentHierarchyGroups {
  L1Ids?: string[];
  L2Ids?: string[];
  L3Ids?: string[];
  L4Ids?: string[];
  L5Ids?: string[];
}
export const AgentHierarchyGroups = S.suspend(() =>
  S.Struct({
    L1Ids: S.optional(HierarchyGroupIdList),
    L2Ids: S.optional(HierarchyGroupIdList),
    L3Ids: S.optional(HierarchyGroupIdList),
    L4Ids: S.optional(HierarchyGroupIdList),
    L5Ids: S.optional(HierarchyGroupIdList),
  }),
).annotations({
  identifier: "AgentHierarchyGroups",
}) as any as S.Schema<AgentHierarchyGroups>;
export interface DateCondition {
  FieldName?: string;
  Value?: string;
  ComparisonType?: DateComparisonType;
}
export const DateCondition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    Value: S.optional(S.String),
    ComparisonType: S.optional(DateComparisonType),
  }),
).annotations({
  identifier: "DateCondition",
}) as any as S.Schema<DateCondition>;
export interface TagSearchCondition {
  tagKey?: string;
  tagValue?: string;
  tagKeyComparisonType?: StringComparisonType;
  tagValueComparisonType?: StringComparisonType;
}
export const TagSearchCondition = S.suspend(() =>
  S.Struct({
    tagKey: S.optional(S.String),
    tagValue: S.optional(S.String),
    tagKeyComparisonType: S.optional(StringComparisonType),
    tagValueComparisonType: S.optional(StringComparisonType),
  }),
).annotations({
  identifier: "TagSearchCondition",
}) as any as S.Schema<TagSearchCondition>;
export interface HierarchyGroupCondition {
  Value?: string;
  HierarchyGroupMatchType?: HierarchyGroupMatchType;
}
export const HierarchyGroupCondition = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String),
    HierarchyGroupMatchType: S.optional(HierarchyGroupMatchType),
  }),
).annotations({
  identifier: "HierarchyGroupCondition",
}) as any as S.Schema<HierarchyGroupCondition>;
export interface HierarchyLevelUpdate {
  Name: string;
}
export const HierarchyLevelUpdate = S.suspend(() =>
  S.Struct({ Name: S.String }),
).annotations({
  identifier: "HierarchyLevelUpdate",
}) as any as S.Schema<HierarchyLevelUpdate>;
export type EvaluationFormItemEnablementAction =
  | "DISABLE"
  | "ENABLE"
  | (string & {});
export const EvaluationFormItemEnablementAction = S.String;
export type SearchableContactAttributeValueList =
  | string
  | redacted.Redacted<string>[];
export const SearchableContactAttributeValueList = S.Array(SensitiveString);
export type SearchableSegmentAttributeValueList =
  | string
  | redacted.Redacted<string>[];
export const SearchableSegmentAttributeValueList = S.Array(SensitiveString);
export type EmailHeaderType =
  | "REFERENCES"
  | "MESSAGE_ID"
  | "IN_REPLY_TO"
  | "X_SES_SPAM_VERDICT"
  | "X_SES_VIRUS_VERDICT"
  | (string & {});
export const EmailHeaderType = S.String;
export type Expressions = Expression[];
export const Expressions = S.Array(
  S.suspend((): S.Schema<Expression, any> => Expression).annotations({
    identifier: "Expression",
  }),
) as any as S.Schema<Expressions>;
export type TimerEligibleParticipantRoles =
  | "CUSTOMER"
  | "AGENT"
  | (string & {});
export const TimerEligibleParticipantRoles = S.String;
export type ParticipantTimerType =
  | "IDLE"
  | "DISCONNECT_NONCUSTOMER"
  | (string & {});
export const ParticipantTimerType = S.String;
export interface AttachedFile {
  CreationTime: string;
  FileArn: string;
  FileId: string;
  FileName: string;
  FileSizeInBytes: number;
  FileStatus: FileStatusType;
  CreatedBy?: CreatedByInfo;
  FileUseCaseType?: FileUseCaseType;
  AssociatedResourceArn?: string;
  Tags?: { [key: string]: string | undefined };
}
export const AttachedFile = S.suspend(() =>
  S.Struct({
    CreationTime: S.String,
    FileArn: S.String,
    FileId: S.String,
    FileName: S.String,
    FileSizeInBytes: S.Number,
    FileStatus: FileStatusType,
    CreatedBy: S.optional(CreatedByInfo),
    FileUseCaseType: S.optional(FileUseCaseType),
    AssociatedResourceArn: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotations({ identifier: "AttachedFile" }) as any as S.Schema<AttachedFile>;
export type AttachedFilesList = AttachedFile[];
export const AttachedFilesList = S.Array(AttachedFile);
export interface AttachedFileError {
  ErrorCode?: string;
  ErrorMessage?: string;
  FileId?: string;
}
export const AttachedFileError = S.suspend(() =>
  S.Struct({
    ErrorCode: S.optional(S.String),
    ErrorMessage: S.optional(S.String),
    FileId: S.optional(S.String),
  }),
).annotations({
  identifier: "AttachedFileError",
}) as any as S.Schema<AttachedFileError>;
export type AttachedFileErrorsList = AttachedFileError[];
export const AttachedFileErrorsList = S.Array(AttachedFileError);
export interface PostAcceptTimeoutConfig {
  DurationInSeconds: number;
}
export const PostAcceptTimeoutConfig = S.suspend(() =>
  S.Struct({ DurationInSeconds: S.Number }),
).annotations({
  identifier: "PostAcceptTimeoutConfig",
}) as any as S.Schema<PostAcceptTimeoutConfig>;
export type AllowedUserAction = "CALL" | "DISCARD" | (string & {});
export const AllowedUserAction = S.String;
export type AllowedUserActions = AllowedUserAction[];
export const AllowedUserActions = S.Array(AllowedUserAction);
export interface Preview {
  PostAcceptTimeoutConfig: PostAcceptTimeoutConfig;
  AllowedUserActions: AllowedUserAction[];
}
export const Preview = S.suspend(() =>
  S.Struct({
    PostAcceptTimeoutConfig: PostAcceptTimeoutConfig,
    AllowedUserActions: AllowedUserActions,
  }),
).annotations({ identifier: "Preview" }) as any as S.Schema<Preview>;
export interface AgentFirst {
  Preview?: Preview;
}
export const AgentFirst = S.suspend(() =>
  S.Struct({ Preview: S.optional(Preview) }),
).annotations({ identifier: "AgentFirst" }) as any as S.Schema<AgentFirst>;
export interface OutboundStrategyConfig {
  AgentFirst?: AgentFirst;
}
export const OutboundStrategyConfig = S.suspend(() =>
  S.Struct({ AgentFirst: S.optional(AgentFirst) }),
).annotations({
  identifier: "OutboundStrategyConfig",
}) as any as S.Schema<OutboundStrategyConfig>;
export interface OutboundStrategy {
  Type: OutboundStrategyType;
  Config?: OutboundStrategyConfig;
}
export const OutboundStrategy = S.suspend(() =>
  S.Struct({
    Type: OutboundStrategyType,
    Config: S.optional(OutboundStrategyConfig),
  }),
).annotations({
  identifier: "OutboundStrategy",
}) as any as S.Schema<OutboundStrategy>;
export interface ContactDataRequest {
  SystemEndpoint?: Endpoint;
  CustomerEndpoint?: Endpoint;
  RequestIdentifier?: string;
  QueueId?: string;
  Attributes?: { [key: string]: string | undefined };
  Campaign?: Campaign;
  OutboundStrategy?: OutboundStrategy;
}
export const ContactDataRequest = S.suspend(() =>
  S.Struct({
    SystemEndpoint: S.optional(Endpoint),
    CustomerEndpoint: S.optional(Endpoint),
    RequestIdentifier: S.optional(S.String),
    QueueId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    Campaign: S.optional(Campaign),
    OutboundStrategy: S.optional(OutboundStrategy),
  }),
).annotations({
  identifier: "ContactDataRequest",
}) as any as S.Schema<ContactDataRequest>;
export type ContactDataRequestList = ContactDataRequest[];
export const ContactDataRequestList = S.Array(ContactDataRequest);
export interface BatchUpdateDataTableValueSuccessResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  LockVersion: DataTableLockVersion;
}
export const BatchUpdateDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotations({
  identifier: "BatchUpdateDataTableValueSuccessResult",
}) as any as S.Schema<BatchUpdateDataTableValueSuccessResult>;
export type BatchUpdateDataTableValueSuccessResultList =
  BatchUpdateDataTableValueSuccessResult[];
export const BatchUpdateDataTableValueSuccessResultList = S.Array(
  BatchUpdateDataTableValueSuccessResult,
);
export interface BatchUpdateDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchUpdateDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotations({
  identifier: "BatchUpdateDataTableValueFailureResult",
}) as any as S.Schema<BatchUpdateDataTableValueFailureResult>;
export type BatchUpdateDataTableValueFailureResultList =
  BatchUpdateDataTableValueFailureResult[];
export const BatchUpdateDataTableValueFailureResultList = S.Array(
  BatchUpdateDataTableValueFailureResult,
);
export interface ParticipantDetailsToAdd {
  ParticipantRole?: ParticipantRole;
  DisplayName?: string;
  ParticipantCapabilities?: ParticipantCapabilities;
}
export const ParticipantDetailsToAdd = S.suspend(() =>
  S.Struct({
    ParticipantRole: S.optional(ParticipantRole),
    DisplayName: S.optional(S.String),
    ParticipantCapabilities: S.optional(ParticipantCapabilities),
  }),
).annotations({
  identifier: "ParticipantDetailsToAdd",
}) as any as S.Schema<ParticipantDetailsToAdd>;
export interface AgentStatus {
  AgentStatusARN?: string;
  AgentStatusId?: string;
  Name?: string;
  Description?: string;
  Type?: AgentStatusType;
  DisplayOrder?: number;
  State?: AgentStatusState;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const AgentStatus = S.suspend(() =>
  S.Struct({
    AgentStatusARN: S.optional(S.String),
    AgentStatusId: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Type: S.optional(AgentStatusType),
    DisplayOrder: S.optional(S.Number),
    State: S.optional(AgentStatusState),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "AgentStatus" }) as any as S.Schema<AgentStatus>;
export interface AuthenticationProfile {
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  AllowedIps?: string[];
  BlockedIps?: string[];
  IsDefault?: boolean;
  CreatedTime?: Date;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  PeriodicSessionDuration?: number;
  MaxSessionDuration?: number;
  SessionInactivityDuration?: number;
  SessionInactivityHandlingEnabled?: boolean;
}
export const AuthenticationProfile = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    AllowedIps: S.optional(IpCidrList),
    BlockedIps: S.optional(IpCidrList),
    IsDefault: S.optional(S.Boolean),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    PeriodicSessionDuration: S.optional(S.Number),
    MaxSessionDuration: S.optional(S.Number),
    SessionInactivityDuration: S.optional(S.Number),
    SessionInactivityHandlingEnabled: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "AuthenticationProfile",
}) as any as S.Schema<AuthenticationProfile>;
export interface EvaluationFormContent {
  EvaluationFormVersion: number;
  EvaluationFormId: string;
  EvaluationFormArn: string;
  Title: string;
  Description?: string;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
}
export const EvaluationFormContent = S.suspend(() =>
  S.Struct({
    EvaluationFormVersion: S.Number,
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    Title: S.String,
    Description: S.optional(S.String),
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
  }),
).annotations({
  identifier: "EvaluationFormContent",
}) as any as S.Schema<EvaluationFormContent>;
export interface ContactFlow {
  Arn?: string;
  Id?: string;
  Name?: string;
  Type?: ContactFlowType;
  State?: ContactFlowState;
  Status?: ContactFlowStatus;
  Description?: string;
  Content?: string;
  Tags?: { [key: string]: string | undefined };
  FlowContentSha256?: string;
  Version?: number;
  VersionDescription?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ContactFlow = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(ContactFlowType),
    State: S.optional(ContactFlowState),
    Status: S.optional(ContactFlowStatus),
    Description: S.optional(S.String),
    Content: S.optional(S.String),
    Tags: S.optional(TagMap),
    FlowContentSha256: S.optional(S.String),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "ContactFlow" }) as any as S.Schema<ContactFlow>;
export interface ContactFlowModule {
  Arn?: string;
  Id?: string;
  Name?: string;
  Content?: string;
  Description?: string;
  State?: ContactFlowModuleState;
  Status?: ContactFlowModuleStatus;
  Tags?: { [key: string]: string | undefined };
  FlowModuleContentSha256?: string;
  Version?: number;
  VersionDescription?: string;
  Settings?: string;
  ExternalInvocationConfiguration?: ExternalInvocationConfiguration;
}
export const ContactFlowModule = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Content: S.optional(S.String),
    Description: S.optional(S.String),
    State: S.optional(ContactFlowModuleState),
    Status: S.optional(ContactFlowModuleStatus),
    Tags: S.optional(TagMap),
    FlowModuleContentSha256: S.optional(S.String),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
    Settings: S.optional(S.String),
    ExternalInvocationConfiguration: S.optional(
      ExternalInvocationConfiguration,
    ),
  }),
).annotations({
  identifier: "ContactFlowModule",
}) as any as S.Schema<ContactFlowModule>;
export interface ContactFlowModuleAliasInfo {
  ContactFlowModuleId?: string;
  ContactFlowModuleArn?: string;
  AliasId?: string;
  Version?: number;
  Name?: string;
  Description?: string;
  LastModifiedRegion?: string;
  LastModifiedTime?: Date;
}
export const ContactFlowModuleAliasInfo = S.suspend(() =>
  S.Struct({
    ContactFlowModuleId: S.optional(S.String),
    ContactFlowModuleArn: S.optional(S.String),
    AliasId: S.optional(S.String),
    Version: S.optional(S.Number),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    LastModifiedRegion: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "ContactFlowModuleAliasInfo",
}) as any as S.Schema<ContactFlowModuleAliasInfo>;
export interface DataTable {
  Name: string;
  Id: string;
  Arn: string;
  TimeZone: string;
  Description?: string;
  ValueLockLevel?: DataTableLockLevel;
  LockVersion?: DataTableLockVersion;
  Version?: string;
  VersionDescription?: string;
  Status?: DataTableStatus;
  CreatedTime?: Date;
  LastModifiedTime: Date;
  LastModifiedRegion?: string;
  Tags?: { [key: string]: string | undefined };
}
export const DataTable = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Id: S.String,
    Arn: S.String,
    TimeZone: S.String,
    Description: S.optional(S.String),
    ValueLockLevel: S.optional(DataTableLockLevel),
    LockVersion: S.optional(DataTableLockVersion),
    Version: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    Status: S.optional(DataTableStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedRegion: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotations({ identifier: "DataTable" }) as any as S.Schema<DataTable>;
export interface EvaluationForm {
  EvaluationFormId: string;
  EvaluationFormVersion: number;
  Locked: boolean;
  EvaluationFormArn: string;
  Title: string;
  Description?: string;
  Status: EvaluationFormVersionStatus;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  Tags?: { [key: string]: string | undefined };
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
}
export const EvaluationForm = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormVersion: S.Number,
    Locked: S.Boolean,
    EvaluationFormArn: S.String,
    Title: S.String,
    Description: S.optional(S.String),
    Status: EvaluationFormVersionStatus,
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    Tags: S.optional(TagMap),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
  }),
).annotations({
  identifier: "EvaluationForm",
}) as any as S.Schema<EvaluationForm>;
export interface HoursOfOperation {
  HoursOfOperationId?: string;
  HoursOfOperationArn?: string;
  Name?: string;
  Description?: string;
  TimeZone?: string;
  Config?: HoursOfOperationConfig[];
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HoursOfOperation = S.suspend(() =>
  S.Struct({
    HoursOfOperationId: S.optional(S.String),
    HoursOfOperationArn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    TimeZone: S.optional(S.String),
    Config: S.optional(HoursOfOperationConfigList),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "HoursOfOperation",
}) as any as S.Schema<HoursOfOperation>;
export interface Prompt {
  PromptARN?: string;
  PromptId?: string;
  Name?: string;
  Description?: string;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const Prompt = S.suspend(() =>
  S.Struct({
    PromptARN: S.optional(S.String),
    PromptId: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "Prompt" }) as any as S.Schema<Prompt>;
export interface Queue {
  Name?: string;
  QueueArn?: string;
  QueueId?: string;
  Description?: string;
  OutboundCallerConfig?: OutboundCallerConfig;
  OutboundEmailConfig?: OutboundEmailConfig;
  HoursOfOperationId?: string;
  MaxContacts?: number;
  Status?: QueueStatus;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const Queue = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    QueueArn: S.optional(S.String),
    QueueId: S.optional(S.String),
    Description: S.optional(S.String),
    OutboundCallerConfig: S.optional(OutboundCallerConfig),
    OutboundEmailConfig: S.optional(OutboundEmailConfig),
    HoursOfOperationId: S.optional(S.String),
    MaxContacts: S.optional(S.Number),
    Status: S.optional(QueueStatus),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "Queue" }) as any as S.Schema<Queue>;
export interface QuickConnect {
  QuickConnectARN?: string;
  QuickConnectId?: string;
  Name?: string;
  Description?: string;
  QuickConnectConfig?: QuickConnectConfig;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const QuickConnect = S.suspend(() =>
  S.Struct({
    QuickConnectARN: S.optional(S.String),
    QuickConnectId: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    QuickConnectConfig: S.optional(QuickConnectConfig),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "QuickConnect" }) as any as S.Schema<QuickConnect>;
export interface RoutingProfile {
  InstanceId?: string;
  Name?: string;
  RoutingProfileArn?: string;
  RoutingProfileId?: string;
  Description?: string;
  MediaConcurrencies?: MediaConcurrency[];
  DefaultOutboundQueueId?: string;
  Tags?: { [key: string]: string | undefined };
  NumberOfAssociatedQueues?: number;
  NumberOfAssociatedManualAssignmentQueues?: number;
  NumberOfAssociatedUsers?: number;
  AgentAvailabilityTimer?: AgentAvailabilityTimer;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  IsDefault?: boolean;
  AssociatedQueueIds?: string[];
  AssociatedManualAssignmentQueueIds?: string[];
}
export const RoutingProfile = S.suspend(() =>
  S.Struct({
    InstanceId: S.optional(S.String),
    Name: S.optional(S.String),
    RoutingProfileArn: S.optional(S.String),
    RoutingProfileId: S.optional(S.String),
    Description: S.optional(S.String),
    MediaConcurrencies: S.optional(MediaConcurrencies),
    DefaultOutboundQueueId: S.optional(S.String),
    Tags: S.optional(TagMap),
    NumberOfAssociatedQueues: S.optional(S.Number),
    NumberOfAssociatedManualAssignmentQueues: S.optional(S.Number),
    NumberOfAssociatedUsers: S.optional(S.Number),
    AgentAvailabilityTimer: S.optional(AgentAvailabilityTimer),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    IsDefault: S.optional(S.Boolean),
    AssociatedQueueIds: S.optional(AssociatedQueueIdList),
    AssociatedManualAssignmentQueueIds: S.optional(AssociatedQueueIdList),
  }),
).annotations({
  identifier: "RoutingProfile",
}) as any as S.Schema<RoutingProfile>;
export interface Rule {
  Name: string;
  RuleId: string;
  RuleArn: string;
  TriggerEventSource: RuleTriggerEventSource;
  Function: string;
  Actions: RuleAction[];
  PublishStatus: RulePublishStatus;
  CreatedTime: Date;
  LastUpdatedTime: Date;
  LastUpdatedBy: string;
  Tags?: { [key: string]: string | undefined };
}
export const Rule = S.suspend(() =>
  S.Struct({
    Name: S.String,
    RuleId: S.String,
    RuleArn: S.String,
    TriggerEventSource: RuleTriggerEventSource,
    Function: S.String,
    Actions: RuleActions,
    PublishStatus: RulePublishStatus,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastUpdatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastUpdatedBy: S.String,
    Tags: S.optional(TagMap),
  }),
).annotations({ identifier: "Rule" }) as any as S.Schema<Rule>;
export interface SecurityProfile {
  Id?: string;
  OrganizationResourceId?: string;
  Arn?: string;
  SecurityProfileName?: string;
  Description?: string;
  Tags?: { [key: string]: string | undefined };
  AllowedAccessControlTags?: { [key: string]: string | undefined };
  TagRestrictedResources?: string[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
  HierarchyRestrictedResources?: string[];
  AllowedAccessControlHierarchyGroupId?: string;
  GranularAccessControlConfiguration?: GranularAccessControlConfiguration;
}
export const SecurityProfile = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    OrganizationResourceId: S.optional(S.String),
    Arn: S.optional(S.String),
    SecurityProfileName: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagMap),
    AllowedAccessControlTags: S.optional(AllowedAccessControlTags),
    TagRestrictedResources: S.optional(TagRestrictedResourceList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
    HierarchyRestrictedResources: S.optional(HierarchyRestrictedResourceList),
    AllowedAccessControlHierarchyGroupId: S.optional(S.String),
    GranularAccessControlConfiguration: S.optional(
      GranularAccessControlConfiguration,
    ),
  }),
).annotations({
  identifier: "SecurityProfile",
}) as any as S.Schema<SecurityProfile>;
export interface TrafficDistributionGroup {
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  InstanceArn?: string;
  Status?: TrafficDistributionGroupStatus;
  Tags?: { [key: string]: string | undefined };
  IsDefault?: boolean;
}
export const TrafficDistributionGroup = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    InstanceArn: S.optional(S.String),
    Status: S.optional(TrafficDistributionGroupStatus),
    Tags: S.optional(TagMap),
    IsDefault: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "TrafficDistributionGroup",
}) as any as S.Schema<TrafficDistributionGroup>;
export interface User {
  Id?: string;
  Arn?: string;
  Username?: string;
  IdentityInfo?: UserIdentityInfo;
  PhoneConfig?: UserPhoneConfig;
  DirectoryUserId?: string;
  SecurityProfileIds?: string[];
  RoutingProfileId?: string;
  HierarchyGroupId?: string;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const User = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Username: S.optional(S.String),
    IdentityInfo: S.optional(UserIdentityInfo),
    PhoneConfig: S.optional(UserPhoneConfig),
    DirectoryUserId: S.optional(S.String),
    SecurityProfileIds: S.optional(SecurityProfileIds),
    RoutingProfileId: S.optional(S.String),
    HierarchyGroupId: S.optional(S.String),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "User" }) as any as S.Schema<User>;
export interface Vocabulary {
  Name: string;
  Id: string;
  Arn: string;
  LanguageCode: VocabularyLanguageCode;
  State: VocabularyState;
  LastModifiedTime: Date;
  FailureReason?: string;
  Content?: string;
  Tags?: { [key: string]: string | undefined };
}
export const Vocabulary = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Id: S.String,
    Arn: S.String,
    LanguageCode: VocabularyLanguageCode,
    State: VocabularyState,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    FailureReason: S.optional(S.String),
    Content: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotations({ identifier: "Vocabulary" }) as any as S.Schema<Vocabulary>;
export interface Workspace {
  Visibility?: Visibility;
  Id: string;
  Name: string;
  Arn: string;
  Description?: string;
  Theme?: WorkspaceTheme;
  Title?: string;
  LastModifiedTime: Date;
  LastModifiedRegion?: string;
  Tags?: { [key: string]: string | undefined };
}
export const Workspace = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    Id: S.String,
    Name: S.String,
    Arn: S.String,
    Description: S.optional(S.String),
    Theme: S.optional(WorkspaceTheme),
    Title: S.optional(S.String),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedRegion: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotations({ identifier: "Workspace" }) as any as S.Schema<Workspace>;
export interface DownloadUrlMetadata {
  Url?: string;
  UrlExpiry?: string;
}
export const DownloadUrlMetadata = S.suspend(() =>
  S.Struct({ Url: S.optional(S.String), UrlExpiry: S.optional(S.String) }),
).annotations({
  identifier: "DownloadUrlMetadata",
}) as any as S.Schema<DownloadUrlMetadata>;
export interface UserDataFilters {
  Queues?: string[];
  ContactFilter?: ContactFilter;
  RoutingProfiles?: string[];
  Agents?: string[];
  UserHierarchyGroups?: string[];
}
export const UserDataFilters = S.suspend(() =>
  S.Struct({
    Queues: S.optional(Queues),
    ContactFilter: S.optional(ContactFilter),
    RoutingProfiles: S.optional(RoutingProfiles),
    Agents: S.optional(AgentsMinOneMaxHundred),
    UserHierarchyGroups: S.optional(UserDataHierarchyGroups),
  }),
).annotations({
  identifier: "UserDataFilters",
}) as any as S.Schema<UserDataFilters>;
export interface Credentials {
  AccessToken?: string | redacted.Redacted<string>;
  AccessTokenExpiration?: Date;
  RefreshToken?: string | redacted.Redacted<string>;
  RefreshTokenExpiration?: Date;
}
export const Credentials = S.suspend(() =>
  S.Struct({
    AccessToken: S.optional(SensitiveString),
    AccessTokenExpiration: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RefreshToken: S.optional(SensitiveString),
    RefreshTokenExpiration: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({ identifier: "Credentials" }) as any as S.Schema<Credentials>;
export interface HistoricalMetric {
  Name?: HistoricalMetricName;
  Threshold?: Threshold;
  Statistic?: Statistic;
  Unit?: Unit;
}
export const HistoricalMetric = S.suspend(() =>
  S.Struct({
    Name: S.optional(HistoricalMetricName),
    Threshold: S.optional(Threshold),
    Statistic: S.optional(Statistic),
    Unit: S.optional(Unit),
  }),
).annotations({
  identifier: "HistoricalMetric",
}) as any as S.Schema<HistoricalMetric>;
export type HistoricalMetrics = HistoricalMetric[];
export const HistoricalMetrics = S.Array(HistoricalMetric);
export interface FilterV2 {
  FilterKey?: string;
  FilterValues?: string[];
  StringCondition?: FilterV2StringCondition;
}
export const FilterV2 = S.suspend(() =>
  S.Struct({
    FilterKey: S.optional(S.String),
    FilterValues: S.optional(FilterValueList),
    StringCondition: S.optional(FilterV2StringCondition),
  }),
).annotations({ identifier: "FilterV2" }) as any as S.Schema<FilterV2>;
export type FiltersV2List = FilterV2[];
export const FiltersV2List = S.Array(FilterV2);
export interface MetricV2 {
  Name?: string;
  Threshold?: ThresholdV2[];
  MetricId?: string;
  MetricFilters?: MetricFilterV2[];
}
export const MetricV2 = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Threshold: S.optional(ThresholdCollections),
    MetricId: S.optional(S.String),
    MetricFilters: S.optional(MetricFiltersV2List),
  }),
).annotations({ identifier: "MetricV2" }) as any as S.Schema<MetricV2>;
export type MetricsV2 = MetricV2[];
export const MetricsV2 = S.Array(MetricV2);
export interface AgentStatusSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  Type?: AgentStatusType;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const AgentStatusSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(AgentStatusType),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "AgentStatusSummary",
}) as any as S.Schema<AgentStatusSummary>;
export type AgentStatusSummaryList = AgentStatusSummary[];
export const AgentStatusSummaryList = S.Array(AgentStatusSummary);
export interface AnalyticsDataSetsResult {
  DataSetId?: string;
  DataSetName?: string;
}
export const AnalyticsDataSetsResult = S.suspend(() =>
  S.Struct({
    DataSetId: S.optional(S.String),
    DataSetName: S.optional(S.String),
  }),
).annotations({
  identifier: "AnalyticsDataSetsResult",
}) as any as S.Schema<AnalyticsDataSetsResult>;
export type AnalyticsDataSetsResults = AnalyticsDataSetsResult[];
export const AnalyticsDataSetsResults = S.Array(AnalyticsDataSetsResult);
export interface AssociatedContactSummary {
  ContactId?: string;
  ContactArn?: string;
  InitiationTimestamp?: Date;
  DisconnectTimestamp?: Date;
  InitialContactId?: string;
  PreviousContactId?: string;
  RelatedContactId?: string;
  InitiationMethod?: ContactInitiationMethod;
  Channel?: Channel;
}
export const AssociatedContactSummary = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DisconnectTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    InitialContactId: S.optional(S.String),
    PreviousContactId: S.optional(S.String),
    RelatedContactId: S.optional(S.String),
    InitiationMethod: S.optional(ContactInitiationMethod),
    Channel: S.optional(Channel),
  }),
).annotations({
  identifier: "AssociatedContactSummary",
}) as any as S.Schema<AssociatedContactSummary>;
export type AssociatedContactSummaryList = AssociatedContactSummary[];
export const AssociatedContactSummaryList = S.Array(AssociatedContactSummary);
export interface AuthenticationProfileSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  IsDefault?: boolean;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const AuthenticationProfileSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    IsDefault: S.optional(S.Boolean),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "AuthenticationProfileSummary",
}) as any as S.Schema<AuthenticationProfileSummary>;
export type AuthenticationProfileSummaryList = AuthenticationProfileSummary[];
export const AuthenticationProfileSummaryList = S.Array(
  AuthenticationProfileSummary,
);
export interface LexBotConfig {
  LexBot?: LexBot;
  LexV2Bot?: LexV2Bot;
}
export const LexBotConfig = S.suspend(() =>
  S.Struct({ LexBot: S.optional(LexBot), LexV2Bot: S.optional(LexV2Bot) }),
).annotations({ identifier: "LexBotConfig" }) as any as S.Schema<LexBotConfig>;
export type LexBotConfigList = LexBotConfig[];
export const LexBotConfigList = S.Array(LexBotConfig);
export interface ContactFlowModuleAliasSummary {
  Arn?: string;
  AliasId?: string;
  Version?: number;
  AliasName?: string;
  AliasDescription?: string;
  LastModifiedTime?: Date;
}
export const ContactFlowModuleAliasSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AliasId: S.optional(S.String),
    Version: S.optional(S.Number),
    AliasName: S.optional(S.String),
    AliasDescription: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "ContactFlowModuleAliasSummary",
}) as any as S.Schema<ContactFlowModuleAliasSummary>;
export type ContactFlowModuleAliasSummaryList = ContactFlowModuleAliasSummary[];
export const ContactFlowModuleAliasSummaryList = S.Array(
  ContactFlowModuleAliasSummary,
);
export interface ContactFlowModuleSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  State?: ContactFlowModuleState;
}
export const ContactFlowModuleSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    State: S.optional(ContactFlowModuleState),
  }),
).annotations({
  identifier: "ContactFlowModuleSummary",
}) as any as S.Schema<ContactFlowModuleSummary>;
export type ContactFlowModulesSummaryList = ContactFlowModuleSummary[];
export const ContactFlowModulesSummaryList = S.Array(ContactFlowModuleSummary);
export interface ContactFlowModuleVersionSummary {
  Arn?: string;
  VersionDescription?: string;
  Version?: number;
}
export const ContactFlowModuleVersionSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotations({
  identifier: "ContactFlowModuleVersionSummary",
}) as any as S.Schema<ContactFlowModuleVersionSummary>;
export type ContactFlowModuleVersionSummaryList =
  ContactFlowModuleVersionSummary[];
export const ContactFlowModuleVersionSummaryList = S.Array(
  ContactFlowModuleVersionSummary,
);
export interface ContactFlowSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  ContactFlowType?: ContactFlowType;
  ContactFlowState?: ContactFlowState;
  ContactFlowStatus?: ContactFlowStatus;
}
export const ContactFlowSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    ContactFlowType: S.optional(ContactFlowType),
    ContactFlowState: S.optional(ContactFlowState),
    ContactFlowStatus: S.optional(ContactFlowStatus),
  }),
).annotations({
  identifier: "ContactFlowSummary",
}) as any as S.Schema<ContactFlowSummary>;
export type ContactFlowSummaryList = ContactFlowSummary[];
export const ContactFlowSummaryList = S.Array(ContactFlowSummary);
export interface ContactFlowVersionSummary {
  Arn?: string;
  VersionDescription?: string;
  Version?: number;
}
export const ContactFlowVersionSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionDescription: S.optional(S.String),
    Version: S.optional(S.Number),
  }),
).annotations({
  identifier: "ContactFlowVersionSummary",
}) as any as S.Schema<ContactFlowVersionSummary>;
export type ContactFlowVersionSummaryList = ContactFlowVersionSummary[];
export const ContactFlowVersionSummaryList = S.Array(ContactFlowVersionSummary);
export interface DataTableSummary {
  Name?: string;
  Id?: string;
  Arn?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const DataTableSummary = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "DataTableSummary",
}) as any as S.Schema<DataTableSummary>;
export type DataTableSummaryList = DataTableSummary[];
export const DataTableSummaryList = S.Array(DataTableSummary);
export interface DefaultVocabulary {
  InstanceId: string;
  LanguageCode: VocabularyLanguageCode;
  VocabularyId: string;
  VocabularyName: string;
}
export const DefaultVocabulary = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    LanguageCode: VocabularyLanguageCode,
    VocabularyId: S.String,
    VocabularyName: S.String,
  }),
).annotations({
  identifier: "DefaultVocabulary",
}) as any as S.Schema<DefaultVocabulary>;
export type DefaultVocabularyList = DefaultVocabulary[];
export const DefaultVocabularyList = S.Array(DefaultVocabulary);
export interface EvaluationFormSummary {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  Title: string;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
  LastActivatedTime?: Date;
  LastActivatedBy?: string;
  LatestVersion: number;
  ActiveVersion?: number;
}
export const EvaluationFormSummary = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    Title: S.String,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
    LastActivatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastActivatedBy: S.optional(S.String),
    LatestVersion: S.Number,
    ActiveVersion: S.optional(S.Number),
  }),
).annotations({
  identifier: "EvaluationFormSummary",
}) as any as S.Schema<EvaluationFormSummary>;
export type EvaluationFormSummaryList = EvaluationFormSummary[];
export const EvaluationFormSummaryList = S.Array(EvaluationFormSummary);
export interface EvaluationFormVersionSummary {
  EvaluationFormArn: string;
  EvaluationFormId: string;
  EvaluationFormVersion: number;
  Locked: boolean;
  Status: EvaluationFormVersionStatus;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
}
export const EvaluationFormVersionSummary = S.suspend(() =>
  S.Struct({
    EvaluationFormArn: S.String,
    EvaluationFormId: S.String,
    EvaluationFormVersion: S.Number,
    Locked: S.Boolean,
    Status: EvaluationFormVersionStatus,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
  }),
).annotations({
  identifier: "EvaluationFormVersionSummary",
}) as any as S.Schema<EvaluationFormVersionSummary>;
export type EvaluationFormVersionSummaryList = EvaluationFormVersionSummary[];
export const EvaluationFormVersionSummaryList = S.Array(
  EvaluationFormVersionSummary,
);
export interface HoursOfOperationSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HoursOfOperationSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "HoursOfOperationSummary",
}) as any as S.Schema<HoursOfOperationSummary>;
export type HoursOfOperationSummaryList = HoursOfOperationSummary[];
export const HoursOfOperationSummaryList = S.Array(HoursOfOperationSummary);
export interface InstanceSummary {
  Id?: string;
  Arn?: string;
  IdentityManagementType?: DirectoryType;
  InstanceAlias?: string | redacted.Redacted<string>;
  CreatedTime?: Date;
  ServiceRole?: string;
  InstanceStatus?: InstanceStatus;
  InboundCallsEnabled?: boolean;
  OutboundCallsEnabled?: boolean;
  InstanceAccessUrl?: string;
}
export const InstanceSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    IdentityManagementType: S.optional(DirectoryType),
    InstanceAlias: S.optional(SensitiveString),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ServiceRole: S.optional(S.String),
    InstanceStatus: S.optional(InstanceStatus),
    InboundCallsEnabled: S.optional(S.Boolean),
    OutboundCallsEnabled: S.optional(S.Boolean),
    InstanceAccessUrl: S.optional(S.String),
  }),
).annotations({
  identifier: "InstanceSummary",
}) as any as S.Schema<InstanceSummary>;
export type InstanceSummaryList = InstanceSummary[];
export const InstanceSummaryList = S.Array(InstanceSummary);
export interface IntegrationAssociationSummary {
  IntegrationAssociationId?: string;
  IntegrationAssociationArn?: string;
  InstanceId?: string;
  IntegrationType?: IntegrationType;
  IntegrationArn?: string;
  SourceApplicationUrl?: string;
  SourceApplicationName?: string;
  SourceType?: SourceType;
}
export const IntegrationAssociationSummary = S.suspend(() =>
  S.Struct({
    IntegrationAssociationId: S.optional(S.String),
    IntegrationAssociationArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    IntegrationType: S.optional(IntegrationType),
    IntegrationArn: S.optional(S.String),
    SourceApplicationUrl: S.optional(S.String),
    SourceApplicationName: S.optional(S.String),
    SourceType: S.optional(SourceType),
  }),
).annotations({
  identifier: "IntegrationAssociationSummary",
}) as any as S.Schema<IntegrationAssociationSummary>;
export type IntegrationAssociationSummaryList = IntegrationAssociationSummary[];
export const IntegrationAssociationSummaryList = S.Array(
  IntegrationAssociationSummary,
);
export interface PhoneNumberSummary {
  Id?: string;
  Arn?: string;
  PhoneNumber?: string;
  PhoneNumberType?: PhoneNumberType;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
}
export const PhoneNumberSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    PhoneNumber: S.optional(S.String),
    PhoneNumberType: S.optional(PhoneNumberType),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
  }),
).annotations({
  identifier: "PhoneNumberSummary",
}) as any as S.Schema<PhoneNumberSummary>;
export type PhoneNumberSummaryList = PhoneNumberSummary[];
export const PhoneNumberSummaryList = S.Array(PhoneNumberSummary);
export interface ListPhoneNumbersSummary {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
  PhoneNumber?: string;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
  PhoneNumberType?: PhoneNumberType;
  TargetArn?: string;
  InstanceId?: string;
  PhoneNumberDescription?: string;
  SourcePhoneNumberArn?: string;
}
export const ListPhoneNumbersSummary = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
    PhoneNumber: S.optional(S.String),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
    PhoneNumberType: S.optional(PhoneNumberType),
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    PhoneNumberDescription: S.optional(S.String),
    SourcePhoneNumberArn: S.optional(S.String),
  }),
).annotations({
  identifier: "ListPhoneNumbersSummary",
}) as any as S.Schema<ListPhoneNumbersSummary>;
export type ListPhoneNumbersSummaryList = ListPhoneNumbersSummary[];
export const ListPhoneNumbersSummaryList = S.Array(ListPhoneNumbersSummary);
export interface PredefinedAttributeSummary {
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const PredefinedAttributeSummary = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "PredefinedAttributeSummary",
}) as any as S.Schema<PredefinedAttributeSummary>;
export type PredefinedAttributeSummaryList = PredefinedAttributeSummary[];
export const PredefinedAttributeSummaryList = S.Array(
  PredefinedAttributeSummary,
);
export interface PromptSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const PromptSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "PromptSummary",
}) as any as S.Schema<PromptSummary>;
export type PromptSummaryList = PromptSummary[];
export const PromptSummaryList = S.Array(PromptSummary);
export interface QueueSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  QueueType?: QueueType;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const QueueSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    QueueType: S.optional(QueueType),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "QueueSummary" }) as any as S.Schema<QueueSummary>;
export type QueueSummaryList = QueueSummary[];
export const QueueSummaryList = S.Array(QueueSummary);
export interface RoutingProfileManualAssignmentQueueConfigSummary {
  QueueId: string;
  QueueArn: string;
  QueueName: string;
  Channel: Channel;
}
export const RoutingProfileManualAssignmentQueueConfigSummary = S.suspend(() =>
  S.Struct({
    QueueId: S.String,
    QueueArn: S.String,
    QueueName: S.String,
    Channel: Channel,
  }),
).annotations({
  identifier: "RoutingProfileManualAssignmentQueueConfigSummary",
}) as any as S.Schema<RoutingProfileManualAssignmentQueueConfigSummary>;
export type RoutingProfileManualAssignmentQueueConfigSummaryList =
  RoutingProfileManualAssignmentQueueConfigSummary[];
export const RoutingProfileManualAssignmentQueueConfigSummaryList = S.Array(
  RoutingProfileManualAssignmentQueueConfigSummary,
);
export interface RoutingProfileQueueConfigSummary {
  QueueId: string;
  QueueArn: string;
  QueueName: string;
  Priority: number;
  Delay: number;
  Channel: Channel;
}
export const RoutingProfileQueueConfigSummary = S.suspend(() =>
  S.Struct({
    QueueId: S.String,
    QueueArn: S.String,
    QueueName: S.String,
    Priority: S.Number,
    Delay: S.Number,
    Channel: Channel,
  }),
).annotations({
  identifier: "RoutingProfileQueueConfigSummary",
}) as any as S.Schema<RoutingProfileQueueConfigSummary>;
export type RoutingProfileQueueConfigSummaryList =
  RoutingProfileQueueConfigSummary[];
export const RoutingProfileQueueConfigSummaryList = S.Array(
  RoutingProfileQueueConfigSummary,
);
export interface RoutingProfileSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const RoutingProfileSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "RoutingProfileSummary",
}) as any as S.Schema<RoutingProfileSummary>;
export type RoutingProfileSummaryList = RoutingProfileSummary[];
export const RoutingProfileSummaryList = S.Array(RoutingProfileSummary);
export interface SecurityKey {
  AssociationId?: string;
  Key?: string;
  CreationTime?: Date;
}
export const SecurityKey = S.suspend(() =>
  S.Struct({
    AssociationId: S.optional(S.String),
    Key: S.optional(S.String),
    CreationTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotations({ identifier: "SecurityKey" }) as any as S.Schema<SecurityKey>;
export type SecurityKeysList = SecurityKey[];
export const SecurityKeysList = S.Array(SecurityKey);
export interface SecurityProfileSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const SecurityProfileSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "SecurityProfileSummary",
}) as any as S.Schema<SecurityProfileSummary>;
export type SecurityProfileSummaryList = SecurityProfileSummary[];
export const SecurityProfileSummaryList = S.Array(SecurityProfileSummary);
export interface TaskTemplateMetadata {
  Id?: string;
  Arn?: string;
  Name?: string;
  Description?: string;
  Status?: TaskTemplateStatus;
  LastModifiedTime?: Date;
  CreatedTime?: Date;
}
export const TaskTemplateMetadata = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    Status: S.optional(TaskTemplateStatus),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotations({
  identifier: "TaskTemplateMetadata",
}) as any as S.Schema<TaskTemplateMetadata>;
export type TaskTemplateList = TaskTemplateMetadata[];
export const TaskTemplateList = S.Array(TaskTemplateMetadata);
export interface TrafficDistributionGroupSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  InstanceArn?: string;
  Status?: TrafficDistributionGroupStatus;
  IsDefault?: boolean;
}
export const TrafficDistributionGroupSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    InstanceArn: S.optional(S.String),
    Status: S.optional(TrafficDistributionGroupStatus),
    IsDefault: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "TrafficDistributionGroupSummary",
}) as any as S.Schema<TrafficDistributionGroupSummary>;
export type TrafficDistributionGroupSummaryList =
  TrafficDistributionGroupSummary[];
export const TrafficDistributionGroupSummaryList = S.Array(
  TrafficDistributionGroupSummary,
);
export interface TrafficDistributionGroupUserSummary {
  UserId?: string;
}
export const TrafficDistributionGroupUserSummary = S.suspend(() =>
  S.Struct({ UserId: S.optional(S.String) }),
).annotations({
  identifier: "TrafficDistributionGroupUserSummary",
}) as any as S.Schema<TrafficDistributionGroupUserSummary>;
export type TrafficDistributionGroupUserSummaryList =
  TrafficDistributionGroupUserSummary[];
export const TrafficDistributionGroupUserSummaryList = S.Array(
  TrafficDistributionGroupUserSummary,
);
export interface UseCase {
  UseCaseId?: string;
  UseCaseArn?: string;
  UseCaseType?: UseCaseType;
}
export const UseCase = S.suspend(() =>
  S.Struct({
    UseCaseId: S.optional(S.String),
    UseCaseArn: S.optional(S.String),
    UseCaseType: S.optional(UseCaseType),
  }),
).annotations({ identifier: "UseCase" }) as any as S.Schema<UseCase>;
export type UseCaseSummaryList = UseCase[];
export const UseCaseSummaryList = S.Array(UseCase);
export interface HierarchyGroupSummary {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HierarchyGroupSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "HierarchyGroupSummary",
}) as any as S.Schema<HierarchyGroupSummary>;
export type HierarchyGroupSummaryList = HierarchyGroupSummary[];
export const HierarchyGroupSummaryList = S.Array(HierarchyGroupSummary);
export interface UserSummary {
  Id?: string;
  Arn?: string;
  Username?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const UserSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Username: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({ identifier: "UserSummary" }) as any as S.Schema<UserSummary>;
export type UserSummaryList = UserSummary[];
export const UserSummaryList = S.Array(UserSummary);
export interface ViewSummary {
  Id?: string;
  Arn?: string;
  Name?: string | redacted.Redacted<string>;
  Type?: ViewType;
  Status?: ViewStatus;
  Description?: string;
}
export const ViewSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(SensitiveString),
    Type: S.optional(ViewType),
    Status: S.optional(ViewStatus),
    Description: S.optional(S.String),
  }),
).annotations({ identifier: "ViewSummary" }) as any as S.Schema<ViewSummary>;
export type ViewsSummaryList = ViewSummary[];
export const ViewsSummaryList = S.Array(ViewSummary);
export interface ViewVersionSummary {
  Id?: string;
  Arn?: string;
  Description?: string;
  Name?: string | redacted.Redacted<string>;
  Type?: ViewType;
  Version?: number;
  VersionDescription?: string;
}
export const ViewVersionSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Description: S.optional(S.String),
    Name: S.optional(SensitiveString),
    Type: S.optional(ViewType),
    Version: S.optional(S.Number),
    VersionDescription: S.optional(S.String),
  }),
).annotations({
  identifier: "ViewVersionSummary",
}) as any as S.Schema<ViewVersionSummary>;
export type ViewVersionSummaryList = ViewVersionSummary[];
export const ViewVersionSummaryList = S.Array(ViewVersionSummary);
export interface MediaItem {
  Type?: MediaType;
  Source?: string;
}
export const MediaItem = S.suspend(() =>
  S.Struct({ Type: S.optional(MediaType), Source: S.optional(S.String) }),
).annotations({ identifier: "MediaItem" }) as any as S.Schema<MediaItem>;
export type MediaList = MediaItem[];
export const MediaList = S.Array(MediaItem);
export interface WorkspacePage {
  ResourceArn?: string;
  Page?: string;
  Slug?: string;
  InputData?: string;
}
export const WorkspacePage = S.suspend(() =>
  S.Struct({
    ResourceArn: S.optional(S.String),
    Page: S.optional(S.String),
    Slug: S.optional(S.String),
    InputData: S.optional(S.String),
  }),
).annotations({
  identifier: "WorkspacePage",
}) as any as S.Schema<WorkspacePage>;
export type WorkspacePageList = WorkspacePage[];
export const WorkspacePageList = S.Array(WorkspacePage);
export interface WorkspaceSummary {
  Id?: string;
  Name?: string;
  Arn?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const WorkspaceSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Arn: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "WorkspaceSummary",
}) as any as S.Schema<WorkspaceSummary>;
export type WorkspaceSummaryList = WorkspaceSummary[];
export const WorkspaceSummaryList = S.Array(WorkspaceSummary);
export interface AgentStatusSearchCriteria {
  OrConditions?: AgentStatusSearchCriteria[];
  AndConditions?: AgentStatusSearchCriteria[];
  StringCondition?: StringCondition;
}
export const AgentStatusSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => AgentStatusSearchConditionList).annotations({
        identifier: "AgentStatusSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => AgentStatusSearchConditionList).annotations({
        identifier: "AgentStatusSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
  }),
).annotations({
  identifier: "AgentStatusSearchCriteria",
}) as any as S.Schema<AgentStatusSearchCriteria>;
export interface AvailableNumberSummary {
  PhoneNumber?: string;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
  PhoneNumberType?: PhoneNumberType;
}
export const AvailableNumberSummary = S.suspend(() =>
  S.Struct({
    PhoneNumber: S.optional(S.String),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
    PhoneNumberType: S.optional(PhoneNumberType),
  }),
).annotations({
  identifier: "AvailableNumberSummary",
}) as any as S.Schema<AvailableNumberSummary>;
export type AvailableNumbersList = AvailableNumberSummary[];
export const AvailableNumbersList = S.Array(AvailableNumberSummary);
export interface EvaluationSearchCriteria {
  OrConditions?: EvaluationSearchCriteria[];
  AndConditions?: EvaluationSearchCriteria[];
  StringCondition?: StringCondition;
  NumberCondition?: NumberCondition;
  BooleanCondition?: BooleanCondition;
  DateTimeCondition?: DateTimeCondition;
  DecimalCondition?: DecimalCondition;
}
export const EvaluationSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => EvaluationSearchConditionList).annotations({
        identifier: "EvaluationSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => EvaluationSearchConditionList).annotations({
        identifier: "EvaluationSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    NumberCondition: S.optional(NumberCondition),
    BooleanCondition: S.optional(BooleanCondition),
    DateTimeCondition: S.optional(DateTimeCondition),
    DecimalCondition: S.optional(DecimalCondition),
  }),
).annotations({
  identifier: "EvaluationSearchCriteria",
}) as any as S.Schema<EvaluationSearchCriteria>;
export interface ContactFlowModuleSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
}
export const ContactFlowModuleSearchFilter = S.suspend(() =>
  S.Struct({ TagFilter: S.optional(ControlPlaneTagFilter) }),
).annotations({
  identifier: "ContactFlowModuleSearchFilter",
}) as any as S.Schema<ContactFlowModuleSearchFilter>;
export type DataTableList = DataTable[];
export const DataTableList = S.Array(DataTable);
export interface HoursOfOperationOverrideSearchCriteria {
  OrConditions?: HoursOfOperationOverrideSearchCriteria[];
  AndConditions?: HoursOfOperationOverrideSearchCriteria[];
  StringCondition?: StringCondition;
  DateCondition?: DateCondition;
}
export const HoursOfOperationOverrideSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => HoursOfOperationOverrideSearchConditionList).annotations({
        identifier: "HoursOfOperationOverrideSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => HoursOfOperationOverrideSearchConditionList).annotations({
        identifier: "HoursOfOperationOverrideSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    DateCondition: S.optional(DateCondition),
  }),
).annotations({
  identifier: "HoursOfOperationOverrideSearchCriteria",
}) as any as S.Schema<HoursOfOperationOverrideSearchCriteria>;
export type HoursOfOperationList = HoursOfOperation[];
export const HoursOfOperationList = S.Array(HoursOfOperation);
export interface PredefinedAttributeConfiguration {
  EnableValueValidationOnAssociation?: boolean;
  IsReadOnly?: boolean;
}
export const PredefinedAttributeConfiguration = S.suspend(() =>
  S.Struct({
    EnableValueValidationOnAssociation: S.optional(S.Boolean),
    IsReadOnly: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "PredefinedAttributeConfiguration",
}) as any as S.Schema<PredefinedAttributeConfiguration>;
export interface PredefinedAttribute {
  Name?: string;
  Values?: PredefinedAttributeValues;
  Purposes?: string[];
  AttributeConfiguration?: PredefinedAttributeConfiguration;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const PredefinedAttribute = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Values: S.optional(PredefinedAttributeValues),
    Purposes: S.optional(PredefinedAttributePurposeNameList),
    AttributeConfiguration: S.optional(PredefinedAttributeConfiguration),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "PredefinedAttribute",
}) as any as S.Schema<PredefinedAttribute>;
export type PredefinedAttributeSearchSummaryList = PredefinedAttribute[];
export const PredefinedAttributeSearchSummaryList =
  S.Array(PredefinedAttribute);
export type PromptList = Prompt[];
export const PromptList = S.Array(Prompt);
export type QueueSearchSummaryList = Queue[];
export const QueueSearchSummaryList = S.Array(Queue);
export type QuickConnectSearchSummaryList = QuickConnect[];
export const QuickConnectSearchSummaryList = S.Array(QuickConnect);
export interface ResourceTagsSearchCriteria {
  TagSearchCondition?: TagSearchCondition;
}
export const ResourceTagsSearchCriteria = S.suspend(() =>
  S.Struct({ TagSearchCondition: S.optional(TagSearchCondition) }),
).annotations({
  identifier: "ResourceTagsSearchCriteria",
}) as any as S.Schema<ResourceTagsSearchCriteria>;
export type RoutingProfileList = RoutingProfile[];
export const RoutingProfileList = S.Array(RoutingProfile);
export interface HierarchyPath {
  LevelOne?: HierarchyGroupSummary;
  LevelTwo?: HierarchyGroupSummary;
  LevelThree?: HierarchyGroupSummary;
  LevelFour?: HierarchyGroupSummary;
  LevelFive?: HierarchyGroupSummary;
}
export const HierarchyPath = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyGroupSummary),
    LevelTwo: S.optional(HierarchyGroupSummary),
    LevelThree: S.optional(HierarchyGroupSummary),
    LevelFour: S.optional(HierarchyGroupSummary),
    LevelFive: S.optional(HierarchyGroupSummary),
  }),
).annotations({
  identifier: "HierarchyPath",
}) as any as S.Schema<HierarchyPath>;
export interface HierarchyGroup {
  Id?: string;
  Arn?: string;
  Name?: string;
  LevelId?: string;
  HierarchyPath?: HierarchyPath;
  Tags?: { [key: string]: string | undefined };
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HierarchyGroup = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LevelId: S.optional(S.String),
    HierarchyPath: S.optional(HierarchyPath),
    Tags: S.optional(TagMap),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "HierarchyGroup",
}) as any as S.Schema<HierarchyGroup>;
export type UserHierarchyGroupList = HierarchyGroup[];
export const UserHierarchyGroupList = S.Array(HierarchyGroup);
export type ViewSearchSummaryList = View[];
export const ViewSearchSummaryList = S.Array(View);
export interface VocabularySummary {
  Name: string;
  Id: string;
  Arn: string;
  LanguageCode: VocabularyLanguageCode;
  State: VocabularyState;
  LastModifiedTime: Date;
  FailureReason?: string;
}
export const VocabularySummary = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Id: S.String,
    Arn: S.String,
    LanguageCode: VocabularyLanguageCode,
    State: VocabularyState,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    FailureReason: S.optional(S.String),
  }),
).annotations({
  identifier: "VocabularySummary",
}) as any as S.Schema<VocabularySummary>;
export type VocabularySummaryList = VocabularySummary[];
export const VocabularySummaryList = S.Array(VocabularySummary);
export interface HierarchyStructureUpdate {
  LevelOne?: HierarchyLevelUpdate;
  LevelTwo?: HierarchyLevelUpdate;
  LevelThree?: HierarchyLevelUpdate;
  LevelFour?: HierarchyLevelUpdate;
  LevelFive?: HierarchyLevelUpdate;
}
export const HierarchyStructureUpdate = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyLevelUpdate),
    LevelTwo: S.optional(HierarchyLevelUpdate),
    LevelThree: S.optional(HierarchyLevelUpdate),
    LevelFour: S.optional(HierarchyLevelUpdate),
    LevelFive: S.optional(HierarchyLevelUpdate),
  }),
).annotations({
  identifier: "HierarchyStructureUpdate",
}) as any as S.Schema<HierarchyStructureUpdate>;
export type SegmentAttributeValueMap = {
  [key: string]: SegmentAttributeValue | undefined;
};
export const SegmentAttributeValueMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(
    S.suspend(
      (): S.Schema<SegmentAttributeValue, any> => SegmentAttributeValue,
    ).annotations({ identifier: "SegmentAttributeValue" }),
  ),
}) as any as S.Schema<SegmentAttributeValueMap>;
export type MediaStreamType = "AUDIO" | "VIDEO" | (string & {});
export const MediaStreamType = S.String;
export type ParticipantType =
  | "ALL"
  | "MANAGER"
  | "AGENT"
  | "CUSTOMER"
  | "THIRDPARTY"
  | (string & {});
export const ParticipantType = S.String;
export type RecordingStatus = "AVAILABLE" | "DELETED" | (string & {});
export const RecordingStatus = S.String;
export type NextContactType = "QUICK_CONNECT" | (string & {});
export const NextContactType = S.String;
export type InstanceReplicationStatus =
  | "INSTANCE_REPLICATION_COMPLETE"
  | "INSTANCE_REPLICATION_IN_PROGRESS"
  | "INSTANCE_REPLICATION_FAILED"
  | "INSTANCE_REPLICA_DELETING"
  | "INSTANCE_REPLICATION_DELETION_FAILED"
  | "RESOURCE_REPLICATION_NOT_STARTED"
  | (string & {});
export const InstanceReplicationStatus = S.String;
export type PhoneNumberWorkflowStatus =
  | "CLAIMED"
  | "IN_PROGRESS"
  | "FAILED"
  | (string & {});
export const PhoneNumberWorkflowStatus = S.String;
export type ContactParticipantRole =
  | "AGENT"
  | "SYSTEM"
  | "CUSTOM_BOT"
  | (string & {});
export const ContactParticipantRole = S.String;
export type RealTimeContactAnalysisSentimentLabel =
  | "POSITIVE"
  | "NEGATIVE"
  | "NEUTRAL"
  | (string & {});
export const RealTimeContactAnalysisSentimentLabel = S.String;
export type RealTimeContactAnalysisPostContactSummaryStatus =
  | "FAILED"
  | "COMPLETED"
  | (string & {});
export const RealTimeContactAnalysisPostContactSummaryStatus = S.String;
export type RealTimeContactAnalysisPostContactSummaryFailureCode =
  | "QUOTA_EXCEEDED"
  | "INSUFFICIENT_CONVERSATION_CONTENT"
  | "FAILED_SAFETY_GUIDELINES"
  | "INVALID_ANALYSIS_CONFIGURATION"
  | "INTERNAL_ERROR"
  | (string & {});
export const RealTimeContactAnalysisPostContactSummaryFailureCode = S.String;
export interface ContactFlowTypeCondition {
  ContactFlowType?: ContactFlowType;
}
export const ContactFlowTypeCondition = S.suspend(() =>
  S.Struct({ ContactFlowType: S.optional(ContactFlowType) }),
).annotations({
  identifier: "ContactFlowTypeCondition",
}) as any as S.Schema<ContactFlowTypeCondition>;
export interface ContactFlowAttributeAndCondition {
  TagConditions?: TagCondition[];
  ContactFlowTypeCondition?: ContactFlowTypeCondition;
}
export const ContactFlowAttributeAndCondition = S.suspend(() =>
  S.Struct({
    TagConditions: S.optional(TagAndConditionList),
    ContactFlowTypeCondition: S.optional(ContactFlowTypeCondition),
  }),
).annotations({
  identifier: "ContactFlowAttributeAndCondition",
}) as any as S.Schema<ContactFlowAttributeAndCondition>;
export type ContactFlowAttributeOrConditionList =
  ContactFlowAttributeAndCondition[];
export const ContactFlowAttributeOrConditionList = S.Array(
  ContactFlowAttributeAndCondition,
);
export interface SearchableContactAttributesCriteria {
  Key: string | redacted.Redacted<string>;
  Values: string | redacted.Redacted<string>[];
}
export const SearchableContactAttributesCriteria = S.suspend(() =>
  S.Struct({
    Key: SensitiveString,
    Values: SearchableContactAttributeValueList,
  }),
).annotations({
  identifier: "SearchableContactAttributesCriteria",
}) as any as S.Schema<SearchableContactAttributesCriteria>;
export type SearchableContactAttributesCriteriaList =
  SearchableContactAttributesCriteria[];
export const SearchableContactAttributesCriteriaList = S.Array(
  SearchableContactAttributesCriteria,
);
export interface SearchableSegmentAttributesCriteria {
  Key: string | redacted.Redacted<string>;
  Values: string | redacted.Redacted<string>[];
}
export const SearchableSegmentAttributesCriteria = S.suspend(() =>
  S.Struct({
    Key: SensitiveString,
    Values: SearchableSegmentAttributeValueList,
  }),
).annotations({
  identifier: "SearchableSegmentAttributesCriteria",
}) as any as S.Schema<SearchableSegmentAttributesCriteria>;
export type SearchableSegmentAttributesCriteriaList =
  SearchableSegmentAttributesCriteria[];
export const SearchableSegmentAttributesCriteriaList = S.Array(
  SearchableSegmentAttributesCriteria,
);
export interface AttributeAndCondition {
  TagConditions?: TagCondition[];
  HierarchyGroupCondition?: HierarchyGroupCondition;
}
export const AttributeAndCondition = S.suspend(() =>
  S.Struct({
    TagConditions: S.optional(TagAndConditionList),
    HierarchyGroupCondition: S.optional(HierarchyGroupCondition),
  }),
).annotations({
  identifier: "AttributeAndCondition",
}) as any as S.Schema<AttributeAndCondition>;
export type AttributeOrConditionList = AttributeAndCondition[];
export const AttributeOrConditionList = S.Array(AttributeAndCondition);
export interface Condition {
  StringCondition?: StringCondition;
  NumberCondition?: NumberCondition;
}
export const Condition = S.suspend(() =>
  S.Struct({
    StringCondition: S.optional(StringCondition),
    NumberCondition: S.optional(NumberCondition),
  }),
).annotations({ identifier: "Condition" }) as any as S.Schema<Condition>;
export type Conditions = Condition[];
export const Conditions = S.Array(Condition);
export type EmailHeaders = { [key in EmailHeaderType]?: string };
export const EmailHeaders = S.partial(
  S.Record({ key: EmailHeaderType, value: S.UndefinedOr(S.String) }),
);
export interface RoutingCriteriaInputStepExpiry {
  DurationInSeconds?: number;
}
export const RoutingCriteriaInputStepExpiry = S.suspend(() =>
  S.Struct({ DurationInSeconds: S.optional(S.Number) }),
).annotations({
  identifier: "RoutingCriteriaInputStepExpiry",
}) as any as S.Schema<RoutingCriteriaInputStepExpiry>;
export interface AssociateWorkspaceResponse {
  SuccessfulList?: SuccessfulBatchAssociationSummary[];
  FailedList?: FailedBatchAssociationSummary[];
}
export const AssociateWorkspaceResponse = S.suspend(() =>
  S.Struct({
    SuccessfulList: S.optional(SuccessfulBatchAssociationSummaryList),
    FailedList: S.optional(FailedBatchAssociationSummaryList),
  }),
).annotations({
  identifier: "AssociateWorkspaceResponse",
}) as any as S.Schema<AssociateWorkspaceResponse>;
export interface BatchAssociateAnalyticsDataSetResponse {
  Created?: AnalyticsDataAssociationResult[];
  Errors?: ErrorResult[];
}
export const BatchAssociateAnalyticsDataSetResponse = S.suspend(() =>
  S.Struct({
    Created: S.optional(AnalyticsDataAssociationResults),
    Errors: S.optional(ErrorResults),
  }),
).annotations({
  identifier: "BatchAssociateAnalyticsDataSetResponse",
}) as any as S.Schema<BatchAssociateAnalyticsDataSetResponse>;
export interface BatchGetAttachedFileMetadataResponse {
  Files?: AttachedFile[];
  Errors?: AttachedFileError[];
}
export const BatchGetAttachedFileMetadataResponse = S.suspend(() =>
  S.Struct({
    Files: S.optional(AttachedFilesList),
    Errors: S.optional(AttachedFileErrorsList),
  }),
).annotations({
  identifier: "BatchGetAttachedFileMetadataResponse",
}) as any as S.Schema<BatchGetAttachedFileMetadataResponse>;
export interface BatchGetFlowAssociationResponse {
  FlowAssociationSummaryList?: FlowAssociationSummary[];
}
export const BatchGetFlowAssociationResponse = S.suspend(() =>
  S.Struct({
    FlowAssociationSummaryList: S.optional(FlowAssociationSummaryList),
  }),
).annotations({
  identifier: "BatchGetFlowAssociationResponse",
}) as any as S.Schema<BatchGetFlowAssociationResponse>;
export interface BatchPutContactRequest {
  ClientToken?: string;
  InstanceId: string;
  ContactDataRequestList: ContactDataRequest[];
}
export const BatchPutContactRequest = S.suspend(() =>
  S.Struct({
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactDataRequestList: ContactDataRequestList,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/batch/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchPutContactRequest",
}) as any as S.Schema<BatchPutContactRequest>;
export interface BatchUpdateDataTableValueResponse {
  Successful: BatchUpdateDataTableValueSuccessResult[];
  Failed: BatchUpdateDataTableValueFailureResult[];
}
export const BatchUpdateDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchUpdateDataTableValueSuccessResultList,
    Failed: BatchUpdateDataTableValueFailureResultList,
  }),
).annotations({
  identifier: "BatchUpdateDataTableValueResponse",
}) as any as S.Schema<BatchUpdateDataTableValueResponse>;
export interface ClaimPhoneNumberResponse {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
}
export const ClaimPhoneNumberResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
  }),
).annotations({
  identifier: "ClaimPhoneNumberResponse",
}) as any as S.Schema<ClaimPhoneNumberResponse>;
export interface CreateContactFlowModuleResponse {
  Id?: string;
  Arn?: string;
}
export const CreateContactFlowModuleResponse = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "CreateContactFlowModuleResponse",
}) as any as S.Schema<CreateContactFlowModuleResponse>;
export interface CreateDataTableAttributeRequest {
  InstanceId: string;
  DataTableId: string;
  Name: string;
  ValueType: DataTableAttributeValueType;
  Description?: string;
  Primary?: boolean;
  Validation?: Validation;
}
export const CreateDataTableAttributeRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    DataTableId: S.String.pipe(T.HttpLabel("DataTableId")),
    Name: S.String,
    ValueType: DataTableAttributeValueType,
    Description: S.optional(S.String),
    Primary: S.optional(S.Boolean),
    Validation: S.optional(Validation),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/data-tables/{InstanceId}/{DataTableId}/attributes",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateDataTableAttributeRequest",
}) as any as S.Schema<CreateDataTableAttributeRequest>;
export type EvaluationFormSingleSelectQuestionDisplayMode =
  | "DROPDOWN"
  | "RADIO"
  | (string & {});
export const EvaluationFormSingleSelectQuestionDisplayMode = S.String;
export type EvaluationFormMultiSelectQuestionDisplayMode =
  | "DROPDOWN"
  | "CHECKBOX"
  | (string & {});
export const EvaluationFormMultiSelectQuestionDisplayMode = S.String;
export type EvaluationFormItemEnablementOperator = "OR" | "AND" | (string & {});
export const EvaluationFormItemEnablementOperator = S.String;
export interface CreateHoursOfOperationRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  TimeZone: string;
  Config: HoursOfOperationConfig[];
  Tags?: { [key: string]: string | undefined };
}
export const CreateHoursOfOperationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    TimeZone: S.String,
    Config: HoursOfOperationConfigList,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/hours-of-operations/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateHoursOfOperationRequest",
}) as any as S.Schema<CreateHoursOfOperationRequest>;
export interface CreateHoursOfOperationOverrideRequest {
  InstanceId: string;
  HoursOfOperationId: string;
  Name: string;
  Description?: string;
  Config: HoursOfOperationOverrideConfig[];
  EffectiveFrom: string;
  EffectiveTill: string;
}
export const CreateHoursOfOperationOverrideRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    HoursOfOperationId: S.String.pipe(T.HttpLabel("HoursOfOperationId")),
    Name: S.String,
    Description: S.optional(S.String),
    Config: HoursOfOperationOverrideConfigList,
    EffectiveFrom: S.String,
    EffectiveTill: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/hours-of-operations/{InstanceId}/{HoursOfOperationId}/overrides",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateHoursOfOperationOverrideRequest",
}) as any as S.Schema<CreateHoursOfOperationOverrideRequest>;
export interface CreateParticipantRequest {
  InstanceId: string;
  ContactId: string;
  ClientToken?: string;
  ParticipantDetails: ParticipantDetailsToAdd;
}
export const CreateParticipantRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ContactId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    ParticipantDetails: ParticipantDetailsToAdd,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/contact/create-participant" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateParticipantRequest",
}) as any as S.Schema<CreateParticipantRequest>;
export interface CreatePushNotificationRegistrationResponse {
  RegistrationId: string;
}
export const CreatePushNotificationRegistrationResponse = S.suspend(() =>
  S.Struct({ RegistrationId: S.String }),
).annotations({
  identifier: "CreatePushNotificationRegistrationResponse",
}) as any as S.Schema<CreatePushNotificationRegistrationResponse>;
export interface CreateQueueResponse {
  QueueArn?: string;
  QueueId?: string;
}
export const CreateQueueResponse = S.suspend(() =>
  S.Struct({ QueueArn: S.optional(S.String), QueueId: S.optional(S.String) }),
).annotations({
  identifier: "CreateQueueResponse",
}) as any as S.Schema<CreateQueueResponse>;
export interface CreateQuickConnectRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  QuickConnectConfig: QuickConnectConfig;
  Tags?: { [key: string]: string | undefined };
}
export const CreateQuickConnectRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    QuickConnectConfig: QuickConnectConfig,
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/quick-connects/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateQuickConnectRequest",
}) as any as S.Schema<CreateQuickConnectRequest>;
export interface CreateRoutingProfileRequest {
  InstanceId: string;
  Name: string;
  Description: string;
  DefaultOutboundQueueId: string;
  QueueConfigs?: RoutingProfileQueueConfig[];
  ManualAssignmentQueueConfigs?: RoutingProfileManualAssignmentQueueConfig[];
  MediaConcurrencies: MediaConcurrency[];
  Tags?: { [key: string]: string | undefined };
  AgentAvailabilityTimer?: AgentAvailabilityTimer;
}
export const CreateRoutingProfileRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.String,
    DefaultOutboundQueueId: S.String,
    QueueConfigs: S.optional(RoutingProfileQueueConfigList),
    ManualAssignmentQueueConfigs: S.optional(
      RoutingProfileManualAssignmentQueueConfigList,
    ),
    MediaConcurrencies: MediaConcurrencies,
    Tags: S.optional(TagMap),
    AgentAvailabilityTimer: S.optional(AgentAvailabilityTimer),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/routing-profiles/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateRoutingProfileRequest",
}) as any as S.Schema<CreateRoutingProfileRequest>;
export interface CreateTaskTemplateRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  ContactFlowId?: string;
  SelfAssignFlowId?: string;
  Constraints?: TaskTemplateConstraints;
  Defaults?: TaskTemplateDefaults;
  Status?: TaskTemplateStatus;
  Fields: TaskTemplateField[];
  ClientToken?: string;
}
export const CreateTaskTemplateRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    ContactFlowId: S.optional(S.String),
    SelfAssignFlowId: S.optional(S.String),
    Constraints: S.optional(TaskTemplateConstraints),
    Defaults: S.optional(TaskTemplateDefaults),
    Status: S.optional(TaskTemplateStatus),
    Fields: TaskTemplateFields,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/task/template" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateTaskTemplateRequest",
}) as any as S.Schema<CreateTaskTemplateRequest>;
export interface CreateUserResponse {
  UserId?: string;
  UserArn?: string;
}
export const CreateUserResponse = S.suspend(() =>
  S.Struct({ UserId: S.optional(S.String), UserArn: S.optional(S.String) }),
).annotations({
  identifier: "CreateUserResponse",
}) as any as S.Schema<CreateUserResponse>;
export interface CreateViewResponse {
  View?: View;
}
export const CreateViewResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotations({
  identifier: "CreateViewResponse",
}) as any as S.Schema<CreateViewResponse>;
export interface DescribeAgentStatusResponse {
  AgentStatus?: AgentStatus;
}
export const DescribeAgentStatusResponse = S.suspend(() =>
  S.Struct({ AgentStatus: S.optional(AgentStatus) }),
).annotations({
  identifier: "DescribeAgentStatusResponse",
}) as any as S.Schema<DescribeAgentStatusResponse>;
export interface DescribeAuthenticationProfileResponse {
  AuthenticationProfile?: AuthenticationProfile;
}
export const DescribeAuthenticationProfileResponse = S.suspend(() =>
  S.Struct({ AuthenticationProfile: S.optional(AuthenticationProfile) }),
).annotations({
  identifier: "DescribeAuthenticationProfileResponse",
}) as any as S.Schema<DescribeAuthenticationProfileResponse>;
export interface DescribeContactFlowResponse {
  ContactFlow?: ContactFlow;
}
export const DescribeContactFlowResponse = S.suspend(() =>
  S.Struct({ ContactFlow: S.optional(ContactFlow) }),
).annotations({
  identifier: "DescribeContactFlowResponse",
}) as any as S.Schema<DescribeContactFlowResponse>;
export interface DescribeContactFlowModuleResponse {
  ContactFlowModule?: ContactFlowModule;
}
export const DescribeContactFlowModuleResponse = S.suspend(() =>
  S.Struct({ ContactFlowModule: S.optional(ContactFlowModule) }),
).annotations({
  identifier: "DescribeContactFlowModuleResponse",
}) as any as S.Schema<DescribeContactFlowModuleResponse>;
export interface DescribeContactFlowModuleAliasResponse {
  ContactFlowModuleAlias?: ContactFlowModuleAliasInfo;
}
export const DescribeContactFlowModuleAliasResponse = S.suspend(() =>
  S.Struct({ ContactFlowModuleAlias: S.optional(ContactFlowModuleAliasInfo) }),
).annotations({
  identifier: "DescribeContactFlowModuleAliasResponse",
}) as any as S.Schema<DescribeContactFlowModuleAliasResponse>;
export interface DescribeDataTableResponse {
  DataTable: DataTable;
}
export const DescribeDataTableResponse = S.suspend(() =>
  S.Struct({ DataTable: DataTable }),
).annotations({
  identifier: "DescribeDataTableResponse",
}) as any as S.Schema<DescribeDataTableResponse>;
export interface DescribeDataTableAttributeResponse {
  Attribute: DataTableAttribute;
}
export const DescribeDataTableAttributeResponse = S.suspend(() =>
  S.Struct({ Attribute: DataTableAttribute }),
).annotations({
  identifier: "DescribeDataTableAttributeResponse",
}) as any as S.Schema<DescribeDataTableAttributeResponse>;
export interface DescribeEvaluationFormResponse {
  EvaluationForm: EvaluationForm;
}
export const DescribeEvaluationFormResponse = S.suspend(() =>
  S.Struct({ EvaluationForm: EvaluationForm }),
).annotations({
  identifier: "DescribeEvaluationFormResponse",
}) as any as S.Schema<DescribeEvaluationFormResponse>;
export interface DescribeHoursOfOperationResponse {
  HoursOfOperation?: HoursOfOperation;
}
export const DescribeHoursOfOperationResponse = S.suspend(() =>
  S.Struct({ HoursOfOperation: S.optional(HoursOfOperation) }),
).annotations({
  identifier: "DescribeHoursOfOperationResponse",
}) as any as S.Schema<DescribeHoursOfOperationResponse>;
export interface DescribeHoursOfOperationOverrideResponse {
  HoursOfOperationOverride?: HoursOfOperationOverride;
}
export const DescribeHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({ HoursOfOperationOverride: S.optional(HoursOfOperationOverride) }),
).annotations({
  identifier: "DescribeHoursOfOperationOverrideResponse",
}) as any as S.Schema<DescribeHoursOfOperationOverrideResponse>;
export interface DescribeInstanceAttributeResponse {
  Attribute?: Attribute;
}
export const DescribeInstanceAttributeResponse = S.suspend(() =>
  S.Struct({ Attribute: S.optional(Attribute) }),
).annotations({
  identifier: "DescribeInstanceAttributeResponse",
}) as any as S.Schema<DescribeInstanceAttributeResponse>;
export interface DescribePromptResponse {
  Prompt?: Prompt;
}
export const DescribePromptResponse = S.suspend(() =>
  S.Struct({ Prompt: S.optional(Prompt) }),
).annotations({
  identifier: "DescribePromptResponse",
}) as any as S.Schema<DescribePromptResponse>;
export interface DescribeQueueResponse {
  Queue?: Queue;
}
export const DescribeQueueResponse = S.suspend(() =>
  S.Struct({ Queue: S.optional(Queue) }),
).annotations({
  identifier: "DescribeQueueResponse",
}) as any as S.Schema<DescribeQueueResponse>;
export interface DescribeQuickConnectResponse {
  QuickConnect?: QuickConnect;
}
export const DescribeQuickConnectResponse = S.suspend(() =>
  S.Struct({ QuickConnect: S.optional(QuickConnect) }),
).annotations({
  identifier: "DescribeQuickConnectResponse",
}) as any as S.Schema<DescribeQuickConnectResponse>;
export interface DescribeRoutingProfileResponse {
  RoutingProfile?: RoutingProfile;
}
export const DescribeRoutingProfileResponse = S.suspend(() =>
  S.Struct({ RoutingProfile: S.optional(RoutingProfile) }),
).annotations({
  identifier: "DescribeRoutingProfileResponse",
}) as any as S.Schema<DescribeRoutingProfileResponse>;
export interface DescribeRuleResponse {
  Rule: Rule;
}
export const DescribeRuleResponse = S.suspend(() =>
  S.Struct({ Rule: Rule }),
).annotations({
  identifier: "DescribeRuleResponse",
}) as any as S.Schema<DescribeRuleResponse>;
export interface DescribeSecurityProfileResponse {
  SecurityProfile?: SecurityProfile;
}
export const DescribeSecurityProfileResponse = S.suspend(() =>
  S.Struct({ SecurityProfile: S.optional(SecurityProfile) }),
).annotations({
  identifier: "DescribeSecurityProfileResponse",
}) as any as S.Schema<DescribeSecurityProfileResponse>;
export interface DescribeTrafficDistributionGroupResponse {
  TrafficDistributionGroup?: TrafficDistributionGroup;
}
export const DescribeTrafficDistributionGroupResponse = S.suspend(() =>
  S.Struct({ TrafficDistributionGroup: S.optional(TrafficDistributionGroup) }),
).annotations({
  identifier: "DescribeTrafficDistributionGroupResponse",
}) as any as S.Schema<DescribeTrafficDistributionGroupResponse>;
export interface DescribeUserResponse {
  User?: User;
}
export const DescribeUserResponse = S.suspend(() =>
  S.Struct({ User: S.optional(User) }),
).annotations({
  identifier: "DescribeUserResponse",
}) as any as S.Schema<DescribeUserResponse>;
export interface DescribeVocabularyResponse {
  Vocabulary: Vocabulary;
}
export const DescribeVocabularyResponse = S.suspend(() =>
  S.Struct({ Vocabulary: Vocabulary }),
).annotations({
  identifier: "DescribeVocabularyResponse",
}) as any as S.Schema<DescribeVocabularyResponse>;
export interface DescribeWorkspaceResponse {
  Workspace: Workspace;
}
export const DescribeWorkspaceResponse = S.suspend(() =>
  S.Struct({ Workspace: Workspace }),
).annotations({
  identifier: "DescribeWorkspaceResponse",
}) as any as S.Schema<DescribeWorkspaceResponse>;
export interface GetAttachedFileResponse {
  FileArn?: string;
  FileId?: string;
  CreationTime?: string;
  FileStatus?: FileStatusType;
  FileName?: string;
  FileSizeInBytes: number;
  AssociatedResourceArn?: string;
  FileUseCaseType?: FileUseCaseType;
  CreatedBy?: CreatedByInfo;
  DownloadUrlMetadata?: DownloadUrlMetadata;
  Tags?: { [key: string]: string | undefined };
}
export const GetAttachedFileResponse = S.suspend(() =>
  S.Struct({
    FileArn: S.optional(S.String),
    FileId: S.optional(S.String),
    CreationTime: S.optional(S.String),
    FileStatus: S.optional(FileStatusType),
    FileName: S.optional(S.String),
    FileSizeInBytes: S.Number,
    AssociatedResourceArn: S.optional(S.String),
    FileUseCaseType: S.optional(FileUseCaseType),
    CreatedBy: S.optional(CreatedByInfo),
    DownloadUrlMetadata: S.optional(DownloadUrlMetadata),
    Tags: S.optional(TagMap),
  }),
).annotations({
  identifier: "GetAttachedFileResponse",
}) as any as S.Schema<GetAttachedFileResponse>;
export interface GetCurrentUserDataRequest {
  InstanceId: string;
  Filters: UserDataFilters;
  NextToken?: string;
  MaxResults?: number;
}
export const GetCurrentUserDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Filters: UserDataFilters,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/userdata/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetCurrentUserDataRequest",
}) as any as S.Schema<GetCurrentUserDataRequest>;
export interface GetFederationTokenResponse {
  Credentials?: Credentials;
  SignInUrl?: string;
  UserArn?: string;
  UserId?: string;
}
export const GetFederationTokenResponse = S.suspend(() =>
  S.Struct({
    Credentials: S.optional(Credentials),
    SignInUrl: S.optional(S.String),
    UserArn: S.optional(S.String),
    UserId: S.optional(S.String),
  }),
).annotations({
  identifier: "GetFederationTokenResponse",
}) as any as S.Schema<GetFederationTokenResponse>;
export interface GetMetricDataRequest {
  InstanceId: string;
  StartTime: Date;
  EndTime: Date;
  Filters: Filters;
  Groupings?: Grouping[];
  HistoricalMetrics: HistoricalMetric[];
  NextToken?: string;
  MaxResults?: number;
}
export const GetMetricDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    StartTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EndTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Filters: Filters,
    Groupings: S.optional(Groupings),
    HistoricalMetrics: HistoricalMetrics,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/historical/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetMetricDataRequest",
}) as any as S.Schema<GetMetricDataRequest>;
export interface GetMetricDataV2Request {
  ResourceArn: string;
  StartTime: Date;
  EndTime: Date;
  Interval?: IntervalDetails;
  Filters: FilterV2[];
  Groupings?: string[];
  Metrics: MetricV2[];
  NextToken?: string;
  MaxResults?: number;
}
export const GetMetricDataV2Request = S.suspend(() =>
  S.Struct({
    ResourceArn: S.String,
    StartTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EndTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Interval: S.optional(IntervalDetails),
    Filters: FiltersV2List,
    Groupings: S.optional(GroupingsV2),
    Metrics: MetricsV2,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/metrics/data" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetMetricDataV2Request",
}) as any as S.Schema<GetMetricDataV2Request>;
export interface ListAgentStatusResponse {
  NextToken?: string;
  AgentStatusSummaryList?: AgentStatusSummary[];
}
export const ListAgentStatusResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    AgentStatusSummaryList: S.optional(AgentStatusSummaryList),
  }),
).annotations({
  identifier: "ListAgentStatusResponse",
}) as any as S.Schema<ListAgentStatusResponse>;
export interface ListAnalyticsDataLakeDataSetsResponse {
  Results?: AnalyticsDataSetsResult[];
  NextToken?: string;
}
export const ListAnalyticsDataLakeDataSetsResponse = S.suspend(() =>
  S.Struct({
    Results: S.optional(AnalyticsDataSetsResults),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListAnalyticsDataLakeDataSetsResponse",
}) as any as S.Schema<ListAnalyticsDataLakeDataSetsResponse>;
export interface ListAssociatedContactsResponse {
  ContactSummaryList?: AssociatedContactSummary[];
  NextToken?: string;
}
export const ListAssociatedContactsResponse = S.suspend(() =>
  S.Struct({
    ContactSummaryList: S.optional(AssociatedContactSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListAssociatedContactsResponse",
}) as any as S.Schema<ListAssociatedContactsResponse>;
export interface ListAuthenticationProfilesResponse {
  AuthenticationProfileSummaryList?: AuthenticationProfileSummary[];
  NextToken?: string;
}
export const ListAuthenticationProfilesResponse = S.suspend(() =>
  S.Struct({
    AuthenticationProfileSummaryList: S.optional(
      AuthenticationProfileSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListAuthenticationProfilesResponse",
}) as any as S.Schema<ListAuthenticationProfilesResponse>;
export interface ListBotsResponse {
  LexBots?: LexBotConfig[];
  NextToken?: string;
}
export const ListBotsResponse = S.suspend(() =>
  S.Struct({
    LexBots: S.optional(LexBotConfigList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListBotsResponse",
}) as any as S.Schema<ListBotsResponse>;
export interface ListContactFlowModuleAliasesResponse {
  ContactFlowModuleAliasSummaryList?: ContactFlowModuleAliasSummary[];
  NextToken?: string;
}
export const ListContactFlowModuleAliasesResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleAliasSummaryList: S.optional(
      ContactFlowModuleAliasSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListContactFlowModuleAliasesResponse",
}) as any as S.Schema<ListContactFlowModuleAliasesResponse>;
export interface ListContactFlowModulesResponse {
  ContactFlowModulesSummaryList?: ContactFlowModuleSummary[];
  NextToken?: string;
}
export const ListContactFlowModulesResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModulesSummaryList: S.optional(ContactFlowModulesSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListContactFlowModulesResponse",
}) as any as S.Schema<ListContactFlowModulesResponse>;
export interface ListContactFlowModuleVersionsResponse {
  ContactFlowModuleVersionSummaryList?: ContactFlowModuleVersionSummary[];
  NextToken?: string;
}
export const ListContactFlowModuleVersionsResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModuleVersionSummaryList: S.optional(
      ContactFlowModuleVersionSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListContactFlowModuleVersionsResponse",
}) as any as S.Schema<ListContactFlowModuleVersionsResponse>;
export interface ListContactFlowsResponse {
  ContactFlowSummaryList?: ContactFlowSummary[];
  NextToken?: string;
}
export const ListContactFlowsResponse = S.suspend(() =>
  S.Struct({
    ContactFlowSummaryList: S.optional(ContactFlowSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListContactFlowsResponse",
}) as any as S.Schema<ListContactFlowsResponse>;
export interface ListContactFlowVersionsResponse {
  ContactFlowVersionSummaryList?: ContactFlowVersionSummary[];
  NextToken?: string;
}
export const ListContactFlowVersionsResponse = S.suspend(() =>
  S.Struct({
    ContactFlowVersionSummaryList: S.optional(ContactFlowVersionSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListContactFlowVersionsResponse",
}) as any as S.Schema<ListContactFlowVersionsResponse>;
export interface ListDataTablesResponse {
  NextToken?: string;
  DataTableSummaryList: DataTableSummary[];
}
export const ListDataTablesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    DataTableSummaryList: DataTableSummaryList,
  }),
).annotations({
  identifier: "ListDataTablesResponse",
}) as any as S.Schema<ListDataTablesResponse>;
export interface ListDefaultVocabulariesResponse {
  DefaultVocabularyList: DefaultVocabulary[];
  NextToken?: string;
}
export const ListDefaultVocabulariesResponse = S.suspend(() =>
  S.Struct({
    DefaultVocabularyList: DefaultVocabularyList,
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListDefaultVocabulariesResponse",
}) as any as S.Schema<ListDefaultVocabulariesResponse>;
export interface ListEvaluationFormsResponse {
  EvaluationFormSummaryList: EvaluationFormSummary[];
  NextToken?: string;
}
export const ListEvaluationFormsResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormSummaryList: EvaluationFormSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListEvaluationFormsResponse",
}) as any as S.Schema<ListEvaluationFormsResponse>;
export interface ListEvaluationFormVersionsResponse {
  EvaluationFormVersionSummaryList: EvaluationFormVersionSummary[];
  NextToken?: string;
}
export const ListEvaluationFormVersionsResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormVersionSummaryList: EvaluationFormVersionSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListEvaluationFormVersionsResponse",
}) as any as S.Schema<ListEvaluationFormVersionsResponse>;
export interface ListHoursOfOperationsResponse {
  HoursOfOperationSummaryList?: HoursOfOperationSummary[];
  NextToken?: string;
}
export const ListHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperationSummaryList: S.optional(HoursOfOperationSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListHoursOfOperationsResponse",
}) as any as S.Schema<ListHoursOfOperationsResponse>;
export interface ListInstancesResponse {
  InstanceSummaryList?: InstanceSummary[];
  NextToken?: string;
}
export const ListInstancesResponse = S.suspend(() =>
  S.Struct({
    InstanceSummaryList: S.optional(InstanceSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListInstancesResponse",
}) as any as S.Schema<ListInstancesResponse>;
export interface ListIntegrationAssociationsResponse {
  IntegrationAssociationSummaryList?: IntegrationAssociationSummary[];
  NextToken?: string;
}
export const ListIntegrationAssociationsResponse = S.suspend(() =>
  S.Struct({
    IntegrationAssociationSummaryList: S.optional(
      IntegrationAssociationSummaryList,
    ),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListIntegrationAssociationsResponse",
}) as any as S.Schema<ListIntegrationAssociationsResponse>;
export interface ListPhoneNumbersResponse {
  PhoneNumberSummaryList?: PhoneNumberSummary[];
  NextToken?: string;
}
export const ListPhoneNumbersResponse = S.suspend(() =>
  S.Struct({
    PhoneNumberSummaryList: S.optional(PhoneNumberSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListPhoneNumbersResponse",
}) as any as S.Schema<ListPhoneNumbersResponse>;
export interface ListPhoneNumbersV2Response {
  NextToken?: string;
  ListPhoneNumbersSummaryList?: ListPhoneNumbersSummary[];
}
export const ListPhoneNumbersV2Response = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    ListPhoneNumbersSummaryList: S.optional(ListPhoneNumbersSummaryList),
  }),
).annotations({
  identifier: "ListPhoneNumbersV2Response",
}) as any as S.Schema<ListPhoneNumbersV2Response>;
export interface ListPredefinedAttributesResponse {
  NextToken?: string;
  PredefinedAttributeSummaryList?: PredefinedAttributeSummary[];
}
export const ListPredefinedAttributesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    PredefinedAttributeSummaryList: S.optional(PredefinedAttributeSummaryList),
  }),
).annotations({
  identifier: "ListPredefinedAttributesResponse",
}) as any as S.Schema<ListPredefinedAttributesResponse>;
export interface ListPromptsResponse {
  PromptSummaryList?: PromptSummary[];
  NextToken?: string;
}
export const ListPromptsResponse = S.suspend(() =>
  S.Struct({
    PromptSummaryList: S.optional(PromptSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListPromptsResponse",
}) as any as S.Schema<ListPromptsResponse>;
export interface ListQueueQuickConnectsResponse {
  NextToken?: string;
  QuickConnectSummaryList?: QuickConnectSummary[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListQueueQuickConnectsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    QuickConnectSummaryList: S.optional(QuickConnectSummaryList),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "ListQueueQuickConnectsResponse",
}) as any as S.Schema<ListQueueQuickConnectsResponse>;
export interface ListQueuesResponse {
  QueueSummaryList?: QueueSummary[];
  NextToken?: string;
}
export const ListQueuesResponse = S.suspend(() =>
  S.Struct({
    QueueSummaryList: S.optional(QueueSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListQueuesResponse",
}) as any as S.Schema<ListQueuesResponse>;
export interface ListRoutingProfileManualAssignmentQueuesResponse {
  NextToken?: string;
  RoutingProfileManualAssignmentQueueConfigSummaryList?: RoutingProfileManualAssignmentQueueConfigSummary[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListRoutingProfileManualAssignmentQueuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    RoutingProfileManualAssignmentQueueConfigSummaryList: S.optional(
      RoutingProfileManualAssignmentQueueConfigSummaryList,
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "ListRoutingProfileManualAssignmentQueuesResponse",
}) as any as S.Schema<ListRoutingProfileManualAssignmentQueuesResponse>;
export interface ListRoutingProfileQueuesResponse {
  NextToken?: string;
  RoutingProfileQueueConfigSummaryList?: RoutingProfileQueueConfigSummary[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const ListRoutingProfileQueuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    RoutingProfileQueueConfigSummaryList: S.optional(
      RoutingProfileQueueConfigSummaryList,
    ),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "ListRoutingProfileQueuesResponse",
}) as any as S.Schema<ListRoutingProfileQueuesResponse>;
export interface ListRoutingProfilesResponse {
  RoutingProfileSummaryList?: RoutingProfileSummary[];
  NextToken?: string;
}
export const ListRoutingProfilesResponse = S.suspend(() =>
  S.Struct({
    RoutingProfileSummaryList: S.optional(RoutingProfileSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListRoutingProfilesResponse",
}) as any as S.Schema<ListRoutingProfilesResponse>;
export interface ListSecurityKeysResponse {
  SecurityKeys?: SecurityKey[];
  NextToken?: string;
}
export const ListSecurityKeysResponse = S.suspend(() =>
  S.Struct({
    SecurityKeys: S.optional(SecurityKeysList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListSecurityKeysResponse",
}) as any as S.Schema<ListSecurityKeysResponse>;
export interface ListSecurityProfilesResponse {
  SecurityProfileSummaryList?: SecurityProfileSummary[];
  NextToken?: string;
}
export const ListSecurityProfilesResponse = S.suspend(() =>
  S.Struct({
    SecurityProfileSummaryList: S.optional(SecurityProfileSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListSecurityProfilesResponse",
}) as any as S.Schema<ListSecurityProfilesResponse>;
export interface ListTaskTemplatesResponse {
  TaskTemplates?: TaskTemplateMetadata[];
  NextToken?: string;
}
export const ListTaskTemplatesResponse = S.suspend(() =>
  S.Struct({
    TaskTemplates: S.optional(TaskTemplateList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListTaskTemplatesResponse",
}) as any as S.Schema<ListTaskTemplatesResponse>;
export interface ListTrafficDistributionGroupsResponse {
  NextToken?: string;
  TrafficDistributionGroupSummaryList?: TrafficDistributionGroupSummary[];
}
export const ListTrafficDistributionGroupsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    TrafficDistributionGroupSummaryList: S.optional(
      TrafficDistributionGroupSummaryList,
    ),
  }),
).annotations({
  identifier: "ListTrafficDistributionGroupsResponse",
}) as any as S.Schema<ListTrafficDistributionGroupsResponse>;
export interface ListTrafficDistributionGroupUsersResponse {
  NextToken?: string;
  TrafficDistributionGroupUserSummaryList?: TrafficDistributionGroupUserSummary[];
}
export const ListTrafficDistributionGroupUsersResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    TrafficDistributionGroupUserSummaryList: S.optional(
      TrafficDistributionGroupUserSummaryList,
    ),
  }),
).annotations({
  identifier: "ListTrafficDistributionGroupUsersResponse",
}) as any as S.Schema<ListTrafficDistributionGroupUsersResponse>;
export interface ListUseCasesResponse {
  UseCaseSummaryList?: UseCase[];
  NextToken?: string;
}
export const ListUseCasesResponse = S.suspend(() =>
  S.Struct({
    UseCaseSummaryList: S.optional(UseCaseSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListUseCasesResponse",
}) as any as S.Schema<ListUseCasesResponse>;
export interface ListUserHierarchyGroupsResponse {
  UserHierarchyGroupSummaryList?: HierarchyGroupSummary[];
  NextToken?: string;
}
export const ListUserHierarchyGroupsResponse = S.suspend(() =>
  S.Struct({
    UserHierarchyGroupSummaryList: S.optional(HierarchyGroupSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListUserHierarchyGroupsResponse",
}) as any as S.Schema<ListUserHierarchyGroupsResponse>;
export interface ListUsersResponse {
  UserSummaryList?: UserSummary[];
  NextToken?: string;
}
export const ListUsersResponse = S.suspend(() =>
  S.Struct({
    UserSummaryList: S.optional(UserSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListUsersResponse",
}) as any as S.Schema<ListUsersResponse>;
export interface ListViewsResponse {
  ViewsSummaryList?: ViewSummary[];
  NextToken?: string;
}
export const ListViewsResponse = S.suspend(() =>
  S.Struct({
    ViewsSummaryList: S.optional(ViewsSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListViewsResponse",
}) as any as S.Schema<ListViewsResponse>;
export interface ListViewVersionsResponse {
  ViewVersionSummaryList?: ViewVersionSummary[];
  NextToken?: string;
}
export const ListViewVersionsResponse = S.suspend(() =>
  S.Struct({
    ViewVersionSummaryList: S.optional(ViewVersionSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListViewVersionsResponse",
}) as any as S.Schema<ListViewVersionsResponse>;
export interface ListWorkspaceMediaResponse {
  Media?: MediaItem[];
}
export const ListWorkspaceMediaResponse = S.suspend(() =>
  S.Struct({ Media: S.optional(MediaList) }),
).annotations({
  identifier: "ListWorkspaceMediaResponse",
}) as any as S.Schema<ListWorkspaceMediaResponse>;
export interface ListWorkspacePagesResponse {
  NextToken?: string;
  WorkspacePageList: WorkspacePage[];
}
export const ListWorkspacePagesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    WorkspacePageList: WorkspacePageList,
  }),
).annotations({
  identifier: "ListWorkspacePagesResponse",
}) as any as S.Schema<ListWorkspacePagesResponse>;
export interface ListWorkspacesResponse {
  NextToken?: string;
  WorkspaceSummaryList: WorkspaceSummary[];
}
export const ListWorkspacesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    WorkspaceSummaryList: WorkspaceSummaryList,
  }),
).annotations({
  identifier: "ListWorkspacesResponse",
}) as any as S.Schema<ListWorkspacesResponse>;
export interface SearchAvailablePhoneNumbersResponse {
  NextToken?: string;
  AvailableNumbersList?: AvailableNumberSummary[];
}
export const SearchAvailablePhoneNumbersResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    AvailableNumbersList: S.optional(AvailableNumbersList),
  }),
).annotations({
  identifier: "SearchAvailablePhoneNumbersResponse",
}) as any as S.Schema<SearchAvailablePhoneNumbersResponse>;
export interface SearchContactEvaluationsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: EvaluationSearchCriteria;
  SearchFilter?: EvaluationSearchFilter;
}
export const SearchContactEvaluationsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(EvaluationSearchCriteria),
    SearchFilter: S.optional(EvaluationSearchFilter),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contact-evaluations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchContactEvaluationsRequest",
}) as any as S.Schema<SearchContactEvaluationsRequest>;
export interface SearchContactFlowModulesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: ContactFlowModuleSearchFilter;
  SearchCriteria?: ContactFlowModuleSearchCriteria;
}
export const SearchContactFlowModulesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(ContactFlowModuleSearchFilter),
    SearchCriteria: S.optional(ContactFlowModuleSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contact-flow-modules" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchContactFlowModulesRequest",
}) as any as S.Schema<SearchContactFlowModulesRequest>;
export type SearchContactsTimeRangeConditionType = "NOT_EXISTS" | (string & {});
export const SearchContactsTimeRangeConditionType = S.String;
export interface SearchDataTablesResponse {
  DataTables?: DataTable[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchDataTablesResponse = S.suspend(() =>
  S.Struct({
    DataTables: S.optional(DataTableList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchDataTablesResponse",
}) as any as S.Schema<SearchDataTablesResponse>;
export interface SearchHoursOfOperationOverridesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: HoursOfOperationSearchFilter;
  SearchCriteria?: HoursOfOperationOverrideSearchCriteria;
}
export const SearchHoursOfOperationOverridesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(HoursOfOperationSearchFilter),
    SearchCriteria: S.optional(HoursOfOperationOverrideSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-hours-of-operation-overrides" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchHoursOfOperationOverridesRequest",
}) as any as S.Schema<SearchHoursOfOperationOverridesRequest>;
export interface SearchHoursOfOperationsResponse {
  HoursOfOperations?: HoursOfOperation[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperations: S.optional(HoursOfOperationList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchHoursOfOperationsResponse",
}) as any as S.Schema<SearchHoursOfOperationsResponse>;
export interface SearchPredefinedAttributesResponse {
  PredefinedAttributes?: PredefinedAttribute[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchPredefinedAttributesResponse = S.suspend(() =>
  S.Struct({
    PredefinedAttributes: S.optional(PredefinedAttributeSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchPredefinedAttributesResponse",
}) as any as S.Schema<SearchPredefinedAttributesResponse>;
export interface SearchPromptsResponse {
  Prompts?: Prompt[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchPromptsResponse = S.suspend(() =>
  S.Struct({
    Prompts: S.optional(PromptList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchPromptsResponse",
}) as any as S.Schema<SearchPromptsResponse>;
export interface SearchQueuesResponse {
  Queues?: Queue[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchQueuesResponse = S.suspend(() =>
  S.Struct({
    Queues: S.optional(QueueSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchQueuesResponse",
}) as any as S.Schema<SearchQueuesResponse>;
export interface SearchQuickConnectsResponse {
  QuickConnects?: QuickConnect[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchQuickConnectsResponse = S.suspend(() =>
  S.Struct({
    QuickConnects: S.optional(QuickConnectSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchQuickConnectsResponse",
}) as any as S.Schema<SearchQuickConnectsResponse>;
export interface SearchResourceTagsRequest {
  InstanceId: string;
  ResourceTypes?: string[];
  NextToken?: string;
  MaxResults?: number;
  SearchCriteria?: ResourceTagsSearchCriteria;
}
export const SearchResourceTagsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ResourceTypes: S.optional(ResourceTypeList),
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchCriteria: S.optional(ResourceTagsSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-resource-tags" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchResourceTagsRequest",
}) as any as S.Schema<SearchResourceTagsRequest>;
export interface SearchRoutingProfilesResponse {
  RoutingProfiles?: RoutingProfile[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchRoutingProfilesResponse = S.suspend(() =>
  S.Struct({
    RoutingProfiles: S.optional(RoutingProfileList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchRoutingProfilesResponse",
}) as any as S.Schema<SearchRoutingProfilesResponse>;
export interface SearchUserHierarchyGroupsResponse {
  UserHierarchyGroups?: HierarchyGroup[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchUserHierarchyGroupsResponse = S.suspend(() =>
  S.Struct({
    UserHierarchyGroups: S.optional(UserHierarchyGroupList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchUserHierarchyGroupsResponse",
}) as any as S.Schema<SearchUserHierarchyGroupsResponse>;
export interface SearchViewsResponse {
  Views?: View[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchViewsResponse = S.suspend(() =>
  S.Struct({
    Views: S.optional(ViewSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchViewsResponse",
}) as any as S.Schema<SearchViewsResponse>;
export interface SearchVocabulariesResponse {
  VocabularySummaryList?: VocabularySummary[];
  NextToken?: string;
}
export const SearchVocabulariesResponse = S.suspend(() =>
  S.Struct({
    VocabularySummaryList: S.optional(VocabularySummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "SearchVocabulariesResponse",
}) as any as S.Schema<SearchVocabulariesResponse>;
export interface SendChatIntegrationEventResponse {
  InitialContactId?: string;
  NewChatCreated?: boolean;
}
export const SendChatIntegrationEventResponse = S.suspend(() =>
  S.Struct({
    InitialContactId: S.optional(S.String),
    NewChatCreated: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "SendChatIntegrationEventResponse",
}) as any as S.Schema<SendChatIntegrationEventResponse>;
export interface SendOutboundEmailRequest {
  InstanceId: string;
  FromEmailAddress: EmailAddressInfo;
  DestinationEmailAddress: EmailAddressInfo;
  AdditionalRecipients?: OutboundAdditionalRecipients;
  EmailMessage: OutboundEmailContent;
  TrafficType: TrafficType;
  SourceCampaign?: SourceCampaign;
  ClientToken?: string;
}
export const SendOutboundEmailRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    FromEmailAddress: EmailAddressInfo,
    DestinationEmailAddress: EmailAddressInfo,
    AdditionalRecipients: S.optional(OutboundAdditionalRecipients),
    EmailMessage: OutboundEmailContent,
    TrafficType: TrafficType,
    SourceCampaign: S.optional(SourceCampaign),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/outbound-email" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SendOutboundEmailRequest",
}) as any as S.Schema<SendOutboundEmailRequest>;
export interface SendOutboundEmailResponse {}
export const SendOutboundEmailResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "SendOutboundEmailResponse",
}) as any as S.Schema<SendOutboundEmailResponse>;
export interface StartChatContactResponse {
  ContactId?: string;
  ParticipantId?: string;
  ParticipantToken?: string;
  ContinuedFromContactId?: string;
}
export const StartChatContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ParticipantId: S.optional(S.String),
    ParticipantToken: S.optional(S.String),
    ContinuedFromContactId: S.optional(S.String),
  }),
).annotations({
  identifier: "StartChatContactResponse",
}) as any as S.Schema<StartChatContactResponse>;
export interface StartContactEvaluationResponse {
  EvaluationId: string;
  EvaluationArn: string;
}
export const StartContactEvaluationResponse = S.suspend(() =>
  S.Struct({ EvaluationId: S.String, EvaluationArn: S.String }),
).annotations({
  identifier: "StartContactEvaluationResponse",
}) as any as S.Schema<StartContactEvaluationResponse>;
export interface StartContactStreamingResponse {
  StreamingId: string;
}
export const StartContactStreamingResponse = S.suspend(() =>
  S.Struct({ StreamingId: S.String }),
).annotations({
  identifier: "StartContactStreamingResponse",
}) as any as S.Schema<StartContactStreamingResponse>;
export interface StartOutboundChatContactRequest {
  SourceEndpoint: Endpoint;
  DestinationEndpoint: Endpoint;
  InstanceId: string;
  SegmentAttributes: { [key: string]: SegmentAttributeValue | undefined };
  Attributes?: { [key: string]: string | undefined };
  ContactFlowId: string;
  ChatDurationInMinutes?: number;
  ParticipantDetails?: ParticipantDetails;
  InitialSystemMessage?: ChatMessage;
  InitialTemplatedSystemMessage?: TemplatedMessageConfig;
  RelatedContactId?: string;
  SupportedMessagingContentTypes?: string[];
  ClientToken?: string;
}
export const StartOutboundChatContactRequest = S.suspend(() =>
  S.Struct({
    SourceEndpoint: Endpoint,
    DestinationEndpoint: Endpoint,
    InstanceId: S.String,
    SegmentAttributes: SegmentAttributes,
    Attributes: S.optional(Attributes),
    ContactFlowId: S.String,
    ChatDurationInMinutes: S.optional(S.Number),
    ParticipantDetails: S.optional(ParticipantDetails),
    InitialSystemMessage: S.optional(ChatMessage),
    InitialTemplatedSystemMessage: S.optional(TemplatedMessageConfig),
    RelatedContactId: S.optional(S.String),
    SupportedMessagingContentTypes: S.optional(SupportedMessagingContentTypes),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/outbound-chat" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartOutboundChatContactRequest",
}) as any as S.Schema<StartOutboundChatContactRequest>;
export interface UpdateDataTablePrimaryValuesResponse {
  LockVersion: DataTableLockVersion;
}
export const UpdateDataTablePrimaryValuesResponse = S.suspend(() =>
  S.Struct({ LockVersion: DataTableLockVersion }),
).annotations({
  identifier: "UpdateDataTablePrimaryValuesResponse",
}) as any as S.Schema<UpdateDataTablePrimaryValuesResponse>;
export type ParticipantTimerAction = "Unset" | (string & {});
export const ParticipantTimerAction = S.String;
export interface UpdateTrafficDistributionRequest {
  Id: string;
  TelephonyConfig?: TelephonyConfig;
  SignInConfig?: SignInConfig;
  AgentConfig?: AgentConfig;
}
export const UpdateTrafficDistributionRequest = S.suspend(() =>
  S.Struct({
    Id: S.String.pipe(T.HttpLabel("Id")),
    TelephonyConfig: S.optional(TelephonyConfig),
    SignInConfig: S.optional(SignInConfig),
    AgentConfig: S.optional(AgentConfig),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/traffic-distribution/{Id}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTrafficDistributionRequest",
}) as any as S.Schema<UpdateTrafficDistributionRequest>;
export interface UpdateTrafficDistributionResponse {}
export const UpdateTrafficDistributionResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateTrafficDistributionResponse",
}) as any as S.Schema<UpdateTrafficDistributionResponse>;
export interface UpdateUserHierarchyStructureRequest {
  HierarchyStructure: HierarchyStructureUpdate;
  InstanceId: string;
}
export const UpdateUserHierarchyStructureRequest = S.suspend(() =>
  S.Struct({
    HierarchyStructure: HierarchyStructureUpdate,
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/user-hierarchy-structure/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserHierarchyStructureRequest",
}) as any as S.Schema<UpdateUserHierarchyStructureRequest>;
export interface UpdateUserHierarchyStructureResponse {}
export const UpdateUserHierarchyStructureResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateUserHierarchyStructureResponse",
}) as any as S.Schema<UpdateUserHierarchyStructureResponse>;
export type AttachedFileInvalidRequestExceptionReason =
  | "INVALID_FILE_SIZE"
  | "INVALID_FILE_TYPE"
  | "INVALID_FILE_NAME"
  | (string & {});
export const AttachedFileInvalidRequestExceptionReason = S.String;
export interface QueueInfo {
  Id?: string;
  EnqueueTimestamp?: Date;
}
export const QueueInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    EnqueueTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({ identifier: "QueueInfo" }) as any as S.Schema<QueueInfo>;
export interface EndpointInfo {
  Type?: EndpointType;
  Address?: string;
  DisplayName?: string;
}
export const EndpointInfo = S.suspend(() =>
  S.Struct({
    Type: S.optional(EndpointType),
    Address: S.optional(S.String),
    DisplayName: S.optional(S.String),
  }),
).annotations({ identifier: "EndpointInfo" }) as any as S.Schema<EndpointInfo>;
export interface DeviceInfo {
  PlatformName?: string;
  PlatformVersion?: string;
  OperatingSystem?: string;
}
export const DeviceInfo = S.suspend(() =>
  S.Struct({
    PlatformName: S.optional(S.String),
    PlatformVersion: S.optional(S.String),
    OperatingSystem: S.optional(S.String),
  }),
).annotations({ identifier: "DeviceInfo" }) as any as S.Schema<DeviceInfo>;
export interface Customer {
  DeviceInfo?: DeviceInfo;
  Capabilities?: ParticipantCapabilities;
}
export const Customer = S.suspend(() =>
  S.Struct({
    DeviceInfo: S.optional(DeviceInfo),
    Capabilities: S.optional(ParticipantCapabilities),
  }),
).annotations({ identifier: "Customer" }) as any as S.Schema<Customer>;
export interface CustomerVoiceActivity {
  GreetingStartTimestamp?: Date;
  GreetingEndTimestamp?: Date;
}
export const CustomerVoiceActivity = S.suspend(() =>
  S.Struct({
    GreetingStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    GreetingEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "CustomerVoiceActivity",
}) as any as S.Schema<CustomerVoiceActivity>;
export interface DisconnectDetails {
  PotentialDisconnectIssue?: string;
}
export const DisconnectDetails = S.suspend(() =>
  S.Struct({ PotentialDisconnectIssue: S.optional(S.String) }),
).annotations({
  identifier: "DisconnectDetails",
}) as any as S.Schema<DisconnectDetails>;
export interface RecordingInfo {
  StorageType?: StorageType;
  Location?: string;
  MediaStreamType?: MediaStreamType;
  ParticipantType?: ParticipantType;
  FragmentStartNumber?: string;
  FragmentStopNumber?: string;
  StartTimestamp?: Date;
  StopTimestamp?: Date;
  Status?: RecordingStatus;
  DeletionReason?: string;
  UnprocessedTranscriptLocation?: string;
}
export const RecordingInfo = S.suspend(() =>
  S.Struct({
    StorageType: S.optional(StorageType),
    Location: S.optional(S.String),
    MediaStreamType: S.optional(MediaStreamType),
    ParticipantType: S.optional(ParticipantType),
    FragmentStartNumber: S.optional(S.String),
    FragmentStopNumber: S.optional(S.String),
    StartTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    StopTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(RecordingStatus),
    DeletionReason: S.optional(S.String),
    UnprocessedTranscriptLocation: S.optional(S.String),
  }),
).annotations({
  identifier: "RecordingInfo",
}) as any as S.Schema<RecordingInfo>;
export type Recordings = RecordingInfo[];
export const Recordings = S.Array(RecordingInfo);
export interface TaskTemplateInfoV2 {
  Arn?: string;
  Name?: string;
}
export const TaskTemplateInfoV2 = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), Name: S.optional(S.String) }),
).annotations({
  identifier: "TaskTemplateInfoV2",
}) as any as S.Schema<TaskTemplateInfoV2>;
export interface ContactDetails {
  Name?: string;
  Description?: string;
}
export const ContactDetails = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Description: S.optional(S.String) }),
).annotations({
  identifier: "ContactDetails",
}) as any as S.Schema<ContactDetails>;
export interface GlobalResiliencyMetadata {
  ActiveRegion?: string;
  OriginRegion?: string;
  TrafficDistributionGroupId?: string;
}
export const GlobalResiliencyMetadata = S.suspend(() =>
  S.Struct({
    ActiveRegion: S.optional(S.String),
    OriginRegion: S.optional(S.String),
    TrafficDistributionGroupId: S.optional(S.String),
  }),
).annotations({
  identifier: "GlobalResiliencyMetadata",
}) as any as S.Schema<GlobalResiliencyMetadata>;
export interface EvaluationScore {
  Percentage?: number;
  NotApplicable?: boolean;
  AutomaticFail?: boolean;
  AppliedWeight?: number;
}
export const EvaluationScore = S.suspend(() =>
  S.Struct({
    Percentage: S.optional(S.Number),
    NotApplicable: S.optional(S.Boolean),
    AutomaticFail: S.optional(S.Boolean),
    AppliedWeight: S.optional(S.Number),
  }),
).annotations({
  identifier: "EvaluationScore",
}) as any as S.Schema<EvaluationScore>;
export type EvaluationScoresMap = {
  [key: string]: EvaluationScore | undefined;
};
export const EvaluationScoresMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(EvaluationScore),
});
export interface InstanceStatusReason {
  Message?: string;
}
export const InstanceStatusReason = S.suspend(() =>
  S.Struct({ Message: S.optional(S.String) }),
).annotations({
  identifier: "InstanceStatusReason",
}) as any as S.Schema<InstanceStatusReason>;
export interface ReplicationStatusSummary {
  Region?: string;
  ReplicationStatus?: InstanceReplicationStatus;
  ReplicationStatusReason?: string;
}
export const ReplicationStatusSummary = S.suspend(() =>
  S.Struct({
    Region: S.optional(S.String),
    ReplicationStatus: S.optional(InstanceReplicationStatus),
    ReplicationStatusReason: S.optional(S.String),
  }),
).annotations({
  identifier: "ReplicationStatusSummary",
}) as any as S.Schema<ReplicationStatusSummary>;
export type ReplicationStatusSummaryList = ReplicationStatusSummary[];
export const ReplicationStatusSummaryList = S.Array(ReplicationStatusSummary);
export interface PhoneNumberStatus {
  Status?: PhoneNumberWorkflowStatus;
  Message?: string;
}
export const PhoneNumberStatus = S.suspend(() =>
  S.Struct({
    Status: S.optional(PhoneNumberWorkflowStatus),
    Message: S.optional(S.String),
  }),
).annotations({
  identifier: "PhoneNumberStatus",
}) as any as S.Schema<PhoneNumberStatus>;
export interface HierarchyLevel {
  Id?: string;
  Arn?: string;
  Name?: string;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const HierarchyLevel = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "HierarchyLevel",
}) as any as S.Schema<HierarchyLevel>;
export interface OperationalHour {
  Start?: OverrideTimeSlice;
  End?: OverrideTimeSlice;
}
export const OperationalHour = S.suspend(() =>
  S.Struct({
    Start: S.optional(OverrideTimeSlice),
    End: S.optional(OverrideTimeSlice),
  }),
).annotations({
  identifier: "OperationalHour",
}) as any as S.Schema<OperationalHour>;
export type OperationalHours = OperationalHour[];
export const OperationalHours = S.Array(OperationalHour);
export interface EvaluationAcknowledgementSummary {
  AcknowledgedTime?: Date;
  AcknowledgedBy?: string;
  AcknowledgerComment?: string;
}
export const EvaluationAcknowledgementSummary = S.suspend(() =>
  S.Struct({
    AcknowledgedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AcknowledgedBy: S.optional(S.String),
    AcknowledgerComment: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationAcknowledgementSummary",
}) as any as S.Schema<EvaluationAcknowledgementSummary>;
export interface EvaluationContactParticipant {
  ContactParticipantRole?: ContactParticipantRole;
  ContactParticipantId?: string;
}
export const EvaluationContactParticipant = S.suspend(() =>
  S.Struct({
    ContactParticipantRole: S.optional(ContactParticipantRole),
    ContactParticipantId: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationContactParticipant",
}) as any as S.Schema<EvaluationContactParticipant>;
export interface UrlReference {
  Name?: string;
  Value?: string;
}
export const UrlReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotations({ identifier: "UrlReference" }) as any as S.Schema<UrlReference>;
export interface AttachmentReference {
  Name?: string;
  Value?: string;
  Status?: ReferenceStatus;
  Arn?: string;
}
export const AttachmentReference = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Value: S.optional(S.String),
    Status: S.optional(ReferenceStatus),
    Arn: S.optional(S.String),
  }),
).annotations({
  identifier: "AttachmentReference",
}) as any as S.Schema<AttachmentReference>;
export interface EmailMessageReference {
  Name?: string;
  Arn?: string;
}
export const EmailMessageReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "EmailMessageReference",
}) as any as S.Schema<EmailMessageReference>;
export interface StringReference {
  Name?: string;
  Value?: string;
}
export const StringReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotations({
  identifier: "StringReference",
}) as any as S.Schema<StringReference>;
export interface NumberReference {
  Name?: string;
  Value?: string;
}
export const NumberReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotations({
  identifier: "NumberReference",
}) as any as S.Schema<NumberReference>;
export interface DateReference {
  Name?: string;
  Value?: string;
}
export const DateReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotations({
  identifier: "DateReference",
}) as any as S.Schema<DateReference>;
export interface EmailReference {
  Name?: string;
  Value?: string;
}
export const EmailReference = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotations({
  identifier: "EmailReference",
}) as any as S.Schema<EmailReference>;
export interface PrimaryValueResponse {
  AttributeName?: string;
  AttributeId?: string;
  Value?: string;
}
export const PrimaryValueResponse = S.suspend(() =>
  S.Struct({
    AttributeName: S.optional(S.String),
    AttributeId: S.optional(S.String),
    Value: S.optional(S.String),
  }),
).annotations({
  identifier: "PrimaryValueResponse",
}) as any as S.Schema<PrimaryValueResponse>;
export type PrimaryValuesResponseSet = PrimaryValueResponse[];
export const PrimaryValuesResponseSet = S.Array(PrimaryValueResponse);
export type RealTimeContactAnalysisTimeData = { AbsoluteTime: Date };
export const RealTimeContactAnalysisTimeData = S.Union(
  S.Struct({ AbsoluteTime: S.Date.pipe(T.TimestampFormat("date-time")) }),
);
export interface RealTimeContactAnalysisSegmentEvent {
  Id: string;
  ParticipantId?: string;
  ParticipantRole?: ParticipantRole;
  DisplayName?: string;
  EventType: string;
  Time: RealTimeContactAnalysisTimeData;
}
export const RealTimeContactAnalysisSegmentEvent = S.suspend(() =>
  S.Struct({
    Id: S.String,
    ParticipantId: S.optional(S.String),
    ParticipantRole: S.optional(ParticipantRole),
    DisplayName: S.optional(S.String),
    EventType: S.String,
    Time: RealTimeContactAnalysisTimeData,
  }),
).annotations({
  identifier: "RealTimeContactAnalysisSegmentEvent",
}) as any as S.Schema<RealTimeContactAnalysisSegmentEvent>;
export interface RealTimeContactAnalysisSegmentPostContactSummary {
  Content?: string;
  Status: RealTimeContactAnalysisPostContactSummaryStatus;
  FailureCode?: RealTimeContactAnalysisPostContactSummaryFailureCode;
}
export const RealTimeContactAnalysisSegmentPostContactSummary = S.suspend(() =>
  S.Struct({
    Content: S.optional(S.String),
    Status: RealTimeContactAnalysisPostContactSummaryStatus,
    FailureCode: S.optional(
      RealTimeContactAnalysisPostContactSummaryFailureCode,
    ),
  }),
).annotations({
  identifier: "RealTimeContactAnalysisSegmentPostContactSummary",
}) as any as S.Schema<RealTimeContactAnalysisSegmentPostContactSummary>;
export interface ActionSummary {
  ActionType: ActionType;
}
export const ActionSummary = S.suspend(() =>
  S.Struct({ ActionType: ActionType }),
).annotations({
  identifier: "ActionSummary",
}) as any as S.Schema<ActionSummary>;
export type ActionSummaries = ActionSummary[];
export const ActionSummaries = S.Array(ActionSummary);
export interface ContactFlowAttributeFilter {
  OrConditions?: ContactFlowAttributeAndCondition[];
  AndCondition?: ContactFlowAttributeAndCondition;
  TagCondition?: TagCondition;
  ContactFlowTypeCondition?: ContactFlowTypeCondition;
}
export const ContactFlowAttributeFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(ContactFlowAttributeOrConditionList),
    AndCondition: S.optional(ContactFlowAttributeAndCondition),
    TagCondition: S.optional(TagCondition),
    ContactFlowTypeCondition: S.optional(ContactFlowTypeCondition),
  }),
).annotations({
  identifier: "ContactFlowAttributeFilter",
}) as any as S.Schema<ContactFlowAttributeFilter>;
export interface SearchableContactAttributes {
  Criteria: SearchableContactAttributesCriteria[];
  MatchType?: SearchContactsMatchType;
}
export const SearchableContactAttributes = S.suspend(() =>
  S.Struct({
    Criteria: SearchableContactAttributesCriteriaList,
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotations({
  identifier: "SearchableContactAttributes",
}) as any as S.Schema<SearchableContactAttributes>;
export interface SearchableSegmentAttributes {
  Criteria: SearchableSegmentAttributesCriteria[];
  MatchType?: SearchContactsMatchType;
}
export const SearchableSegmentAttributes = S.suspend(() =>
  S.Struct({
    Criteria: SearchableSegmentAttributesCriteriaList,
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotations({
  identifier: "SearchableSegmentAttributes",
}) as any as S.Schema<SearchableSegmentAttributes>;
export interface ControlPlaneUserAttributeFilter {
  OrConditions?: AttributeAndCondition[];
  AndCondition?: AttributeAndCondition;
  TagCondition?: TagCondition;
  HierarchyGroupCondition?: HierarchyGroupCondition;
}
export const ControlPlaneUserAttributeFilter = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(AttributeOrConditionList),
    AndCondition: S.optional(AttributeAndCondition),
    TagCondition: S.optional(TagCondition),
    HierarchyGroupCondition: S.optional(HierarchyGroupCondition),
  }),
).annotations({
  identifier: "ControlPlaneUserAttributeFilter",
}) as any as S.Schema<ControlPlaneUserAttributeFilter>;
export interface ListCondition {
  TargetListType?: TargetListType;
  Conditions?: Condition[];
}
export const ListCondition = S.suspend(() =>
  S.Struct({
    TargetListType: S.optional(TargetListType),
    Conditions: S.optional(Conditions),
  }),
).annotations({
  identifier: "ListCondition",
}) as any as S.Schema<ListCondition>;
export interface InboundRawMessage {
  Subject: string | redacted.Redacted<string>;
  Body: string | redacted.Redacted<string>;
  ContentType: string;
  Headers?: { [key: string]: string | undefined };
}
export const InboundRawMessage = S.suspend(() =>
  S.Struct({
    Subject: SensitiveString,
    Body: SensitiveString,
    ContentType: S.String,
    Headers: S.optional(EmailHeaders),
  }),
).annotations({
  identifier: "InboundRawMessage",
}) as any as S.Schema<InboundRawMessage>;
export type ParticipantState =
  | "INITIAL"
  | "CONNECTED"
  | "DISCONNECTED"
  | "MISSED"
  | (string & {});
export const ParticipantState = S.String;
export type AiUseCase = "AgentAssistance" | "SelfService" | (string & {});
export const AiUseCase = S.String;
export type RoutingCriteriaStepStatus =
  | "ACTIVE"
  | "INACTIVE"
  | "JOINED"
  | "EXPIRED"
  | (string & {});
export const RoutingCriteriaStepStatus = S.String;
export type Status = "COMPLETE" | "IN_PROGRESS" | "DELETED" | (string & {});
export const Status = S.String;
export type ArtifactStatus =
  | "APPROVED"
  | "REJECTED"
  | "IN_PROGRESS"
  | (string & {});
export const ArtifactStatus = S.String;
export interface TranscriptCriteria {
  ParticipantRole: ParticipantRole;
  SearchText: string | redacted.Redacted<string>[];
  MatchType: SearchContactsMatchType;
}
export const TranscriptCriteria = S.suspend(() =>
  S.Struct({
    ParticipantRole: ParticipantRole,
    SearchText: SearchTextList,
    MatchType: SearchContactsMatchType,
  }),
).annotations({
  identifier: "TranscriptCriteria",
}) as any as S.Schema<TranscriptCriteria>;
export type TranscriptCriteriaList = TranscriptCriteria[];
export const TranscriptCriteriaList = S.Array(TranscriptCriteria);
export interface SearchableAgentCriteriaStep {
  AgentIds?: string[];
  MatchType?: SearchContactsMatchType;
}
export const SearchableAgentCriteriaStep = S.suspend(() =>
  S.Struct({
    AgentIds: S.optional(AgentResourceIdList),
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotations({
  identifier: "SearchableAgentCriteriaStep",
}) as any as S.Schema<SearchableAgentCriteriaStep>;
export interface SearchContactsTimestampCondition {
  Type: SearchContactsTimeRangeType;
  ConditionType: SearchContactsTimeRangeConditionType;
}
export const SearchContactsTimestampCondition = S.suspend(() =>
  S.Struct({
    Type: SearchContactsTimeRangeType,
    ConditionType: SearchContactsTimeRangeConditionType,
  }),
).annotations({
  identifier: "SearchContactsTimestampCondition",
}) as any as S.Schema<SearchContactsTimestampCondition>;
export type ParticipantTimerValue =
  | {
      ParticipantTimerAction: ParticipantTimerAction;
      ParticipantTimerDurationInMinutes?: never;
    }
  | {
      ParticipantTimerAction?: never;
      ParticipantTimerDurationInMinutes: number;
    };
export const ParticipantTimerValue = S.Union(
  S.Struct({ ParticipantTimerAction: ParticipantTimerAction }),
  S.Struct({ ParticipantTimerDurationInMinutes: S.Number }),
);
export type InvalidRequestExceptionReason = {
  AttachedFileInvalidRequestExceptionReason: AttachedFileInvalidRequestExceptionReason;
};
export const InvalidRequestExceptionReason = S.Union(
  S.Struct({
    AttachedFileInvalidRequestExceptionReason:
      AttachedFileInvalidRequestExceptionReason,
  }),
);
export interface BatchCreateDataTableValueSuccessResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  RecordId: string;
  LockVersion: DataTableLockVersion;
}
export const BatchCreateDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    RecordId: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotations({
  identifier: "BatchCreateDataTableValueSuccessResult",
}) as any as S.Schema<BatchCreateDataTableValueSuccessResult>;
export type BatchCreateDataTableValueSuccessResultList =
  BatchCreateDataTableValueSuccessResult[];
export const BatchCreateDataTableValueSuccessResultList = S.Array(
  BatchCreateDataTableValueSuccessResult,
);
export interface BatchCreateDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchCreateDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotations({
  identifier: "BatchCreateDataTableValueFailureResult",
}) as any as S.Schema<BatchCreateDataTableValueFailureResult>;
export type BatchCreateDataTableValueFailureResultList =
  BatchCreateDataTableValueFailureResult[];
export const BatchCreateDataTableValueFailureResultList = S.Array(
  BatchCreateDataTableValueFailureResult,
);
export interface BatchDeleteDataTableValueSuccessResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  LockVersion: DataTableLockVersion;
}
export const BatchDeleteDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    LockVersion: DataTableLockVersion,
  }),
).annotations({
  identifier: "BatchDeleteDataTableValueSuccessResult",
}) as any as S.Schema<BatchDeleteDataTableValueSuccessResult>;
export type BatchDeleteDataTableValueSuccessResultList =
  BatchDeleteDataTableValueSuccessResult[];
export const BatchDeleteDataTableValueSuccessResultList = S.Array(
  BatchDeleteDataTableValueSuccessResult,
);
export interface BatchDeleteDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchDeleteDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotations({
  identifier: "BatchDeleteDataTableValueFailureResult",
}) as any as S.Schema<BatchDeleteDataTableValueFailureResult>;
export type BatchDeleteDataTableValueFailureResultList =
  BatchDeleteDataTableValueFailureResult[];
export const BatchDeleteDataTableValueFailureResultList = S.Array(
  BatchDeleteDataTableValueFailureResult,
);
export interface BatchDescribeDataTableValueSuccessResult {
  RecordId: string;
  AttributeId: string;
  PrimaryValues: PrimaryValueResponse[];
  AttributeName: string;
  Value?: string;
  LockVersion: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const BatchDescribeDataTableValueSuccessResult = S.suspend(() =>
  S.Struct({
    RecordId: S.String,
    AttributeId: S.String,
    PrimaryValues: PrimaryValuesResponseSet,
    AttributeName: S.String,
    Value: S.optional(S.String),
    LockVersion: DataTableLockVersion,
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "BatchDescribeDataTableValueSuccessResult",
}) as any as S.Schema<BatchDescribeDataTableValueSuccessResult>;
export type BatchDescribeDataTableValueSuccessResultList =
  BatchDescribeDataTableValueSuccessResult[];
export const BatchDescribeDataTableValueSuccessResultList = S.Array(
  BatchDescribeDataTableValueSuccessResult,
);
export interface BatchDescribeDataTableValueFailureResult {
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  Message: string;
}
export const BatchDescribeDataTableValueFailureResult = S.suspend(() =>
  S.Struct({
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    Message: S.String,
  }),
).annotations({
  identifier: "BatchDescribeDataTableValueFailureResult",
}) as any as S.Schema<BatchDescribeDataTableValueFailureResult>;
export type BatchDescribeDataTableValueFailureResultList =
  BatchDescribeDataTableValueFailureResult[];
export const BatchDescribeDataTableValueFailureResultList = S.Array(
  BatchDescribeDataTableValueFailureResult,
);
export type ReferenceIdList = string[];
export const ReferenceIdList = S.Array(S.String);
export interface Instance {
  Id?: string;
  Arn?: string;
  IdentityManagementType?: DirectoryType;
  InstanceAlias?: string | redacted.Redacted<string>;
  CreatedTime?: Date;
  ServiceRole?: string;
  InstanceStatus?: InstanceStatus;
  StatusReason?: InstanceStatusReason;
  InboundCallsEnabled?: boolean;
  OutboundCallsEnabled?: boolean;
  InstanceAccessUrl?: string;
  Tags?: { [key: string]: string | undefined };
}
export const Instance = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
    IdentityManagementType: S.optional(DirectoryType),
    InstanceAlias: S.optional(SensitiveString),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ServiceRole: S.optional(S.String),
    InstanceStatus: S.optional(InstanceStatus),
    StatusReason: S.optional(InstanceStatusReason),
    InboundCallsEnabled: S.optional(S.Boolean),
    OutboundCallsEnabled: S.optional(S.Boolean),
    InstanceAccessUrl: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotations({ identifier: "Instance" }) as any as S.Schema<Instance>;
export interface ReplicationConfiguration {
  ReplicationStatusSummaryList?: ReplicationStatusSummary[];
  SourceRegion?: string;
  GlobalSignInEndpoint?: string;
}
export const ReplicationConfiguration = S.suspend(() =>
  S.Struct({
    ReplicationStatusSummaryList: S.optional(ReplicationStatusSummaryList),
    SourceRegion: S.optional(S.String),
    GlobalSignInEndpoint: S.optional(S.String),
  }),
).annotations({
  identifier: "ReplicationConfiguration",
}) as any as S.Schema<ReplicationConfiguration>;
export interface ClaimedPhoneNumberSummary {
  PhoneNumberId?: string;
  PhoneNumberArn?: string;
  PhoneNumber?: string;
  PhoneNumberCountryCode?: PhoneNumberCountryCode;
  PhoneNumberType?: PhoneNumberType;
  PhoneNumberDescription?: string;
  TargetArn?: string;
  InstanceId?: string;
  Tags?: { [key: string]: string | undefined };
  PhoneNumberStatus?: PhoneNumberStatus;
  SourcePhoneNumberArn?: string;
}
export const ClaimedPhoneNumberSummary = S.suspend(() =>
  S.Struct({
    PhoneNumberId: S.optional(S.String),
    PhoneNumberArn: S.optional(S.String),
    PhoneNumber: S.optional(S.String),
    PhoneNumberCountryCode: S.optional(PhoneNumberCountryCode),
    PhoneNumberType: S.optional(PhoneNumberType),
    PhoneNumberDescription: S.optional(S.String),
    TargetArn: S.optional(S.String),
    InstanceId: S.optional(S.String),
    Tags: S.optional(TagMap),
    PhoneNumberStatus: S.optional(PhoneNumberStatus),
    SourcePhoneNumberArn: S.optional(S.String),
  }),
).annotations({
  identifier: "ClaimedPhoneNumberSummary",
}) as any as S.Schema<ClaimedPhoneNumberSummary>;
export interface HierarchyStructure {
  LevelOne?: HierarchyLevel;
  LevelTwo?: HierarchyLevel;
  LevelThree?: HierarchyLevel;
  LevelFour?: HierarchyLevel;
  LevelFive?: HierarchyLevel;
}
export const HierarchyStructure = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyLevel),
    LevelTwo: S.optional(HierarchyLevel),
    LevelThree: S.optional(HierarchyLevel),
    LevelFour: S.optional(HierarchyLevel),
    LevelFive: S.optional(HierarchyLevel),
  }),
).annotations({
  identifier: "HierarchyStructure",
}) as any as S.Schema<HierarchyStructure>;
export interface DataTableEvaluatedValue {
  RecordId: string;
  PrimaryValues: PrimaryValue[];
  AttributeName: string;
  ValueType: DataTableAttributeValueType;
  Found: boolean;
  Error: boolean;
  EvaluatedValue: string;
}
export const DataTableEvaluatedValue = S.suspend(() =>
  S.Struct({
    RecordId: S.String,
    PrimaryValues: PrimaryValuesSet,
    AttributeName: S.String,
    ValueType: DataTableAttributeValueType,
    Found: S.Boolean,
    Error: S.Boolean,
    EvaluatedValue: S.String,
  }),
).annotations({
  identifier: "DataTableEvaluatedValue",
}) as any as S.Schema<DataTableEvaluatedValue>;
export type DataTableEvaluatedValueList = DataTableEvaluatedValue[];
export const DataTableEvaluatedValueList = S.Array(DataTableEvaluatedValue);
export interface EffectiveHoursOfOperations {
  Date?: string;
  OperationalHours?: OperationalHour[];
}
export const EffectiveHoursOfOperations = S.suspend(() =>
  S.Struct({
    Date: S.optional(S.String),
    OperationalHours: S.optional(OperationalHours),
  }),
).annotations({
  identifier: "EffectiveHoursOfOperations",
}) as any as S.Schema<EffectiveHoursOfOperations>;
export type EffectiveHoursOfOperationList = EffectiveHoursOfOperations[];
export const EffectiveHoursOfOperationList = S.Array(
  EffectiveHoursOfOperations,
);
export interface EvaluationSummary {
  EvaluationId: string;
  EvaluationArn: string;
  EvaluationFormTitle: string;
  EvaluationFormId: string;
  CalibrationSessionId?: string;
  Status: EvaluationStatus;
  AutoEvaluationEnabled?: boolean;
  AutoEvaluationStatus?: AutoEvaluationStatus;
  EvaluatorArn: string;
  Score?: EvaluationScore;
  Acknowledgement?: EvaluationAcknowledgementSummary;
  EvaluationType?: EvaluationType;
  CreatedTime: Date;
  LastModifiedTime: Date;
  ContactParticipant?: EvaluationContactParticipant;
}
export const EvaluationSummary = S.suspend(() =>
  S.Struct({
    EvaluationId: S.String,
    EvaluationArn: S.String,
    EvaluationFormTitle: S.String,
    EvaluationFormId: S.String,
    CalibrationSessionId: S.optional(S.String),
    Status: EvaluationStatus,
    AutoEvaluationEnabled: S.optional(S.Boolean),
    AutoEvaluationStatus: S.optional(AutoEvaluationStatus),
    EvaluatorArn: S.String,
    Score: S.optional(EvaluationScore),
    Acknowledgement: S.optional(EvaluationAcknowledgementSummary),
    EvaluationType: S.optional(EvaluationType),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ContactParticipant: S.optional(EvaluationContactParticipant),
  }),
).annotations({
  identifier: "EvaluationSummary",
}) as any as S.Schema<EvaluationSummary>;
export type EvaluationSummaryList = EvaluationSummary[];
export const EvaluationSummaryList = S.Array(EvaluationSummary);
export type ReferenceSummary =
  | {
      Url: UrlReference;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment: AttachmentReference;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage: EmailMessageReference;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText: EmailMessageReference;
      String?: never;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String: StringReference;
      Number?: never;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number: NumberReference;
      Date?: never;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date: DateReference;
      Email?: never;
    }
  | {
      Url?: never;
      Attachment?: never;
      EmailMessage?: never;
      EmailMessagePlainText?: never;
      String?: never;
      Number?: never;
      Date?: never;
      Email: EmailReference;
    };
export const ReferenceSummary = S.Union(
  S.Struct({ Url: UrlReference }),
  S.Struct({ Attachment: AttachmentReference }),
  S.Struct({ EmailMessage: EmailMessageReference }),
  S.Struct({ EmailMessagePlainText: EmailMessageReference }),
  S.Struct({ String: StringReference }),
  S.Struct({ Number: NumberReference }),
  S.Struct({ Date: DateReference }),
  S.Struct({ Email: EmailReference }),
);
export type ReferenceSummaryList = ReferenceSummary[];
export const ReferenceSummaryList = S.Array(ReferenceSummary);
export interface RecordPrimaryValue {
  RecordId?: string;
  PrimaryValues?: PrimaryValueResponse[];
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const RecordPrimaryValue = S.suspend(() =>
  S.Struct({
    RecordId: S.optional(S.String),
    PrimaryValues: S.optional(PrimaryValuesResponseSet),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "RecordPrimaryValue",
}) as any as S.Schema<RecordPrimaryValue>;
export type PrimaryValuesList = RecordPrimaryValue[];
export const PrimaryValuesList = S.Array(RecordPrimaryValue);
export interface DataTableValueSummary {
  RecordId?: string;
  AttributeId?: string;
  PrimaryValues: PrimaryValueResponse[];
  AttributeName: string;
  ValueType: DataTableAttributeValueType;
  Value: string;
  LockVersion?: DataTableLockVersion;
  LastModifiedTime?: Date;
  LastModifiedRegion?: string;
}
export const DataTableValueSummary = S.suspend(() =>
  S.Struct({
    RecordId: S.optional(S.String),
    AttributeId: S.optional(S.String),
    PrimaryValues: PrimaryValuesResponseSet,
    AttributeName: S.String,
    ValueType: DataTableAttributeValueType,
    Value: S.String,
    LockVersion: S.optional(DataTableLockVersion),
    LastModifiedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastModifiedRegion: S.optional(S.String),
  }),
).annotations({
  identifier: "DataTableValueSummary",
}) as any as S.Schema<DataTableValueSummary>;
export type DataTableValueSummaryList = DataTableValueSummary[];
export const DataTableValueSummaryList = S.Array(DataTableValueSummary);
export interface RuleSummary {
  Name: string;
  RuleId: string;
  RuleArn: string;
  EventSourceName: EventSourceName;
  PublishStatus: RulePublishStatus;
  ActionSummaries: ActionSummary[];
  CreatedTime: Date;
  LastUpdatedTime: Date;
}
export const RuleSummary = S.suspend(() =>
  S.Struct({
    Name: S.String,
    RuleId: S.String,
    RuleArn: S.String,
    EventSourceName: EventSourceName,
    PublishStatus: RulePublishStatus,
    ActionSummaries: ActionSummaries,
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastUpdatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
  }),
).annotations({ identifier: "RuleSummary" }) as any as S.Schema<RuleSummary>;
export type RuleSummaryList = RuleSummary[];
export const RuleSummaryList = S.Array(RuleSummary);
export interface AgentStatusSearchFilter {
  AttributeFilter?: ControlPlaneAttributeFilter;
}
export const AgentStatusSearchFilter = S.suspend(() =>
  S.Struct({ AttributeFilter: S.optional(ControlPlaneAttributeFilter) }),
).annotations({
  identifier: "AgentStatusSearchFilter",
}) as any as S.Schema<AgentStatusSearchFilter>;
export type ContactFlowModuleSearchSummaryList = ContactFlowModule[];
export const ContactFlowModuleSearchSummaryList = S.Array(ContactFlowModule);
export interface ContactFlowSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
  FlowAttributeFilter?: ContactFlowAttributeFilter;
}
export const ContactFlowSearchFilter = S.suspend(() =>
  S.Struct({
    TagFilter: S.optional(ControlPlaneTagFilter),
    FlowAttributeFilter: S.optional(ContactFlowAttributeFilter),
  }),
).annotations({
  identifier: "ContactFlowSearchFilter",
}) as any as S.Schema<ContactFlowSearchFilter>;
export interface EmailAddressMetadata {
  EmailAddressId?: string;
  EmailAddressArn?: string;
  EmailAddress?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  DisplayName?: string | redacted.Redacted<string>;
  AliasConfigurations?: AliasConfiguration[];
}
export const EmailAddressMetadata = S.suspend(() =>
  S.Struct({
    EmailAddressId: S.optional(S.String),
    EmailAddressArn: S.optional(S.String),
    EmailAddress: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    DisplayName: S.optional(SensitiveString),
    AliasConfigurations: S.optional(AliasConfigurationList),
  }),
).annotations({
  identifier: "EmailAddressMetadata",
}) as any as S.Schema<EmailAddressMetadata>;
export type EmailAddressList = EmailAddressMetadata[];
export const EmailAddressList = S.Array(EmailAddressMetadata);
export interface EvaluationFormSearchSummary {
  EvaluationFormId: string;
  EvaluationFormArn: string;
  Title: string;
  Status: EvaluationFormVersionStatus;
  Description?: string;
  CreatedTime: Date;
  CreatedBy: string;
  LastModifiedTime: Date;
  LastModifiedBy: string;
  LastActivatedTime?: Date;
  LastActivatedBy?: string;
  LatestVersion: number;
  ActiveVersion?: number;
  AutoEvaluationEnabled?: boolean;
  EvaluationFormLanguage?: EvaluationFormLanguageCode;
  ContactInteractionType?: ContactInteractionType;
  Tags?: { [key: string]: string | undefined };
}
export const EvaluationFormSearchSummary = S.suspend(() =>
  S.Struct({
    EvaluationFormId: S.String,
    EvaluationFormArn: S.String,
    Title: S.String,
    Status: EvaluationFormVersionStatus,
    Description: S.optional(S.String),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.String,
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedBy: S.String,
    LastActivatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastActivatedBy: S.optional(S.String),
    LatestVersion: S.Number,
    ActiveVersion: S.optional(S.Number),
    AutoEvaluationEnabled: S.optional(S.Boolean),
    EvaluationFormLanguage: S.optional(EvaluationFormLanguageCode),
    ContactInteractionType: S.optional(ContactInteractionType),
    Tags: S.optional(TagMap),
  }),
).annotations({
  identifier: "EvaluationFormSearchSummary",
}) as any as S.Schema<EvaluationFormSearchSummary>;
export type EvaluationFormSearchSummaryList = EvaluationFormSearchSummary[];
export const EvaluationFormSearchSummaryList = S.Array(
  EvaluationFormSearchSummary,
);
export interface SecurityProfileSearchSummary {
  Id?: string;
  OrganizationResourceId?: string;
  Arn?: string;
  SecurityProfileName?: string;
  Description?: string;
  Tags?: { [key: string]: string | undefined };
}
export const SecurityProfileSearchSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    OrganizationResourceId: S.optional(S.String),
    Arn: S.optional(S.String),
    SecurityProfileName: S.optional(S.String),
    Description: S.optional(S.String),
    Tags: S.optional(TagMap),
  }),
).annotations({
  identifier: "SecurityProfileSearchSummary",
}) as any as S.Schema<SecurityProfileSearchSummary>;
export type SecurityProfilesSearchSummaryList = SecurityProfileSearchSummary[];
export const SecurityProfilesSearchSummaryList = S.Array(
  SecurityProfileSearchSummary,
);
export interface UserSearchFilter {
  TagFilter?: ControlPlaneTagFilter;
  UserAttributeFilter?: ControlPlaneUserAttributeFilter;
}
export const UserSearchFilter = S.suspend(() =>
  S.Struct({
    TagFilter: S.optional(ControlPlaneTagFilter),
    UserAttributeFilter: S.optional(ControlPlaneUserAttributeFilter),
  }),
).annotations({
  identifier: "UserSearchFilter",
}) as any as S.Schema<UserSearchFilter>;
export interface UserSearchCriteria {
  OrConditions?: UserSearchCriteria[];
  AndConditions?: UserSearchCriteria[];
  StringCondition?: StringCondition;
  ListCondition?: ListCondition;
  HierarchyGroupCondition?: HierarchyGroupCondition;
}
export const UserSearchCriteria = S.suspend(() =>
  S.Struct({
    OrConditions: S.optional(
      S.suspend(() => UserSearchConditionList).annotations({
        identifier: "UserSearchConditionList",
      }),
    ),
    AndConditions: S.optional(
      S.suspend(() => UserSearchConditionList).annotations({
        identifier: "UserSearchConditionList",
      }),
    ),
    StringCondition: S.optional(StringCondition),
    ListCondition: S.optional(ListCondition),
    HierarchyGroupCondition: S.optional(HierarchyGroupCondition),
  }),
).annotations({
  identifier: "UserSearchCriteria",
}) as any as S.Schema<UserSearchCriteria>;
export interface WorkspaceAssociationSearchSummary {
  WorkspaceId?: string;
  WorkspaceArn?: string;
  ResourceId?: string;
  ResourceArn?: string;
  ResourceType?: string;
  ResourceName?: string;
}
export const WorkspaceAssociationSearchSummary = S.suspend(() =>
  S.Struct({
    WorkspaceId: S.optional(S.String),
    WorkspaceArn: S.optional(S.String),
    ResourceId: S.optional(S.String),
    ResourceArn: S.optional(S.String),
    ResourceType: S.optional(S.String),
    ResourceName: S.optional(S.String),
  }),
).annotations({
  identifier: "WorkspaceAssociationSearchSummary",
}) as any as S.Schema<WorkspaceAssociationSearchSummary>;
export type WorkspaceAssociationSearchSummaryList =
  WorkspaceAssociationSearchSummary[];
export const WorkspaceAssociationSearchSummaryList = S.Array(
  WorkspaceAssociationSearchSummary,
);
export interface WorkspaceSearchSummary {
  Id?: string;
  Name?: string;
  Visibility?: Visibility;
  Description?: string;
  Title?: string;
  Arn?: string;
  CreatedAt?: Date;
  Tags?: { [key: string]: string | undefined };
}
export const WorkspaceSearchSummary = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    Name: S.optional(S.String),
    Visibility: S.optional(Visibility),
    Description: S.optional(S.String),
    Title: S.optional(S.String),
    Arn: S.optional(S.String),
    CreatedAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Tags: S.optional(TagMap),
  }),
).annotations({
  identifier: "WorkspaceSearchSummary",
}) as any as S.Schema<WorkspaceSearchSummary>;
export type WorkspaceSearchSummaryList = WorkspaceSearchSummary[];
export const WorkspaceSearchSummaryList = S.Array(WorkspaceSearchSummary);
export interface InboundEmailContent {
  MessageSourceType: InboundMessageSourceType;
  RawMessage?: InboundRawMessage;
}
export const InboundEmailContent = S.suspend(() =>
  S.Struct({
    MessageSourceType: InboundMessageSourceType,
    RawMessage: S.optional(InboundRawMessage),
  }),
).annotations({
  identifier: "InboundEmailContent",
}) as any as S.Schema<InboundEmailContent>;
export interface ProblemDetail {
  message?: string;
}
export const ProblemDetail = S.suspend(() =>
  S.Struct({ message: S.optional(S.String) }),
).annotations({
  identifier: "ProblemDetail",
}) as any as S.Schema<ProblemDetail>;
export type Problems = ProblemDetail[];
export const Problems = S.Array(ProblemDetail);
export type ResourceType =
  | "CONTACT"
  | "CONTACT_FLOW"
  | "INSTANCE"
  | "PARTICIPANT"
  | "HIERARCHY_LEVEL"
  | "HIERARCHY_GROUP"
  | "USER"
  | "PHONE_NUMBER"
  | (string & {});
export const ResourceType = S.String;
export interface StateTransition {
  State?: ParticipantState;
  StateStartTimestamp?: Date;
  StateEndTimestamp?: Date;
}
export const StateTransition = S.suspend(() =>
  S.Struct({
    State: S.optional(ParticipantState),
    StateStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StateEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "StateTransition",
}) as any as S.Schema<StateTransition>;
export type StateTransitions = StateTransition[];
export const StateTransitions = S.Array(StateTransition);
export interface AiAgentInfo {
  AiUseCase?: AiUseCase;
  AiAgentVersionId?: string;
  AiAgentEscalated?: boolean;
}
export const AiAgentInfo = S.suspend(() =>
  S.Struct({
    AiUseCase: S.optional(AiUseCase),
    AiAgentVersionId: S.optional(S.String),
    AiAgentEscalated: S.optional(S.Boolean),
  }),
).annotations({ identifier: "AiAgentInfo" }) as any as S.Schema<AiAgentInfo>;
export type AiAgents = AiAgentInfo[];
export const AiAgents = S.Array(AiAgentInfo);
export type PotentialAudioQualityIssues = string[];
export const PotentialAudioQualityIssues = S.Array(S.String);
export interface AudioQualityMetricsInfo {
  QualityScore?: number;
  PotentialQualityIssues?: string[];
}
export const AudioQualityMetricsInfo = S.suspend(() =>
  S.Struct({
    QualityScore: S.optional(S.Number),
    PotentialQualityIssues: S.optional(PotentialAudioQualityIssues),
  }),
).annotations({
  identifier: "AudioQualityMetricsInfo",
}) as any as S.Schema<AudioQualityMetricsInfo>;
export interface CustomerQualityMetrics {
  Audio?: AudioQualityMetricsInfo;
}
export const CustomerQualityMetrics = S.suspend(() =>
  S.Struct({ Audio: S.optional(AudioQualityMetricsInfo) }),
).annotations({
  identifier: "CustomerQualityMetrics",
}) as any as S.Schema<CustomerQualityMetrics>;
export interface ChatContactMetrics {
  MultiParty?: boolean;
  TotalMessages?: number;
  TotalBotMessages?: number;
  TotalBotMessageLengthInChars?: number;
  ConversationCloseTimeInMillis?: number;
  ConversationTurnCount?: number;
  AgentFirstResponseTimestamp?: Date;
  AgentFirstResponseTimeInMillis?: number;
}
export const ChatContactMetrics = S.suspend(() =>
  S.Struct({
    MultiParty: S.optional(S.Boolean),
    TotalMessages: S.optional(S.Number),
    TotalBotMessages: S.optional(S.Number),
    TotalBotMessageLengthInChars: S.optional(S.Number),
    ConversationCloseTimeInMillis: S.optional(S.Number),
    ConversationTurnCount: S.optional(S.Number),
    AgentFirstResponseTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AgentFirstResponseTimeInMillis: S.optional(S.Number),
  }),
).annotations({
  identifier: "ChatContactMetrics",
}) as any as S.Schema<ChatContactMetrics>;
export interface ParticipantMetrics {
  ParticipantId?: string;
  ParticipantType?: ParticipantType;
  ConversationAbandon?: boolean;
  MessagesSent?: number;
  NumResponses?: number;
  MessageLengthInChars?: number;
  TotalResponseTimeInMillis?: number;
  MaxResponseTimeInMillis?: number;
  LastMessageTimestamp?: Date;
}
export const ParticipantMetrics = S.suspend(() =>
  S.Struct({
    ParticipantId: S.optional(S.String),
    ParticipantType: S.optional(ParticipantType),
    ConversationAbandon: S.optional(S.Boolean),
    MessagesSent: S.optional(S.Number),
    NumResponses: S.optional(S.Number),
    MessageLengthInChars: S.optional(S.Number),
    TotalResponseTimeInMillis: S.optional(S.Number),
    MaxResponseTimeInMillis: S.optional(S.Number),
    LastMessageTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "ParticipantMetrics",
}) as any as S.Schema<ParticipantMetrics>;
export interface EmailRecipient {
  Address?: string;
  DisplayName?: string;
}
export const EmailRecipient = S.suspend(() =>
  S.Struct({
    Address: S.optional(S.String),
    DisplayName: S.optional(S.String),
  }),
).annotations({
  identifier: "EmailRecipient",
}) as any as S.Schema<EmailRecipient>;
export type EmailRecipientsList = EmailRecipient[];
export const EmailRecipientsList = S.Array(EmailRecipient);
export interface ContactEvaluation {
  FormId?: string;
  EvaluationArn?: string;
  Status?: Status;
  StartTimestamp?: Date;
  EndTimestamp?: Date;
  DeleteTimestamp?: Date;
  ExportLocation?: string;
}
export const ContactEvaluation = S.suspend(() =>
  S.Struct({
    FormId: S.optional(S.String),
    EvaluationArn: S.optional(S.String),
    Status: S.optional(Status),
    StartTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTimestamp: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    DeleteTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ExportLocation: S.optional(S.String),
  }),
).annotations({
  identifier: "ContactEvaluation",
}) as any as S.Schema<ContactEvaluation>;
export interface AutoEvaluationDetails {
  AutoEvaluationEnabled: boolean;
  AutoEvaluationStatus?: AutoEvaluationStatus;
}
export const AutoEvaluationDetails = S.suspend(() =>
  S.Struct({
    AutoEvaluationEnabled: S.Boolean,
    AutoEvaluationStatus: S.optional(AutoEvaluationStatus),
  }),
).annotations({
  identifier: "AutoEvaluationDetails",
}) as any as S.Schema<AutoEvaluationDetails>;
export interface EvaluationAcknowledgement {
  AcknowledgedTime: Date;
  AcknowledgedBy: string;
  AcknowledgerComment?: string;
}
export const EvaluationAcknowledgement = S.suspend(() =>
  S.Struct({
    AcknowledgedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    AcknowledgedBy: S.String,
    AcknowledgerComment: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationAcknowledgement",
}) as any as S.Schema<EvaluationAcknowledgement>;
export interface RealTimeContactAnalysisAttachment {
  AttachmentName: string;
  ContentType?: string;
  AttachmentId: string;
  Status?: ArtifactStatus;
}
export const RealTimeContactAnalysisAttachment = S.suspend(() =>
  S.Struct({
    AttachmentName: S.String,
    ContentType: S.optional(S.String),
    AttachmentId: S.String,
    Status: S.optional(ArtifactStatus),
  }),
).annotations({
  identifier: "RealTimeContactAnalysisAttachment",
}) as any as S.Schema<RealTimeContactAnalysisAttachment>;
export type RealTimeContactAnalysisAttachments =
  RealTimeContactAnalysisAttachment[];
export const RealTimeContactAnalysisAttachments = S.Array(
  RealTimeContactAnalysisAttachment,
);
export interface Transcript {
  Criteria: TranscriptCriteria[];
  MatchType?: SearchContactsMatchType;
}
export const Transcript = S.suspend(() =>
  S.Struct({
    Criteria: TranscriptCriteriaList,
    MatchType: S.optional(SearchContactsMatchType),
  }),
).annotations({ identifier: "Transcript" }) as any as S.Schema<Transcript>;
export interface SearchableRoutingCriteriaStep {
  AgentCriteria?: SearchableAgentCriteriaStep;
}
export const SearchableRoutingCriteriaStep = S.suspend(() =>
  S.Struct({ AgentCriteria: S.optional(SearchableAgentCriteriaStep) }),
).annotations({
  identifier: "SearchableRoutingCriteriaStep",
}) as any as S.Schema<SearchableRoutingCriteriaStep>;
export type SearchableRoutingCriteriaStepList = SearchableRoutingCriteriaStep[];
export const SearchableRoutingCriteriaStepList = S.Array(
  SearchableRoutingCriteriaStep,
);
export interface SearchContactsAdditionalTimeRangeCriteria {
  TimeRange?: SearchContactsTimeRange;
  TimestampCondition?: SearchContactsTimestampCondition;
}
export const SearchContactsAdditionalTimeRangeCriteria = S.suspend(() =>
  S.Struct({
    TimeRange: S.optional(SearchContactsTimeRange),
    TimestampCondition: S.optional(SearchContactsTimestampCondition),
  }),
).annotations({
  identifier: "SearchContactsAdditionalTimeRangeCriteria",
}) as any as S.Schema<SearchContactsAdditionalTimeRangeCriteria>;
export type SearchContactsAdditionalTimeRangeCriteriaList =
  SearchContactsAdditionalTimeRangeCriteria[];
export const SearchContactsAdditionalTimeRangeCriteriaList = S.Array(
  SearchContactsAdditionalTimeRangeCriteria,
);
export interface ParticipantTimerConfiguration {
  ParticipantRole: TimerEligibleParticipantRoles;
  TimerType: ParticipantTimerType;
  TimerValue: ParticipantTimerValue;
}
export const ParticipantTimerConfiguration = S.suspend(() =>
  S.Struct({
    ParticipantRole: TimerEligibleParticipantRoles,
    TimerType: ParticipantTimerType,
    TimerValue: ParticipantTimerValue,
  }),
).annotations({
  identifier: "ParticipantTimerConfiguration",
}) as any as S.Schema<ParticipantTimerConfiguration>;
export type ParticipantTimerConfigList = ParticipantTimerConfiguration[];
export const ParticipantTimerConfigList = S.Array(
  ParticipantTimerConfiguration,
);
export interface AssociateInstanceStorageConfigRequest {
  InstanceId: string;
  ResourceType: InstanceStorageResourceType;
  StorageConfig: InstanceStorageConfig;
  ClientToken?: string;
}
export const AssociateInstanceStorageConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ResourceType: InstanceStorageResourceType,
    StorageConfig: InstanceStorageConfig,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/instance/{InstanceId}/storage-config" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "AssociateInstanceStorageConfigRequest",
}) as any as S.Schema<AssociateInstanceStorageConfigRequest>;
export interface BatchCreateDataTableValueResponse {
  Successful: BatchCreateDataTableValueSuccessResult[];
  Failed: BatchCreateDataTableValueFailureResult[];
}
export const BatchCreateDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchCreateDataTableValueSuccessResultList,
    Failed: BatchCreateDataTableValueFailureResultList,
  }),
).annotations({
  identifier: "BatchCreateDataTableValueResponse",
}) as any as S.Schema<BatchCreateDataTableValueResponse>;
export interface BatchDeleteDataTableValueResponse {
  Successful: BatchDeleteDataTableValueSuccessResult[];
  Failed: BatchDeleteDataTableValueFailureResult[];
}
export const BatchDeleteDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchDeleteDataTableValueSuccessResultList,
    Failed: BatchDeleteDataTableValueFailureResultList,
  }),
).annotations({
  identifier: "BatchDeleteDataTableValueResponse",
}) as any as S.Schema<BatchDeleteDataTableValueResponse>;
export interface BatchDescribeDataTableValueResponse {
  Successful: BatchDescribeDataTableValueSuccessResult[];
  Failed: BatchDescribeDataTableValueFailureResult[];
}
export const BatchDescribeDataTableValueResponse = S.suspend(() =>
  S.Struct({
    Successful: BatchDescribeDataTableValueSuccessResultList,
    Failed: BatchDescribeDataTableValueFailureResultList,
  }),
).annotations({
  identifier: "BatchDescribeDataTableValueResponse",
}) as any as S.Schema<BatchDescribeDataTableValueResponse>;
export interface CreateContactRequest {
  InstanceId: string;
  ClientToken?: string;
  RelatedContactId?: string;
  Attributes?: { [key: string]: string | undefined };
  References?: { [key: string]: Reference | undefined };
  Channel: Channel;
  InitiationMethod: ContactInitiationMethod;
  ExpiryDurationInMinutes?: number;
  UserInfo?: UserInfo;
  InitiateAs?: InitiateAs;
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  PreviousContactId?: string;
}
export const CreateContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    RelatedContactId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    References: S.optional(ContactReferences),
    Channel: Channel,
    InitiationMethod: ContactInitiationMethod,
    ExpiryDurationInMinutes: S.optional(S.Number),
    UserInfo: S.optional(UserInfo),
    InitiateAs: S.optional(InitiateAs),
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    SegmentAttributes: S.optional(SegmentAttributes),
    PreviousContactId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/create-contact" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateContactRequest",
}) as any as S.Schema<CreateContactRequest>;
export interface CreateDataTableAttributeResponse {
  Name: string;
  AttributeId?: string;
  LockVersion: DataTableLockVersion;
}
export const CreateDataTableAttributeResponse = S.suspend(() =>
  S.Struct({
    Name: S.String,
    AttributeId: S.optional(S.String),
    LockVersion: DataTableLockVersion,
  }),
).annotations({
  identifier: "CreateDataTableAttributeResponse",
}) as any as S.Schema<CreateDataTableAttributeResponse>;
export interface AutomaticFailConfiguration {
  TargetSection?: string;
}
export const AutomaticFailConfiguration = S.suspend(() =>
  S.Struct({ TargetSection: S.optional(S.String) }),
).annotations({
  identifier: "AutomaticFailConfiguration",
}) as any as S.Schema<AutomaticFailConfiguration>;
export interface EvaluationFormSingleSelectQuestionOption {
  RefId: string;
  Text: string;
  Score?: number;
  AutomaticFail?: boolean;
  AutomaticFailConfiguration?: AutomaticFailConfiguration;
}
export const EvaluationFormSingleSelectQuestionOption = S.suspend(() =>
  S.Struct({
    RefId: S.String,
    Text: S.String,
    Score: S.optional(S.Number),
    AutomaticFail: S.optional(S.Boolean),
    AutomaticFailConfiguration: S.optional(AutomaticFailConfiguration),
  }),
).annotations({
  identifier: "EvaluationFormSingleSelectQuestionOption",
}) as any as S.Schema<EvaluationFormSingleSelectQuestionOption>;
export type EvaluationFormSingleSelectQuestionOptionList =
  EvaluationFormSingleSelectQuestionOption[];
export const EvaluationFormSingleSelectQuestionOptionList = S.Array(
  EvaluationFormSingleSelectQuestionOption,
);
export type EvaluationFormQuestionAutomationAnswerSourceType =
  | "CONTACT_LENS_DATA"
  | "GEN_AI"
  | (string & {});
export const EvaluationFormQuestionAutomationAnswerSourceType = S.String;
export interface EvaluationFormQuestionAutomationAnswerSource {
  SourceType: EvaluationFormQuestionAutomationAnswerSourceType;
}
export const EvaluationFormQuestionAutomationAnswerSource = S.suspend(() =>
  S.Struct({ SourceType: EvaluationFormQuestionAutomationAnswerSourceType }),
).annotations({
  identifier: "EvaluationFormQuestionAutomationAnswerSource",
}) as any as S.Schema<EvaluationFormQuestionAutomationAnswerSource>;
export interface EvaluationFormTextQuestionAutomation {
  AnswerSource?: EvaluationFormQuestionAutomationAnswerSource;
}
export const EvaluationFormTextQuestionAutomation = S.suspend(() =>
  S.Struct({
    AnswerSource: S.optional(EvaluationFormQuestionAutomationAnswerSource),
  }),
).annotations({
  identifier: "EvaluationFormTextQuestionAutomation",
}) as any as S.Schema<EvaluationFormTextQuestionAutomation>;
export interface EvaluationFormMultiSelectQuestionOption {
  RefId: string;
  Text: string;
}
export const EvaluationFormMultiSelectQuestionOption = S.suspend(() =>
  S.Struct({ RefId: S.String, Text: S.String }),
).annotations({
  identifier: "EvaluationFormMultiSelectQuestionOption",
}) as any as S.Schema<EvaluationFormMultiSelectQuestionOption>;
export type EvaluationFormMultiSelectQuestionOptionList =
  EvaluationFormMultiSelectQuestionOption[];
export const EvaluationFormMultiSelectQuestionOptionList = S.Array(
  EvaluationFormMultiSelectQuestionOption,
);
export interface CreateHoursOfOperationResponse {
  HoursOfOperationId?: string;
  HoursOfOperationArn?: string;
}
export const CreateHoursOfOperationResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperationId: S.optional(S.String),
    HoursOfOperationArn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateHoursOfOperationResponse",
}) as any as S.Schema<CreateHoursOfOperationResponse>;
export interface CreateHoursOfOperationOverrideResponse {
  HoursOfOperationOverrideId?: string;
}
export const CreateHoursOfOperationOverrideResponse = S.suspend(() =>
  S.Struct({ HoursOfOperationOverrideId: S.optional(S.String) }),
).annotations({
  identifier: "CreateHoursOfOperationOverrideResponse",
}) as any as S.Schema<CreateHoursOfOperationOverrideResponse>;
export interface CreateQuickConnectResponse {
  QuickConnectARN?: string;
  QuickConnectId?: string;
}
export const CreateQuickConnectResponse = S.suspend(() =>
  S.Struct({
    QuickConnectARN: S.optional(S.String),
    QuickConnectId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateQuickConnectResponse",
}) as any as S.Schema<CreateQuickConnectResponse>;
export interface CreateRoutingProfileResponse {
  RoutingProfileArn?: string;
  RoutingProfileId?: string;
}
export const CreateRoutingProfileResponse = S.suspend(() =>
  S.Struct({
    RoutingProfileArn: S.optional(S.String),
    RoutingProfileId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateRoutingProfileResponse",
}) as any as S.Schema<CreateRoutingProfileResponse>;
export interface CreateTaskTemplateResponse {
  Id: string;
  Arn: string;
}
export const CreateTaskTemplateResponse = S.suspend(() =>
  S.Struct({ Id: S.String, Arn: S.String }),
).annotations({
  identifier: "CreateTaskTemplateResponse",
}) as any as S.Schema<CreateTaskTemplateResponse>;
export interface CreateViewVersionResponse {
  View?: View;
}
export const CreateViewVersionResponse = S.suspend(() =>
  S.Struct({ View: S.optional(View) }),
).annotations({
  identifier: "CreateViewVersionResponse",
}) as any as S.Schema<CreateViewVersionResponse>;
export type EvaluationSuggestedAnswerStatus =
  | "IN_PROGRESS"
  | "FAILED"
  | "SUCCEEDED"
  | (string & {});
export const EvaluationSuggestedAnswerStatus = S.String;
export type EvaluationQuestionAnswerAnalysisType =
  | "CONTACT_LENS_DATA"
  | "GEN_AI"
  | (string & {});
export const EvaluationQuestionAnswerAnalysisType = S.String;
export interface DescribeInstanceResponse {
  Instance?: Instance;
  ReplicationConfiguration?: ReplicationConfiguration;
}
export const DescribeInstanceResponse = S.suspend(() =>
  S.Struct({
    Instance: S.optional(Instance),
    ReplicationConfiguration: S.optional(ReplicationConfiguration),
  }),
).annotations({
  identifier: "DescribeInstanceResponse",
}) as any as S.Schema<DescribeInstanceResponse>;
export interface DescribePhoneNumberResponse {
  ClaimedPhoneNumberSummary?: ClaimedPhoneNumberSummary;
}
export const DescribePhoneNumberResponse = S.suspend(() =>
  S.Struct({
    ClaimedPhoneNumberSummary: S.optional(ClaimedPhoneNumberSummary),
  }),
).annotations({
  identifier: "DescribePhoneNumberResponse",
}) as any as S.Schema<DescribePhoneNumberResponse>;
export interface DescribePredefinedAttributeResponse {
  PredefinedAttribute?: PredefinedAttribute;
}
export const DescribePredefinedAttributeResponse = S.suspend(() =>
  S.Struct({ PredefinedAttribute: S.optional(PredefinedAttribute) }),
).annotations({
  identifier: "DescribePredefinedAttributeResponse",
}) as any as S.Schema<DescribePredefinedAttributeResponse>;
export interface DescribeUserHierarchyGroupResponse {
  HierarchyGroup?: HierarchyGroup;
}
export const DescribeUserHierarchyGroupResponse = S.suspend(() =>
  S.Struct({ HierarchyGroup: S.optional(HierarchyGroup) }),
).annotations({
  identifier: "DescribeUserHierarchyGroupResponse",
}) as any as S.Schema<DescribeUserHierarchyGroupResponse>;
export interface DescribeUserHierarchyStructureResponse {
  HierarchyStructure?: HierarchyStructure;
}
export const DescribeUserHierarchyStructureResponse = S.suspend(() =>
  S.Struct({ HierarchyStructure: S.optional(HierarchyStructure) }),
).annotations({
  identifier: "DescribeUserHierarchyStructureResponse",
}) as any as S.Schema<DescribeUserHierarchyStructureResponse>;
export interface EvaluateDataTableValuesResponse {
  Values: DataTableEvaluatedValue[];
  NextToken?: string;
}
export const EvaluateDataTableValuesResponse = S.suspend(() =>
  S.Struct({
    Values: DataTableEvaluatedValueList,
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluateDataTableValuesResponse",
}) as any as S.Schema<EvaluateDataTableValuesResponse>;
export interface GetEffectiveHoursOfOperationsResponse {
  EffectiveHoursOfOperationList?: EffectiveHoursOfOperations[];
  TimeZone?: string;
}
export const GetEffectiveHoursOfOperationsResponse = S.suspend(() =>
  S.Struct({
    EffectiveHoursOfOperationList: S.optional(EffectiveHoursOfOperationList),
    TimeZone: S.optional(S.String),
  }),
).annotations({
  identifier: "GetEffectiveHoursOfOperationsResponse",
}) as any as S.Schema<GetEffectiveHoursOfOperationsResponse>;
export interface ListContactEvaluationsResponse {
  EvaluationSummaryList: EvaluationSummary[];
  NextToken?: string;
}
export const ListContactEvaluationsResponse = S.suspend(() =>
  S.Struct({
    EvaluationSummaryList: EvaluationSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListContactEvaluationsResponse",
}) as any as S.Schema<ListContactEvaluationsResponse>;
export interface ListContactReferencesResponse {
  ReferenceSummaryList?: ReferenceSummary[];
  NextToken?: string;
}
export const ListContactReferencesResponse = S.suspend(() =>
  S.Struct({
    ReferenceSummaryList: S.optional(ReferenceSummaryList),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListContactReferencesResponse",
}) as any as S.Schema<ListContactReferencesResponse>;
export interface ListDataTablePrimaryValuesResponse {
  NextToken?: string;
  PrimaryValuesList: RecordPrimaryValue[];
}
export const ListDataTablePrimaryValuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    PrimaryValuesList: PrimaryValuesList,
  }),
).annotations({
  identifier: "ListDataTablePrimaryValuesResponse",
}) as any as S.Schema<ListDataTablePrimaryValuesResponse>;
export interface ListDataTableValuesResponse {
  NextToken?: string;
  Values: DataTableValueSummary[];
}
export const ListDataTableValuesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    Values: DataTableValueSummaryList,
  }),
).annotations({
  identifier: "ListDataTableValuesResponse",
}) as any as S.Schema<ListDataTableValuesResponse>;
export interface ListRulesResponse {
  RuleSummaryList: RuleSummary[];
  NextToken?: string;
}
export const ListRulesResponse = S.suspend(() =>
  S.Struct({
    RuleSummaryList: RuleSummaryList,
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListRulesResponse",
}) as any as S.Schema<ListRulesResponse>;
export interface SearchAgentStatusesRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: AgentStatusSearchFilter;
  SearchCriteria?: AgentStatusSearchCriteria;
}
export const SearchAgentStatusesRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(AgentStatusSearchFilter),
    SearchCriteria: S.optional(AgentStatusSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-agent-statuses" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchAgentStatusesRequest",
}) as any as S.Schema<SearchAgentStatusesRequest>;
export interface SearchContactFlowModulesResponse {
  ContactFlowModules?: ContactFlowModule[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchContactFlowModulesResponse = S.suspend(() =>
  S.Struct({
    ContactFlowModules: S.optional(ContactFlowModuleSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchContactFlowModulesResponse",
}) as any as S.Schema<SearchContactFlowModulesResponse>;
export interface SearchContactFlowsRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: ContactFlowSearchFilter;
  SearchCriteria?: ContactFlowSearchCriteria;
}
export const SearchContactFlowsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(ContactFlowSearchFilter),
    SearchCriteria: S.optional(ContactFlowSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contact-flows" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchContactFlowsRequest",
}) as any as S.Schema<SearchContactFlowsRequest>;
export interface SearchEmailAddressesResponse {
  NextToken?: string;
  EmailAddresses?: EmailAddressMetadata[];
  ApproximateTotalCount?: number;
}
export const SearchEmailAddressesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    EmailAddresses: S.optional(EmailAddressList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchEmailAddressesResponse",
}) as any as S.Schema<SearchEmailAddressesResponse>;
export interface SearchEvaluationFormsResponse {
  EvaluationFormSearchSummaryList?: EvaluationFormSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchEvaluationFormsResponse = S.suspend(() =>
  S.Struct({
    EvaluationFormSearchSummaryList: S.optional(
      EvaluationFormSearchSummaryList,
    ),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchEvaluationFormsResponse",
}) as any as S.Schema<SearchEvaluationFormsResponse>;
export interface SearchHoursOfOperationOverridesResponse {
  HoursOfOperationOverrides?: HoursOfOperationOverride[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchHoursOfOperationOverridesResponse = S.suspend(() =>
  S.Struct({
    HoursOfOperationOverrides: S.optional(HoursOfOperationOverrideList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchHoursOfOperationOverridesResponse",
}) as any as S.Schema<SearchHoursOfOperationOverridesResponse>;
export interface SearchSecurityProfilesResponse {
  SecurityProfiles?: SecurityProfileSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchSecurityProfilesResponse = S.suspend(() =>
  S.Struct({
    SecurityProfiles: S.optional(SecurityProfilesSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchSecurityProfilesResponse",
}) as any as S.Schema<SearchSecurityProfilesResponse>;
export interface SearchUsersRequest {
  InstanceId: string;
  NextToken?: string;
  MaxResults?: number;
  SearchFilter?: UserSearchFilter;
  SearchCriteria?: UserSearchCriteria;
}
export const SearchUsersRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
    SearchFilter: S.optional(UserSearchFilter),
    SearchCriteria: S.optional(UserSearchCriteria),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-users" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchUsersRequest",
}) as any as S.Schema<SearchUsersRequest>;
export interface SearchWorkspaceAssociationsResponse {
  NextToken?: string;
  WorkspaceAssociations?: WorkspaceAssociationSearchSummary[];
  ApproximateTotalCount?: number;
}
export const SearchWorkspaceAssociationsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    WorkspaceAssociations: S.optional(WorkspaceAssociationSearchSummaryList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchWorkspaceAssociationsResponse",
}) as any as S.Schema<SearchWorkspaceAssociationsResponse>;
export interface SearchWorkspacesResponse {
  NextToken?: string;
  Workspaces?: WorkspaceSearchSummary[];
  ApproximateTotalCount?: number;
}
export const SearchWorkspacesResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    Workspaces: S.optional(WorkspaceSearchSummaryList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchWorkspacesResponse",
}) as any as S.Schema<SearchWorkspacesResponse>;
export interface StartEmailContactRequest {
  InstanceId: string;
  FromEmailAddress: EmailAddressInfo;
  DestinationEmailAddress: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  Name?: string | redacted.Redacted<string>;
  EmailMessage: InboundEmailContent;
  AdditionalRecipients?: InboundAdditionalRecipients;
  Attachments?: EmailAttachment[];
  ContactFlowId?: string;
  RelatedContactId?: string;
  Attributes?: { [key: string]: string | undefined };
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  ClientToken?: string;
}
export const StartEmailContactRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    FromEmailAddress: EmailAddressInfo,
    DestinationEmailAddress: SensitiveString,
    Description: S.optional(SensitiveString),
    References: S.optional(ContactReferences),
    Name: S.optional(SensitiveString),
    EmailMessage: InboundEmailContent,
    AdditionalRecipients: S.optional(InboundAdditionalRecipients),
    Attachments: S.optional(EmailAttachments),
    ContactFlowId: S.optional(S.String),
    RelatedContactId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    SegmentAttributes: S.optional(SegmentAttributes),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/email" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartEmailContactRequest",
}) as any as S.Schema<StartEmailContactRequest>;
export interface StartOutboundChatContactResponse {
  ContactId?: string;
}
export const StartOutboundChatContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotations({
  identifier: "StartOutboundChatContactResponse",
}) as any as S.Schema<StartOutboundChatContactResponse>;
export interface SubmitContactEvaluationRequest {
  InstanceId: string;
  EvaluationId: string;
  Answers?: { [key: string]: EvaluationAnswerInput | undefined };
  Notes?: { [key: string]: EvaluationNote | undefined };
  SubmittedBy?: EvaluatorUserUnion;
}
export const SubmitContactEvaluationRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    EvaluationId: S.String.pipe(T.HttpLabel("EvaluationId")),
    Answers: S.optional(EvaluationAnswersInputMap),
    Notes: S.optional(EvaluationNotesMap),
    SubmittedBy: S.optional(EvaluatorUserUnion),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contact-evaluations/{InstanceId}/{EvaluationId}/submit",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SubmitContactEvaluationRequest",
}) as any as S.Schema<SubmitContactEvaluationRequest>;
export interface Range {
  MinProficiencyLevel?: number;
  MaxProficiencyLevel?: number;
}
export const Range = S.suspend(() =>
  S.Struct({
    MinProficiencyLevel: S.optional(S.Number),
    MaxProficiencyLevel: S.optional(S.Number),
  }),
).annotations({ identifier: "Range" }) as any as S.Schema<Range>;
export type FailureReasonCode =
  | "INVALID_ATTRIBUTE_KEY"
  | "INVALID_CUSTOMER_ENDPOINT"
  | "INVALID_SYSTEM_ENDPOINT"
  | "INVALID_QUEUE"
  | "INVALID_OUTBOUND_STRATEGY"
  | "MISSING_CAMPAIGN"
  | "MISSING_CUSTOMER_ENDPOINT"
  | "MISSING_QUEUE_ID_AND_SYSTEM_ENDPOINT"
  | "REQUEST_THROTTLED"
  | "IDEMPOTENCY_EXCEPTION"
  | "INTERNAL_ERROR"
  | (string & {});
export const FailureReasonCode = S.String;
export type NumericQuestionPropertyAutomationLabel =
  | "OVERALL_CUSTOMER_SENTIMENT_SCORE"
  | "OVERALL_AGENT_SENTIMENT_SCORE"
  | "CUSTOMER_SENTIMENT_SCORE_WITHOUT_AGENT"
  | "CUSTOMER_SENTIMENT_SCORE_WITH_AGENT"
  | "NON_TALK_TIME"
  | "NON_TALK_TIME_PERCENTAGE"
  | "NUMBER_OF_INTERRUPTIONS"
  | "CONTACT_DURATION"
  | "AGENT_INTERACTION_DURATION"
  | "CUSTOMER_HOLD_TIME"
  | "LONGEST_HOLD_DURATION"
  | "NUMBER_OF_HOLDS"
  | "AGENT_INTERACTION_AND_HOLD_DURATION"
  | (string & {});
export const NumericQuestionPropertyAutomationLabel = S.String;
export type EvaluationFormItemSourceValuesComparator =
  | "IN"
  | "NOT_IN"
  | "ALL_IN"
  | "EXACT"
  | (string & {});
export const EvaluationFormItemSourceValuesComparator = S.String;
export interface WisdomInfo {
  SessionArn?: string;
  AiAgents?: AiAgentInfo[];
}
export const WisdomInfo = S.suspend(() =>
  S.Struct({
    SessionArn: S.optional(S.String),
    AiAgents: S.optional(AiAgents),
  }),
).annotations({ identifier: "WisdomInfo" }) as any as S.Schema<WisdomInfo>;
export interface ChatMetrics {
  ChatContactMetrics?: ChatContactMetrics;
  AgentMetrics?: ParticipantMetrics;
  CustomerMetrics?: ParticipantMetrics;
}
export const ChatMetrics = S.suspend(() =>
  S.Struct({
    ChatContactMetrics: S.optional(ChatContactMetrics),
    AgentMetrics: S.optional(ParticipantMetrics),
    CustomerMetrics: S.optional(ParticipantMetrics),
  }),
).annotations({ identifier: "ChatMetrics" }) as any as S.Schema<ChatMetrics>;
export interface AdditionalEmailRecipients {
  ToList?: EmailRecipient[];
  CcList?: EmailRecipient[];
}
export const AdditionalEmailRecipients = S.suspend(() =>
  S.Struct({
    ToList: S.optional(EmailRecipientsList),
    CcList: S.optional(EmailRecipientsList),
  }),
).annotations({
  identifier: "AdditionalEmailRecipients",
}) as any as S.Schema<AdditionalEmailRecipients>;
export type ContactEvaluations = {
  [key: string]: ContactEvaluation | undefined;
};
export const ContactEvaluations = S.Record({
  key: S.String,
  value: S.UndefinedOr(ContactEvaluation),
});
export interface EvaluationMetadata {
  ContactId: string;
  EvaluatorArn: string;
  ContactAgentId?: string;
  CalibrationSessionId?: string;
  Score?: EvaluationScore;
  AutoEvaluation?: AutoEvaluationDetails;
  Acknowledgement?: EvaluationAcknowledgement;
  ContactParticipant?: EvaluationContactParticipant;
  SamplingJobId?: string;
}
export const EvaluationMetadata = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    EvaluatorArn: S.String,
    ContactAgentId: S.optional(S.String),
    CalibrationSessionId: S.optional(S.String),
    Score: S.optional(EvaluationScore),
    AutoEvaluation: S.optional(AutoEvaluationDetails),
    Acknowledgement: S.optional(EvaluationAcknowledgement),
    ContactParticipant: S.optional(EvaluationContactParticipant),
    SamplingJobId: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationMetadata",
}) as any as S.Schema<EvaluationMetadata>;
export type ContactMetricValue = { Number: number };
export const ContactMetricValue = S.Union(S.Struct({ Number: S.Number }));
export interface CurrentMetricData {
  Metric?: CurrentMetric;
  Value?: number;
}
export const CurrentMetricData = S.suspend(() =>
  S.Struct({ Metric: S.optional(CurrentMetric), Value: S.optional(S.Number) }),
).annotations({
  identifier: "CurrentMetricData",
}) as any as S.Schema<CurrentMetricData>;
export type CurrentMetricDataCollections = CurrentMetricData[];
export const CurrentMetricDataCollections = S.Array(CurrentMetricData);
export interface RealTimeContactAnalysisSegmentAttachments {
  Id: string;
  ParticipantId: string;
  ParticipantRole: ParticipantRole;
  DisplayName?: string;
  Attachments: RealTimeContactAnalysisAttachment[];
  Time: RealTimeContactAnalysisTimeData;
}
export const RealTimeContactAnalysisSegmentAttachments = S.suspend(() =>
  S.Struct({
    Id: S.String,
    ParticipantId: S.String,
    ParticipantRole: ParticipantRole,
    DisplayName: S.optional(S.String),
    Attachments: RealTimeContactAnalysisAttachments,
    Time: RealTimeContactAnalysisTimeData,
  }),
).annotations({
  identifier: "RealTimeContactAnalysisSegmentAttachments",
}) as any as S.Schema<RealTimeContactAnalysisSegmentAttachments>;
export interface ContactAnalysis {
  Transcript?: Transcript;
}
export const ContactAnalysis = S.suspend(() =>
  S.Struct({ Transcript: S.optional(Transcript) }),
).annotations({
  identifier: "ContactAnalysis",
}) as any as S.Schema<ContactAnalysis>;
export interface SearchableRoutingCriteria {
  Steps?: SearchableRoutingCriteriaStep[];
}
export const SearchableRoutingCriteria = S.suspend(() =>
  S.Struct({ Steps: S.optional(SearchableRoutingCriteriaStepList) }),
).annotations({
  identifier: "SearchableRoutingCriteria",
}) as any as S.Schema<SearchableRoutingCriteria>;
export interface SearchContactsAdditionalTimeRange {
  Criteria: SearchContactsAdditionalTimeRangeCriteria[];
  MatchType: SearchContactsMatchType;
}
export const SearchContactsAdditionalTimeRange = S.suspend(() =>
  S.Struct({
    Criteria: SearchContactsAdditionalTimeRangeCriteriaList,
    MatchType: SearchContactsMatchType,
  }),
).annotations({
  identifier: "SearchContactsAdditionalTimeRange",
}) as any as S.Schema<SearchContactsAdditionalTimeRange>;
export type UrlMetadataSignedHeaders = { [key: string]: string | undefined };
export const UrlMetadataSignedHeaders = S.Record({
  key: S.String,
  value: S.UndefinedOr(S.String),
});
export interface Attendee {
  AttendeeId?: string;
  JoinToken?: string | redacted.Redacted<string>;
}
export const Attendee = S.suspend(() =>
  S.Struct({
    AttendeeId: S.optional(S.String),
    JoinToken: S.optional(SensitiveString),
  }),
).annotations({ identifier: "Attendee" }) as any as S.Schema<Attendee>;
export type AgentIds = string[];
export const AgentIds = S.Array(S.String);
export interface ChatParticipantRoleConfig {
  ParticipantTimerConfigList: ParticipantTimerConfiguration[];
}
export const ChatParticipantRoleConfig = S.suspend(() =>
  S.Struct({ ParticipantTimerConfigList: ParticipantTimerConfigList }),
).annotations({
  identifier: "ChatParticipantRoleConfig",
}) as any as S.Schema<ChatParticipantRoleConfig>;
export type PropertyValidationExceptionReason =
  | "INVALID_FORMAT"
  | "UNIQUE_CONSTRAINT_VIOLATED"
  | "REFERENCED_RESOURCE_NOT_FOUND"
  | "RESOURCE_NAME_ALREADY_EXISTS"
  | "REQUIRED_PROPERTY_MISSING"
  | "NOT_SUPPORTED"
  | (string & {});
export const PropertyValidationExceptionReason = S.String;
export interface EvaluationFormTextQuestionProperties {
  Automation?: EvaluationFormTextQuestionAutomation;
}
export const EvaluationFormTextQuestionProperties = S.suspend(() =>
  S.Struct({ Automation: S.optional(EvaluationFormTextQuestionAutomation) }),
).annotations({
  identifier: "EvaluationFormTextQuestionProperties",
}) as any as S.Schema<EvaluationFormTextQuestionProperties>;
export interface AgentHierarchyGroup {
  Arn?: string;
}
export const AgentHierarchyGroup = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String) }),
).annotations({
  identifier: "AgentHierarchyGroup",
}) as any as S.Schema<AgentHierarchyGroup>;
export interface Expiry {
  DurationInSeconds?: number;
  ExpiryTimestamp?: Date;
}
export const Expiry = S.suspend(() =>
  S.Struct({
    DurationInSeconds: S.optional(S.Number),
    ExpiryTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({ identifier: "Expiry" }) as any as S.Schema<Expiry>;
export interface QuickConnectContactData {
  ContactId?: string;
  InitiationTimestamp?: Date;
  QuickConnectId?: string;
  QuickConnectName?: string;
  QuickConnectType?: QuickConnectType;
}
export const QuickConnectContactData = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    QuickConnectId: S.optional(S.String),
    QuickConnectName: S.optional(S.String),
    QuickConnectType: S.optional(QuickConnectType),
  }),
).annotations({
  identifier: "QuickConnectContactData",
}) as any as S.Schema<QuickConnectContactData>;
export interface RealTimeContactAnalysisCharacterInterval {
  BeginOffsetChar: number;
  EndOffsetChar: number;
}
export const RealTimeContactAnalysisCharacterInterval = S.suspend(() =>
  S.Struct({ BeginOffsetChar: S.Number, EndOffsetChar: S.Number }),
).annotations({
  identifier: "RealTimeContactAnalysisCharacterInterval",
}) as any as S.Schema<RealTimeContactAnalysisCharacterInterval>;
export type RealTimeContactAnalysisCharacterIntervals =
  RealTimeContactAnalysisCharacterInterval[];
export const RealTimeContactAnalysisCharacterIntervals = S.Array(
  RealTimeContactAnalysisCharacterInterval,
);
export interface RealTimeContactAnalysisTranscriptItemWithContent {
  Content?: string;
  Id: string;
  CharacterOffsets?: RealTimeContactAnalysisCharacterInterval;
}
export const RealTimeContactAnalysisTranscriptItemWithContent = S.suspend(() =>
  S.Struct({
    Content: S.optional(S.String),
    Id: S.String,
    CharacterOffsets: S.optional(RealTimeContactAnalysisCharacterInterval),
  }),
).annotations({
  identifier: "RealTimeContactAnalysisTranscriptItemWithContent",
}) as any as S.Schema<RealTimeContactAnalysisTranscriptItemWithContent>;
export type RealTimeContactAnalysisTranscriptItemsWithContent =
  RealTimeContactAnalysisTranscriptItemWithContent[];
export const RealTimeContactAnalysisTranscriptItemsWithContent = S.Array(
  RealTimeContactAnalysisTranscriptItemWithContent,
);
export interface SuccessfulRequest {
  RequestIdentifier?: string;
  ContactId?: string;
}
export const SuccessfulRequest = S.suspend(() =>
  S.Struct({
    RequestIdentifier: S.optional(S.String),
    ContactId: S.optional(S.String),
  }),
).annotations({
  identifier: "SuccessfulRequest",
}) as any as S.Schema<SuccessfulRequest>;
export type SuccessfulRequestList = SuccessfulRequest[];
export const SuccessfulRequestList = S.Array(SuccessfulRequest);
export interface FailedRequest {
  RequestIdentifier?: string;
  FailureReasonCode?: FailureReasonCode;
  FailureReasonMessage?: string;
}
export const FailedRequest = S.suspend(() =>
  S.Struct({
    RequestIdentifier: S.optional(S.String),
    FailureReasonCode: S.optional(FailureReasonCode),
    FailureReasonMessage: S.optional(S.String),
  }),
).annotations({
  identifier: "FailedRequest",
}) as any as S.Schema<FailedRequest>;
export type FailedRequestList = FailedRequest[];
export const FailedRequestList = S.Array(FailedRequest);
export interface NumericQuestionPropertyValueAutomation {
  Label: NumericQuestionPropertyAutomationLabel;
}
export const NumericQuestionPropertyValueAutomation = S.suspend(() =>
  S.Struct({ Label: NumericQuestionPropertyAutomationLabel }),
).annotations({
  identifier: "NumericQuestionPropertyValueAutomation",
}) as any as S.Schema<NumericQuestionPropertyValueAutomation>;
export interface ParticipantTokenCredentials {
  ParticipantToken?: string;
  Expiry?: string;
}
export const ParticipantTokenCredentials = S.suspend(() =>
  S.Struct({
    ParticipantToken: S.optional(S.String),
    Expiry: S.optional(S.String),
  }),
).annotations({
  identifier: "ParticipantTokenCredentials",
}) as any as S.Schema<ParticipantTokenCredentials>;
export type EvaluationTranscriptType = "RAW" | "REDACTED" | (string & {});
export const EvaluationTranscriptType = S.String;
export interface ContactMetricResult {
  Name: ContactMetricName;
  Value: ContactMetricValue;
}
export const ContactMetricResult = S.suspend(() =>
  S.Struct({ Name: ContactMetricName, Value: ContactMetricValue }),
).annotations({
  identifier: "ContactMetricResult",
}) as any as S.Schema<ContactMetricResult>;
export type ContactMetricResults = ContactMetricResult[];
export const ContactMetricResults = S.Array(ContactMetricResult);
export type AgentStatusList = AgentStatus[];
export const AgentStatusList = S.Array(AgentStatus);
export type ContactFlowSearchSummaryList = ContactFlow[];
export const ContactFlowSearchSummaryList = S.Array(ContactFlow);
export interface SearchCriteria {
  Name?: NameCriteria;
  AgentIds?: string[];
  AgentHierarchyGroups?: AgentHierarchyGroups;
  Channels?: Channel[];
  ContactAnalysis?: ContactAnalysis;
  InitiationMethods?: ContactInitiationMethod[];
  QueueIds?: string[];
  RoutingCriteria?: SearchableRoutingCriteria;
  AdditionalTimeRange?: SearchContactsAdditionalTimeRange;
  SearchableContactAttributes?: SearchableContactAttributes;
  SearchableSegmentAttributes?: SearchableSegmentAttributes;
  ActiveRegions?: string[];
}
export const SearchCriteria = S.suspend(() =>
  S.Struct({
    Name: S.optional(NameCriteria),
    AgentIds: S.optional(AgentResourceIdList),
    AgentHierarchyGroups: S.optional(AgentHierarchyGroups),
    Channels: S.optional(ChannelList),
    ContactAnalysis: S.optional(ContactAnalysis),
    InitiationMethods: S.optional(InitiationMethodList),
    QueueIds: S.optional(QueueIdList),
    RoutingCriteria: S.optional(SearchableRoutingCriteria),
    AdditionalTimeRange: S.optional(SearchContactsAdditionalTimeRange),
    SearchableContactAttributes: S.optional(SearchableContactAttributes),
    SearchableSegmentAttributes: S.optional(SearchableSegmentAttributes),
    ActiveRegions: S.optional(ActiveRegionList),
  }),
).annotations({
  identifier: "SearchCriteria",
}) as any as S.Schema<SearchCriteria>;
export interface TagSet {
  key?: string;
  value?: string;
}
export const TagSet = S.suspend(() =>
  S.Struct({ key: S.optional(S.String), value: S.optional(S.String) }),
).annotations({ identifier: "TagSet" }) as any as S.Schema<TagSet>;
export type TagsList = TagSet[];
export const TagsList = S.Array(TagSet);
export interface UploadUrlMetadata {
  Url?: string;
  UrlExpiry?: string;
  HeadersToInclude?: { [key: string]: string | undefined };
}
export const UploadUrlMetadata = S.suspend(() =>
  S.Struct({
    Url: S.optional(S.String),
    UrlExpiry: S.optional(S.String),
    HeadersToInclude: S.optional(UrlMetadataSignedHeaders),
  }),
).annotations({
  identifier: "UploadUrlMetadata",
}) as any as S.Schema<UploadUrlMetadata>;
export interface AgentsCriteria {
  AgentIds?: string[];
}
export const AgentsCriteria = S.suspend(() =>
  S.Struct({ AgentIds: S.optional(AgentIds) }),
).annotations({
  identifier: "AgentsCriteria",
}) as any as S.Schema<AgentsCriteria>;
export type UpdateParticipantRoleConfigChannelInfo = {
  Chat: ChatParticipantRoleConfig;
};
export const UpdateParticipantRoleConfigChannelInfo = S.Union(
  S.Struct({ Chat: ChatParticipantRoleConfig }),
);
export interface PropertyValidationExceptionProperty {
  PropertyPath: string;
  Reason: PropertyValidationExceptionReason;
  Message: string;
}
export const PropertyValidationExceptionProperty = S.suspend(() =>
  S.Struct({
    PropertyPath: S.String,
    Reason: PropertyValidationExceptionReason,
    Message: S.String,
  }),
).annotations({
  identifier: "PropertyValidationExceptionProperty",
}) as any as S.Schema<PropertyValidationExceptionProperty>;
export type PropertyValidationExceptionPropertyList =
  PropertyValidationExceptionProperty[];
export const PropertyValidationExceptionPropertyList = S.Array(
  PropertyValidationExceptionProperty,
);
export type SingleSelectQuestionRuleCategoryAutomationCondition =
  | "PRESENT"
  | "NOT_PRESENT"
  | (string & {});
export const SingleSelectQuestionRuleCategoryAutomationCondition = S.String;
export type MultiSelectQuestionRuleCategoryAutomationCondition =
  | "PRESENT"
  | "NOT_PRESENT"
  | (string & {});
export const MultiSelectQuestionRuleCategoryAutomationCondition = S.String;
export type EvaluationFormItemEnablementSourceType =
  | "QUESTION_REF_ID"
  | (string & {});
export const EvaluationFormItemEnablementSourceType = S.String;
export type EvaluationFormItemEnablementSourceValueType =
  | "OPTION_REF_ID"
  | (string & {});
export const EvaluationFormItemEnablementSourceValueType = S.String;
export interface HierarchyGroups {
  Level1?: AgentHierarchyGroup;
  Level2?: AgentHierarchyGroup;
  Level3?: AgentHierarchyGroup;
  Level4?: AgentHierarchyGroup;
  Level5?: AgentHierarchyGroup;
}
export const HierarchyGroups = S.suspend(() =>
  S.Struct({
    Level1: S.optional(AgentHierarchyGroup),
    Level2: S.optional(AgentHierarchyGroup),
    Level3: S.optional(AgentHierarchyGroup),
    Level4: S.optional(AgentHierarchyGroup),
    Level5: S.optional(AgentHierarchyGroup),
  }),
).annotations({
  identifier: "HierarchyGroups",
}) as any as S.Schema<HierarchyGroups>;
export interface MatchCriteria {
  AgentsCriteria?: AgentsCriteria;
}
export const MatchCriteria = S.suspend(() =>
  S.Struct({ AgentsCriteria: S.optional(AgentsCriteria) }),
).annotations({
  identifier: "MatchCriteria",
}) as any as S.Schema<MatchCriteria>;
export interface AttributeCondition {
  Name?: string;
  Value?: string;
  ProficiencyLevel?: number;
  Range?: Range;
  MatchCriteria?: MatchCriteria;
  ComparisonOperator?: string;
}
export const AttributeCondition = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Value: S.optional(S.String),
    ProficiencyLevel: S.optional(S.Number),
    Range: S.optional(Range),
    MatchCriteria: S.optional(MatchCriteria),
    ComparisonOperator: S.optional(S.String),
  }),
).annotations({
  identifier: "AttributeCondition",
}) as any as S.Schema<AttributeCondition>;
export interface Expression {
  AttributeCondition?: AttributeCondition;
  AndExpression?: Expression[];
  OrExpression?: Expression[];
  NotAttributeCondition?: AttributeCondition;
}
export const Expression = S.suspend(() =>
  S.Struct({
    AttributeCondition: S.optional(AttributeCondition),
    AndExpression: S.optional(
      S.suspend(() => Expressions).annotations({ identifier: "Expressions" }),
    ),
    OrExpression: S.optional(
      S.suspend(() => Expressions).annotations({ identifier: "Expressions" }),
    ),
    NotAttributeCondition: S.optional(AttributeCondition),
  }),
).annotations({ identifier: "Expression" }) as any as S.Schema<Expression>;
export interface Step {
  Expiry?: Expiry;
  Expression?: Expression;
  Status?: RoutingCriteriaStepStatus;
}
export const Step = S.suspend(() =>
  S.Struct({
    Expiry: S.optional(Expiry),
    Expression: S.optional(Expression),
    Status: S.optional(RoutingCriteriaStepStatus),
  }),
).annotations({ identifier: "Step" }) as any as S.Schema<Step>;
export type Steps = Step[];
export const Steps = S.Array(Step);
export interface AgentQualityMetrics {
  Audio?: AudioQualityMetricsInfo;
}
export const AgentQualityMetrics = S.suspend(() =>
  S.Struct({ Audio: S.optional(AudioQualityMetricsInfo) }),
).annotations({
  identifier: "AgentQualityMetrics",
}) as any as S.Schema<AgentQualityMetrics>;
export type NextContactMetadata = {
  QuickConnectContactData: QuickConnectContactData;
};
export const NextContactMetadata = S.Union(
  S.Struct({ QuickConnectContactData: QuickConnectContactData }),
);
export interface QueueReference {
  Id?: string;
  Arn?: string;
}
export const QueueReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "QueueReference",
}) as any as S.Schema<QueueReference>;
export interface RoutingProfileReference {
  Id?: string;
  Arn?: string;
}
export const RoutingProfileReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "RoutingProfileReference",
}) as any as S.Schema<RoutingProfileReference>;
export interface AgentStatusIdentifier {
  Arn?: string;
  Id?: string;
}
export const AgentStatusIdentifier = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), Id: S.optional(S.String) }),
).annotations({
  identifier: "AgentStatusIdentifier",
}) as any as S.Schema<AgentStatusIdentifier>;
export interface RealTimeContactAnalysisTranscriptItemRedaction {
  CharacterOffsets?: RealTimeContactAnalysisCharacterInterval[];
}
export const RealTimeContactAnalysisTranscriptItemRedaction = S.suspend(() =>
  S.Struct({
    CharacterOffsets: S.optional(RealTimeContactAnalysisCharacterIntervals),
  }),
).annotations({
  identifier: "RealTimeContactAnalysisTranscriptItemRedaction",
}) as any as S.Schema<RealTimeContactAnalysisTranscriptItemRedaction>;
export interface RealTimeContactAnalysisIssueDetected {
  TranscriptItems: RealTimeContactAnalysisTranscriptItemWithContent[];
}
export const RealTimeContactAnalysisIssueDetected = S.suspend(() =>
  S.Struct({
    TranscriptItems: RealTimeContactAnalysisTranscriptItemsWithContent,
  }),
).annotations({
  identifier: "RealTimeContactAnalysisIssueDetected",
}) as any as S.Schema<RealTimeContactAnalysisIssueDetected>;
export type RealTimeContactAnalysisIssuesDetected =
  RealTimeContactAnalysisIssueDetected[];
export const RealTimeContactAnalysisIssuesDetected = S.Array(
  RealTimeContactAnalysisIssueDetected,
);
export interface MediaPlacement {
  AudioHostUrl?: string;
  AudioFallbackUrl?: string;
  SignalingUrl?: string;
  TurnControlUrl?: string;
  EventIngestionUrl?: string;
}
export const MediaPlacement = S.suspend(() =>
  S.Struct({
    AudioHostUrl: S.optional(S.String),
    AudioFallbackUrl: S.optional(S.String),
    SignalingUrl: S.optional(S.String),
    TurnControlUrl: S.optional(S.String),
    EventIngestionUrl: S.optional(S.String),
  }),
).annotations({
  identifier: "MediaPlacement",
}) as any as S.Schema<MediaPlacement>;
export interface AssociateInstanceStorageConfigResponse {
  AssociationId?: string;
}
export const AssociateInstanceStorageConfigResponse = S.suspend(() =>
  S.Struct({ AssociationId: S.optional(S.String) }),
).annotations({
  identifier: "AssociateInstanceStorageConfigResponse",
}) as any as S.Schema<AssociateInstanceStorageConfigResponse>;
export interface BatchPutContactResponse {
  SuccessfulRequestList?: SuccessfulRequest[];
  FailedRequestList?: FailedRequest[];
}
export const BatchPutContactResponse = S.suspend(() =>
  S.Struct({
    SuccessfulRequestList: S.optional(SuccessfulRequestList),
    FailedRequestList: S.optional(FailedRequestList),
  }),
).annotations({
  identifier: "BatchPutContactResponse",
}) as any as S.Schema<BatchPutContactResponse>;
export interface CreateContactResponse {
  ContactId?: string;
  ContactArn?: string;
}
export const CreateContactResponse = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    ContactArn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateContactResponse",
}) as any as S.Schema<CreateContactResponse>;
export interface EvaluationFormNumericQuestionOption {
  MinValue: number;
  MaxValue: number;
  Score?: number;
  AutomaticFail?: boolean;
  AutomaticFailConfiguration?: AutomaticFailConfiguration;
}
export const EvaluationFormNumericQuestionOption = S.suspend(() =>
  S.Struct({
    MinValue: S.Number,
    MaxValue: S.Number,
    Score: S.optional(S.Number),
    AutomaticFail: S.optional(S.Boolean),
    AutomaticFailConfiguration: S.optional(AutomaticFailConfiguration),
  }),
).annotations({
  identifier: "EvaluationFormNumericQuestionOption",
}) as any as S.Schema<EvaluationFormNumericQuestionOption>;
export type EvaluationFormNumericQuestionOptionList =
  EvaluationFormNumericQuestionOption[];
export const EvaluationFormNumericQuestionOptionList = S.Array(
  EvaluationFormNumericQuestionOption,
);
export type EvaluationFormNumericQuestionAutomation =
  | {
      PropertyValue: NumericQuestionPropertyValueAutomation;
      AnswerSource?: never;
    }
  | {
      PropertyValue?: never;
      AnswerSource: EvaluationFormQuestionAutomationAnswerSource;
    };
export const EvaluationFormNumericQuestionAutomation = S.Union(
  S.Struct({ PropertyValue: NumericQuestionPropertyValueAutomation }),
  S.Struct({ AnswerSource: EvaluationFormQuestionAutomationAnswerSource }),
);
export interface CreateParticipantResponse {
  ParticipantCredentials?: ParticipantTokenCredentials;
  ParticipantId?: string;
}
export const CreateParticipantResponse = S.suspend(() =>
  S.Struct({
    ParticipantCredentials: S.optional(ParticipantTokenCredentials),
    ParticipantId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateParticipantResponse",
}) as any as S.Schema<CreateParticipantResponse>;
export interface CreateRuleRequest {
  InstanceId: string;
  Name: string;
  TriggerEventSource: RuleTriggerEventSource;
  Function: string;
  Actions: RuleAction[];
  PublishStatus: RulePublishStatus;
  ClientToken?: string;
}
export const CreateRuleRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    TriggerEventSource: RuleTriggerEventSource,
    Function: S.String,
    Actions: RuleActions,
    PublishStatus: RulePublishStatus,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/rules/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateRuleRequest",
}) as any as S.Schema<CreateRuleRequest>;
export interface CreateSecurityProfileRequest {
  SecurityProfileName: string;
  Description?: string;
  Permissions?: string[];
  InstanceId: string;
  Tags?: { [key: string]: string | undefined };
  AllowedAccessControlTags?: { [key: string]: string | undefined };
  TagRestrictedResources?: string[];
  Applications?: Application[];
  HierarchyRestrictedResources?: string[];
  AllowedAccessControlHierarchyGroupId?: string;
  AllowedFlowModules?: FlowModule[];
  GranularAccessControlConfiguration?: GranularAccessControlConfiguration;
}
export const CreateSecurityProfileRequest = S.suspend(() =>
  S.Struct({
    SecurityProfileName: S.String,
    Description: S.optional(S.String),
    Permissions: S.optional(PermissionsList),
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Tags: S.optional(TagMap),
    AllowedAccessControlTags: S.optional(AllowedAccessControlTags),
    TagRestrictedResources: S.optional(TagRestrictedResourceList),
    Applications: S.optional(Applications),
    HierarchyRestrictedResources: S.optional(HierarchyRestrictedResourceList),
    AllowedAccessControlHierarchyGroupId: S.optional(S.String),
    AllowedFlowModules: S.optional(AllowedFlowModules),
    GranularAccessControlConfiguration: S.optional(
      GranularAccessControlConfiguration,
    ),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/security-profiles/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateSecurityProfileRequest",
}) as any as S.Schema<CreateSecurityProfileRequest>;
export interface CreateWorkspaceRequest {
  InstanceId: string;
  Name: string;
  Description?: string;
  Theme?: WorkspaceTheme;
  Title?: string;
  Tags?: { [key: string]: string | undefined };
}
export const CreateWorkspaceRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Name: S.String,
    Description: S.optional(S.String),
    Theme: S.optional(WorkspaceTheme),
    Title: S.optional(S.String),
    Tags: S.optional(TagMap),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/workspaces/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateWorkspaceRequest",
}) as any as S.Schema<CreateWorkspaceRequest>;
export interface EvaluationQuestionInputDetails {
  TranscriptType?: EvaluationTranscriptType;
}
export const EvaluationQuestionInputDetails = S.suspend(() =>
  S.Struct({ TranscriptType: S.optional(EvaluationTranscriptType) }),
).annotations({
  identifier: "EvaluationQuestionInputDetails",
}) as any as S.Schema<EvaluationQuestionInputDetails>;
export interface GetContactMetricsResponse {
  MetricResults?: ContactMetricResult[];
  Id?: string;
  Arn?: string;
}
export const GetContactMetricsResponse = S.suspend(() =>
  S.Struct({
    MetricResults: S.optional(ContactMetricResults),
    Id: S.optional(S.String),
    Arn: S.optional(S.String),
  }),
).annotations({
  identifier: "GetContactMetricsResponse",
}) as any as S.Schema<GetContactMetricsResponse>;
export interface SearchAgentStatusesResponse {
  AgentStatuses?: AgentStatus[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchAgentStatusesResponse = S.suspend(() =>
  S.Struct({
    AgentStatuses: S.optional(AgentStatusList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchAgentStatusesResponse",
}) as any as S.Schema<SearchAgentStatusesResponse>;
export interface SearchContactFlowsResponse {
  ContactFlows?: ContactFlow[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchContactFlowsResponse = S.suspend(() =>
  S.Struct({
    ContactFlows: S.optional(ContactFlowSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchContactFlowsResponse",
}) as any as S.Schema<SearchContactFlowsResponse>;
export interface SearchContactsRequest {
  InstanceId: string;
  TimeRange: SearchContactsTimeRange;
  SearchCriteria?: SearchCriteria;
  MaxResults?: number;
  NextToken?: string;
  Sort?: Sort;
}
export const SearchContactsRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String,
    TimeRange: SearchContactsTimeRange,
    SearchCriteria: S.optional(SearchCriteria),
    MaxResults: S.optional(S.Number),
    NextToken: S.optional(S.String),
    Sort: S.optional(Sort),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/search-contacts" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchContactsRequest",
}) as any as S.Schema<SearchContactsRequest>;
export interface SearchResourceTagsResponse {
  Tags?: TagSet[];
  NextToken?: string;
}
export const SearchResourceTagsResponse = S.suspend(() =>
  S.Struct({ Tags: S.optional(TagsList), NextToken: S.optional(S.String) }),
).annotations({
  identifier: "SearchResourceTagsResponse",
}) as any as S.Schema<SearchResourceTagsResponse>;
export interface StartAttachedFileUploadResponse {
  FileArn?: string;
  FileId?: string;
  CreationTime?: string;
  FileStatus?: FileStatusType;
  CreatedBy?: CreatedByInfo;
  UploadUrlMetadata?: UploadUrlMetadata;
}
export const StartAttachedFileUploadResponse = S.suspend(() =>
  S.Struct({
    FileArn: S.optional(S.String),
    FileId: S.optional(S.String),
    CreationTime: S.optional(S.String),
    FileStatus: S.optional(FileStatusType),
    CreatedBy: S.optional(CreatedByInfo),
    UploadUrlMetadata: S.optional(UploadUrlMetadata),
  }),
).annotations({
  identifier: "StartAttachedFileUploadResponse",
}) as any as S.Schema<StartAttachedFileUploadResponse>;
export interface StartEmailContactResponse {
  ContactId?: string;
}
export const StartEmailContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotations({
  identifier: "StartEmailContactResponse",
}) as any as S.Schema<StartEmailContactResponse>;
export type MeetingFeatureStatus = "AVAILABLE" | "UNAVAILABLE" | (string & {});
export const MeetingFeatureStatus = S.String;
export interface SubmitContactEvaluationResponse {
  EvaluationId: string;
  EvaluationArn: string;
}
export const SubmitContactEvaluationResponse = S.suspend(() =>
  S.Struct({ EvaluationId: S.String, EvaluationArn: S.String }),
).annotations({
  identifier: "SubmitContactEvaluationResponse",
}) as any as S.Schema<SubmitContactEvaluationResponse>;
export interface UpdateParticipantRoleConfigRequest {
  InstanceId: string;
  ContactId: string;
  ChannelConfiguration: UpdateParticipantRoleConfigChannelInfo;
}
export const UpdateParticipantRoleConfigRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    ChannelConfiguration: UpdateParticipantRoleConfigChannelInfo,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/contact/participant-role-config/{InstanceId}/{ContactId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateParticipantRoleConfigRequest",
}) as any as S.Schema<UpdateParticipantRoleConfigRequest>;
export interface UpdateParticipantRoleConfigResponse {}
export const UpdateParticipantRoleConfigResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateParticipantRoleConfigResponse",
}) as any as S.Schema<UpdateParticipantRoleConfigResponse>;
export type AttachedFileServiceQuotaExceededExceptionReason =
  | "TOTAL_FILE_SIZE_EXCEEDED"
  | "TOTAL_FILE_COUNT_EXCEEDED"
  | (string & {});
export const AttachedFileServiceQuotaExceededExceptionReason = S.String;
export interface SingleSelectQuestionRuleCategoryAutomation {
  Category: string;
  Condition: SingleSelectQuestionRuleCategoryAutomationCondition;
  OptionRefId: string;
}
export const SingleSelectQuestionRuleCategoryAutomation = S.suspend(() =>
  S.Struct({
    Category: S.String,
    Condition: SingleSelectQuestionRuleCategoryAutomationCondition,
    OptionRefId: S.String,
  }),
).annotations({
  identifier: "SingleSelectQuestionRuleCategoryAutomation",
}) as any as S.Schema<SingleSelectQuestionRuleCategoryAutomation>;
export interface MultiSelectQuestionRuleCategoryAutomation {
  Category: string;
  Condition: MultiSelectQuestionRuleCategoryAutomationCondition;
  OptionRefIds: string[];
}
export const MultiSelectQuestionRuleCategoryAutomation = S.suspend(() =>
  S.Struct({
    Category: S.String,
    Condition: MultiSelectQuestionRuleCategoryAutomationCondition,
    OptionRefIds: ReferenceIdList,
  }),
).annotations({
  identifier: "MultiSelectQuestionRuleCategoryAutomation",
}) as any as S.Schema<MultiSelectQuestionRuleCategoryAutomation>;
export interface EvaluationFormItemEnablementSource {
  Type: EvaluationFormItemEnablementSourceType;
  RefId?: string;
}
export const EvaluationFormItemEnablementSource = S.suspend(() =>
  S.Struct({
    Type: EvaluationFormItemEnablementSourceType,
    RefId: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationFormItemEnablementSource",
}) as any as S.Schema<EvaluationFormItemEnablementSource>;
export interface EvaluationFormItemEnablementSourceValue {
  Type: EvaluationFormItemEnablementSourceValueType;
  RefId?: string;
}
export const EvaluationFormItemEnablementSourceValue = S.suspend(() =>
  S.Struct({
    Type: EvaluationFormItemEnablementSourceValueType,
    RefId: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationFormItemEnablementSourceValue",
}) as any as S.Schema<EvaluationFormItemEnablementSourceValue>;
export type EvaluationFormItemEnablementSourceValueList =
  EvaluationFormItemEnablementSourceValue[];
export const EvaluationFormItemEnablementSourceValueList = S.Array(
  EvaluationFormItemEnablementSourceValue,
);
export interface AgentInfo {
  Id?: string;
  AcceptedByAgentTimestamp?: Date;
  PreviewEndTimestamp?: Date;
  ConnectedToAgentTimestamp?: Date;
  AgentPauseDurationInSeconds?: number;
  HierarchyGroups?: HierarchyGroups;
  DeviceInfo?: DeviceInfo;
  Capabilities?: ParticipantCapabilities;
  AfterContactWorkDuration?: number;
  AfterContactWorkStartTimestamp?: Date;
  AfterContactWorkEndTimestamp?: Date;
  AgentInitiatedHoldDuration?: number;
  StateTransitions?: StateTransition[];
}
export const AgentInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    AcceptedByAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    PreviewEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ConnectedToAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AgentPauseDurationInSeconds: S.optional(S.Number),
    HierarchyGroups: S.optional(HierarchyGroups),
    DeviceInfo: S.optional(DeviceInfo),
    Capabilities: S.optional(ParticipantCapabilities),
    AfterContactWorkDuration: S.optional(S.Number),
    AfterContactWorkStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AfterContactWorkEndTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AgentInitiatedHoldDuration: S.optional(S.Number),
    StateTransitions: S.optional(StateTransitions),
  }),
).annotations({ identifier: "AgentInfo" }) as any as S.Schema<AgentInfo>;
export interface RoutingCriteria {
  Steps?: Step[];
  ActivationTimestamp?: Date;
  Index?: number;
}
export const RoutingCriteria = S.suspend(() =>
  S.Struct({
    Steps: S.optional(Steps),
    ActivationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Index: S.optional(S.Number),
  }),
).annotations({
  identifier: "RoutingCriteria",
}) as any as S.Schema<RoutingCriteria>;
export interface QualityMetrics {
  Agent?: AgentQualityMetrics;
  Customer?: CustomerQualityMetrics;
}
export const QualityMetrics = S.suspend(() =>
  S.Struct({
    Agent: S.optional(AgentQualityMetrics),
    Customer: S.optional(CustomerQualityMetrics),
  }),
).annotations({
  identifier: "QualityMetrics",
}) as any as S.Schema<QualityMetrics>;
export interface NextContactEntry {
  Type?: NextContactType;
  NextContactMetadata?: NextContactMetadata;
}
export const NextContactEntry = S.suspend(() =>
  S.Struct({
    Type: S.optional(NextContactType),
    NextContactMetadata: S.optional(NextContactMetadata),
  }),
).annotations({
  identifier: "NextContactEntry",
}) as any as S.Schema<NextContactEntry>;
export type NextContacts = NextContactEntry[];
export const NextContacts = S.Array(NextContactEntry);
export interface Dimensions {
  Queue?: QueueReference;
  Channel?: Channel;
  RoutingProfile?: RoutingProfileReference;
  RoutingStepExpression?: string;
  AgentStatus?: AgentStatusIdentifier;
  Subtype?: string;
  ValidationTestType?: string;
}
export const Dimensions = S.suspend(() =>
  S.Struct({
    Queue: S.optional(QueueReference),
    Channel: S.optional(Channel),
    RoutingProfile: S.optional(RoutingProfileReference),
    RoutingStepExpression: S.optional(S.String),
    AgentStatus: S.optional(AgentStatusIdentifier),
    Subtype: S.optional(S.String),
    ValidationTestType: S.optional(S.String),
  }),
).annotations({ identifier: "Dimensions" }) as any as S.Schema<Dimensions>;
export interface UserReference {
  Id?: string;
  Arn?: string;
}
export const UserReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "UserReference",
}) as any as S.Schema<UserReference>;
export interface AgentStatusReference {
  StatusStartTimestamp?: Date;
  StatusArn?: string;
  StatusName?: string;
}
export const AgentStatusReference = S.suspend(() =>
  S.Struct({
    StatusStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    StatusArn: S.optional(S.String),
    StatusName: S.optional(S.String),
  }),
).annotations({
  identifier: "AgentStatusReference",
}) as any as S.Schema<AgentStatusReference>;
export type ChannelToCountMap = { [key in Channel]?: number };
export const ChannelToCountMap = S.partial(
  S.Record({ key: Channel, value: S.UndefinedOr(S.Number) }),
);
export interface AgentContactReference {
  ContactId?: string;
  Channel?: Channel;
  InitiationMethod?: ContactInitiationMethod;
  AgentContactState?: ContactState;
  StateStartTimestamp?: Date;
  ConnectedToAgentTimestamp?: Date;
  Queue?: QueueReference;
}
export const AgentContactReference = S.suspend(() =>
  S.Struct({
    ContactId: S.optional(S.String),
    Channel: S.optional(Channel),
    InitiationMethod: S.optional(ContactInitiationMethod),
    AgentContactState: S.optional(ContactState),
    StateStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ConnectedToAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Queue: S.optional(QueueReference),
  }),
).annotations({
  identifier: "AgentContactReference",
}) as any as S.Schema<AgentContactReference>;
export type AgentContactReferenceList = AgentContactReference[];
export const AgentContactReferenceList = S.Array(AgentContactReference);
export interface HistoricalMetricData {
  Metric?: HistoricalMetric;
  Value?: number;
}
export const HistoricalMetricData = S.suspend(() =>
  S.Struct({
    Metric: S.optional(HistoricalMetric),
    Value: S.optional(S.Number),
  }),
).annotations({
  identifier: "HistoricalMetricData",
}) as any as S.Schema<HistoricalMetricData>;
export type HistoricalMetricDataCollections = HistoricalMetricData[];
export const HistoricalMetricDataCollections = S.Array(HistoricalMetricData);
export type DimensionsV2Map = { [key: string]: string | undefined };
export const DimensionsV2Map = S.Record({
  key: S.String,
  value: S.UndefinedOr(S.String),
});
export interface MetricInterval {
  Interval?: IntervalPeriod;
  StartTime?: Date;
  EndTime?: Date;
}
export const MetricInterval = S.suspend(() =>
  S.Struct({
    Interval: S.optional(IntervalPeriod),
    StartTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    EndTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotations({
  identifier: "MetricInterval",
}) as any as S.Schema<MetricInterval>;
export interface MetricDataV2 {
  Metric?: MetricV2;
  Value?: number;
}
export const MetricDataV2 = S.suspend(() =>
  S.Struct({ Metric: S.optional(MetricV2), Value: S.optional(S.Number) }),
).annotations({ identifier: "MetricDataV2" }) as any as S.Schema<MetricDataV2>;
export type MetricDataCollectionsV2 = MetricDataV2[];
export const MetricDataCollectionsV2 = S.Array(MetricDataV2);
export interface RealTimeContactAnalysisSegmentTranscript {
  Id: string;
  ParticipantId: string;
  ParticipantRole: ParticipantRole;
  DisplayName?: string;
  Content: string;
  ContentType?: string;
  Time: RealTimeContactAnalysisTimeData;
  Redaction?: RealTimeContactAnalysisTranscriptItemRedaction;
  Sentiment?: RealTimeContactAnalysisSentimentLabel;
}
export const RealTimeContactAnalysisSegmentTranscript = S.suspend(() =>
  S.Struct({
    Id: S.String,
    ParticipantId: S.String,
    ParticipantRole: ParticipantRole,
    DisplayName: S.optional(S.String),
    Content: S.String,
    ContentType: S.optional(S.String),
    Time: RealTimeContactAnalysisTimeData,
    Redaction: S.optional(RealTimeContactAnalysisTranscriptItemRedaction),
    Sentiment: S.optional(RealTimeContactAnalysisSentimentLabel),
  }),
).annotations({
  identifier: "RealTimeContactAnalysisSegmentTranscript",
}) as any as S.Schema<RealTimeContactAnalysisSegmentTranscript>;
export interface RealTimeContactAnalysisSegmentIssues {
  IssuesDetected: RealTimeContactAnalysisIssueDetected[];
}
export const RealTimeContactAnalysisSegmentIssues = S.suspend(() =>
  S.Struct({ IssuesDetected: RealTimeContactAnalysisIssuesDetected }),
).annotations({
  identifier: "RealTimeContactAnalysisSegmentIssues",
}) as any as S.Schema<RealTimeContactAnalysisSegmentIssues>;
export interface EvaluationSearchMetadata {
  ContactId: string;
  EvaluatorArn: string;
  ContactAgentId?: string;
  CalibrationSessionId?: string;
  ScorePercentage?: number;
  ScoreAutomaticFail?: boolean;
  ScoreNotApplicable?: boolean;
  AutoEvaluationEnabled?: boolean;
  AutoEvaluationStatus?: AutoEvaluationStatus;
  AcknowledgedTime?: Date;
  AcknowledgedBy?: string;
  AcknowledgerComment?: string;
  SamplingJobId?: string;
  ReviewId?: string;
  ContactParticipantRole?: ContactParticipantRole;
  ContactParticipantId?: string;
}
export const EvaluationSearchMetadata = S.suspend(() =>
  S.Struct({
    ContactId: S.String,
    EvaluatorArn: S.String,
    ContactAgentId: S.optional(S.String),
    CalibrationSessionId: S.optional(S.String),
    ScorePercentage: S.optional(S.Number),
    ScoreAutomaticFail: S.optional(S.Boolean),
    ScoreNotApplicable: S.optional(S.Boolean),
    AutoEvaluationEnabled: S.optional(S.Boolean),
    AutoEvaluationStatus: S.optional(AutoEvaluationStatus),
    AcknowledgedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    AcknowledgedBy: S.optional(S.String),
    AcknowledgerComment: S.optional(S.String),
    SamplingJobId: S.optional(S.String),
    ReviewId: S.optional(S.String),
    ContactParticipantRole: S.optional(ContactParticipantRole),
    ContactParticipantId: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationSearchMetadata",
}) as any as S.Schema<EvaluationSearchMetadata>;
export interface EvaluationFormNumericQuestionProperties {
  MinValue: number;
  MaxValue: number;
  Options?: EvaluationFormNumericQuestionOption[];
  Automation?: EvaluationFormNumericQuestionAutomation;
}
export const EvaluationFormNumericQuestionProperties = S.suspend(() =>
  S.Struct({
    MinValue: S.Number,
    MaxValue: S.Number,
    Options: S.optional(EvaluationFormNumericQuestionOptionList),
    Automation: S.optional(EvaluationFormNumericQuestionAutomation),
  }),
).annotations({
  identifier: "EvaluationFormNumericQuestionProperties",
}) as any as S.Schema<EvaluationFormNumericQuestionProperties>;
export interface AudioFeatures {
  EchoReduction?: MeetingFeatureStatus;
}
export const AudioFeatures = S.suspend(() =>
  S.Struct({ EchoReduction: S.optional(MeetingFeatureStatus) }),
).annotations({
  identifier: "AudioFeatures",
}) as any as S.Schema<AudioFeatures>;
export type ServiceQuotaExceededExceptionReason = {
  AttachedFileServiceQuotaExceededExceptionReason: AttachedFileServiceQuotaExceededExceptionReason;
};
export const ServiceQuotaExceededExceptionReason = S.Union(
  S.Struct({
    AttachedFileServiceQuotaExceededExceptionReason:
      AttachedFileServiceQuotaExceededExceptionReason,
  }),
);
export type EvaluationFormSingleSelectQuestionAutomationOption = {
  RuleCategory: SingleSelectQuestionRuleCategoryAutomation;
};
export const EvaluationFormSingleSelectQuestionAutomationOption = S.Union(
  S.Struct({ RuleCategory: SingleSelectQuestionRuleCategoryAutomation }),
);
export type EvaluationFormSingleSelectQuestionAutomationOptionList =
  EvaluationFormSingleSelectQuestionAutomationOption[];
export const EvaluationFormSingleSelectQuestionAutomationOptionList = S.Array(
  EvaluationFormSingleSelectQuestionAutomationOption,
);
export type EvaluationFormMultiSelectQuestionAutomationOption = {
  RuleCategory: MultiSelectQuestionRuleCategoryAutomation;
};
export const EvaluationFormMultiSelectQuestionAutomationOption = S.Union(
  S.Struct({ RuleCategory: MultiSelectQuestionRuleCategoryAutomation }),
);
export type EvaluationFormMultiSelectQuestionAutomationOptionList =
  EvaluationFormMultiSelectQuestionAutomationOption[];
export const EvaluationFormMultiSelectQuestionAutomationOptionList = S.Array(
  EvaluationFormMultiSelectQuestionAutomationOption,
);
export interface EvaluationFormItemEnablementExpression {
  Source: EvaluationFormItemEnablementSource;
  Values: EvaluationFormItemEnablementSourceValue[];
  Comparator: EvaluationFormItemSourceValuesComparator;
}
export const EvaluationFormItemEnablementExpression = S.suspend(() =>
  S.Struct({
    Source: EvaluationFormItemEnablementSource,
    Values: EvaluationFormItemEnablementSourceValueList,
    Comparator: EvaluationFormItemSourceValuesComparator,
  }),
).annotations({
  identifier: "EvaluationFormItemEnablementExpression",
}) as any as S.Schema<EvaluationFormItemEnablementExpression>;
export interface Contact {
  Arn?: string;
  Id?: string;
  InitialContactId?: string;
  PreviousContactId?: string;
  ContactAssociationId?: string;
  InitiationMethod?: ContactInitiationMethod;
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  Channel?: Channel;
  QueueInfo?: QueueInfo;
  AgentInfo?: AgentInfo;
  InitiationTimestamp?: Date;
  DisconnectTimestamp?: Date;
  LastUpdateTimestamp?: Date;
  LastPausedTimestamp?: Date;
  LastResumedTimestamp?: Date;
  RingStartTimestamp?: Date;
  TotalPauseCount?: number;
  TotalPauseDurationInSeconds?: number;
  ScheduledTimestamp?: Date;
  RelatedContactId?: string;
  WisdomInfo?: WisdomInfo;
  CustomerId?: string;
  CustomerEndpoint?: EndpointInfo;
  SystemEndpoint?: EndpointInfo;
  QueueTimeAdjustmentSeconds?: number;
  QueuePriority?: number;
  Tags?: { [key: string]: string | undefined };
  ConnectedToSystemTimestamp?: Date;
  RoutingCriteria?: RoutingCriteria;
  Customer?: Customer;
  Campaign?: Campaign;
  AnsweringMachineDetectionStatus?: AnsweringMachineDetectionStatus;
  CustomerVoiceActivity?: CustomerVoiceActivity;
  QualityMetrics?: QualityMetrics;
  ChatMetrics?: ChatMetrics;
  DisconnectDetails?: DisconnectDetails;
  AdditionalEmailRecipients?: AdditionalEmailRecipients;
  SegmentAttributes?: { [key: string]: SegmentAttributeValue | undefined };
  Recordings?: RecordingInfo[];
  DisconnectReason?: string;
  ContactEvaluations?: { [key: string]: ContactEvaluation | undefined };
  TaskTemplateInfo?: TaskTemplateInfoV2;
  ContactDetails?: ContactDetails;
  OutboundStrategy?: OutboundStrategy;
  Attributes?: { [key: string]: string | undefined };
  NextContacts?: NextContactEntry[];
  GlobalResiliencyMetadata?: GlobalResiliencyMetadata;
}
export const Contact = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    InitialContactId: S.optional(S.String),
    PreviousContactId: S.optional(S.String),
    ContactAssociationId: S.optional(S.String),
    InitiationMethod: S.optional(ContactInitiationMethod),
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    Channel: S.optional(Channel),
    QueueInfo: S.optional(QueueInfo),
    AgentInfo: S.optional(AgentInfo),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DisconnectTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastUpdateTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastPausedTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastResumedTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RingStartTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    TotalPauseCount: S.optional(S.Number),
    TotalPauseDurationInSeconds: S.optional(S.Number),
    ScheduledTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RelatedContactId: S.optional(S.String),
    WisdomInfo: S.optional(WisdomInfo),
    CustomerId: S.optional(S.String),
    CustomerEndpoint: S.optional(EndpointInfo),
    SystemEndpoint: S.optional(EndpointInfo),
    QueueTimeAdjustmentSeconds: S.optional(S.Number),
    QueuePriority: S.optional(S.Number),
    Tags: S.optional(ContactTagMap),
    ConnectedToSystemTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RoutingCriteria: S.optional(RoutingCriteria),
    Customer: S.optional(Customer),
    Campaign: S.optional(Campaign),
    AnsweringMachineDetectionStatus: S.optional(
      AnsweringMachineDetectionStatus,
    ),
    CustomerVoiceActivity: S.optional(CustomerVoiceActivity),
    QualityMetrics: S.optional(QualityMetrics),
    ChatMetrics: S.optional(ChatMetrics),
    DisconnectDetails: S.optional(DisconnectDetails),
    AdditionalEmailRecipients: S.optional(AdditionalEmailRecipients),
    SegmentAttributes: S.optional(SegmentAttributes),
    Recordings: S.optional(Recordings),
    DisconnectReason: S.optional(S.String),
    ContactEvaluations: S.optional(ContactEvaluations),
    TaskTemplateInfo: S.optional(TaskTemplateInfoV2),
    ContactDetails: S.optional(ContactDetails),
    OutboundStrategy: S.optional(OutboundStrategy),
    Attributes: S.optional(Attributes),
    NextContacts: S.optional(NextContacts),
    GlobalResiliencyMetadata: S.optional(GlobalResiliencyMetadata),
  }),
).annotations({ identifier: "Contact" }) as any as S.Schema<Contact>;
export interface CurrentMetricResult {
  Dimensions?: Dimensions;
  Collections?: CurrentMetricData[];
}
export const CurrentMetricResult = S.suspend(() =>
  S.Struct({
    Dimensions: S.optional(Dimensions),
    Collections: S.optional(CurrentMetricDataCollections),
  }),
).annotations({
  identifier: "CurrentMetricResult",
}) as any as S.Schema<CurrentMetricResult>;
export type CurrentMetricResults = CurrentMetricResult[];
export const CurrentMetricResults = S.Array(CurrentMetricResult);
export interface HistoricalMetricResult {
  Dimensions?: Dimensions;
  Collections?: HistoricalMetricData[];
}
export const HistoricalMetricResult = S.suspend(() =>
  S.Struct({
    Dimensions: S.optional(Dimensions),
    Collections: S.optional(HistoricalMetricDataCollections),
  }),
).annotations({
  identifier: "HistoricalMetricResult",
}) as any as S.Schema<HistoricalMetricResult>;
export type HistoricalMetricResults = HistoricalMetricResult[];
export const HistoricalMetricResults = S.Array(HistoricalMetricResult);
export interface MetricResultV2 {
  Dimensions?: { [key: string]: string | undefined };
  MetricInterval?: MetricInterval;
  Collections?: MetricDataV2[];
}
export const MetricResultV2 = S.suspend(() =>
  S.Struct({
    Dimensions: S.optional(DimensionsV2Map),
    MetricInterval: S.optional(MetricInterval),
    Collections: S.optional(MetricDataCollectionsV2),
  }),
).annotations({
  identifier: "MetricResultV2",
}) as any as S.Schema<MetricResultV2>;
export type MetricResultsV2 = MetricResultV2[];
export const MetricResultsV2 = S.Array(MetricResultV2);
export interface RealTimeContactAnalysisTranscriptItemWithCharacterOffsets {
  Id: string;
  CharacterOffsets?: RealTimeContactAnalysisCharacterInterval;
}
export const RealTimeContactAnalysisTranscriptItemWithCharacterOffsets =
  S.suspend(() =>
    S.Struct({
      Id: S.String,
      CharacterOffsets: S.optional(RealTimeContactAnalysisCharacterInterval),
    }),
  ).annotations({
    identifier: "RealTimeContactAnalysisTranscriptItemWithCharacterOffsets",
  }) as any as S.Schema<RealTimeContactAnalysisTranscriptItemWithCharacterOffsets>;
export type RealTimeContactAnalysisTranscriptItemsWithCharacterOffsets =
  RealTimeContactAnalysisTranscriptItemWithCharacterOffsets[];
export const RealTimeContactAnalysisTranscriptItemsWithCharacterOffsets =
  S.Array(RealTimeContactAnalysisTranscriptItemWithCharacterOffsets);
export interface EvaluationSearchSummary {
  EvaluationId: string;
  EvaluationArn: string;
  EvaluationFormId?: string;
  EvaluationFormVersion: number;
  EvaluationFormTitle?: string;
  Metadata: EvaluationSearchMetadata;
  Status: EvaluationStatus;
  EvaluationType?: EvaluationType;
  CreatedTime: Date;
  LastModifiedTime: Date;
  Tags?: { [key: string]: string | undefined };
}
export const EvaluationSearchSummary = S.suspend(() =>
  S.Struct({
    EvaluationId: S.String,
    EvaluationArn: S.String,
    EvaluationFormId: S.optional(S.String),
    EvaluationFormVersion: S.Number,
    EvaluationFormTitle: S.optional(S.String),
    Metadata: EvaluationSearchMetadata,
    Status: EvaluationStatus,
    EvaluationType: S.optional(EvaluationType),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Tags: S.optional(TagMap),
  }),
).annotations({
  identifier: "EvaluationSearchSummary",
}) as any as S.Schema<EvaluationSearchSummary>;
export type EvaluationSearchSummaryList = EvaluationSearchSummary[];
export const EvaluationSearchSummaryList = S.Array(EvaluationSearchSummary);
export type QuestionRuleCategoryAutomationCondition =
  | "PRESENT"
  | "NOT_PRESENT"
  | (string & {});
export const QuestionRuleCategoryAutomationCondition = S.String;
export interface HierarchyGroupSummaryReference {
  Id?: string;
  Arn?: string;
}
export const HierarchyGroupSummaryReference = S.suspend(() =>
  S.Struct({ Id: S.optional(S.String), Arn: S.optional(S.String) }),
).annotations({
  identifier: "HierarchyGroupSummaryReference",
}) as any as S.Schema<HierarchyGroupSummaryReference>;
export interface MeetingFeaturesConfiguration {
  Audio?: AudioFeatures;
}
export const MeetingFeaturesConfiguration = S.suspend(() =>
  S.Struct({ Audio: S.optional(AudioFeatures) }),
).annotations({
  identifier: "MeetingFeaturesConfiguration",
}) as any as S.Schema<MeetingFeaturesConfiguration>;
export interface EvaluationFormSingleSelectQuestionAutomation {
  Options?: EvaluationFormSingleSelectQuestionAutomationOption[];
  DefaultOptionRefId?: string;
  AnswerSource?: EvaluationFormQuestionAutomationAnswerSource;
}
export const EvaluationFormSingleSelectQuestionAutomation = S.suspend(() =>
  S.Struct({
    Options: S.optional(EvaluationFormSingleSelectQuestionAutomationOptionList),
    DefaultOptionRefId: S.optional(S.String),
    AnswerSource: S.optional(EvaluationFormQuestionAutomationAnswerSource),
  }),
).annotations({
  identifier: "EvaluationFormSingleSelectQuestionAutomation",
}) as any as S.Schema<EvaluationFormSingleSelectQuestionAutomation>;
export interface EvaluationFormMultiSelectQuestionAutomation {
  Options?: EvaluationFormMultiSelectQuestionAutomationOption[];
  DefaultOptionRefIds?: string[];
  AnswerSource?: EvaluationFormQuestionAutomationAnswerSource;
}
export const EvaluationFormMultiSelectQuestionAutomation = S.suspend(() =>
  S.Struct({
    Options: S.optional(EvaluationFormMultiSelectQuestionAutomationOptionList),
    DefaultOptionRefIds: S.optional(ReferenceIdList),
    AnswerSource: S.optional(EvaluationFormQuestionAutomationAnswerSource),
  }),
).annotations({
  identifier: "EvaluationFormMultiSelectQuestionAutomation",
}) as any as S.Schema<EvaluationFormMultiSelectQuestionAutomation>;
export type EvaluationFormItemEnablementConditionOperand =
  | { Expression: EvaluationFormItemEnablementExpression; Condition?: never }
  | { Expression?: never; Condition: EvaluationFormItemEnablementCondition };
export const EvaluationFormItemEnablementConditionOperand = S.Union(
  S.Struct({ Expression: EvaluationFormItemEnablementExpression }),
  S.Struct({
    Condition: S.suspend(
      (): S.Schema<EvaluationFormItemEnablementCondition, any> =>
        EvaluationFormItemEnablementCondition,
    ).annotations({ identifier: "EvaluationFormItemEnablementCondition" }),
  }),
) as any as S.Schema<EvaluationFormItemEnablementConditionOperand>;
export type EvaluationFormItemEnablementConditionOperandList =
  EvaluationFormItemEnablementConditionOperand[];
export const EvaluationFormItemEnablementConditionOperandList = S.Array(
  S.suspend(() => EvaluationFormItemEnablementConditionOperand).annotations({
    identifier: "EvaluationFormItemEnablementConditionOperand",
  }),
) as any as S.Schema<EvaluationFormItemEnablementConditionOperandList>;
export interface CreateRuleResponse {
  RuleArn: string;
  RuleId: string;
}
export const CreateRuleResponse = S.suspend(() =>
  S.Struct({ RuleArn: S.String, RuleId: S.String }),
).annotations({
  identifier: "CreateRuleResponse",
}) as any as S.Schema<CreateRuleResponse>;
export interface CreateSecurityProfileResponse {
  SecurityProfileId?: string;
  SecurityProfileArn?: string;
}
export const CreateSecurityProfileResponse = S.suspend(() =>
  S.Struct({
    SecurityProfileId: S.optional(S.String),
    SecurityProfileArn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateSecurityProfileResponse",
}) as any as S.Schema<CreateSecurityProfileResponse>;
export interface CreateWorkspaceResponse {
  WorkspaceId: string;
  WorkspaceArn: string;
}
export const CreateWorkspaceResponse = S.suspend(() =>
  S.Struct({ WorkspaceId: S.String, WorkspaceArn: S.String }),
).annotations({
  identifier: "CreateWorkspaceResponse",
}) as any as S.Schema<CreateWorkspaceResponse>;
export interface DescribeContactResponse {
  Contact?: Contact;
}
export const DescribeContactResponse = S.suspend(() =>
  S.Struct({ Contact: S.optional(Contact) }),
).annotations({
  identifier: "DescribeContactResponse",
}) as any as S.Schema<DescribeContactResponse>;
export interface GetCurrentMetricDataResponse {
  NextToken?: string;
  MetricResults?: CurrentMetricResult[];
  DataSnapshotTime?: Date;
  ApproximateTotalCount?: number;
}
export const GetCurrentMetricDataResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MetricResults: S.optional(CurrentMetricResults),
    DataSnapshotTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "GetCurrentMetricDataResponse",
}) as any as S.Schema<GetCurrentMetricDataResponse>;
export interface GetMetricDataResponse {
  NextToken?: string;
  MetricResults?: HistoricalMetricResult[];
}
export const GetMetricDataResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MetricResults: S.optional(HistoricalMetricResults),
  }),
).annotations({
  identifier: "GetMetricDataResponse",
}) as any as S.Schema<GetMetricDataResponse>;
export interface GetMetricDataV2Response {
  NextToken?: string;
  MetricResults?: MetricResultV2[];
}
export const GetMetricDataV2Response = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    MetricResults: S.optional(MetricResultsV2),
  }),
).annotations({
  identifier: "GetMetricDataV2Response",
}) as any as S.Schema<GetMetricDataV2Response>;
export interface RealTimeContactAnalysisPointOfInterest {
  TranscriptItems?: RealTimeContactAnalysisTranscriptItemWithCharacterOffsets[];
}
export const RealTimeContactAnalysisPointOfInterest = S.suspend(() =>
  S.Struct({
    TranscriptItems: S.optional(
      RealTimeContactAnalysisTranscriptItemsWithCharacterOffsets,
    ),
  }),
).annotations({
  identifier: "RealTimeContactAnalysisPointOfInterest",
}) as any as S.Schema<RealTimeContactAnalysisPointOfInterest>;
export type RealTimeContactAnalysisPointsOfInterest =
  RealTimeContactAnalysisPointOfInterest[];
export const RealTimeContactAnalysisPointsOfInterest = S.Array(
  RealTimeContactAnalysisPointOfInterest,
);
export interface SearchContactEvaluationsResponse {
  EvaluationSearchSummaryList?: EvaluationSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchContactEvaluationsResponse = S.suspend(() =>
  S.Struct({
    EvaluationSearchSummaryList: S.optional(EvaluationSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchContactEvaluationsResponse",
}) as any as S.Schema<SearchContactEvaluationsResponse>;
export interface StartOutboundVoiceContactRequest {
  Name?: string | redacted.Redacted<string>;
  Description?: string | redacted.Redacted<string>;
  References?: { [key: string]: Reference | undefined };
  RelatedContactId?: string;
  DestinationPhoneNumber: string;
  ContactFlowId: string;
  InstanceId: string;
  ClientToken?: string;
  SourcePhoneNumber?: string;
  QueueId?: string;
  Attributes?: { [key: string]: string | undefined };
  AnswerMachineDetectionConfig?: AnswerMachineDetectionConfig;
  CampaignId?: string;
  TrafficType?: TrafficType;
  OutboundStrategy?: OutboundStrategy;
  RingTimeoutInSeconds?: number;
}
export const StartOutboundVoiceContactRequest = S.suspend(() =>
  S.Struct({
    Name: S.optional(SensitiveString),
    Description: S.optional(SensitiveString),
    References: S.optional(ContactReferences),
    RelatedContactId: S.optional(S.String),
    DestinationPhoneNumber: S.String,
    ContactFlowId: S.String,
    InstanceId: S.String,
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    SourcePhoneNumber: S.optional(S.String),
    QueueId: S.optional(S.String),
    Attributes: S.optional(Attributes),
    AnswerMachineDetectionConfig: S.optional(AnswerMachineDetectionConfig),
    CampaignId: S.optional(S.String),
    TrafficType: S.optional(TrafficType),
    OutboundStrategy: S.optional(OutboundStrategy),
    RingTimeoutInSeconds: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/contact/outbound-voice" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartOutboundVoiceContactRequest",
}) as any as S.Schema<StartOutboundVoiceContactRequest>;
export interface EvaluationSuggestedAnswerTranscriptMillisecondOffsets {
  BeginOffsetMillis: number;
}
export const EvaluationSuggestedAnswerTranscriptMillisecondOffsets = S.suspend(
  () => S.Struct({ BeginOffsetMillis: S.Number }),
).annotations({
  identifier: "EvaluationSuggestedAnswerTranscriptMillisecondOffsets",
}) as any as S.Schema<EvaluationSuggestedAnswerTranscriptMillisecondOffsets>;
export interface EvaluationTranscriptPointOfInterest {
  MillisecondOffsets?: EvaluationSuggestedAnswerTranscriptMillisecondOffsets;
  TranscriptSegment?: string;
}
export const EvaluationTranscriptPointOfInterest = S.suspend(() =>
  S.Struct({
    MillisecondOffsets: S.optional(
      EvaluationSuggestedAnswerTranscriptMillisecondOffsets,
    ),
    TranscriptSegment: S.optional(S.String),
  }),
).annotations({
  identifier: "EvaluationTranscriptPointOfInterest",
}) as any as S.Schema<EvaluationTranscriptPointOfInterest>;
export type EvaluationTranscriptPointsOfInterest =
  EvaluationTranscriptPointOfInterest[];
export const EvaluationTranscriptPointsOfInterest = S.Array(
  EvaluationTranscriptPointOfInterest,
);
export interface EvaluationAutomationRuleCategory {
  Category: string;
  Condition: QuestionRuleCategoryAutomationCondition;
  PointsOfInterest?: EvaluationTranscriptPointOfInterest[];
}
export const EvaluationAutomationRuleCategory = S.suspend(() =>
  S.Struct({
    Category: S.String,
    Condition: QuestionRuleCategoryAutomationCondition,
    PointsOfInterest: S.optional(EvaluationTranscriptPointsOfInterest),
  }),
).annotations({
  identifier: "EvaluationAutomationRuleCategory",
}) as any as S.Schema<EvaluationAutomationRuleCategory>;
export type EvaluationAutomationRuleCategoryList =
  EvaluationAutomationRuleCategory[];
export const EvaluationAutomationRuleCategoryList = S.Array(
  EvaluationAutomationRuleCategory,
);
export interface HierarchyPathReference {
  LevelOne?: HierarchyGroupSummaryReference;
  LevelTwo?: HierarchyGroupSummaryReference;
  LevelThree?: HierarchyGroupSummaryReference;
  LevelFour?: HierarchyGroupSummaryReference;
  LevelFive?: HierarchyGroupSummaryReference;
}
export const HierarchyPathReference = S.suspend(() =>
  S.Struct({
    LevelOne: S.optional(HierarchyGroupSummaryReference),
    LevelTwo: S.optional(HierarchyGroupSummaryReference),
    LevelThree: S.optional(HierarchyGroupSummaryReference),
    LevelFour: S.optional(HierarchyGroupSummaryReference),
    LevelFive: S.optional(HierarchyGroupSummaryReference),
  }),
).annotations({
  identifier: "HierarchyPathReference",
}) as any as S.Schema<HierarchyPathReference>;
export interface UserIdentityInfoLite {
  FirstName?: string | redacted.Redacted<string>;
  LastName?: string | redacted.Redacted<string>;
}
export const UserIdentityInfoLite = S.suspend(() =>
  S.Struct({
    FirstName: S.optional(SensitiveString),
    LastName: S.optional(SensitiveString),
  }),
).annotations({
  identifier: "UserIdentityInfoLite",
}) as any as S.Schema<UserIdentityInfoLite>;
export interface Meeting {
  MediaRegion?: string;
  MediaPlacement?: MediaPlacement;
  MeetingFeatures?: MeetingFeaturesConfiguration;
  MeetingId?: string;
}
export const Meeting = S.suspend(() =>
  S.Struct({
    MediaRegion: S.optional(S.String),
    MediaPlacement: S.optional(MediaPlacement),
    MeetingFeatures: S.optional(MeetingFeaturesConfiguration),
    MeetingId: S.optional(S.String),
  }),
).annotations({ identifier: "Meeting" }) as any as S.Schema<Meeting>;
export interface RoutingCriteriaInputStep {
  Expiry?: RoutingCriteriaInputStepExpiry;
  Expression?: Expression;
}
export const RoutingCriteriaInputStep = S.suspend(() =>
  S.Struct({
    Expiry: S.optional(RoutingCriteriaInputStepExpiry),
    Expression: S.optional(Expression),
  }),
).annotations({
  identifier: "RoutingCriteriaInputStep",
}) as any as S.Schema<RoutingCriteriaInputStep>;
export type RoutingCriteriaInputSteps = RoutingCriteriaInputStep[];
export const RoutingCriteriaInputSteps = S.Array(RoutingCriteriaInputStep);
export interface EvaluationFormSingleSelectQuestionProperties {
  Options: EvaluationFormSingleSelectQuestionOption[];
  DisplayAs?: EvaluationFormSingleSelectQuestionDisplayMode;
  Automation?: EvaluationFormSingleSelectQuestionAutomation;
}
export const EvaluationFormSingleSelectQuestionProperties = S.suspend(() =>
  S.Struct({
    Options: EvaluationFormSingleSelectQuestionOptionList,
    DisplayAs: S.optional(EvaluationFormSingleSelectQuestionDisplayMode),
    Automation: S.optional(EvaluationFormSingleSelectQuestionAutomation),
  }),
).annotations({
  identifier: "EvaluationFormSingleSelectQuestionProperties",
}) as any as S.Schema<EvaluationFormSingleSelectQuestionProperties>;
export interface EvaluationFormMultiSelectQuestionProperties {
  Options: EvaluationFormMultiSelectQuestionOption[];
  DisplayAs?: EvaluationFormMultiSelectQuestionDisplayMode;
  Automation?: EvaluationFormMultiSelectQuestionAutomation;
}
export const EvaluationFormMultiSelectQuestionProperties = S.suspend(() =>
  S.Struct({
    Options: EvaluationFormMultiSelectQuestionOptionList,
    DisplayAs: S.optional(EvaluationFormMultiSelectQuestionDisplayMode),
    Automation: S.optional(EvaluationFormMultiSelectQuestionAutomation),
  }),
).annotations({
  identifier: "EvaluationFormMultiSelectQuestionProperties",
}) as any as S.Schema<EvaluationFormMultiSelectQuestionProperties>;
export interface EvaluationFormItemEnablementCondition {
  Operands: EvaluationFormItemEnablementConditionOperand[];
  Operator?: EvaluationFormItemEnablementOperator;
}
export const EvaluationFormItemEnablementCondition = S.suspend(() =>
  S.Struct({
    Operands: S.suspend(
      () => EvaluationFormItemEnablementConditionOperandList,
    ).annotations({
      identifier: "EvaluationFormItemEnablementConditionOperandList",
    }),
    Operator: S.optional(EvaluationFormItemEnablementOperator),
  }),
).annotations({
  identifier: "EvaluationFormItemEnablementCondition",
}) as any as S.Schema<EvaluationFormItemEnablementCondition>;
export interface RealTimeContactAnalysisCategoryDetails {
  PointsOfInterest: RealTimeContactAnalysisPointOfInterest[];
}
export const RealTimeContactAnalysisCategoryDetails = S.suspend(() =>
  S.Struct({ PointsOfInterest: RealTimeContactAnalysisPointsOfInterest }),
).annotations({
  identifier: "RealTimeContactAnalysisCategoryDetails",
}) as any as S.Schema<RealTimeContactAnalysisCategoryDetails>;
export interface EvaluationContactLensAnswerAnalysisDetails {
  MatchedRuleCategories?: EvaluationAutomationRuleCategory[];
}
export const EvaluationContactLensAnswerAnalysisDetails = S.suspend(() =>
  S.Struct({
    MatchedRuleCategories: S.optional(EvaluationAutomationRuleCategoryList),
  }),
).annotations({
  identifier: "EvaluationContactLensAnswerAnalysisDetails",
}) as any as S.Schema<EvaluationContactLensAnswerAnalysisDetails>;
export interface UserData {
  User?: UserReference;
  RoutingProfile?: RoutingProfileReference;
  HierarchyPath?: HierarchyPathReference;
  Status?: AgentStatusReference;
  AvailableSlotsByChannel?: { [key: string]: number | undefined };
  MaxSlotsByChannel?: { [key: string]: number | undefined };
  ActiveSlotsByChannel?: { [key: string]: number | undefined };
  Contacts?: AgentContactReference[];
  NextStatus?: string;
}
export const UserData = S.suspend(() =>
  S.Struct({
    User: S.optional(UserReference),
    RoutingProfile: S.optional(RoutingProfileReference),
    HierarchyPath: S.optional(HierarchyPathReference),
    Status: S.optional(AgentStatusReference),
    AvailableSlotsByChannel: S.optional(ChannelToCountMap),
    MaxSlotsByChannel: S.optional(ChannelToCountMap),
    ActiveSlotsByChannel: S.optional(ChannelToCountMap),
    Contacts: S.optional(AgentContactReferenceList),
    NextStatus: S.optional(S.String),
  }),
).annotations({ identifier: "UserData" }) as any as S.Schema<UserData>;
export type UserDataList = UserData[];
export const UserDataList = S.Array(UserData);
export interface UserSearchSummary {
  Arn?: string;
  DirectoryUserId?: string;
  HierarchyGroupId?: string;
  Id?: string;
  IdentityInfo?: UserIdentityInfoLite;
  PhoneConfig?: UserPhoneConfig;
  RoutingProfileId?: string;
  SecurityProfileIds?: string[];
  Tags?: { [key: string]: string | undefined };
  Username?: string;
}
export const UserSearchSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DirectoryUserId: S.optional(S.String),
    HierarchyGroupId: S.optional(S.String),
    Id: S.optional(S.String),
    IdentityInfo: S.optional(UserIdentityInfoLite),
    PhoneConfig: S.optional(UserPhoneConfig),
    RoutingProfileId: S.optional(S.String),
    SecurityProfileIds: S.optional(SecurityProfileIds),
    Tags: S.optional(TagMap),
    Username: S.optional(S.String),
  }),
).annotations({
  identifier: "UserSearchSummary",
}) as any as S.Schema<UserSearchSummary>;
export type UserSearchSummaryList = UserSearchSummary[];
export const UserSearchSummaryList = S.Array(UserSearchSummary);
export interface ConnectionData {
  Attendee?: Attendee;
  Meeting?: Meeting;
}
export const ConnectionData = S.suspend(() =>
  S.Struct({ Attendee: S.optional(Attendee), Meeting: S.optional(Meeting) }),
).annotations({
  identifier: "ConnectionData",
}) as any as S.Schema<ConnectionData>;
export interface RoutingCriteriaInput {
  Steps?: RoutingCriteriaInputStep[];
}
export const RoutingCriteriaInput = S.suspend(() =>
  S.Struct({ Steps: S.optional(RoutingCriteriaInputSteps) }),
).annotations({
  identifier: "RoutingCriteriaInput",
}) as any as S.Schema<RoutingCriteriaInput>;
export type EvaluationFormQuestionTypeProperties =
  | {
      Numeric: EvaluationFormNumericQuestionProperties;
      SingleSelect?: never;
      Text?: never;
      MultiSelect?: never;
    }
  | {
      Numeric?: never;
      SingleSelect: EvaluationFormSingleSelectQuestionProperties;
      Text?: never;
      MultiSelect?: never;
    }
  | {
      Numeric?: never;
      SingleSelect?: never;
      Text: EvaluationFormTextQuestionProperties;
      MultiSelect?: never;
    }
  | {
      Numeric?: never;
      SingleSelect?: never;
      Text?: never;
      MultiSelect: EvaluationFormMultiSelectQuestionProperties;
    };
export const EvaluationFormQuestionTypeProperties = S.Union(
  S.Struct({ Numeric: EvaluationFormNumericQuestionProperties }),
  S.Struct({ SingleSelect: EvaluationFormSingleSelectQuestionProperties }),
  S.Struct({ Text: EvaluationFormTextQuestionProperties }),
  S.Struct({ MultiSelect: EvaluationFormMultiSelectQuestionProperties }),
);
export interface EvaluationFormItemEnablementConfiguration {
  Condition: EvaluationFormItemEnablementCondition;
  Action: EvaluationFormItemEnablementAction;
  DefaultAction?: EvaluationFormItemEnablementAction;
}
export const EvaluationFormItemEnablementConfiguration = S.suspend(() =>
  S.Struct({
    Condition: EvaluationFormItemEnablementCondition,
    Action: EvaluationFormItemEnablementAction,
    DefaultAction: S.optional(EvaluationFormItemEnablementAction),
  }),
).annotations({
  identifier: "EvaluationFormItemEnablementConfiguration",
}) as any as S.Schema<EvaluationFormItemEnablementConfiguration>;
export type RealTimeContactAnalysisMatchedDetails = {
  [key: string]: RealTimeContactAnalysisCategoryDetails | undefined;
};
export const RealTimeContactAnalysisMatchedDetails = S.Record({
  key: S.String,
  value: S.UndefinedOr(RealTimeContactAnalysisCategoryDetails),
});
export interface GetCurrentUserDataResponse {
  NextToken?: string;
  UserDataList?: UserData[];
  ApproximateTotalCount?: number;
}
export const GetCurrentUserDataResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    UserDataList: S.optional(UserDataList),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "GetCurrentUserDataResponse",
}) as any as S.Schema<GetCurrentUserDataResponse>;
export interface SearchUsersResponse {
  Users?: UserSearchSummary[];
  NextToken?: string;
  ApproximateTotalCount?: number;
}
export const SearchUsersResponse = S.suspend(() =>
  S.Struct({
    Users: S.optional(UserSearchSummaryList),
    NextToken: S.optional(S.String),
    ApproximateTotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchUsersResponse",
}) as any as S.Schema<SearchUsersResponse>;
export interface StartOutboundVoiceContactResponse {
  ContactId?: string;
}
export const StartOutboundVoiceContactResponse = S.suspend(() =>
  S.Struct({ ContactId: S.optional(S.String) }),
).annotations({
  identifier: "StartOutboundVoiceContactResponse",
}) as any as S.Schema<StartOutboundVoiceContactResponse>;
export interface StartWebRTCContactResponse {
  ConnectionData?: ConnectionData;
  ContactId?: string;
  ParticipantId?: string;
  ParticipantToken?: string;
}
export const StartWebRTCContactResponse = S.suspend(() =>
  S.Struct({
    ConnectionData: S.optional(ConnectionData),
    ContactId: S.optional(S.String),
    ParticipantId: S.optional(S.String),
    ParticipantToken: S.optional(S.String),
  }),
).annotations({
  identifier: "StartWebRTCContactResponse",
}) as any as S.Schema<StartWebRTCContactResponse>;
export interface UpdateContactRoutingDataRequest {
  InstanceId: string;
  ContactId: string;
  QueueTimeAdjustmentSeconds?: number;
  QueuePriority?: number;
  RoutingCriteria?: RoutingCriteriaInput;
}
export const UpdateContactRoutingDataRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    ContactId: S.String.pipe(T.HttpLabel("ContactId")),
    QueueTimeAdjustmentSeconds: S.optional(S.Number),
    QueuePriority: S.optional(S.Number),
    RoutingCriteria: S.optional(RoutingCriteriaInput),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/contacts/{InstanceId}/{ContactId}/routing-data",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateContactRoutingDataRequest",
}) as any as S.Schema<UpdateContactRoutingDataRequest>;
export interface UpdateContactRoutingDataResponse {}
export const UpdateContactRoutingDataResponse = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "UpdateContactRoutingDataResponse",
}) as any as S.Schema<UpdateContactRoutingDataResponse>;
export interface EvaluationFormQuestion {
  Title: string;
  Instructions?: string;
  RefId: string;
  NotApplicableEnabled?: boolean;
  QuestionType: EvaluationFormQuestionType;
  QuestionTypeProperties?: EvaluationFormQuestionTypeProperties;
  Enablement?: EvaluationFormItemEnablementConfiguration;
  Weight?: number;
}
export const EvaluationFormQuestion = S.suspend(() =>
  S.Struct({
    Title: S.String,
    Instructions: S.optional(S.String),
    RefId: S.String,
    NotApplicableEnabled: S.optional(S.Boolean),
    QuestionType: EvaluationFormQuestionType,
    QuestionTypeProperties: S.optional(EvaluationFormQuestionTypeProperties),
    Enablement: S.optional(EvaluationFormItemEnablementConfiguration),
    Weight: S.optional(S.Number),
  }),
).annotations({
  identifier: "EvaluationFormQuestion",
}) as any as S.Schema<EvaluationFormQuestion>;
export interface RealTimeContactAnalysisSegmentCategories {
  MatchedDetails: {
    [key: string]: RealTimeContactAnalysisCategoryDetails | undefined;
  };
}
export const RealTimeContactAnalysisSegmentCategories = S.suspend(() =>
  S.Struct({ MatchedDetails: RealTimeContactAnalysisMatchedDetails }),
).annotations({
  identifier: "RealTimeContactAnalysisSegmentCategories",
}) as any as S.Schema<RealTimeContactAnalysisSegmentCategories>;
export interface ContactSearchSummaryQueueInfo {
  Id?: string;
  EnqueueTimestamp?: Date;
}
export const ContactSearchSummaryQueueInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    EnqueueTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "ContactSearchSummaryQueueInfo",
}) as any as S.Schema<ContactSearchSummaryQueueInfo>;
export interface ContactSearchSummaryAgentInfo {
  Id?: string;
  ConnectedToAgentTimestamp?: Date;
}
export const ContactSearchSummaryAgentInfo = S.suspend(() =>
  S.Struct({
    Id: S.optional(S.String),
    ConnectedToAgentTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "ContactSearchSummaryAgentInfo",
}) as any as S.Schema<ContactSearchSummaryAgentInfo>;
export type EvaluationFormItem =
  | { Section: EvaluationFormSection; Question?: never }
  | { Section?: never; Question: EvaluationFormQuestion };
export const EvaluationFormItem = S.Union(
  S.Struct({
    Section: S.suspend(
      (): S.Schema<EvaluationFormSection, any> => EvaluationFormSection,
    ).annotations({ identifier: "EvaluationFormSection" }),
  }),
  S.Struct({ Question: EvaluationFormQuestion }),
) as any as S.Schema<EvaluationFormItem>;
export interface EvaluationGenAIAnswerAnalysisDetails {
  Justification?: string;
  PointsOfInterest?: EvaluationTranscriptPointOfInterest[];
}
export const EvaluationGenAIAnswerAnalysisDetails = S.suspend(() =>
  S.Struct({
    Justification: S.optional(S.String),
    PointsOfInterest: S.optional(EvaluationTranscriptPointsOfInterest),
  }),
).annotations({
  identifier: "EvaluationGenAIAnswerAnalysisDetails",
}) as any as S.Schema<EvaluationGenAIAnswerAnalysisDetails>;
export type RealtimeContactAnalysisSegment =
  | {
      Transcript: RealTimeContactAnalysisSegmentTranscript;
      Categories?: never;
      Issues?: never;
      Event?: never;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories: RealTimeContactAnalysisSegmentCategories;
      Issues?: never;
      Event?: never;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues: RealTimeContactAnalysisSegmentIssues;
      Event?: never;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues?: never;
      Event: RealTimeContactAnalysisSegmentEvent;
      Attachments?: never;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues?: never;
      Event?: never;
      Attachments: RealTimeContactAnalysisSegmentAttachments;
      PostContactSummary?: never;
    }
  | {
      Transcript?: never;
      Categories?: never;
      Issues?: never;
      Event?: never;
      Attachments?: never;
      PostContactSummary: RealTimeContactAnalysisSegmentPostContactSummary;
    };
export const RealtimeContactAnalysisSegment = S.Union(
  S.Struct({ Transcript: RealTimeContactAnalysisSegmentTranscript }),
  S.Struct({ Categories: RealTimeContactAnalysisSegmentCategories }),
  S.Struct({ Issues: RealTimeContactAnalysisSegmentIssues }),
  S.Struct({ Event: RealTimeContactAnalysisSegmentEvent }),
  S.Struct({ Attachments: RealTimeContactAnalysisSegmentAttachments }),
  S.Struct({
    PostContactSummary: RealTimeContactAnalysisSegmentPostContactSummary,
  }),
);
export type RealtimeContactAnalysisSegments = RealtimeContactAnalysisSegment[];
export const RealtimeContactAnalysisSegments = S.Array(
  RealtimeContactAnalysisSegment,
);
export interface ContactSearchSummarySegmentAttributeValue {
  ValueString?: string;
  ValueMap?: { [key: string]: SegmentAttributeValue | undefined };
}
export const ContactSearchSummarySegmentAttributeValue = S.suspend(() =>
  S.Struct({
    ValueString: S.optional(S.String),
    ValueMap: S.optional(SegmentAttributeValueMap),
  }),
).annotations({
  identifier: "ContactSearchSummarySegmentAttributeValue",
}) as any as S.Schema<ContactSearchSummarySegmentAttributeValue>;
export interface CreateEvaluationFormRequest {
  InstanceId: string;
  Title: string;
  Description?: string;
  Items: EvaluationFormItem[];
  ScoringStrategy?: EvaluationFormScoringStrategy;
  AutoEvaluationConfiguration?: EvaluationFormAutoEvaluationConfiguration;
  ClientToken?: string;
  AsDraft?: boolean;
  Tags?: { [key: string]: string | undefined };
  TargetConfiguration?: EvaluationFormTargetConfiguration;
  LanguageConfiguration?: EvaluationFormLanguageConfiguration;
}
export const CreateEvaluationFormRequest = S.suspend(() =>
  S.Struct({
    InstanceId: S.String.pipe(T.HttpLabel("InstanceId")),
    Title: S.String,
    Description: S.optional(S.String),
    Items: EvaluationFormItemsList,
    ScoringStrategy: S.optional(EvaluationFormScoringStrategy),
    AutoEvaluationConfiguration: S.optional(
      EvaluationFormAutoEvaluationConfiguration,
    ),
    ClientToken: S.optional(S.String).pipe(T.IdempotencyToken()),
    AsDraft: S.optional(S.Boolean),
    Tags: S.optional(TagMap),
    TargetConfiguration: S.optional(EvaluationFormTargetConfiguration),
    LanguageConfiguration: S.optional(EvaluationFormLanguageConfiguration),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/evaluation-forms/{InstanceId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateEvaluationFormRequest",
}) as any as S.Schema<CreateEvaluationFormRequest>;
export type EvaluationQuestionAnswerAnalysisDetails =
  | { GenAI: EvaluationGenAIAnswerAnalysisDetails; ContactLens?: never }
  | { GenAI?: never; ContactLens: EvaluationContactLensAnswerAnalysisDetails };
export const EvaluationQuestionAnswerAnalysisDetails = S.Union(
  S.Struct({ GenAI: EvaluationGenAIAnswerAnalysisDetails }),
  S.Struct({ ContactLens: EvaluationContactLensAnswerAnalysisDetails }),
);
export interface ListRealtimeContactAnalysisSegmentsV2Response {
  Channel: RealTimeContactAnalysisSupportedChannel;
  Status: RealTimeContactAnalysisStatus;
  Segments: RealtimeContactAnalysisSegment[];
  NextToken?: string;
}
export const ListRealtimeContactAnalysisSegmentsV2Response = S.suspend(() =>
  S.Struct({
    Channel: RealTimeContactAnalysisSupportedChannel,
    Status: RealTimeContactAnalysisStatus,
    Segments: RealtimeContactAnalysisSegments,
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListRealtimeContactAnalysisSegmentsV2Response",
}) as any as S.Schema<ListRealtimeContactAnalysisSegmentsV2Response>;
export type ContactSearchSummarySegmentAttributes = {
  [key: string]: ContactSearchSummarySegmentAttributeValue | undefined;
};
export const ContactSearchSummarySegmentAttributes = S.Record({
  key: S.String,
  value: S.UndefinedOr(ContactSearchSummarySegmentAttributeValue),
});
export interface EvaluationSuggestedAnswer {
  Value?: EvaluationAnswerData;
  Status: EvaluationSuggestedAnswerStatus;
  Input?: EvaluationQuestionInputDetails;
  AnalysisType: EvaluationQuestionAnswerAnalysisType;
  AnalysisDetails?: EvaluationQuestionAnswerAnalysisDetails;
}
export const EvaluationSuggestedAnswer = S.suspend(() =>
  S.Struct({
    Value: S.optional(EvaluationAnswerData),
    Status: EvaluationSuggestedAnswerStatus,
    Input: S.optional(EvaluationQuestionInputDetails),
    AnalysisType: EvaluationQuestionAnswerAnalysisType,
    AnalysisDetails: S.optional(EvaluationQuestionAnswerAnalysisDetails),
  }),
).annotations({
  identifier: "EvaluationSuggestedAnswer",
}) as any as S.Schema<EvaluationSuggestedAnswer>;
export type EvaluationSuggestedAnswersList = EvaluationSuggestedAnswer[];
export const EvaluationSuggestedAnswersList = S.Array(
  EvaluationSuggestedAnswer,
);
export interface ContactSearchSummary {
  Arn?: string;
  Id?: string;
  InitialContactId?: string;
  PreviousContactId?: string;
  InitiationMethod?: ContactInitiationMethod;
  Channel?: Channel;
  QueueInfo?: ContactSearchSummaryQueueInfo;
  AgentInfo?: ContactSearchSummaryAgentInfo;
  InitiationTimestamp?: Date;
  DisconnectTimestamp?: Date;
  ScheduledTimestamp?: Date;
  SegmentAttributes?: {
    [key: string]: ContactSearchSummarySegmentAttributeValue | undefined;
  };
  Name?: string | redacted.Redacted<string>;
  RoutingCriteria?: RoutingCriteria;
  GlobalResiliencyMetadata?: GlobalResiliencyMetadata;
}
export const ContactSearchSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Id: S.optional(S.String),
    InitialContactId: S.optional(S.String),
    PreviousContactId: S.optional(S.String),
    InitiationMethod: S.optional(ContactInitiationMethod),
    Channel: S.optional(Channel),
    QueueInfo: S.optional(ContactSearchSummaryQueueInfo),
    AgentInfo: S.optional(ContactSearchSummaryAgentInfo),
    InitiationTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DisconnectTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ScheduledTimestamp: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SegmentAttributes: S.optional(ContactSearchSummarySegmentAttributes),
    Name: S.optional(SensitiveString),
    RoutingCriteria: S.optional(RoutingCriteria),
    GlobalResiliencyMetadata: S.optional(GlobalResiliencyMetadata),
  }),
).annotations({
  identifier: "ContactSearchSummary",
}) as any as S.Schema<ContactSearchSummary>;
export type Contacts = ContactSearchSummary[];
export const Contacts = S.Array(ContactSearchSummary);
export interface EvaluationAnswerOutput {
  Value?: EvaluationAnswerData;
  SystemSuggestedValue?: EvaluationAnswerData;
  SuggestedAnswers?: EvaluationSuggestedAnswer[];
}
export const EvaluationAnswerOutput = S.suspend(() =>
  S.Struct({
    Value: S.optional(EvaluationAnswerData),
    SystemSuggestedValue: S.optional(EvaluationAnswerData),
    SuggestedAnswers: S.optional(EvaluationSuggestedAnswersList),
  }),
).annotations({
  identifier: "EvaluationAnswerOutput",
}) as any as S.Schema<EvaluationAnswerOutput>;
export interface CreateEvaluationFormResponse {
  EvaluationFormId: string;
  EvaluationFormArn: string;
}
export const CreateEvaluationFormResponse = S.suspend(() =>
  S.Struct({ EvaluationFormId: S.String, EvaluationFormArn: S.String }),
).annotations({
  identifier: "CreateEvaluationFormResponse",
}) as any as S.Schema<CreateEvaluationFormResponse>;
export interface SearchContactsResponse {
  Contacts: ContactSearchSummary[];
  NextToken?: string;
  TotalCount?: number;
}
export const SearchContactsResponse = S.suspend(() =>
  S.Struct({
    Contacts: Contacts,
    NextToken: S.optional(S.String),
    TotalCount: S.optional(S.Number),
  }),
).annotations({
  identifier: "SearchContactsResponse",
}) as any as S.Schema<SearchContactsResponse>;
export type EvaluationAnswersOutputMap = {
  [key: string]: EvaluationAnswerOutput | undefined;
};
export const EvaluationAnswersOutputMap = S.Record({
  key: S.String,
  value: S.UndefinedOr(EvaluationAnswerOutput),
});
export interface Evaluation {
  EvaluationId: string;
  EvaluationArn: string;
  Metadata: EvaluationMetadata;
  Answers: { [key: string]: EvaluationAnswerOutput | undefined };
  Notes: { [key: string]: EvaluationNote | undefined };
  Status: EvaluationStatus;
  Scores?: { [key: string]: EvaluationScore | undefined };
  CreatedTime: Date;
  LastModifiedTime: Date;
  EvaluationType?: EvaluationType;
  Tags?: { [key: string]: string | undefined };
}
export const Evaluation = S.suspend(() =>
  S.Struct({
    EvaluationId: S.String,
    EvaluationArn: S.String,
    Metadata: EvaluationMetadata,
    Answers: EvaluationAnswersOutputMap,
    Notes: EvaluationNotesMap,
    Status: EvaluationStatus,
    Scores: S.optional(EvaluationScoresMap),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastModifiedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EvaluationType: S.optional(EvaluationType),
    Tags: S.optional(TagMap),
  }),
).annotations({ identifier: "Evaluation" }) as any as S.Schema<Evaluation>;
export interface DescribeContactEvaluationResponse {
  Evaluation: Evaluation;
  EvaluationForm: EvaluationFormContent;
}
export const DescribeContactEvaluationResponse = S.suspend(() =>
  S.Struct({ Evaluation: Evaluation, EvaluationForm: EvaluationFormContent }),
).annotations({
  identifier: "DescribeContactEvaluationResponse",
}) as any as S.Schema<DescribeContactEvaluationResponse>;

//# Errors
export class InternalServiceException extends S.TaggedError<InternalServiceException>()(
  "InternalServiceException",
  { Message: S.optional(S.String) },
).pipe(C.withServerError) {}
export class AccessDeniedException extends S.TaggedError<AccessDeniedException>()(
  "AccessDeniedException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "AccessDeniedException", httpResponseCode: 403 }),
).pipe(C.withAuthError) {}
export class DuplicateResourceException extends S.TaggedError<DuplicateResourceException>()(
  "DuplicateResourceException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class ConditionalOperationFailedException extends S.TaggedError<ConditionalOperationFailedException>()(
  "ConditionalOperationFailedException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class InvalidParameterException extends S.TaggedError<InvalidParameterException>()(
  "InvalidParameterException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class IdempotencyException extends S.TaggedError<IdempotencyException>()(
  "IdempotencyException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class ConflictException extends S.TaggedError<ConflictException>()(
  "ConflictException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class InvalidActiveRegionException extends S.TaggedError<InvalidActiveRegionException>()(
  "InvalidActiveRegionException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class ContactNotFoundException extends S.TaggedError<ContactNotFoundException>()(
  "ContactNotFoundException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "ContactNotFoundException", httpResponseCode: 410 }),
).pipe(C.withBadRequestError) {}
export class InvalidContactFlowModuleException extends S.TaggedError<InvalidContactFlowModuleException>()(
  "InvalidContactFlowModuleException",
  { Problems: S.optional(Problems) },
).pipe(C.withBadRequestError) {}
export class InvalidRequestException extends S.TaggedError<InvalidRequestException>()(
  "InvalidRequestException",
  {
    Message: S.optional(S.String),
    Reason: S.optional(InvalidRequestExceptionReason),
  },
).pipe(C.withBadRequestError) {}
export class ResourceNotFoundException extends S.TaggedError<ResourceNotFoundException>()(
  "ResourceNotFoundException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class ContactFlowNotPublishedException extends S.TaggedError<ContactFlowNotPublishedException>()(
  "ContactFlowNotPublishedException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class ThrottlingException extends S.TaggedError<ThrottlingException>()(
  "ThrottlingException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "ThrottlingException", httpResponseCode: 429 }),
).pipe(C.withThrottlingError) {}
export class ResourceConflictException extends S.TaggedError<ResourceConflictException>()(
  "ResourceConflictException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class InvalidContactFlowException extends S.TaggedError<InvalidContactFlowException>()(
  "InvalidContactFlowException",
  { problems: S.optional(Problems) },
).pipe(C.withBadRequestError) {}
export class ResourceInUseException extends S.TaggedError<ResourceInUseException>()(
  "ResourceInUseException",
  {
    Message: S.optional(S.String),
    ResourceType: S.optional(ResourceType),
    ResourceId: S.optional(S.String),
  },
).pipe(C.withConflictError) {}
export class LimitExceededException extends S.TaggedError<LimitExceededException>()(
  "LimitExceededException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({ code: "LimitExceededException", httpResponseCode: 429 }),
).pipe(C.withThrottlingError) {}
export class PropertyValidationException extends S.TaggedError<PropertyValidationException>()(
  "PropertyValidationException",
  {
    Message: S.String,
    PropertyList: S.optional(PropertyValidationExceptionPropertyList),
  },
).pipe(C.withBadRequestError) {}
export class ResourceNotReadyException extends S.TaggedError<ResourceNotReadyException>()(
  "ResourceNotReadyException",
  { Message: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class UserNotFoundException extends S.TaggedError<UserNotFoundException>()(
  "UserNotFoundException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class TooManyRequestsException extends S.TaggedError<TooManyRequestsException>()(
  "TooManyRequestsException",
  { Message: S.optional(S.String) },
).pipe(C.withThrottlingError) {}
export class ServiceQuotaExceededException extends S.TaggedError<ServiceQuotaExceededException>()(
  "ServiceQuotaExceededException",
  {
    Message: S.optional(S.String),
    Reason: S.optional(ServiceQuotaExceededExceptionReason),
  },
).pipe(C.withQuotaError) {}
export class MaximumResultReturnedException extends S.TaggedError<MaximumResultReturnedException>()(
  "MaximumResultReturnedException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class DestinationNotAllowedException extends S.TaggedError<DestinationNotAllowedException>()(
  "DestinationNotAllowedException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({
    code: "DestinationNotAllowedException",
    httpResponseCode: 403,
  }),
).pipe(C.withAuthError) {}
export class OutputTypeNotFoundException extends S.TaggedError<OutputTypeNotFoundException>()(
  "OutputTypeNotFoundException",
  { Message: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class OutboundContactNotPermittedException extends S.TaggedError<OutboundContactNotPermittedException>()(
  "OutboundContactNotPermittedException",
  { Message: S.optional(S.String) },
  T.AwsQueryError({
    code: "OutboundContactNotPermittedException",
    httpResponseCode: 403,
  }),
).pipe(C.withAuthError) {}

//# Operations
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns the current state of the specified instance identifier. It tracks the instance while it is being created
 * and returns an error status, if applicable.
 *
 * If an instance is not created successfully, the instance status reason field returns details relevant to the
 * reason. The instance in a failed state is returned only for 24 hours after the CreateInstance API was invoked.
 */
export const describeInstance: (
  input: DescribeInstanceRequest,
) => effect.Effect<
  DescribeInstanceResponse,
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceRequest,
  output: DescribeInstanceResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Searches for available phone numbers that you can claim to your Amazon Connect instance or traffic distribution group. If the
 * provided `TargetArn` is a traffic distribution group, you can call this API in both Amazon Web Services Regions associated with
 * the traffic distribution group.
 */
export const searchAvailablePhoneNumbers: {
  (
    input: SearchAvailablePhoneNumbersRequest,
  ): effect.Effect<
    SearchAvailablePhoneNumbersResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchAvailablePhoneNumbersRequest,
  ) => stream.Stream<
    SearchAvailablePhoneNumbersResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchAvailablePhoneNumbersRequest,
  ) => stream.Stream<
    AvailableNumberSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchAvailablePhoneNumbersRequest,
  output: SearchAvailablePhoneNumbersResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AvailableNumbersList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches the flow modules in an Amazon Connect instance, with optional filtering.
 */
export const searchContactFlowModules: {
  (
    input: SearchContactFlowModulesRequest,
  ): effect.Effect<
    SearchContactFlowModulesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchContactFlowModulesRequest,
  ) => stream.Stream<
    SearchContactFlowModulesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchContactFlowModulesRequest,
  ) => stream.Stream<
    ContactFlowModule,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchContactFlowModulesRequest,
  output: SearchContactFlowModulesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModules",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches email address in an instance, with optional filtering.
 */
export const searchEmailAddresses: (
  input: SearchEmailAddressesRequest,
) => effect.Effect<
  SearchEmailAddressesResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchEmailAddressesRequest,
  output: SearchEmailAddressesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Searches evaluation forms in an Amazon Connect instance, with optional filtering.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - List all evaluation forms in an instance.
 *
 * - Find all evaluation forms that meet specific criteria, such as Title, Description, Status, and more.
 *
 * - Find all evaluation forms that are tagged with a specific set of tags.
 *
 * **Important things to know**
 *
 * - A Search operation, unlike a List operation, takes time to index changes to resource (create, update or
 * delete). If you don't see updated information for recently changed contact evaluations, try calling the API again
 * in a few seconds.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const searchEvaluationForms: (
  input: SearchEvaluationFormsRequest,
) => effect.Effect<
  SearchEvaluationFormsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchEvaluationFormsRequest,
  output: SearchEvaluationFormsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Searches the hours of operation overrides.
 */
export const searchHoursOfOperationOverrides: {
  (
    input: SearchHoursOfOperationOverridesRequest,
  ): effect.Effect<
    SearchHoursOfOperationOverridesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    SearchHoursOfOperationOverridesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    HoursOfOperationOverride,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchHoursOfOperationOverridesRequest,
  output: SearchHoursOfOperationOverridesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperationOverrides",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches security profiles in an Amazon Connect instance, with optional filtering.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const searchSecurityProfiles: {
  (
    input: SearchSecurityProfilesRequest,
  ): effect.Effect<
    SearchSecurityProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchSecurityProfilesRequest,
  ) => stream.Stream<
    SearchSecurityProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchSecurityProfilesRequest,
  ) => stream.Stream<
    SecurityProfileSearchSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchSecurityProfilesRequest,
  output: SearchSecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityProfiles",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for workspace associations with users or routing profiles based on various criteria.
 */
export const searchWorkspaceAssociations: {
  (
    input: SearchWorkspaceAssociationsRequest,
  ): effect.Effect<
    SearchWorkspaceAssociationsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchWorkspaceAssociationsRequest,
  ) => stream.Stream<
    SearchWorkspaceAssociationsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchWorkspaceAssociationsRequest,
  ) => stream.Stream<
    WorkspaceAssociationSearchSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchWorkspaceAssociationsRequest,
  output: SearchWorkspaceAssociationsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "WorkspaceAssociations",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches workspaces based on name, description, visibility, or tags.
 */
export const searchWorkspaces: {
  (
    input: SearchWorkspacesRequest,
  ): effect.Effect<
    SearchWorkspacesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchWorkspacesRequest,
  ) => stream.Stream<
    SearchWorkspacesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchWorkspacesRequest,
  ) => stream.Stream<
    WorkspaceSearchSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchWorkspacesRequest,
  output: SearchWorkspacesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Workspaces",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Updates the specified flow.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 */
export const updateContactFlowContent: (
  input: UpdateContactFlowContentRequest,
) => effect.Effect<
  UpdateContactFlowContentResponse,
  | InternalServiceException
  | InvalidContactFlowException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowContentRequest,
  output: UpdateContactFlowContentResponse,
  errors: [
    InternalServiceException,
    InvalidContactFlowException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves the contact attributes for the specified contact.
 */
export const getContactAttributes: (
  input: GetContactAttributesRequest,
) => effect.Effect<
  GetContactAttributesResponse,
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetContactAttributesRequest,
  output: GetContactAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Retrieves the current traffic distribution for a given traffic distribution group.
 */
export const getTrafficDistribution: (
  input: GetTrafficDistributionRequest,
) => effect.Effect<
  GetTrafficDistributionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetTrafficDistributionRequest,
  output: GetTrafficDistributionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Deletes the Amazon Connect instance. For more information, see Delete your Amazon Connect instance in the
 * *Amazon Connect Administrator Guide*.
 *
 * Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
 * If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
 * You must wait 30 days before you can restart creating and deleting instances in your account.
 */
export const deleteInstance: (
  input: DeleteInstanceRequest,
) => effect.Effect<
  DeleteInstanceResponse,
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteInstanceRequest,
  output: DeleteInstanceResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Deletes an Amazon Web Services resource association from an Amazon Connect instance. The association must not
 * have any use cases associated with it.
 */
export const deleteIntegrationAssociation: (
  input: DeleteIntegrationAssociationRequest,
) => effect.Effect<
  DeleteIntegrationAssociationResponse,
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIntegrationAssociationRequest,
  output: DeleteIntegrationAssociationResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a use case from an integration association.
 */
export const deleteUseCase: (
  input: DeleteUseCaseRequest,
) => effect.Effect<
  DeleteUseCaseResponse,
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUseCaseRequest,
  output: DeleteUseCaseResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Revokes authorization from the specified instance to access the specified Amazon Lex or Amazon Lex V2 bot.
 */
export const disassociateBot: (
  input: DisassociateBotRequest,
) => effect.Effect<
  DisassociateBotResponse,
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateBotRequest,
  output: DisassociateBotResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates an existing vocabulary as the default. Contact Lens for Amazon Connect uses the vocabulary in post-call and real-time
 * analysis sessions for the given language.
 */
export const associateDefaultVocabulary: (
  input: AssociateDefaultVocabularyRequest,
) => effect.Effect<
  AssociateDefaultVocabularyResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateDefaultVocabularyRequest,
  output: AssociateDefaultVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates an agent with a traffic distribution group. This API can be called only in the Region where the traffic distribution group
 * is created.
 */
export const associateTrafficDistributionGroupUser: (
  input: AssociateTrafficDistributionGroupUserRequest,
) => effect.Effect<
  AssociateTrafficDistributionGroupUserResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateTrafficDistributionGroupUserRequest,
  output: AssociateTrafficDistributionGroupUserResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Allows you to confirm that the attached file has been uploaded using the pre-signed URL provided in the
 * StartAttachedFileUpload API.
 */
export const completeAttachedFileUpload: (
  input: CompleteAttachedFileUploadRequest,
) => effect.Effect<
  CompleteAttachedFileUploadResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CompleteAttachedFileUploadRequest,
  output: CompleteAttachedFileUploadResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes an attached file along with the underlying S3 Object.
 *
 * The attached file is **permanently deleted** if S3 bucket versioning is not
 * enabled.
 */
export const deleteAttachedFile: (
  input: DeleteAttachedFileRequest,
) => effect.Effect<
  DeleteAttachedFileResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAttachedFileRequest,
  output: DeleteAttachedFileResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a rule for the specified Amazon Connect instance.
 */
export const deleteRule: (
  input: DeleteRuleRequest,
) => effect.Effect<
  DeleteRuleResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRuleRequest,
  output: DeleteRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Disassociates an agent from a traffic distribution group. This API can be called only in the Region where the
 * traffic distribution group is created.
 */
export const disassociateTrafficDistributionGroupUser: (
  input: DisassociateTrafficDistributionGroupUserRequest,
) => effect.Effect<
  DisassociateTrafficDistributionGroupUserResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateTrafficDistributionGroupUserRequest,
  output: DisassociateTrafficDistributionGroupUserResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a rule for the specified Amazon Connect instance.
 *
 * Use the Rules Function
 * language to code conditions for the rule.
 */
export const updateRule: (
  input: UpdateRuleRequest,
) => effect.Effect<
  UpdateRuleResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRuleRequest,
  output: UpdateRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates an Amazon Web Services resource association with an Amazon Connect instance.
 */
export const createIntegrationAssociation: (
  input: CreateIntegrationAssociationRequest,
) => effect.Effect<
  CreateIntegrationAssociationResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIntegrationAssociationRequest,
  output: CreateIntegrationAssociationResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a use case for an integration association.
 */
export const createUseCase: (
  input: CreateUseCaseRequest,
) => effect.Effect<
  CreateUseCaseResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateUseCaseRequest,
  output: CreateUseCaseResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates an email address alias with an existing email address in an Amazon Connect instance. This creates
 * a forwarding relationship where emails sent to the alias email address are automatically forwarded to the primary
 * email address.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - **Unified customer support**: Create multiple entry points (for example,
 * support@example.com, help@example.com, customercare@example.com) that all forward to a single agent queue for
 * streamlined management.
 *
 * - **Department consolidation**: Forward emails from legacy department addresses
 * (for example, sales@example.com, info@example.com) to a centralized customer service email during organizational
 * restructuring.
 *
 * - **Brand management**: Enable you to use familiar brand-specific email addresses
 * that forward to the appropriate Amazon Connect instance email address.
 *
 * **Important things to know**
 *
 * - Each email address can have a maximum of one alias. You cannot create multiple aliases for the same email
 * address.
 *
 * - If the alias email address already receives direct emails, it continues to receive direct emails plus
 * forwarded emails.
 *
 * - You cannot chain email aliases together (that is, create an alias of an alias).
 *
 * `AssociateEmailAddressAlias` does not return the following information:
 *
 * - A confirmation of the alias relationship details (you must call DescribeEmailAddress to verify).
 *
 * - The timestamp of when the association occurred.
 *
 * - The status of the forwarding configuration.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 *
 * **Related operations**
 *
 * - DisassociateEmailAddressAlias: Removes the alias association between two email addresses in an Amazon Connect instance.
 *
 * - DescribeEmailAddress: View current alias configurations for an email address.
 *
 * - SearchEmailAddresses: Find email addresses and their alias relationships across an instance.
 *
 * - CreateEmailAddress: Create new email addresses that can participate in alias relationships.
 *
 * - DeleteEmailAddress: Remove email addresses (automatically removes any alias relationships).
 *
 * - UpdateEmailAddressMetadata: Modify email address properties (does not affect alias relationships).
 */
export const associateEmailAddressAlias: (
  input: AssociateEmailAddressAliasRequest,
) => effect.Effect<
  AssociateEmailAddressAliasResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateEmailAddressAliasRequest,
  output: AssociateEmailAddressAliasResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates a workspace with one or more users or routing profiles, allowing them to access the workspace's
 * configured views and pages.
 */
export const associateWorkspace: (
  input: AssociateWorkspaceRequest,
) => effect.Effect<
  AssociateWorkspaceResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateWorkspaceRequest,
  output: AssociateWorkspaceResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates a list of analytics datasets for a given Amazon Connect instance to a target account. You can
 * associate multiple datasets in a single call.
 */
export const batchAssociateAnalyticsDataSet: (
  input: BatchAssociateAnalyticsDataSetRequest,
) => effect.Effect<
  BatchAssociateAnalyticsDataSetResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchAssociateAnalyticsDataSetRequest,
  output: BatchAssociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Allows you to retrieve metadata about multiple attached files on an associated resource. Each attached file
 * provided in the input list must be associated with the input AssociatedResourceArn.
 */
export const batchGetAttachedFileMetadata: (
  input: BatchGetAttachedFileMetadataRequest,
) => effect.Effect<
  BatchGetAttachedFileMetadataResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchGetAttachedFileMetadataRequest,
  output: BatchGetAttachedFileMetadataResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieve the flow associations for the given resources.
 */
export const batchGetFlowAssociation: (
  input: BatchGetFlowAssociationRequest,
) => effect.Effect<
  BatchGetFlowAssociationResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchGetFlowAssociationRequest,
  output: BatchGetFlowAssociationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes an agent status.
 */
export const describeAgentStatus: (
  input: DescribeAgentStatusRequest,
) => effect.Effect<
  DescribeAgentStatusResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAgentStatusRequest,
  output: DescribeAgentStatusResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change. To
 * request access to this API, contact Amazon Web Services Support.
 *
 * Describes the target authentication profile.
 */
export const describeAuthenticationProfile: (
  input: DescribeAuthenticationProfileRequest,
) => effect.Effect<
  DescribeAuthenticationProfileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAuthenticationProfileRequest,
  output: DescribeAuthenticationProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the specified flow module.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 */
export const describeContactFlowModule: (
  input: DescribeContactFlowModuleRequest,
) => effect.Effect<
  DescribeContactFlowModuleResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactFlowModuleRequest,
  output: DescribeContactFlowModuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves detailed information about a specific alias, including which version it currently points to and its
 * metadata.
 */
export const describeContactFlowModuleAlias: (
  input: DescribeContactFlowModuleAliasRequest,
) => effect.Effect<
  DescribeContactFlowModuleAliasResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactFlowModuleAliasRequest,
  output: DescribeContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Returns all properties for a data table except for attributes and values. All properties from CreateDataTable
 * are returned as well as properties for region replication, versioning, and system tables. "Describe" is a deprecated
 * term but is allowed to maintain consistency with existing operations.
 */
export const describeDataTable: (
  input: DescribeDataTableRequest,
) => effect.Effect<
  DescribeDataTableResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataTableRequest,
  output: DescribeDataTableResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Returns detailed information for a specific data table attribute including its configuration, validation rules,
 * and metadata. "Describe" is a deprecated term but is allowed to maintain consistency with existing operations.
 */
export const describeDataTableAttribute: (
  input: DescribeDataTableAttributeRequest,
) => effect.Effect<
  DescribeDataTableAttributeResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataTableAttributeRequest,
  output: DescribeDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the hours of operation.
 */
export const describeHoursOfOperation: (
  input: DescribeHoursOfOperationRequest,
) => effect.Effect<
  DescribeHoursOfOperationResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHoursOfOperationRequest,
  output: DescribeHoursOfOperationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the hours of operation override.
 */
export const describeHoursOfOperationOverride: (
  input: DescribeHoursOfOperationOverrideRequest,
) => effect.Effect<
  DescribeHoursOfOperationOverrideResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeHoursOfOperationOverrideRequest,
  output: DescribeHoursOfOperationOverrideResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Describes the specified instance attribute.
 */
export const describeInstanceAttribute: (
  input: DescribeInstanceAttributeRequest,
) => effect.Effect<
  DescribeInstanceAttributeResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceAttributeRequest,
  output: DescribeInstanceAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the prompt.
 */
export const describePrompt: (
  input: DescribePromptRequest,
) => effect.Effect<
  DescribePromptResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePromptRequest,
  output: DescribePromptResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the specified queue.
 */
export const describeQueue: (
  input: DescribeQueueRequest,
) => effect.Effect<
  DescribeQueueResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeQueueRequest,
  output: DescribeQueueResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the quick connect.
 */
export const describeQuickConnect: (
  input: DescribeQuickConnectRequest,
) => effect.Effect<
  DescribeQuickConnectResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeQuickConnectRequest,
  output: DescribeQuickConnectResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the specified routing profile.
 *
 * `DescribeRoutingProfile` does not populate AssociatedQueueIds in its response. The example Response
 * Syntax shown on this page is incorrect; we are working to update it. SearchRoutingProfiles does include
 * AssociatedQueueIds.
 */
export const describeRoutingProfile: (
  input: DescribeRoutingProfileRequest,
) => effect.Effect<
  DescribeRoutingProfileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeRoutingProfileRequest,
  output: DescribeRoutingProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes a rule for the specified Amazon Connect instance.
 */
export const describeRule: (
  input: DescribeRuleRequest,
) => effect.Effect<
  DescribeRuleResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeRuleRequest,
  output: DescribeRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Gets basic information about the security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const describeSecurityProfile: (
  input: DescribeSecurityProfileRequest,
) => effect.Effect<
  DescribeSecurityProfileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSecurityProfileRequest,
  output: DescribeSecurityProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Gets details and status of a traffic distribution group.
 */
export const describeTrafficDistributionGroup: (
  input: DescribeTrafficDistributionGroupRequest,
) => effect.Effect<
  DescribeTrafficDistributionGroupResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTrafficDistributionGroupRequest,
  output: DescribeTrafficDistributionGroupResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the specified user. You can find the instance ID in the Amazon Connect
 * console (its the final part of the ARN). The console does not display the user IDs. Instead, list the users
 * and note the IDs provided in the output.
 */
export const describeUser: (
  input: DescribeUserRequest,
) => effect.Effect<
  DescribeUserResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserRequest,
  output: DescribeUserResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the specified vocabulary.
 */
export const describeVocabulary: (
  input: DescribeVocabularyRequest,
) => effect.Effect<
  DescribeVocabularyResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVocabularyRequest,
  output: DescribeVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves details about a workspace, including its configuration and metadata.
 */
export const describeWorkspace: (
  input: DescribeWorkspaceRequest,
) => effect.Effect<
  DescribeWorkspaceResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeWorkspaceRequest,
  output: DescribeWorkspaceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Provides a pre-signed URL for download of an approved attached file. This API also returns metadata about the
 * attached file. It will only return a downloadURL if the status of the attached file is `APPROVED`.
 */
export const getAttachedFile: (
  input: GetAttachedFileRequest,
) => effect.Effect<
  GetAttachedFileResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetAttachedFileRequest,
  output: GetAttachedFileResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists agent statuses.
 */
export const listAgentStatuses: {
  (
    input: ListAgentStatusRequest,
  ): effect.Effect<
    ListAgentStatusResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAgentStatusRequest,
  ) => stream.Stream<
    ListAgentStatusResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAgentStatusRequest,
  ) => stream.Stream<
    AgentStatusSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAgentStatusRequest,
  output: ListAgentStatusResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AgentStatusSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the data lake datasets available to associate with for a given Amazon Connect instance.
 */
export const listAnalyticsDataLakeDataSets: (
  input: ListAnalyticsDataLakeDataSetsRequest,
) => effect.Effect<
  ListAnalyticsDataLakeDataSetsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListAnalyticsDataLakeDataSetsRequest,
  output: ListAnalyticsDataLakeDataSetsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Provides information about contact tree, a list of associated contacts with a unique identifier.
 */
export const listAssociatedContacts: (
  input: ListAssociatedContactsRequest,
) => effect.Effect<
  ListAssociatedContactsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListAssociatedContactsRequest,
  output: ListAssociatedContactsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change. To
 * request access to this API, contact Amazon Web Services Support.
 *
 * Provides summary information about the authentication profiles in a specified Amazon Connect
 * instance.
 */
export const listAuthenticationProfiles: {
  (
    input: ListAuthenticationProfilesRequest,
  ): effect.Effect<
    ListAuthenticationProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAuthenticationProfilesRequest,
  ) => stream.Stream<
    ListAuthenticationProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAuthenticationProfilesRequest,
  ) => stream.Stream<
    AuthenticationProfileSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAuthenticationProfilesRequest,
  output: ListAuthenticationProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AuthenticationProfileSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * For the specified version of Amazon Lex, returns a paginated list of all the Amazon Lex bots
 * currently associated with the instance. Use this API to return both Amazon Lex V1 and V2
 * bots.
 */
export const listBots: {
  (
    input: ListBotsRequest,
  ): effect.Effect<
    ListBotsResponse,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListBotsRequest,
  ) => stream.Stream<
    ListBotsResponse,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListBotsRequest,
  ) => stream.Stream<
    LexBotConfig,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListBotsRequest,
  output: ListBotsResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LexBots",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all aliases associated with a contact flow module, showing their current version mappings and
 * metadata.
 */
export const listContactFlowModuleAliases: {
  (
    input: ListContactFlowModuleAliasesRequest,
  ): effect.Effect<
    ListContactFlowModuleAliasesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContactFlowModuleAliasesRequest,
  ) => stream.Stream<
    ListContactFlowModuleAliasesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowModuleAliasesRequest,
  ) => stream.Stream<
    ContactFlowModuleAliasSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowModuleAliasesRequest,
  output: ListContactFlowModuleAliasesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModuleAliasSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides information about the flow modules for the specified Amazon Connect instance.
 */
export const listContactFlowModules: {
  (
    input: ListContactFlowModulesRequest,
  ): effect.Effect<
    ListContactFlowModulesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContactFlowModulesRequest,
  ) => stream.Stream<
    ListContactFlowModulesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowModulesRequest,
  ) => stream.Stream<
    ContactFlowModuleSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowModulesRequest,
  output: ListContactFlowModulesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModulesSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Retrieves a paginated list of all versions for a specific contact flow module.
 */
export const listContactFlowModuleVersions: {
  (
    input: ListContactFlowModuleVersionsRequest,
  ): effect.Effect<
    ListContactFlowModuleVersionsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContactFlowModuleVersionsRequest,
  ) => stream.Stream<
    ListContactFlowModuleVersionsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowModuleVersionsRequest,
  ) => stream.Stream<
    ContactFlowModuleVersionSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowModuleVersionsRequest,
  output: ListContactFlowModuleVersionsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowModuleVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides information about the flows for the specified Amazon Connect instance.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 *
 * For more information about flows, see Flows in the Amazon Connect
 * Administrator Guide.
 */
export const listContactFlows: {
  (
    input: ListContactFlowsRequest,
  ): effect.Effect<
    ListContactFlowsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContactFlowsRequest,
  ) => stream.Stream<
    ListContactFlowsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowsRequest,
  ) => stream.Stream<
    ContactFlowSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowsRequest,
  output: ListContactFlowsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns all the available versions for the specified Amazon Connect instance and flow identifier.
 */
export const listContactFlowVersions: {
  (
    input: ListContactFlowVersionsRequest,
  ): effect.Effect<
    ListContactFlowVersionsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContactFlowVersionsRequest,
  ) => stream.Stream<
    ListContactFlowVersionsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactFlowVersionsRequest,
  ) => stream.Stream<
    ContactFlowVersionSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactFlowVersionsRequest,
  output: ListContactFlowVersionsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlowVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all data tables for the specified Amazon Connect instance. Returns summary information for each table
 * including basic metadata and modification details.
 */
export const listDataTables: {
  (
    input: ListDataTablesRequest,
  ): effect.Effect<
    ListDataTablesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDataTablesRequest,
  ) => stream.Stream<
    ListDataTablesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTablesRequest,
  ) => stream.Stream<
    DataTableSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTablesRequest,
  output: ListDataTablesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataTableSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the default vocabularies for the specified Amazon Connect instance.
 */
export const listDefaultVocabularies: {
  (
    input: ListDefaultVocabulariesRequest,
  ): effect.Effect<
    ListDefaultVocabulariesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDefaultVocabulariesRequest,
  ) => stream.Stream<
    ListDefaultVocabulariesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDefaultVocabulariesRequest,
  ) => stream.Stream<
    DefaultVocabulary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDefaultVocabulariesRequest,
  output: ListDefaultVocabulariesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DefaultVocabularyList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides information about the hours of operation for the specified Amazon Connect instance.
 *
 * For more information about hours of operation, see Set the Hours of Operation for a Queue in the
 * *Amazon Connect Administrator Guide*.
 */
export const listHoursOfOperations: {
  (
    input: ListHoursOfOperationsRequest,
  ): effect.Effect<
    ListHoursOfOperationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListHoursOfOperationsRequest,
  ) => stream.Stream<
    ListHoursOfOperationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListHoursOfOperationsRequest,
  ) => stream.Stream<
    HoursOfOperationSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListHoursOfOperationsRequest,
  output: ListHoursOfOperationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperationSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Return a list of instances which are in active state, creation-in-progress state, and failed state. Instances
 * that aren't successfully created (they are in a failed state) are returned only for 24 hours after the CreateInstance
 * API was invoked.
 */
export const listInstances: {
  (
    input: ListInstancesRequest,
  ): effect.Effect<
    ListInstancesResponse,
    InternalServiceException | InvalidRequestException | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListInstancesRequest,
  ) => stream.Stream<
    ListInstancesResponse,
    InternalServiceException | InvalidRequestException | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInstancesRequest,
  ) => stream.Stream<
    InstanceSummary,
    InternalServiceException | InvalidRequestException | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInstancesRequest,
  output: ListInstancesResponse,
  errors: [InternalServiceException, InvalidRequestException],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "InstanceSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides summary information about the Amazon Web Services resource associations for the specified Amazon Connect instance.
 */
export const listIntegrationAssociations: {
  (
    input: ListIntegrationAssociationsRequest,
  ): effect.Effect<
    ListIntegrationAssociationsResponse,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListIntegrationAssociationsRequest,
  ) => stream.Stream<
    ListIntegrationAssociationsResponse,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListIntegrationAssociationsRequest,
  ) => stream.Stream<
    IntegrationAssociationSummary,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListIntegrationAssociationsRequest,
  output: ListIntegrationAssociationsResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IntegrationAssociationSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides information about the phone numbers for the specified Amazon Connect instance.
 *
 * For more information about phone numbers, see Set Up Phone Numbers for Your Contact
 * Center in the *Amazon Connect Administrator Guide*.
 *
 * - We recommend using ListPhoneNumbersV2 to return phone number types. ListPhoneNumbers doesn't support number types
 * `UIFN`, `SHARED`, `THIRD_PARTY_TF`, and `THIRD_PARTY_DID`. While it
 * returns numbers of those types, it incorrectly lists them as `TOLL_FREE` or `DID`.
 *
 * - The phone number `Arn` value that is returned from each of the items in the PhoneNumberSummaryList cannot be used to tag phone number resources. It will fail with a
 * `ResourceNotFoundException`. Instead, use the ListPhoneNumbersV2 API. It returns the new
 * phone number ARN that can be used to tag phone number resources.
 */
export const listPhoneNumbers: {
  (
    input: ListPhoneNumbersRequest,
  ): effect.Effect<
    ListPhoneNumbersResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPhoneNumbersRequest,
  ) => stream.Stream<
    ListPhoneNumbersResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPhoneNumbersRequest,
  ) => stream.Stream<
    PhoneNumberSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPhoneNumbersRequest,
  output: ListPhoneNumbersResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PhoneNumberSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists predefined attributes for the specified Amazon Connect instance. A *predefined attribute* is
 * made up of a name and a value. You can use predefined attributes for:
 *
 * - Routing proficiency (for example, agent certification) that has predefined values (for example, a list of
 * possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Contact information that varies between transfers or conferences, such as the name of the business unit
 * handling the contact. For more information, see Use contact segment attributes.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const listPredefinedAttributes: {
  (
    input: ListPredefinedAttributesRequest,
  ): effect.Effect<
    ListPredefinedAttributesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPredefinedAttributesRequest,
  ) => stream.Stream<
    ListPredefinedAttributesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPredefinedAttributesRequest,
  ) => stream.Stream<
    PredefinedAttributeSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPredefinedAttributesRequest,
  output: ListPredefinedAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PredefinedAttributeSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides information about the prompts for the specified Amazon Connect instance.
 */
export const listPrompts: {
  (
    input: ListPromptsRequest,
  ): effect.Effect<
    ListPromptsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPromptsRequest,
  ) => stream.Stream<
    ListPromptsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPromptsRequest,
  ) => stream.Stream<
    PromptSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPromptsRequest,
  output: ListPromptsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PromptSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the quick connects associated with a queue.
 */
export const listQueueQuickConnects: {
  (
    input: ListQueueQuickConnectsRequest,
  ): effect.Effect<
    ListQueueQuickConnectsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListQueueQuickConnectsRequest,
  ) => stream.Stream<
    ListQueueQuickConnectsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListQueueQuickConnectsRequest,
  ) => stream.Stream<
    QuickConnectSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListQueueQuickConnectsRequest,
  output: ListQueueQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QuickConnectSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides information about the queues for the specified Amazon Connect instance.
 *
 * If you do not specify a `QueueTypes` parameter, both standard and
 * agent queues are returned. This might cause an unexpected truncation of results if you have more than 1000 agents and
 * you limit the number of results of the API call in code.
 *
 * For more information about queues, see Queues: Standard and Agent in the
 * *Amazon Connect Administrator Guide*.
 */
export const listQueues: {
  (
    input: ListQueuesRequest,
  ): effect.Effect<
    ListQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListQueuesRequest,
  ) => stream.Stream<
    ListQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListQueuesRequest,
  ) => stream.Stream<
    QueueSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListQueuesRequest,
  output: ListQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QueueSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the manual assignment queues associated with a routing profile.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - This API returns list of queues where contacts can be manually assigned or picked by an agent who has access
 * to the Worklist app. The user can additionally filter on queues, if they have access to those queues (otherwise a
 * invalid request exception will be thrown).
 *
 * For information about how manual contact assignment works in the agent workspace, see the Access the Worklist app in the Amazon Connect agent workspace in the *Amazon Connect Administrator Guide*.
 *
 * **Important things to know**
 *
 * - This API only returns the manual assignment queues associated with a routing profile. Use the
 * ListRoutingProfileQueues API to list the auto assignment queues for the routing profile.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const listRoutingProfileManualAssignmentQueues: {
  (
    input: ListRoutingProfileManualAssignmentQueuesRequest,
  ): effect.Effect<
    ListRoutingProfileManualAssignmentQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListRoutingProfileManualAssignmentQueuesRequest,
  ) => stream.Stream<
    ListRoutingProfileManualAssignmentQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRoutingProfileManualAssignmentQueuesRequest,
  ) => stream.Stream<
    RoutingProfileManualAssignmentQueueConfigSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRoutingProfileManualAssignmentQueuesRequest,
  output: ListRoutingProfileManualAssignmentQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfileManualAssignmentQueueConfigSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the queues associated with a routing profile.
 */
export const listRoutingProfileQueues: {
  (
    input: ListRoutingProfileQueuesRequest,
  ): effect.Effect<
    ListRoutingProfileQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListRoutingProfileQueuesRequest,
  ) => stream.Stream<
    ListRoutingProfileQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRoutingProfileQueuesRequest,
  ) => stream.Stream<
    RoutingProfileQueueConfigSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRoutingProfileQueuesRequest,
  output: ListRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfileQueueConfigSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides summary information about the routing profiles for the specified Amazon Connect instance.
 *
 * For more information about routing profiles, see Routing Profiles and Create a Routing Profile in the *Amazon Connect Administrator Guide*.
 */
export const listRoutingProfiles: {
  (
    input: ListRoutingProfilesRequest,
  ): effect.Effect<
    ListRoutingProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListRoutingProfilesRequest,
  ) => stream.Stream<
    ListRoutingProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRoutingProfilesRequest,
  ) => stream.Stream<
    RoutingProfileSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRoutingProfilesRequest,
  output: ListRoutingProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfileSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all security keys associated with the instance.
 */
export const listSecurityKeys: {
  (
    input: ListSecurityKeysRequest,
  ): effect.Effect<
    ListSecurityKeysResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListSecurityKeysRequest,
  ) => stream.Stream<
    ListSecurityKeysResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityKeysRequest,
  ) => stream.Stream<
    SecurityKey,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityKeysRequest,
  output: ListSecurityKeysResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityKeys",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides summary information about the security profiles for the specified Amazon Connect instance.
 *
 * For more information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const listSecurityProfiles: {
  (
    input: ListSecurityProfilesRequest,
  ): effect.Effect<
    ListSecurityProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListSecurityProfilesRequest,
  ) => stream.Stream<
    ListSecurityProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfilesRequest,
  ) => stream.Stream<
    SecurityProfileSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfilesRequest,
  output: ListSecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityProfileSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists task templates for the specified Amazon Connect instance.
 */
export const listTaskTemplates: {
  (
    input: ListTaskTemplatesRequest,
  ): effect.Effect<
    ListTaskTemplatesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTaskTemplatesRequest,
  ) => stream.Stream<
    ListTaskTemplatesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTaskTemplatesRequest,
  ) => stream.Stream<
    TaskTemplateMetadata,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTaskTemplatesRequest,
  output: ListTaskTemplatesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TaskTemplates",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists traffic distribution groups.
 */
export const listTrafficDistributionGroups: {
  (
    input: ListTrafficDistributionGroupsRequest,
  ): effect.Effect<
    ListTrafficDistributionGroupsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTrafficDistributionGroupsRequest,
  ) => stream.Stream<
    ListTrafficDistributionGroupsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrafficDistributionGroupsRequest,
  ) => stream.Stream<
    TrafficDistributionGroupSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrafficDistributionGroupsRequest,
  output: ListTrafficDistributionGroupsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrafficDistributionGroupSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists traffic distribution group users.
 */
export const listTrafficDistributionGroupUsers: {
  (
    input: ListTrafficDistributionGroupUsersRequest,
  ): effect.Effect<
    ListTrafficDistributionGroupUsersResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTrafficDistributionGroupUsersRequest,
  ) => stream.Stream<
    ListTrafficDistributionGroupUsersResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTrafficDistributionGroupUsersRequest,
  ) => stream.Stream<
    TrafficDistributionGroupUserSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTrafficDistributionGroupUsersRequest,
  output: ListTrafficDistributionGroupUsersResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TrafficDistributionGroupUserSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the use cases for the integration association.
 */
export const listUseCases: {
  (
    input: ListUseCasesRequest,
  ): effect.Effect<
    ListUseCasesResponse,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUseCasesRequest,
  ) => stream.Stream<
    ListUseCasesResponse,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUseCasesRequest,
  ) => stream.Stream<
    UseCase,
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUseCasesRequest,
  output: ListUseCasesResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UseCaseSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides summary information about the hierarchy groups for the specified Amazon Connect instance.
 *
 * For more information about agent hierarchies, see Set Up Agent Hierarchies in the *Amazon Connect Administrator Guide*.
 */
export const listUserHierarchyGroups: {
  (
    input: ListUserHierarchyGroupsRequest,
  ): effect.Effect<
    ListUserHierarchyGroupsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUserHierarchyGroupsRequest,
  ) => stream.Stream<
    ListUserHierarchyGroupsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUserHierarchyGroupsRequest,
  ) => stream.Stream<
    HierarchyGroupSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUserHierarchyGroupsRequest,
  output: ListUserHierarchyGroupsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserHierarchyGroupSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides summary information about the users for the specified Amazon Connect instance.
 */
export const listUsers: {
  (
    input: ListUsersRequest,
  ): effect.Effect<
    ListUsersResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUsersRequest,
  ) => stream.Stream<
    ListUsersResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUsersRequest,
  ) => stream.Stream<
    UserSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUsersRequest,
  output: ListUsersResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists media assets (such as logos) associated with a workspace.
 */
export const listWorkspaceMedia: (
  input: ListWorkspaceMediaRequest,
) => effect.Effect<
  ListWorkspaceMediaResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListWorkspaceMediaRequest,
  output: ListWorkspaceMediaResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists the page configurations in a workspace, including the views assigned to each page.
 */
export const listWorkspacePages: {
  (
    input: ListWorkspacePagesRequest,
  ): effect.Effect<
    ListWorkspacePagesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListWorkspacePagesRequest,
  ) => stream.Stream<
    ListWorkspacePagesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListWorkspacePagesRequest,
  ) => stream.Stream<
    WorkspacePage,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListWorkspacePagesRequest,
  output: ListWorkspacePagesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "WorkspacePageList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the workspaces in an Amazon Connect instance.
 */
export const listWorkspaces: {
  (
    input: ListWorkspacesRequest,
  ): effect.Effect<
    ListWorkspacesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListWorkspacesRequest,
  ) => stream.Stream<
    ListWorkspacesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListWorkspacesRequest,
  ) => stream.Stream<
    WorkspaceSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListWorkspacesRequest,
  output: ListWorkspacesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "WorkspaceSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for data tables based on the table's ID, name, and description. In the future, this operation can
 * support searching on attribute names and possibly primary values. Follows other search operations closely and
 * supports both search criteria and filters.
 */
export const searchDataTables: {
  (
    input: SearchDataTablesRequest,
  ): effect.Effect<
    SearchDataTablesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchDataTablesRequest,
  ) => stream.Stream<
    SearchDataTablesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchDataTablesRequest,
  ) => stream.Stream<
    DataTable,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchDataTablesRequest,
  output: SearchDataTablesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataTables",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches the hours of operation in an Amazon Connect instance, with optional filtering.
 */
export const searchHoursOfOperations: {
  (
    input: SearchHoursOfOperationsRequest,
  ): effect.Effect<
    SearchHoursOfOperationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchHoursOfOperationsRequest,
  ) => stream.Stream<
    SearchHoursOfOperationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchHoursOfOperationsRequest,
  ) => stream.Stream<
    HoursOfOperation,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchHoursOfOperationsRequest,
  output: SearchHoursOfOperationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperations",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches predefined attributes that meet certain criteria. A *predefined attribute* is made
 * up of a name and a value. You can use predefined attributes for:
 *
 * - Routing proficiency (for example, agent certification) that has predefined values (for example, a list of
 * possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Contact information that varies between transfers or conferences, such as the name of the business unit
 * handling the contact. For more information, see Use contact segment attributes.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const searchPredefinedAttributes: {
  (
    input: SearchPredefinedAttributesRequest,
  ): effect.Effect<
    SearchPredefinedAttributesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchPredefinedAttributesRequest,
  ) => stream.Stream<
    SearchPredefinedAttributesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchPredefinedAttributesRequest,
  ) => stream.Stream<
    PredefinedAttribute,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchPredefinedAttributesRequest,
  output: SearchPredefinedAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PredefinedAttributes",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches prompts in an Amazon Connect instance, with optional filtering.
 */
export const searchPrompts: {
  (
    input: SearchPromptsRequest,
  ): effect.Effect<
    SearchPromptsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchPromptsRequest,
  ) => stream.Stream<
    SearchPromptsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchPromptsRequest,
  ) => stream.Stream<
    Prompt,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchPromptsRequest,
  output: SearchPromptsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Prompts",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches queues in an Amazon Connect instance, with optional filtering.
 */
export const searchQueues: {
  (
    input: SearchQueuesRequest,
  ): effect.Effect<
    SearchQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchQueuesRequest,
  ) => stream.Stream<
    SearchQueuesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchQueuesRequest,
  ) => stream.Stream<
    Queue,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchQueuesRequest,
  output: SearchQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Queues",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches quick connects in an Amazon Connect instance, with optional filtering.
 */
export const searchQuickConnects: {
  (
    input: SearchQuickConnectsRequest,
  ): effect.Effect<
    SearchQuickConnectsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchQuickConnectsRequest,
  ) => stream.Stream<
    SearchQuickConnectsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchQuickConnectsRequest,
  ) => stream.Stream<
    QuickConnect,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchQuickConnectsRequest,
  output: SearchQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QuickConnects",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches routing profiles in an Amazon Connect instance, with optional filtering.
 *
 * `SearchRoutingProfiles` does not populate LastModifiedRegion, LastModifiedTime,
 * MediaConcurrencies.CrossChannelBehavior, and AgentAvailabilityTimer in its response, but DescribeRoutingProfile does.
 */
export const searchRoutingProfiles: {
  (
    input: SearchRoutingProfilesRequest,
  ): effect.Effect<
    SearchRoutingProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchRoutingProfilesRequest,
  ) => stream.Stream<
    SearchRoutingProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchRoutingProfilesRequest,
  ) => stream.Stream<
    RoutingProfile,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchRoutingProfilesRequest,
  output: SearchRoutingProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RoutingProfiles",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches UserHierarchyGroups in an Amazon Connect instance, with optional filtering.
 *
 * The UserHierarchyGroup with `"LevelId": "0"` is the foundation for building levels on top of an
 * instance. It is not user-definable, nor is it visible in the UI.
 */
export const searchUserHierarchyGroups: {
  (
    input: SearchUserHierarchyGroupsRequest,
  ): effect.Effect<
    SearchUserHierarchyGroupsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchUserHierarchyGroupsRequest,
  ) => stream.Stream<
    SearchUserHierarchyGroupsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchUserHierarchyGroupsRequest,
  ) => stream.Stream<
    HierarchyGroup,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchUserHierarchyGroupsRequest,
  output: SearchUserHierarchyGroupsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserHierarchyGroups",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches views based on name, description, or tags.
 */
export const searchViews: {
  (
    input: SearchViewsRequest,
  ): effect.Effect<
    SearchViewsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchViewsRequest,
  ) => stream.Stream<
    SearchViewsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchViewsRequest,
  ) => stream.Stream<
    View,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchViewsRequest,
  output: SearchViewsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Views",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for vocabularies within a specific Amazon Connect instance using `State`,
 * `NameStartsWith`, and `LanguageCode`.
 */
export const searchVocabularies: {
  (
    input: SearchVocabulariesRequest,
  ): effect.Effect<
    SearchVocabulariesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchVocabulariesRequest,
  ) => stream.Stream<
    SearchVocabulariesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchVocabulariesRequest,
  ) => stream.Stream<
    VocabularySummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchVocabulariesRequest,
  output: SearchVocabulariesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "VocabularySummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Processes chat integration events from Amazon Web Services or external integrations to Amazon Connect. A chat
 * integration event includes:
 *
 * - SourceId, DestinationId, and Subtype: a set of identifiers, uniquely representing a chat
 *
 * - ChatEvent: details of the chat action to perform such as sending a message, event, or disconnecting from a
 * chat
 *
 * When a chat integration event is sent with chat identifiers that do not map to an active chat contact, a new
 * chat contact is also created before handling chat action.
 *
 * Access to this API is currently restricted to Amazon Web Services End User Messaging for supporting SMS
 * integration.
 */
export const sendChatIntegrationEvent: (
  input: SendChatIntegrationEventRequest,
) => effect.Effect<
  SendChatIntegrationEventResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SendChatIntegrationEventRequest,
  output: SendChatIntegrationEventResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Starts recording the contact:
 *
 * - If the API is called *before* the agent joins the call, recording starts when the agent
 * joins the call.
 *
 * - If the API is called *after* the agent joins the call, recording starts at the time of the
 * API call.
 *
 * StartContactRecording is a one-time action. For example, if you use StopContactRecording to stop recording an
 * ongoing call, you can't use StartContactRecording to restart it. For scenarios where the recording has started and
 * you want to suspend and resume it, such as when collecting sensitive information (for example, a credit card number),
 * use SuspendContactRecording and ResumeContactRecording.
 *
 * You can use this API to override the recording behavior configured in the Set recording behavior block.
 *
 * Only voice recordings are supported at this time.
 */
export const startContactRecording: (
  input: StartContactRecordingRequest,
) => effect.Effect<
  StartContactRecordingResponse,
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactRecordingRequest,
  output: StartContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Ends the specified contact. Use this API to stop queued callbacks. It does not work for voice contacts that use
 * the following initiation methods:
 *
 * - DISCONNECT
 *
 * - TRANSFER
 *
 * - QUEUE_TRANSFER
 *
 * - EXTERNAL_OUTBOUND
 *
 * - MONITOR
 *
 * Chat and task contacts can be terminated in any state, regardless of initiation method.
 */
export const stopContact: (
  input: StopContactRequest,
) => effect.Effect<
  StopContactResponse,
  | ContactNotFoundException
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactRequest,
  output: StopContactResponse,
  errors: [
    ContactNotFoundException,
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Updates the primary values for a record. This operation affects all existing values that are currently
 * associated to the record and its primary values. Users that have restrictions on attributes and/or primary values are
 * not authorized to use this endpoint. The combination of new primary values must be unique within the table.
 */
export const updateDataTablePrimaryValues: (
  input: UpdateDataTablePrimaryValuesRequest,
) => effect.Effect<
  UpdateDataTablePrimaryValuesResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataTablePrimaryValuesRequest,
  output: UpdateDataTablePrimaryValuesResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the traffic distribution for a given traffic distribution group.
 *
 * When you shift telephony traffic, also shift agents and/or agent sign-ins to ensure they can handle the calls
 * in the other Region. If you don't shift the agents, voice calls will go to the shifted Region but there won't be any
 * agents available to receive the calls.
 *
 * The `SignInConfig` distribution is available only on a
 * default `TrafficDistributionGroup` (see the `IsDefault` parameter in the
 * TrafficDistributionGroup
 * data type). If you call
 * `UpdateTrafficDistribution` with a modified `SignInConfig` and a non-default `TrafficDistributionGroup`,
 * an `InvalidRequestException` is returned.
 *
 * For more information about updating a traffic distribution group, see Update telephony traffic distribution
 * across Amazon Web Services Regions
 * in the *Amazon Connect Administrator Guide*.
 */
export const updateTrafficDistribution: (
  input: UpdateTrafficDistributionRequest,
) => effect.Effect<
  UpdateTrafficDistributionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTrafficDistributionRequest,
  output: UpdateTrafficDistributionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates a queued contact with an agent.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Programmatically assign queued contacts to available users.
 *
 * - Leverage the IAM context key `connect:PreferredUserArn` to restrict contact association to specific
 * preferred user.
 *
 * **Important things to know**
 *
 * - Use this API with chat, email, and task contacts. It does not support voice contacts.
 *
 * - Use it to associate contacts with users regardless of their current state, including custom states. Ensure
 * your application logic accounts for user availability before making associations.
 *
 * - It honors the IAM context key `connect:PreferredUserArn` to prevent unauthorized contact
 * associations.
 *
 * - It respects the IAM context key `connect:PreferredUserArn` to enforce authorization controls and
 * prevent unauthorized contact associations. Verify that your IAM policies are properly configured to support your
 * intended use cases.
 *
 * - The service quota *Queues per routing profile per instance* applies to manually assigned
 * queues, too. For more information about this quota, see Amazon Connect
 * quotas in the *Amazon Connect Administrator Guide*.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const associateContactWithUser: (
  input: AssociateContactWithUserRequest,
) => effect.Effect<
  AssociateContactWithUserResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateContactWithUserRequest,
  output: AssociateContactWithUserResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates a set of queues with a routing profile.
 */
export const associateRoutingProfileQueues: (
  input: AssociateRoutingProfileQueuesRequest,
) => effect.Effect<
  AssociateRoutingProfileQueuesResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateRoutingProfileQueuesRequest,
  output: AssociateRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates a set of proficiencies with a user.
 */
export const associateUserProficiencies: (
  input: AssociateUserProficienciesRequest,
) => effect.Effect<
  AssociateUserProficienciesResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateUserProficienciesRequest,
  output: AssociateUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes a list of analytics datasets associated with a given Amazon Connect instance. You can disassociate
 * multiple datasets in a single call.
 */
export const batchDisassociateAnalyticsDataSet: (
  input: BatchDisassociateAnalyticsDataSetRequest,
) => effect.Effect<
  BatchDisassociateAnalyticsDataSetResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDisassociateAnalyticsDataSetRequest,
  output: BatchDisassociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Enables rehydration of chats for the lifespan of a contact. For more information about chat rehydration, see
 * Enable persistent chat in
 * the *Amazon Connect Administrator Guide*.
 */
export const createPersistentContactAssociation: (
  input: CreatePersistentContactAssociationRequest,
) => effect.Effect<
  CreatePersistentContactAssociationResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePersistentContactAssociationRequest,
  output: CreatePersistentContactAssociationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describe email address form the specified Amazon Connect instance.
 */
export const describeEmailAddress: (
  input: DescribeEmailAddressRequest,
) => effect.Effect<
  DescribeEmailAddressResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEmailAddressRequest,
  output: DescribeEmailAddressResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Retrieves the current storage configurations for the specified resource type, association ID, and instance
 * ID.
 */
export const describeInstanceStorageConfig: (
  input: DescribeInstanceStorageConfigRequest,
) => effect.Effect<
  DescribeInstanceStorageConfigResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeInstanceStorageConfigRequest,
  output: DescribeInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Disassociates a set of queues from a routing profile.
 *
 * Up to 10 queue references can be disassociated in a single API call. More than 10 queue references results in a
 * single call results in an InvalidParameterException.
 */
export const disassociateRoutingProfileQueues: (
  input: DisassociateRoutingProfileQueuesRequest,
) => effect.Effect<
  DisassociateRoutingProfileQueuesResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateRoutingProfileQueuesRequest,
  output: DisassociateRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Disassociates a set of proficiencies from a user.
 */
export const disassociateUserProficiencies: (
  input: DisassociateUserProficienciesRequest,
) => effect.Effect<
  DisassociateUserProficienciesResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateUserProficienciesRequest,
  output: DisassociateUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes the association between a workspace and one or more users or routing profiles.
 */
export const disassociateWorkspace: (
  input: DisassociateWorkspaceRequest,
) => effect.Effect<
  DisassociateWorkspaceResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateWorkspaceRequest,
  output: DisassociateWorkspaceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves the flow associated for a given resource.
 */
export const getFlowAssociation: (
  input: GetFlowAssociationRequest,
) => effect.Effect<
  GetFlowAssociationResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetFlowAssociationRequest,
  output: GetFlowAssociationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Gets the prompt file.
 */
export const getPromptFile: (
  input: GetPromptFileRequest,
) => effect.Effect<
  GetPromptFileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetPromptFileRequest,
  output: GetPromptFileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Gets details about a specific task template in the specified Amazon Connect instance.
 */
export const getTaskTemplate: (
  input: GetTaskTemplateRequest,
) => effect.Effect<
  GetTaskTemplateResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetTaskTemplateRequest,
  output: GetTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists the association status of requested dataset ID for a given Amazon Connect instance.
 */
export const listAnalyticsDataAssociations: (
  input: ListAnalyticsDataAssociationsRequest,
) => effect.Effect<
  ListAnalyticsDataAssociationsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListAnalyticsDataAssociationsRequest,
  output: ListAnalyticsDataAssociationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all approved origins associated with the instance.
 */
export const listApprovedOrigins: {
  (
    input: ListApprovedOriginsRequest,
  ): effect.Effect<
    ListApprovedOriginsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListApprovedOriginsRequest,
  ) => stream.Stream<
    ListApprovedOriginsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListApprovedOriginsRequest,
  ) => stream.Stream<
    Origin,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListApprovedOriginsRequest,
  output: ListApprovedOriginsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Origins",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns all attributes for a specified data table. A maximum of 100 attributes per data table is allowed.
 * Customers can request an increase by using Amazon Web Services Service Quotas. The response can be filtered by specific attribute IDs
 * for CloudFormation integration.
 */
export const listDataTableAttributes: {
  (
    input: ListDataTableAttributesRequest,
  ): effect.Effect<
    ListDataTableAttributesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDataTableAttributesRequest,
  ) => stream.Stream<
    ListDataTableAttributesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTableAttributesRequest,
  ) => stream.Stream<
    DataTableAttribute,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTableAttributesRequest,
  output: ListDataTableAttributesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Attributes",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all security profiles attached to a Q in Connect AIAgent Entity in an Amazon Connect instance.
 */
export const listEntitySecurityProfiles: {
  (
    input: ListEntitySecurityProfilesRequest,
  ): effect.Effect<
    ListEntitySecurityProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListEntitySecurityProfilesRequest,
  ) => stream.Stream<
    ListEntitySecurityProfilesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEntitySecurityProfilesRequest,
  ) => stream.Stream<
    SecurityProfileItem,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEntitySecurityProfilesRequest,
  output: ListEntitySecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "SecurityProfiles",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List the flow association based on the filters.
 */
export const listFlowAssociations: {
  (
    input: ListFlowAssociationsRequest,
  ): effect.Effect<
    ListFlowAssociationsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListFlowAssociationsRequest,
  ) => stream.Stream<
    ListFlowAssociationsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFlowAssociationsRequest,
  ) => stream.Stream<
    FlowAssociationSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFlowAssociationsRequest,
  output: ListFlowAssociationsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FlowAssociationSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List the hours of operation overrides.
 */
export const listHoursOfOperationOverrides: {
  (
    input: ListHoursOfOperationOverridesRequest,
  ): effect.Effect<
    ListHoursOfOperationOverridesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    ListHoursOfOperationOverridesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListHoursOfOperationOverridesRequest,
  ) => stream.Stream<
    HoursOfOperationOverride,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListHoursOfOperationOverridesRequest,
  output: ListHoursOfOperationOverridesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "HoursOfOperationOverrideList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all attribute types for the given instance.
 */
export const listInstanceAttributes: {
  (
    input: ListInstanceAttributesRequest,
  ): effect.Effect<
    ListInstanceAttributesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListInstanceAttributesRequest,
  ) => stream.Stream<
    ListInstanceAttributesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInstanceAttributesRequest,
  ) => stream.Stream<
    Attribute,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInstanceAttributesRequest,
  output: ListInstanceAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Attributes",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of storage configs for the identified instance and resource type.
 */
export const listInstanceStorageConfigs: {
  (
    input: ListInstanceStorageConfigsRequest,
  ): effect.Effect<
    ListInstanceStorageConfigsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListInstanceStorageConfigsRequest,
  ) => stream.Stream<
    ListInstanceStorageConfigsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListInstanceStorageConfigsRequest,
  ) => stream.Stream<
    InstanceStorageConfig,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListInstanceStorageConfigsRequest,
  output: ListInstanceStorageConfigsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "StorageConfigs",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all Lambda functions that display in the dropdown options in the relevant flow
 * blocks.
 */
export const listLambdaFunctions: {
  (
    input: ListLambdaFunctionsRequest,
  ): effect.Effect<
    ListLambdaFunctionsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListLambdaFunctionsRequest,
  ) => stream.Stream<
    ListLambdaFunctionsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListLambdaFunctionsRequest,
  ) => stream.Stream<
    FunctionArn,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListLambdaFunctionsRequest,
  output: ListLambdaFunctionsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LambdaFunctions",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Returns a paginated list of all the Amazon Lex V1 bots currently associated with the instance. To return
 * both Amazon Lex V1 and V2 bots, use the ListBots API.
 */
export const listLexBots: {
  (
    input: ListLexBotsRequest,
  ): effect.Effect<
    ListLexBotsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListLexBotsRequest,
  ) => stream.Stream<
    ListLexBotsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListLexBotsRequest,
  ) => stream.Stream<
    LexBot,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListLexBotsRequest,
  output: ListLexBotsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "LexBots",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Provides information about the quick connects for the specified Amazon Connect instance.
 */
export const listQuickConnects: {
  (
    input: ListQuickConnectsRequest,
  ): effect.Effect<
    ListQuickConnectsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListQuickConnectsRequest,
  ) => stream.Stream<
    ListQuickConnectsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListQuickConnectsRequest,
  ) => stream.Stream<
    QuickConnectSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListQuickConnectsRequest,
  output: ListQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "QuickConnectSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns a list of third-party applications or MCP Servers in a specific security profile.
 */
export const listSecurityProfileApplications: {
  (
    input: ListSecurityProfileApplicationsRequest,
  ): effect.Effect<
    ListSecurityProfileApplicationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListSecurityProfileApplicationsRequest,
  ) => stream.Stream<
    ListSecurityProfileApplicationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfileApplicationsRequest,
  ) => stream.Stream<
    Application,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfileApplicationsRequest,
  output: ListSecurityProfileApplicationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Applications",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * A list of Flow Modules an AI Agent can invoke as a tool
 */
export const listSecurityProfileFlowModules: {
  (
    input: ListSecurityProfileFlowModulesRequest,
  ): effect.Effect<
    ListSecurityProfileFlowModulesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListSecurityProfileFlowModulesRequest,
  ) => stream.Stream<
    ListSecurityProfileFlowModulesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfileFlowModulesRequest,
  ) => stream.Stream<
    FlowModule,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfileFlowModulesRequest,
  output: ListSecurityProfileFlowModulesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AllowedFlowModules",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the permissions granted to a security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const listSecurityProfilePermissions: {
  (
    input: ListSecurityProfilePermissionsRequest,
  ): effect.Effect<
    ListSecurityProfilePermissionsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListSecurityProfilePermissionsRequest,
  ) => stream.Stream<
    ListSecurityProfilePermissionsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListSecurityProfilePermissionsRequest,
  ) => stream.Stream<
    SecurityProfilePermission,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListSecurityProfilePermissionsRequest,
  output: ListSecurityProfilePermissionsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Permissions",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the tags for the specified resource.
 *
 * For sample policies that use tags, see Amazon Connect Identity-Based Policy
 * Examples in the *Amazon Connect Administrator Guide*.
 */
export const listTagsForResource: (
  input: ListTagsForResourceRequest,
) => effect.Effect<
  ListTagsForResourceResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListTagsForResourceRequest,
  output: ListTagsForResourceResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists proficiencies associated with a user.
 */
export const listUserProficiencies: {
  (
    input: ListUserProficienciesRequest,
  ): effect.Effect<
    ListUserProficienciesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUserProficienciesRequest,
  ) => stream.Stream<
    ListUserProficienciesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUserProficienciesRequest,
  ) => stream.Stream<
    UserProficiency,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUserProficienciesRequest,
  output: ListUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserProficiencyList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Update the hours of operation override.
 */
export const updateHoursOfOperationOverride: (
  input: UpdateHoursOfOperationOverrideRequest,
) => effect.Effect<
  UpdateHoursOfOperationOverrideResponse,
  | ConditionalOperationFailedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateHoursOfOperationOverrideRequest,
  output: UpdateHoursOfOperationOverrideResponse,
  errors: [
    ConditionalOperationFailedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a prompt.
 */
export const updatePrompt: (
  input: UpdatePromptRequest,
) => effect.Effect<
  UpdatePromptResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePromptRequest,
  output: UpdatePromptResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes an hours of operation.
 */
export const deleteHoursOfOperation: (
  input: DeleteHoursOfOperationRequest,
) => effect.Effect<
  DeleteHoursOfOperationResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHoursOfOperationRequest,
  output: DeleteHoursOfOperationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes an hours of operation override in an Amazon Connect hours of operation resource.
 */
export const deleteHoursOfOperationOverride: (
  input: DeleteHoursOfOperationOverrideRequest,
) => effect.Effect<
  DeleteHoursOfOperationOverrideResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteHoursOfOperationOverrideRequest,
  output: DeleteHoursOfOperationOverrideResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a prompt.
 */
export const deletePrompt: (
  input: DeletePromptRequest,
) => effect.Effect<
  DeletePromptResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePromptRequest,
  output: DeletePromptResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a quick connect.
 *
 * After calling DeleteUser, it's important to call `DeleteQuickConnect` to delete any records related to the
 * deleted users. This will help you:
 *
 * - Avoid dangling resources that impact your service quotas.
 *
 * - Remove deleted users so they don't appear to agents as transfer options.
 *
 * - Avoid the disruption of other Amazon Connect processes, such as instance replication and syncing if
 * you're using Amazon Connect Global Resiliency.
 */
export const deleteQuickConnect: (
  input: DeleteQuickConnectRequest,
) => effect.Effect<
  DeleteQuickConnectResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteQuickConnectRequest,
  output: DeleteQuickConnectResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes the task template.
 */
export const deleteTaskTemplate: (
  input: DeleteTaskTemplateRequest,
) => effect.Effect<
  DeleteTaskTemplateResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTaskTemplateRequest,
  output: DeleteTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a user account from the specified Amazon Connect instance.
 *
 * For information about what happens to a user's data when their account is deleted, see Delete Users from Your Amazon Connect
 * Instance in the *Amazon Connect Administrator Guide*.
 *
 * After calling DeleteUser, call DeleteQuickConnect to delete any records
 * related to the deleted users. This will help you:
 *
 * - Avoid dangling resources that impact your service quotas.
 *
 * - Remove deleted users so they don't appear to agents as transfer options.
 *
 * - Avoid the disruption of other Amazon Connect processes, such as instance replication and syncing if
 * you're using Amazon Connect Global Resiliency.
 */
export const deleteUser: (
  input: DeleteUserRequest,
) => effect.Effect<
  DeleteUserResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserRequest,
  output: DeleteUserResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a media asset (such as a logo) from a workspace.
 */
export const deleteWorkspaceMedia: (
  input: DeleteWorkspaceMediaRequest,
) => effect.Effect<
  DeleteWorkspaceMediaResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkspaceMediaRequest,
  output: DeleteWorkspaceMediaResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes the dataset ID associated with a given Amazon Connect instance.
 */
export const disassociateAnalyticsDataSet: (
  input: DisassociateAnalyticsDataSetRequest,
) => effect.Effect<
  DisassociateAnalyticsDataSetResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateAnalyticsDataSetRequest,
  output: DisassociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Revokes access to integrated applications from Amazon Connect.
 */
export const disassociateApprovedOrigin: (
  input: DisassociateApprovedOriginRequest,
) => effect.Effect<
  DisassociateApprovedOriginResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateApprovedOriginRequest,
  output: DisassociateApprovedOriginResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Removes the storage type configurations for the specified resource type and association ID.
 */
export const disassociateInstanceStorageConfig: (
  input: DisassociateInstanceStorageConfigRequest,
) => effect.Effect<
  DisassociateInstanceStorageConfigResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateInstanceStorageConfigRequest,
  output: DisassociateInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Remove the Lambda function from the dropdown options available in the relevant flow blocks.
 */
export const disassociateLambdaFunction: (
  input: DisassociateLambdaFunctionRequest,
) => effect.Effect<
  DisassociateLambdaFunctionResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateLambdaFunctionRequest,
  output: DisassociateLambdaFunctionResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Revokes authorization from the specified instance to access the specified Amazon Lex bot.
 */
export const disassociateLexBot: (
  input: DisassociateLexBotRequest,
) => effect.Effect<
  DisassociateLexBotResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateLexBotRequest,
  output: DisassociateLexBotResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Disassociates a set of quick connects from a queue.
 */
export const disassociateQueueQuickConnects: (
  input: DisassociateQueueQuickConnectsRequest,
) => effect.Effect<
  DisassociateQueueQuickConnectsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateQueueQuickConnectsRequest,
  output: DisassociateQueueQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Deletes the specified security key.
 */
export const disassociateSecurityKey: (
  input: DisassociateSecurityKeyRequest,
) => effect.Effect<
  DisassociateSecurityKeyResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateSecurityKeyRequest,
  output: DisassociateSecurityKeyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Imports a media asset (such as a logo) for use in a workspace.
 */
export const importWorkspaceMedia: (
  input: ImportWorkspaceMediaRequest,
) => effect.Effect<
  ImportWorkspaceMediaResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportWorkspaceMediaRequest,
  output: ImportWorkspaceMediaResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Ends message streaming on a specified contact. To restart message streaming on that contact, call the StartContactStreaming
 * API.
 */
export const stopContactStreaming: (
  input: StopContactStreamingRequest,
) => effect.Effect<
  StopContactStreamingResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactStreamingRequest,
  output: StopContactStreamingResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Adds the specified tags to the specified resource.
 *
 * Some of the supported resource types are agents, routing profiles, queues, quick connects, flows, agent
 * statuses, hours of operation, phone numbers, security profiles, and task templates. For a complete list, see Tagging resources in Amazon Connect.
 *
 * For sample policies that use tags, see Amazon Connect Identity-Based Policy
 * Examples in the *Amazon Connect Administrator Guide*.
 */
export const tagResource: (
  input: TagResourceRequest,
) => effect.Effect<
  TagResourceResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TagResourceRequest,
  output: TagResourceResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes the specified tags from the specified resource.
 */
export const untagResource: (
  input: UntagResourceRequest,
) => effect.Effect<
  UntagResourceResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UntagResourceRequest,
  output: UntagResourceResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change. To
 * request access to this API, contact Amazon Web Services Support.
 *
 * Updates the selected authentication profile.
 */
export const updateAuthenticationProfile: (
  input: UpdateAuthenticationProfileRequest,
) => effect.Effect<
  UpdateAuthenticationProfileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAuthenticationProfileRequest,
  output: UpdateAuthenticationProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Updates the value for the specified attribute type.
 */
export const updateInstanceAttribute: (
  input: UpdateInstanceAttributeRequest,
) => effect.Effect<
  UpdateInstanceAttributeResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInstanceAttributeRequest,
  output: UpdateInstanceAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Updates an existing configuration for a resource type. This API is idempotent.
 */
export const updateInstanceStorageConfig: (
  input: UpdateInstanceStorageConfigRequest,
) => effect.Effect<
  UpdateInstanceStorageConfigResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateInstanceStorageConfigRequest,
  output: UpdateInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a predefined attribute for the specified Amazon Connect instance. A *predefined attribute* is
 * made up of a name and a value.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Update routing proficiency (for example, agent certification) that has predefined values (for example, a list
 * of possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Update an attribute for business unit name that has a list of predefined business unit names used in your
 * organization. This is a use case where information for a contact varies between transfers or conferences. For more
 * information, see Use contact segment attributes.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const updatePredefinedAttribute: (
  input: UpdatePredefinedAttributeRequest,
) => effect.Effect<
  UpdatePredefinedAttributeResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePredefinedAttributeRequest,
  output: UpdatePredefinedAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the hours of operation for the specified queue.
 */
export const updateQueueHoursOfOperation: (
  input: UpdateQueueHoursOfOperationRequest,
) => effect.Effect<
  UpdateQueueHoursOfOperationResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueHoursOfOperationRequest,
  output: UpdateQueueHoursOfOperationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the maximum number of contacts allowed in a queue before it is considered full.
 */
export const updateQueueMaxContacts: (
  input: UpdateQueueMaxContactsRequest,
) => effect.Effect<
  UpdateQueueMaxContactsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueMaxContactsRequest,
  output: UpdateQueueMaxContactsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the outbound caller ID name, number, and outbound whisper flow for a specified queue.
 *
 * - If the phone number is claimed to a traffic distribution group that was created in the
 * same Region as the Amazon Connect instance where you are calling this API, then you can use a
 * full phone number ARN or a UUID for `OutboundCallerIdNumberId`. However, if the phone number is claimed
 * to a traffic distribution group that is in one Region, and you are calling this API from an instance in another Amazon Web Services Region that is associated with the traffic distribution group, you must provide a full phone number ARN. If a
 * UUID is provided in this scenario, you will receive a
 * `ResourceNotFoundException`.
 *
 * - Only use the phone number ARN format that doesn't contain `instance` in the path, for example,
 * `arn:aws:connect:us-east-1:1234567890:phone-number/uuid`. This is the same ARN format that is returned
 * when you call the ListPhoneNumbersV2 API.
 *
 * - If you plan to use IAM policies to allow/deny access to this API for phone number resources
 * claimed to a traffic distribution group, see Allow or Deny queue API actions for phone numbers in a replica Region.
 */
export const updateQueueOutboundCallerConfig: (
  input: UpdateQueueOutboundCallerConfigRequest,
) => effect.Effect<
  UpdateQueueOutboundCallerConfigResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueOutboundCallerConfigRequest,
  output: UpdateQueueOutboundCallerConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the status of the queue.
 */
export const updateQueueStatus: (
  input: UpdateQueueStatusRequest,
) => effect.Effect<
  UpdateQueueStatusResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueStatusRequest,
  output: UpdateQueueStatusResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the configuration settings for the specified quick connect.
 */
export const updateQuickConnectConfig: (
  input: UpdateQuickConnectConfigRequest,
) => effect.Effect<
  UpdateQuickConnectConfigResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQuickConnectConfigRequest,
  output: UpdateQuickConnectConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the name and description of a quick connect. The request accepts the following data in JSON format. At least `Name` or `Description` must be provided.
 */
export const updateQuickConnectName: (
  input: UpdateQuickConnectNameRequest,
) => effect.Effect<
  UpdateQuickConnectNameResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQuickConnectNameRequest,
  output: UpdateQuickConnectNameResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Whether agents with this routing profile will have their routing order calculated based on time since
 * their last inbound contact or *longest idle time*.
 */
export const updateRoutingProfileAgentAvailabilityTimer: (
  input: UpdateRoutingProfileAgentAvailabilityTimerRequest,
) => effect.Effect<
  UpdateRoutingProfileAgentAvailabilityTimerResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileAgentAvailabilityTimerRequest,
  output: UpdateRoutingProfileAgentAvailabilityTimerResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the channels that agents can handle in the Contact Control Panel (CCP) for a routing profile.
 */
export const updateRoutingProfileConcurrency: (
  input: UpdateRoutingProfileConcurrencyRequest,
) => effect.Effect<
  UpdateRoutingProfileConcurrencyResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileConcurrencyRequest,
  output: UpdateRoutingProfileConcurrencyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the default outbound queue of a routing profile.
 */
export const updateRoutingProfileDefaultOutboundQueue: (
  input: UpdateRoutingProfileDefaultOutboundQueueRequest,
) => effect.Effect<
  UpdateRoutingProfileDefaultOutboundQueueResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileDefaultOutboundQueueRequest,
  output: UpdateRoutingProfileDefaultOutboundQueueResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the properties associated with a set of queues for a routing profile.
 */
export const updateRoutingProfileQueues: (
  input: UpdateRoutingProfileQueuesRequest,
) => effect.Effect<
  UpdateRoutingProfileQueuesResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileQueuesRequest,
  output: UpdateRoutingProfileQueuesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const updateSecurityProfile: (
  input: UpdateSecurityProfileRequest,
) => effect.Effect<
  UpdateSecurityProfileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSecurityProfileRequest,
  output: UpdateSecurityProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Assigns the specified hierarchy group to the specified user.
 */
export const updateUserHierarchy: (
  input: UpdateUserHierarchyRequest,
) => effect.Effect<
  UpdateUserHierarchyResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserHierarchyRequest,
  output: UpdateUserHierarchyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the identity information for the specified user.
 *
 * We strongly recommend limiting who has the ability to invoke `UpdateUserIdentityInfo`. Someone with
 * that ability can change the login credentials of other users by changing their email address. This poses a security
 * risk to your organization. They can change the email address of a user to the attacker's email address, and then
 * reset the password through email. For more information, see Best Practices for Security Profiles
 * in the *Amazon Connect Administrator Guide*.
 */
export const updateUserIdentityInfo: (
  input: UpdateUserIdentityInfoRequest,
) => effect.Effect<
  UpdateUserIdentityInfoResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserIdentityInfoRequest,
  output: UpdateUserIdentityInfoResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the phone configuration settings for the specified user.
 */
export const updateUserPhoneConfig: (
  input: UpdateUserPhoneConfigRequest,
) => effect.Effect<
  UpdateUserPhoneConfigResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserPhoneConfigRequest,
  output: UpdateUserPhoneConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the properties associated with the proficiencies of a user.
 */
export const updateUserProficiencies: (
  input: UpdateUserProficienciesRequest,
) => effect.Effect<
  UpdateUserProficienciesResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserProficienciesRequest,
  output: UpdateUserProficienciesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Assigns the specified routing profile to the specified user.
 */
export const updateUserRoutingProfile: (
  input: UpdateUserRoutingProfileRequest,
) => effect.Effect<
  UpdateUserRoutingProfileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserRoutingProfileRequest,
  output: UpdateUserRoutingProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Assigns the specified security profiles to the specified user.
 */
export const updateUserSecurityProfiles: (
  input: UpdateUserSecurityProfilesRequest,
) => effect.Effect<
  UpdateUserSecurityProfilesResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserSecurityProfilesRequest,
  output: UpdateUserSecurityProfilesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates the specified dataset for a Amazon Connect instance with the target account. You can associate
 * only one dataset in a single call.
 */
export const associateAnalyticsDataSet: (
  input: AssociateAnalyticsDataSetRequest,
) => effect.Effect<
  AssociateAnalyticsDataSetResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateAnalyticsDataSetRequest,
  output: AssociateAnalyticsDataSetResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates a connect resource to a flow.
 */
export const associateFlow: (
  input: AssociateFlowRequest,
) => effect.Effect<
  AssociateFlowResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateFlowRequest,
  output: AssociateFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a flow for the specified Amazon Connect instance.
 */
export const deleteContactFlow: (
  input: DeleteContactFlowRequest,
) => effect.Effect<
  DeleteContactFlowResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowRequest,
  output: DeleteContactFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes the specified flow module.
 */
export const deleteContactFlowModule: (
  input: DeleteContactFlowModuleRequest,
) => effect.Effect<
  DeleteContactFlowModuleResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowModuleRequest,
  output: DeleteContactFlowModuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes an alias reference, breaking the named connection to the underlying module version without affecting the
 * version itself.
 */
export const deleteContactFlowModuleAlias: (
  input: DeleteContactFlowModuleAliasRequest,
) => effect.Effect<
  DeleteContactFlowModuleAliasResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowModuleAliasRequest,
  output: DeleteContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes a specific version of a contact flow module.
 */
export const deleteContactFlowModuleVersion: (
  input: DeleteContactFlowModuleVersionRequest,
) => effect.Effect<
  DeleteContactFlowModuleVersionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowModuleVersionRequest,
  output: DeleteContactFlowModuleVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes the particular version specified in flow version identifier.
 */
export const deleteContactFlowVersion: (
  input: DeleteContactFlowVersionRequest,
) => effect.Effect<
  DeleteContactFlowVersionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactFlowVersionRequest,
  output: DeleteContactFlowVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes email address from the specified Amazon Connect instance.
 */
export const deleteEmailAddress: (
  input: DeleteEmailAddressRequest,
) => effect.Effect<
  DeleteEmailAddressResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEmailAddressRequest,
  output: DeleteEmailAddressResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a workspace and removes all associated view and resource assignments.
 */
export const deleteWorkspace: (
  input: DeleteWorkspaceRequest,
) => effect.Effect<
  DeleteWorkspaceResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkspaceRequest,
  output: DeleteWorkspaceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes the association between a view and a page in a workspace. The page will display the default view after
 * deletion.
 */
export const deleteWorkspacePage: (
  input: DeleteWorkspacePageRequest,
) => effect.Effect<
  DeleteWorkspacePageResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteWorkspacePageRequest,
  output: DeleteWorkspacePageResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes the alias association between two email addresses in an Amazon Connect instance. After
 * disassociation, emails sent to the former alias email address are no longer forwarded to the primary email address.
 * Both email addresses continue to exist independently and can receive emails directly.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - **Department separation**: Remove alias relationships when splitting a
 * consolidated support queue back into separate department-specific queues.
 *
 * - **Email address retirement**: Cleanly remove forwarding relationships before
 * decommissioning old email addresses.
 *
 * - **Organizational restructuring**: Reconfigure email routing when business
 * processes change and aliases are no longer needed.
 *
 * **Important things to know**
 *
 * - Concurrent operations: This API uses distributed locking, so concurrent operations on the same email addresses
 * may be temporarily blocked.
 *
 * - Emails sent to the former alias address are still delivered directly to that address if it exists.
 *
 * - You do not need to delete the email addresses after disassociation. Both addresses remain active
 * independently.
 *
 * - After a successful disassociation, you can immediately create a new alias relationship with the same
 * addresses.
 *
 * - 200 status means alias was successfully disassociated.
 *
 * `DisassociateEmailAddressAlias` does not return the following information:
 *
 * - Details in the response about the email that was disassociated. The response returns an empty body.
 *
 * - The timestamp of when the disassociation occurred.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 *
 * **Related operations**
 *
 * - AssociateEmailAddressAlias: Associates an email address alias with an existing email address in an
 * Amazon Connect instance.
 *
 * - DescribeEmailAddress: View current alias configurations for an email address.
 *
 * - SearchEmailAddresses: Find email addresses and their alias relationships across an instance.
 *
 * - CreateEmailAddress: Create new email addresses that can participate in alias relationships.
 *
 * - DeleteEmailAddress: Remove email addresses (automatically removes any alias relationships).
 *
 * - UpdateEmailAddressMetadata: Modify email address properties (does not affect alias relationships).
 */
export const disassociateEmailAddressAlias: (
  input: DisassociateEmailAddressAliasRequest,
) => effect.Effect<
  DisassociateEmailAddressAliasResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateEmailAddressAliasRequest,
  output: DisassociateEmailAddressAliasResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Disassociates a connect resource from a flow.
 */
export const disassociateFlow: (
  input: DisassociateFlowRequest,
) => effect.Effect<
  DisassociateFlowResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateFlowRequest,
  output: DisassociateFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Disassociates a security profile attached to a Q in Connect AI Agent Entity in an Amazon Connect instance.
 */
export const disassociateSecurityProfiles: (
  input: DisassociateSecurityProfilesRequest,
) => effect.Effect<
  DisassociateSecurityProfilesResponse,
  | AccessDeniedException
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociateSecurityProfilesRequest,
  output: DisassociateSecurityProfilesResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
  ],
}));
/**
 * Dismisses contacts from an agents CCP and returns the agent to an available state, which allows the agent to
 * receive a new routed contact. Contacts can only be dismissed if they are in a `MISSED`,
 * `ERROR`, `ENDED`, or `REJECTED` state in the Agent Event Stream.
 */
export const dismissUserContact: (
  input: DismissUserContactRequest,
) => effect.Effect<
  DismissUserContactResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DismissUserContactRequest,
  output: DismissUserContactResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Changes the current status of a user or agent in Amazon Connect. If the agent is currently handling a
 * contact, this sets the agent's next status.
 *
 * For more information, see Agent status and Set your
 * next status in the *Amazon Connect Administrator Guide*.
 */
export const putUserStatus: (
  input: PutUserStatusRequest,
) => effect.Effect<
  PutUserStatusResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PutUserStatusRequest,
  output: PutUserStatusResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Starts screen sharing for a contact. For more information about screen sharing, see Set up in-app, web, video calling, and screen sharing
 * capabilities in the *Amazon Connect Administrator Guide*.
 */
export const startScreenSharing: (
  input: StartScreenSharingRequest,
) => effect.Effect<
  StartScreenSharingResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartScreenSharingRequest,
  output: StartScreenSharingResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a specific Aliases metadata, including the version its tied to, its name, and description.
 */
export const updateContactFlowModuleAlias: (
  input: UpdateContactFlowModuleAliasRequest,
) => effect.Effect<
  UpdateContactFlowModuleAliasResponse,
  | AccessDeniedException
  | ConditionalOperationFailedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowModuleAliasRequest,
  output: UpdateContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates metadata about specified flow module.
 */
export const updateContactFlowModuleMetadata: (
  input: UpdateContactFlowModuleMetadataRequest,
) => effect.Effect<
  UpdateContactFlowModuleMetadataResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowModuleMetadataRequest,
  output: UpdateContactFlowModuleMetadataResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the outbound email address Id for a specified queue.
 */
export const updateQueueOutboundEmailConfig: (
  input: UpdateQueueOutboundEmailConfigRequest,
) => effect.Effect<
  UpdateQueueOutboundEmailConfigResponse,
  | AccessDeniedException
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueOutboundEmailConfigRequest,
  output: UpdateQueueOutboundEmailConfigResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the metadata of a workspace, such as its name and description.
 */
export const updateWorkspaceMetadata: (
  input: UpdateWorkspaceMetadataRequest,
) => effect.Effect<
  UpdateWorkspaceMetadataResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspaceMetadataRequest,
  output: UpdateWorkspaceMetadataResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the configuration of a page in a workspace, including the associated view and input data.
 */
export const updateWorkspacePage: (
  input: UpdateWorkspacePageRequest,
) => effect.Effect<
  UpdateWorkspacePageResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspacePageRequest,
  output: UpdateWorkspacePageResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the theme configuration for a workspace, including colors and styling.
 */
export const updateWorkspaceTheme: (
  input: UpdateWorkspaceThemeRequest,
) => effect.Effect<
  UpdateWorkspaceThemeResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspaceThemeRequest,
  output: UpdateWorkspaceThemeResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the visibility setting of a workspace, controlling whether it is available to all users, assigned users
 * only, or none.
 */
export const updateWorkspaceVisibility: (
  input: UpdateWorkspaceVisibilityRequest,
) => effect.Effect<
  UpdateWorkspaceVisibilityResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateWorkspaceVisibilityRequest,
  output: UpdateWorkspaceVisibilityResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates metadata about specified flow.
 */
export const updateContactFlowMetadata: (
  input: UpdateContactFlowMetadataRequest,
) => effect.Effect<
  UpdateContactFlowMetadataResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowMetadataRequest,
  output: UpdateContactFlowMetadataResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * The name of the flow.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 */
export const updateContactFlowName: (
  input: UpdateContactFlowNameRequest,
) => effect.Effect<
  UpdateContactFlowNameResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowNameRequest,
  output: UpdateContactFlowNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the hours of operation.
 */
export const updateHoursOfOperation: (
  input: UpdateHoursOfOperationRequest,
) => effect.Effect<
  UpdateHoursOfOperationResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateHoursOfOperationRequest,
  output: UpdateHoursOfOperationResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the name and description of a queue. At least `Name` or `Description` must be provided.
 */
export const updateQueueName: (
  input: UpdateQueueNameRequest,
) => effect.Effect<
  UpdateQueueNameResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQueueNameRequest,
  output: UpdateQueueNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the name and description of a routing profile. The request accepts the following data in JSON format. At least `Name` or `Description` must be provided.
 */
export const updateRoutingProfileName: (
  input: UpdateRoutingProfileNameRequest,
) => effect.Effect<
  UpdateRoutingProfileNameResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoutingProfileNameRequest,
  output: UpdateRoutingProfileNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the name of the user hierarchy group.
 */
export const updateUserHierarchyGroupName: (
  input: UpdateUserHierarchyGroupNameRequest,
) => effect.Effect<
  UpdateUserHierarchyGroupNameResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserHierarchyGroupNameRequest,
  output: UpdateUserHierarchyGroupNameResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associate security profiles with an Entity in an Amazon Connect instance.
 */
export const associateSecurityProfiles: (
  input: AssociateSecurityProfilesRequest,
) => effect.Effect<
  AssociateSecurityProfilesResponse,
  | AccessDeniedException
  | ConditionalOperationFailedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateSecurityProfilesRequest,
  output: AssociateSecurityProfilesResponse,
  errors: [
    AccessDeniedException,
    ConditionalOperationFailedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
  ],
}));
/**
 * Updates specified flow module for the specified Amazon Connect instance.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 */
export const updateContactFlowModuleContent: (
  input: UpdateContactFlowModuleContentRequest,
) => effect.Effect<
  UpdateContactFlowModuleContentResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidContactFlowModuleException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactFlowModuleContentRequest,
  output: UpdateContactFlowModuleContentResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidContactFlowModuleException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates an email address metadata. For more information about email addresses, see Create email addresses in the Amazon Connect
 * Administrator Guide.
 */
export const updateEmailAddressMetadata: (
  input: UpdateEmailAddressMetadataRequest,
) => effect.Effect<
  UpdateEmailAddressMetadataResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateEmailAddressMetadataRequest,
  output: UpdateEmailAddressMetadataResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes an attribute and all its values from a data table.
 */
export const deleteDataTableAttribute: (
  input: DeleteDataTableAttributeRequest,
) => effect.Effect<
  DeleteDataTableAttributeResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataTableAttributeRequest,
  output: DeleteDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Adds or updates user-defined contact information associated with the specified contact. At least one field to be
 * updated must be present in the request.
 *
 * You can add or update user-defined contact information for both ongoing and completed contacts.
 */
export const updateContact: (
  input: UpdateContactRequest,
) => effect.Effect<
  UpdateContactResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactRequest,
  output: UpdateContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the metadata properties of a data table. Accepts all fields similar to CreateDataTable, except for
 * fields and tags. There are no other granular update endpoints. It does not act as a patch operation - all properties
 * must be provided or defaults will be used. Fields follow the same requirements as CreateDataTable.
 */
export const updateDataTableMetadata: (
  input: UpdateDataTableMetadataRequest,
) => effect.Effect<
  UpdateDataTableMetadataResponse,
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataTableMetadataRequest,
  output: UpdateDataTableMetadataResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a data table and all associated attributes, versions, audits, and values. Does not update any references
 * to the data table, even from other data tables. This includes dynamic values and conditional validations. System
 * managed data tables are not deletable by customers. API users may delete the table at any time. When deletion is
 * requested from the admin website, a warning is shown alerting the user of the most recent time the table and its
 * values were accessed.
 */
export const deleteDataTable: (
  input: DeleteDataTableRequest,
) => effect.Effect<
  DeleteDataTableResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataTableRequest,
  output: DeleteDataTableResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Allows resuming a task contact in a paused state.
 */
export const resumeContact: (
  input: ResumeContactRequest,
) => effect.Effect<
  ResumeContactResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResumeContactRequest,
  output: ResumeContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Instructs Amazon Connect to resume the authentication process. The subsequent actions depend on the request
 * body contents:
 *
 * - **If a code is provided**: Connect retrieves the identity information from Amazon
 * Cognito and imports it into Connect Customer Profiles.
 *
 * - **If an error is provided**: The error branch of the Authenticate Customer block
 * is executed.
 *
 * The API returns a success response to acknowledge the request. However, the interaction and exchange of
 * identity information occur asynchronously after the response is returned.
 */
export const updateParticipantAuthentication: (
  input: UpdateParticipantAuthenticationRequest,
) => effect.Effect<
  UpdateParticipantAuthenticationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateParticipantAuthenticationRequest,
  output: UpdateParticipantAuthenticationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ThrottlingException,
  ],
}));
/**
 * Updates multiple data table values using all properties from BatchCreateDataTableValue. System managed values
 * are not modifiable by customers. The operation requires proper lock versions to prevent concurrent modification
 * conflicts.
 */
export const batchUpdateDataTableValue: (
  input: BatchUpdateDataTableValueRequest,
) => effect.Effect<
  BatchUpdateDataTableValueResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchUpdateDataTableValueRequest,
  output: BatchUpdateDataTableValueResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Adds the specified tags to the contact resource. For more information about this API is used, see Set up granular billing for a detailed
 * view of your Amazon Connect usage.
 */
export const tagContact: (
  input: TagContactRequest,
) => effect.Effect<
  TagContactResponse,
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TagContactRequest,
  output: TagContactResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * When a contact is being recorded, and the recording has been suspended using SuspendContactRecording, this API
 * resumes recording whatever recording is selected in the flow configuration: call, screen, or both. If only call
 * recording or only screen recording is enabled, then it would resume.
 *
 * Voice and screen recordings are supported.
 */
export const resumeContactRecording: (
  input: ResumeContactRecordingRequest,
) => effect.Effect<
  ResumeContactRecordingResponse,
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ResumeContactRecordingRequest,
  output: ResumeContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Stops recording a call when a contact is being recorded. StopContactRecording is a one-time action. If you use
 * StopContactRecording to stop recording an ongoing call, you can't use StartContactRecording to restart it. For
 * scenarios where the recording has started and you want to suspend it for sensitive information (for example, to
 * collect a credit card number), and then restart it, use SuspendContactRecording and ResumeContactRecording.
 *
 * Only voice recordings are supported at this time.
 */
export const stopContactRecording: (
  input: StopContactRecordingRequest,
) => effect.Effect<
  StopContactRecordingResponse,
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactRecordingRequest,
  output: StopContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * When a contact is being recorded, this API suspends recording whatever is selected in the flow configuration:
 * call (IVR or agent), screen, or both. If only call recording or only screen recording is enabled, then it would be
 * suspended. For example, you might suspend the screen recording while collecting sensitive information, such as a
 * credit card number. Then use ResumeContactRecording to restart
 * recording the screen.
 *
 * The period of time that the recording is suspended is filled with silence in the final recording.
 *
 * Voice (IVR, agent) and screen recordings are supported.
 */
export const suspendContactRecording: (
  input: SuspendContactRecordingRequest,
) => effect.Effect<
  SuspendContactRecordingResponse,
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SuspendContactRecordingRequest,
  output: SuspendContactRecordingResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Removes the specified tags from the contact resource. For more information about this API is used, see Set up granular billing for a detailed
 * view of your Amazon Connect usage.
 */
export const untagContact: (
  input: UntagContactRequest,
) => effect.Effect<
  UntagContactResponse,
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UntagContactRequest,
  output: UntagContactResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates or updates user-defined contact
 * attributes associated with the specified contact.
 *
 * You can create or update user-defined attributes for both ongoing and completed contacts. For example, while the
 * call is active, you can update the customer's name or the reason the customer called. You can add notes about steps
 * that the agent took during the call that display to the next agent that takes the call. You can also update
 * attributes for a contact using data from your CRM application and save the data with the contact in Amazon Connect. You could also flag calls for additional analysis, such as legal review or to identify abusive callers.
 *
 * Contact attributes are available in Amazon Connect for 24 months, and are then deleted. For information
 * about contact record retention and the maximum size of the contact record attributes section, see Feature
 * specifications in the *Amazon Connect Administrator Guide*.
 */
export const updateContactAttributes: (
  input: UpdateContactAttributesRequest,
) => effect.Effect<
  UpdateContactAttributesResponse,
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactAttributesRequest,
  output: UpdateContactAttributesResponse,
  errors: [
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
  ],
}));
/**
 * Updates your claimed phone number from its current Amazon Connect instance or traffic distribution group to another Amazon Connect instance or traffic distribution group in the same Amazon Web Services Region.
 *
 * After using this API, you must verify that the phone number is attached to the correct flow in the target
 * instance or traffic distribution group. You need to do this because the API switches only the phone number to a new
 * instance or traffic distribution group. It doesn't migrate the flow configuration of the phone number, too.
 *
 * You can call DescribePhoneNumber API to verify the status of a previous UpdatePhoneNumber operation.
 */
export const updatePhoneNumber: (
  input: UpdatePhoneNumberRequest,
) => effect.Effect<
  UpdatePhoneNumberResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePhoneNumberRequest,
  output: UpdatePhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes an evaluation form in the specified Amazon Connect instance. If the version property is not
 * provided, the latest version of the evaluation form is described.
 */
export const describeEvaluationForm: (
  input: DescribeEvaluationFormRequest,
) => effect.Effect<
  DescribeEvaluationFormResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeEvaluationFormRequest,
  output: DescribeEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists evaluation forms in the specified Amazon Connect instance.
 */
export const listEvaluationForms: {
  (
    input: ListEvaluationFormsRequest,
  ): effect.Effect<
    ListEvaluationFormsResponse,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListEvaluationFormsRequest,
  ) => stream.Stream<
    ListEvaluationFormsResponse,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEvaluationFormsRequest,
  ) => stream.Stream<
    EvaluationFormSummary,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEvaluationFormsRequest,
  output: ListEvaluationFormsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EvaluationFormSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists versions of an evaluation form in the specified Amazon Connect instance.
 */
export const listEvaluationFormVersions: {
  (
    input: ListEvaluationFormVersionsRequest,
  ): effect.Effect<
    ListEvaluationFormVersionsResponse,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListEvaluationFormVersionsRequest,
  ) => stream.Stream<
    ListEvaluationFormVersionsResponse,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListEvaluationFormVersionsRequest,
  ) => stream.Stream<
    EvaluationFormVersionSummary,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListEvaluationFormVersionsRequest,
  output: ListEvaluationFormVersionsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EvaluationFormVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists phone numbers claimed to your Amazon Connect instance or traffic distribution group. If the provided `TargetArn`
 * is a traffic distribution group, you can call this API in both Amazon Web Services Regions associated with traffic distribution group.
 *
 * For more information about phone numbers, see Set Up Phone Numbers for Your Contact
 * Center in the *Amazon Connect Administrator Guide*.
 *
 * - When given an instance ARN, `ListPhoneNumbersV2` returns only the phone numbers claimed to the
 * instance.
 *
 * - When given a traffic distribution group ARN `ListPhoneNumbersV2` returns only the phone numbers claimed to the
 * traffic distribution group.
 */
export const listPhoneNumbersV2: {
  (
    input: ListPhoneNumbersV2Request,
  ): effect.Effect<
    ListPhoneNumbersV2Response,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListPhoneNumbersV2Request,
  ) => stream.Stream<
    ListPhoneNumbersV2Response,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListPhoneNumbersV2Request,
  ) => stream.Stream<
    ListPhoneNumbersSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListPhoneNumbersV2Request,
  output: ListPhoneNumbersV2Response,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ListPhoneNumbersSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Associates a flow with a phone number claimed to your Amazon Connect instance.
 *
 * If the number is claimed to a traffic distribution group, and you are calling this API using an instance in the Amazon Web Services Region where the traffic distribution group was created, you can use either a full phone number ARN or UUID value for the
 * `PhoneNumberId` URI request parameter. However, if the number is claimed to a traffic distribution group and you are calling
 * this API using an instance in the alternate Amazon Web Services Region associated with the traffic distribution group, you must provide a
 * full phone number ARN. If a UUID is provided
 * in
 * this scenario, you will receive a `ResourceNotFoundException`.
 */
export const associatePhoneNumberContactFlow: (
  input: AssociatePhoneNumberContactFlowRequest,
) => effect.Effect<
  AssociatePhoneNumberContactFlowResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociatePhoneNumberContactFlowRequest,
  output: AssociatePhoneNumberContactFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes registration for a device token and a chat contact.
 */
export const deletePushNotificationRegistration: (
  input: DeletePushNotificationRegistrationRequest,
) => effect.Effect<
  DeletePushNotificationRegistrationResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePushNotificationRegistrationRequest,
  output: DeletePushNotificationRegistrationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes the flow association from a phone number claimed to your Amazon Connect instance.
 *
 * If the number is claimed to a traffic distribution group, and you are calling this API using an instance in the Amazon Web Services Region where the traffic distribution group was created, you can use either a full phone number ARN or UUID value for the
 * `PhoneNumberId` URI request parameter. However, if the number is claimed to a traffic distribution group and you are calling
 * this API using an instance in the alternate Amazon Web Services Region associated with the traffic distribution group, you must provide a
 * full phone number ARN. If a UUID is provided in this scenario, you will receive a
 * `ResourceNotFoundException`.
 */
export const disassociatePhoneNumberContactFlow: (
  input: DisassociatePhoneNumberContactFlowRequest,
) => effect.Effect<
  DisassociatePhoneNumberContactFlowResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DisassociatePhoneNumberContactFlowRequest,
  output: DisassociatePhoneNumberContactFlowResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Imports a claimed phone number from an external service, such as Amazon Web Services End User Messaging, into an
 * Amazon Connect instance. You can call this API only in the same Amazon Web Services Region where the Amazon Connect instance was created.
 *
 * Call the DescribePhoneNumber API to verify the status of a previous `ImportPhoneNumber` operation.
 *
 * If you plan to claim or import numbers and then release numbers frequently, contact us for a service quota
 * exception. Otherwise, it is possible you will be blocked from claiming and releasing any more numbers until up to 180
 * days past the oldest number released has expired.
 *
 * By default you can claim or import and then release up to 200% of your maximum number of active phone numbers.
 * If you claim or import and then release phone numbers using the UI or API during a rolling 180 day cycle that exceeds
 * 200% of your phone number service level quota, you will be blocked from claiming or importing any more numbers until
 * 180 days past the oldest number released has expired.
 *
 * For example, if you already have 99 claimed or imported numbers and a service level quota of 99 phone numbers,
 * and in any 180 day period you release 99, claim 99, and then release 99, you will have exceeded the 200% limit. At
 * that point you are blocked from claiming any more numbers until you open an Amazon Web Services Support ticket.
 */
export const importPhoneNumber: (
  input: ImportPhoneNumberRequest,
) => effect.Effect<
  ImportPhoneNumberResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ImportPhoneNumberRequest,
  output: ImportPhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes multiple values from a data table. API users may delete values at any time. When deletion is requested
 * from the admin website, a warning is shown alerting the user of the most recent time the attribute and its values
 * were accessed. System managed values are not deletable by customers.
 */
export const batchDeleteDataTableValue: (
  input: BatchDeleteDataTableValueRequest,
) => effect.Effect<
  BatchDeleteDataTableValueResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDeleteDataTableValueRequest,
  output: BatchDeleteDataTableValueResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves multiple values from a data table without evaluating expressions. Returns the raw stored values along
 * with metadata such as lock versions and modification timestamps. "Describe" is a deprecated term but is allowed to
 * maintain consistency with existing operations.
 */
export const batchDescribeDataTableValue: (
  input: BatchDescribeDataTableValueRequest,
) => effect.Effect<
  BatchDescribeDataTableValueResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDescribeDataTableValueRequest,
  output: BatchDescribeDataTableValueResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Claims an available phone number to your Amazon Connect instance or traffic distribution group. You can call
 * this API only in the same Amazon Web Services Region where the Amazon Connect instance or traffic distribution group was
 * created.
 *
 * For more information about how to use this operation, see Claim a phone number in your country and Claim
 * phone numbers to traffic distribution groups in the Amazon Connect Administrator
 * Guide.
 *
 * You can call the SearchAvailablePhoneNumbers API for
 * available phone numbers that you can claim. Call the DescribePhoneNumber API to verify the status
 * of a previous ClaimPhoneNumber operation.
 *
 * If you plan to claim and release numbers frequently,
 * contact us for a service quota exception. Otherwise, it is possible you will be blocked from
 * claiming and releasing any more numbers until up to 180 days past the oldest number
 * released has expired.
 *
 * By default you can claim and release up to 200% of your maximum number of active
 * phone numbers. If you claim and release phone numbers using
 * the UI or API during a rolling 180 day cycle that exceeds 200% of your phone number
 * service level quota, you will be blocked from claiming any more numbers until 180
 * days past the oldest number released has expired.
 *
 * For example, if you already have 99 claimed numbers and a service level quota of 99 phone numbers, and in any 180
 * day period you release 99, claim 99, and then release 99, you will have exceeded the
 * 200% limit. At that point you are blocked from claiming any more numbers until you
 * open an Amazon Web Services support ticket.
 */
export const claimPhoneNumber: (
  input: ClaimPhoneNumberRequest,
) => effect.Effect<
  ClaimPhoneNumberResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ClaimPhoneNumberRequest,
  output: ClaimPhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the specified flow.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 *
 * Use the `$SAVED` alias in the request to describe the `SAVED` content of a Flow. For
 * example, `arn:aws:.../contact-flow/{id}:$SAVED`. After a flow is published, `$SAVED` needs to
 * be supplied to view saved content that has not been published.
 *
 * Use `arn:aws:.../contact-flow/{id}:{version}` to retrieve the content of a specific flow
 * version.
 *
 * In the response, **Status** indicates the flow status as either `SAVED`
 * or `PUBLISHED`. The `PUBLISHED` status will initiate validation on the content.
 * `SAVED` does not initiate validation of the content. `SAVED` | `PUBLISHED`
 */
export const describeContactFlow: (
  input: DescribeContactFlowRequest,
) => effect.Effect<
  DescribeContactFlowResponse,
  | ContactFlowNotPublishedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactFlowRequest,
  output: DescribeContactFlowResponse,
  errors: [
    ContactFlowNotPublishedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Gets details and status of a phone number thats claimed to your Amazon Connect instance or traffic distribution group.
 *
 * If the number is claimed to a traffic distribution group, and you are calling in the Amazon Web Services Region where the traffic distribution group was
 * created, you can use either a phone number ARN or UUID value for the `PhoneNumberId` URI request
 * parameter. However, if the number is claimed to a traffic distribution group and you are calling this API in the alternate Amazon Web Services Region associated with the traffic distribution group, you must provide a full phone number ARN. If a UUID is provided
 * in
 * this scenario, you receive a `ResourceNotFoundException`.
 */
export const describePhoneNumber: (
  input: DescribePhoneNumberRequest,
) => effect.Effect<
  DescribePhoneNumberResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePhoneNumberRequest,
  output: DescribePhoneNumberResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes a predefined attribute for the specified Amazon Connect instance. A *predefined attribute*
 * is made up of a name and a value. You can use predefined attributes for:
 *
 * - Routing proficiency (for example, agent certification) that has predefined values (for example, a list of
 * possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Contact information that varies between transfers or conferences, such as the name of the business unit
 * handling the contact. For more information, see Use contact segment attributes.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const describePredefinedAttribute: (
  input: DescribePredefinedAttributeRequest,
) => effect.Effect<
  DescribePredefinedAttributeResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribePredefinedAttributeRequest,
  output: DescribePredefinedAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the specified hierarchy group.
 */
export const describeUserHierarchyGroup: (
  input: DescribeUserHierarchyGroupRequest,
) => effect.Effect<
  DescribeUserHierarchyGroupResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserHierarchyGroupRequest,
  output: DescribeUserHierarchyGroupResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the hierarchy structure of the specified Amazon Connect instance.
 */
export const describeUserHierarchyStructure: (
  input: DescribeUserHierarchyStructureRequest,
) => effect.Effect<
  DescribeUserHierarchyStructureResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserHierarchyStructureRequest,
  output: DescribeUserHierarchyStructureResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Evaluates values at the time of the request and returns them. It considers the request's timezone or the table's
 * timezone, in that order, when accessing time based tables. When a value is accessed, the accessor's identity and the
 * time of access are saved alongside the value to help identify values that are actively in use. The term "Batch" is
 * not included in the operation name since it does not meet all the criteria for a batch operation as specified in
 * Batch Operations: Amazon Web Services API Standards.
 */
export const evaluateDataTableValues: {
  (
    input: EvaluateDataTableValuesRequest,
  ): effect.Effect<
    EvaluateDataTableValuesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: EvaluateDataTableValuesRequest,
  ) => stream.Stream<
    EvaluateDataTableValuesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: EvaluateDataTableValuesRequest,
  ) => stream.Stream<
    unknown,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: EvaluateDataTableValuesRequest,
  output: EvaluateDataTableValuesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Get the hours of operations with the effective override applied.
 */
export const getEffectiveHoursOfOperations: (
  input: GetEffectiveHoursOfOperationsRequest,
) => effect.Effect<
  GetEffectiveHoursOfOperationsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetEffectiveHoursOfOperationsRequest,
  output: GetEffectiveHoursOfOperationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists contact evaluations in the specified Amazon Connect instance.
 */
export const listContactEvaluations: {
  (
    input: ListContactEvaluationsRequest,
  ): effect.Effect<
    ListContactEvaluationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContactEvaluationsRequest,
  ) => stream.Stream<
    ListContactEvaluationsResponse,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactEvaluationsRequest,
  ) => stream.Stream<
    EvaluationSummary,
    | InternalServiceException
    | InvalidParameterException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactEvaluationsRequest,
  output: ListContactEvaluationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "EvaluationSummaryList",
  } as const,
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * For the specified `referenceTypes`, returns a list of references associated with the contact.
 * *References* are links to documents that are related to a contact, such as emails, attachments,
 * or URLs.
 */
export const listContactReferences: {
  (
    input: ListContactReferencesRequest,
  ): effect.Effect<
    ListContactReferencesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListContactReferencesRequest,
  ) => stream.Stream<
    ListContactReferencesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListContactReferencesRequest,
  ) => stream.Stream<
    ReferenceSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListContactReferencesRequest,
  output: ListContactReferencesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ReferenceSummaryList",
  } as const,
}));
/**
 * Lists all primary value combinations for a given data table. Returns the unique combinations of primary
 * attribute values that identify records in the table. Up to 100 records are returned per request.
 */
export const listDataTablePrimaryValues: {
  (
    input: ListDataTablePrimaryValuesRequest,
  ): effect.Effect<
    ListDataTablePrimaryValuesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDataTablePrimaryValuesRequest,
  ) => stream.Stream<
    ListDataTablePrimaryValuesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTablePrimaryValuesRequest,
  ) => stream.Stream<
    RecordPrimaryValue,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTablePrimaryValuesRequest,
  output: ListDataTablePrimaryValuesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "PrimaryValuesList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists values stored in a data table with optional filtering by record IDs or primary attribute values. Returns
 * the raw stored values along with metadata such as lock versions and modification timestamps.
 */
export const listDataTableValues: {
  (
    input: ListDataTableValuesRequest,
  ): effect.Effect<
    ListDataTableValuesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDataTableValuesRequest,
  ) => stream.Stream<
    ListDataTableValuesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataTableValuesRequest,
  ) => stream.Stream<
    DataTableValueSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataTableValuesRequest,
  output: ListDataTableValuesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Values",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List all rules for the specified Amazon Connect instance.
 */
export const listRules: {
  (
    input: ListRulesRequest,
  ): effect.Effect<
    ListRulesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListRulesRequest,
  ) => stream.Stream<
    ListRulesResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRulesRequest,
  ) => stream.Stream<
    RuleSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRulesRequest,
  output: ListRulesResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "RuleSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Deactivates an evaluation form in the specified Amazon Connect instance. After a form is deactivated, it is no longer
 * available for users to start new evaluations based on the form.
 */
export const deactivateEvaluationForm: (
  input: DeactivateEvaluationFormRequest,
) => effect.Effect<
  DeactivateEvaluationFormResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeactivateEvaluationFormRequest,
  output: DeactivateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates details about a contact evaluation in the specified Amazon Connect instance. A contact evaluation
 * must be in draft state. Answers included in the request are merged with existing answers for the given evaluation. An
 * answer or note can be deleted by passing an empty object (`{}`) to the question identifier.
 */
export const updateContactEvaluation: (
  input: UpdateContactEvaluationRequest,
) => effect.Effect<
  UpdateContactEvaluationResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactEvaluationRequest,
  output: UpdateContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a contact evaluation in the specified Amazon Connect instance.
 */
export const deleteContactEvaluation: (
  input: DeleteContactEvaluationRequest,
) => effect.Effect<
  DeleteContactEvaluationResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteContactEvaluationRequest,
  output: DeleteContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes an evaluation form in the specified Amazon Connect instance.
 *
 * - If the version property is provided, only the specified version of the evaluation form is deleted.
 *
 * - If no version is provided, then the full form (all versions) is deleted.
 */
export const deleteEvaluationForm: (
  input: DeleteEvaluationFormRequest,
) => effect.Effect<
  DeleteEvaluationFormResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteEvaluationFormRequest,
  output: DeleteEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Activates an evaluation form in the specified Amazon Connect instance. After the evaluation form is
 * activated, it is available to start new evaluations based on the form.
 */
export const activateEvaluationForm: (
  input: ActivateEvaluationFormRequest,
) => effect.Effect<
  ActivateEvaluationFormResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ActivateEvaluationFormRequest,
  output: ActivateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Releases a phone number previously claimed to an Amazon Connect instance or traffic distribution group. You can call this API
 * only in the Amazon Web Services Region where the number was claimed.
 *
 * To release phone numbers from a traffic distribution group, use the `ReleasePhoneNumber` API, not the Amazon Connect admin website.
 *
 * After releasing a phone number, the phone number enters into a cooldown period for up to 180 days. It cannot be
 * searched for or claimed again until the period has ended. If you accidentally release a phone number, contact
 * Amazon Web Services Support.
 *
 * If you plan to claim and release numbers frequently,
 * contact us for a service quota exception. Otherwise, it is possible you will be blocked from
 * claiming and releasing any more numbers until up to 180 days past the oldest number
 * released has expired.
 *
 * By default you can claim and release up to 200% of your maximum number of active
 * phone numbers. If you claim and release phone numbers using
 * the UI or API during a rolling 180 day cycle that exceeds 200% of your phone number
 * service level quota, you will be blocked from claiming any more numbers until 180
 * days past the oldest number released has expired.
 *
 * For example, if you already have 99 claimed numbers and a service level quota of 99 phone numbers, and in any 180
 * day period you release 99, claim 99, and then release 99, you will have exceeded the
 * 200% limit. At that point you are blocked from claiming any more numbers until you
 * open an Amazon Web Services support ticket.
 */
export const releasePhoneNumber: (
  input: ReleasePhoneNumberRequest,
) => effect.Effect<
  ReleasePhoneNumberResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReleasePhoneNumberRequest,
  output: ReleasePhoneNumberResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes the vocabulary that has the given identifier.
 */
export const deleteVocabulary: (
  input: DeleteVocabularyRequest,
) => effect.Effect<
  DeleteVocabularyResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVocabularyRequest,
  output: DeleteVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a traffic distribution group. This API can be called only in the Region where the traffic distribution group is created.
 *
 * For more information about deleting traffic distribution groups, see Delete traffic distribution groups in the
 * *Amazon Connect Administrator Guide*.
 */
export const deleteTrafficDistributionGroup: (
  input: DeleteTrafficDistributionGroupRequest,
) => effect.Effect<
  DeleteTrafficDistributionGroupResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceInUseException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTrafficDistributionGroupRequest,
  output: DeleteTrafficDistributionGroupResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceInUseException,
    ThrottlingException,
  ],
}));
/**
 * Updates the user hierarchy structure: add, remove, and rename user hierarchy levels.
 */
export const updateUserHierarchyStructure: (
  input: UpdateUserHierarchyStructureRequest,
) => effect.Effect<
  UpdateUserHierarchyStructureResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserHierarchyStructureRequest,
  output: UpdateUserHierarchyStructureResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a predefined attribute from the specified Amazon Connect instance.
 */
export const deletePredefinedAttribute: (
  input: DeletePredefinedAttributeRequest,
) => effect.Effect<
  DeletePredefinedAttributeResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeletePredefinedAttributeRequest,
  output: DeletePredefinedAttributeResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a queue.
 */
export const deleteQueue: (
  input: DeleteQueueRequest,
) => effect.Effect<
  DeleteQueueResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteQueueRequest,
  output: DeleteQueueResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a routing profile.
 */
export const deleteRoutingProfile: (
  input: DeleteRoutingProfileRequest,
) => effect.Effect<
  DeleteRoutingProfileResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRoutingProfileRequest,
  output: DeleteRoutingProfileResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes an existing user hierarchy group. It must not be associated with any agents or have any active child
 * groups.
 */
export const deleteUserHierarchyGroup: (
  input: DeleteUserHierarchyGroupRequest,
) => effect.Effect<
  DeleteUserHierarchyGroupResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserHierarchyGroupRequest,
  output: DeleteUserHierarchyGroupResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a security profile.
 */
export const deleteSecurityProfile: (
  input: DeleteSecurityProfileRequest,
) => effect.Effect<
  DeleteSecurityProfileResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteSecurityProfileRequest,
  output: DeleteSecurityProfileResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a phone numbers metadata.
 *
 * To verify the status of a previous UpdatePhoneNumberMetadata operation, call the DescribePhoneNumber API.
 */
export const updatePhoneNumberMetadata: (
  input: UpdatePhoneNumberMetadataRequest,
) => effect.Effect<
  UpdatePhoneNumberMetadataResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePhoneNumberMetadataRequest,
  output: UpdatePhoneNumberMetadataResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Associates a storage resource type for the first time. You can only associate one type of storage configuration
 * in a single call. This means, for example, that you can't define an instance with multiple S3 buckets for storing
 * chat transcripts.
 *
 * This API does not create a resource that doesn't exist. It only associates it to the instance. Ensure that the
 * resource being specified in the storage configuration, like an S3 bucket, exists when being used for
 * association.
 */
export const associateInstanceStorageConfig: (
  input: AssociateInstanceStorageConfigRequest,
) => effect.Effect<
  AssociateInstanceStorageConfigResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateInstanceStorageConfigRequest,
  output: AssociateInstanceStorageConfigResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Only the Amazon Connect outbound campaigns service principal is allowed to assume a role in your account
 * and call this API.
 *
 * Allows you to create a batch of contacts in Amazon Connect. The outbound campaigns capability ingests dial
 * requests via the PutDialRequestBatch API. It then uses BatchPutContact to create contacts corresponding to those dial
 * requests. If agents are available, the dial requests are dialed out, which results in a voice call. The resulting
 * voice call uses the same contactId that was created by BatchPutContact.
 */
export const batchPutContact: (
  input: BatchPutContactRequest,
) => effect.Effect<
  BatchPutContactResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchPutContactRequest,
  output: BatchPutContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
/**
 * Retrieves the position of the contact in the queue.
 *
 * **Use cases**
 *
 * Following are common uses cases for position in queue:
 *
 * - Understand the expected wait experience of a contact.
 *
 * - Inform customers of their position in queue and potentially offer a callback.
 *
 * - Make data-driven routing decisions between primary and alternative queues.
 *
 * - Enhance queue visibility and leverage agent proficiencies to streamline contact routing.
 *
 * **Important things to know**
 *
 * - The only way to retrieve the position of the contact in queue is by using this API. You can't retrieve the
 * position by using flows and attributes.
 *
 * - For more information, see the Position in queue metric in the *Amazon Connect Administrator Guide*.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const getContactMetrics: (
  input: GetContactMetricsRequest,
) => effect.Effect<
  GetContactMetricsResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetContactMetricsRequest,
  output: GetContactMetricsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Searches AgentStatuses in an Amazon Connect instance, with optional filtering.
 */
export const searchAgentStatuses: {
  (
    input: SearchAgentStatusesRequest,
  ): effect.Effect<
    SearchAgentStatusesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchAgentStatusesRequest,
  ) => stream.Stream<
    SearchAgentStatusesResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchAgentStatusesRequest,
  ) => stream.Stream<
    AgentStatus,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchAgentStatusesRequest,
  output: SearchAgentStatusesResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AgentStatuses",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches the flows in an Amazon Connect instance, with optional filtering.
 */
export const searchContactFlows: {
  (
    input: SearchContactFlowsRequest,
  ): effect.Effect<
    SearchContactFlowsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchContactFlowsRequest,
  ) => stream.Stream<
    SearchContactFlowsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchContactFlowsRequest,
  ) => stream.Stream<
    ContactFlow,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchContactFlowsRequest,
  output: SearchContactFlowsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ContactFlows",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Submits a contact evaluation in the specified Amazon Connect instance. Answers included in the request are
 * merged with existing answers for the given evaluation. If no answers or notes are passed, the evaluation is submitted
 * with the existing answers and notes. You can delete an answer or note by passing an empty object (`{}`) to
 * the question identifier.
 *
 * If a contact evaluation is already in submitted state, this operation will trigger a resubmission.
 */
export const submitContactEvaluation: (
  input: SubmitContactEvaluationRequest,
) => effect.Effect<
  SubmitContactEvaluationResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SubmitContactEvaluationRequest,
  output: SubmitContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates timeouts for when human chat participants are to be considered idle, and when agents are automatically
 * disconnected from a chat due to idleness. You can set four timers:
 *
 * - Customer idle timeout
 *
 * - Customer auto-disconnect timeout
 *
 * - Agent idle timeout
 *
 * - Agent auto-disconnect timeout
 *
 * For more information about how chat timeouts work, see
 * Set up chat timeouts for human participants.
 */
export const updateParticipantRoleConfig: (
  input: UpdateParticipantRoleConfigRequest,
) => effect.Effect<
  UpdateParticipantRoleConfigResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateParticipantRoleConfigRequest,
  output: UpdateParticipantRoleConfigResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Supports SAML sign-in for Amazon Connect. Retrieves a token for federation. The token is for the Amazon Connect user which corresponds to the IAM credentials that were used to invoke this action.
 *
 * For more information about how SAML sign-in works in Amazon Connect, see Configure SAML with IAM for Amazon Connect
 * in the *Amazon Connect Administrator Guide*.
 *
 * This API doesn't support root users. If you try to invoke GetFederationToken with root credentials, an error
 * message similar to the following one appears:
 *
 * `Provided identity: Principal: .... User: .... cannot be used for federation with Amazon Connect`
 */
export const getFederationToken: (
  input: GetFederationTokenRequest,
) => effect.Effect<
  GetFederationTokenResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | UserNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetFederationTokenRequest,
  output: GetFederationTokenResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    UserNotFoundException,
  ],
}));
/**
 * Returns views in the given instance.
 *
 * Results are sorted primarily by type, and secondarily by name.
 */
export const listViews: {
  (
    input: ListViewsRequest,
  ): effect.Effect<
    ListViewsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | TooManyRequestsException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListViewsRequest,
  ) => stream.Stream<
    ListViewsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | TooManyRequestsException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListViewsRequest,
  ) => stream.Stream<
    ViewSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | TooManyRequestsException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListViewsRequest,
  output: ListViewsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ViewsSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Creates hours of operation.
 */
export const createHoursOfOperation: (
  input: CreateHoursOfOperationRequest,
) => effect.Effect<
  CreateHoursOfOperationResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHoursOfOperationRequest,
  output: CreateHoursOfOperationResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates an hours of operation override in an Amazon Connect hours of operation resource.
 */
export const createHoursOfOperationOverride: (
  input: CreateHoursOfOperationOverrideRequest,
) => effect.Effect<
  CreateHoursOfOperationOverrideResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateHoursOfOperationOverrideRequest,
  output: CreateHoursOfOperationOverrideResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a quick connect for the specified Amazon Connect instance.
 */
export const createQuickConnect: (
  input: CreateQuickConnectRequest,
) => effect.Effect<
  CreateQuickConnectResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateQuickConnectRequest,
  output: CreateQuickConnectResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a new routing profile.
 */
export const createRoutingProfile: (
  input: CreateRoutingProfileRequest,
) => effect.Effect<
  CreateRoutingProfileResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRoutingProfileRequest,
  output: CreateRoutingProfileResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Initiates a new outbound SMS or WhatsApp contact to a customer. Response of this API provides the
 * `ContactId` of the outbound SMS or WhatsApp contact created.
 *
 * **SourceEndpoint** only supports Endpoints with
 * `CONNECT_PHONENUMBER_ARN` as Type and **DestinationEndpoint** only supports
 * Endpoints with `TELEPHONE_NUMBER` as Type. **ContactFlowId** initiates the
 * flow to manage the new contact created.
 *
 * This API can be used to initiate outbound SMS or WhatsApp contacts for an agent, or it can also deflect
 * an ongoing contact to an outbound SMS or WhatsApp contact by using the StartOutboundChatContact Flow
 * Action.
 *
 * For more information about using SMS or WhatsApp in Amazon Connect, see the following topics in
 * the *Amazon Connect Administrator Guide*:
 *
 * - Set up SMS
 * messaging
 *
 * - Request an SMS-enabled phone
 * number through Amazon Web Services End User Messaging SMS
 *
 * - Set up WhatsApp
 * Business messaging
 */
export const startOutboundChatContact: (
  input: StartOutboundChatContactRequest,
) => effect.Effect<
  StartOutboundChatContactResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartOutboundChatContactRequest,
  output: StartOutboundChatContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a new queue for the specified Amazon Connect instance.
 *
 * - If the phone number is claimed to a traffic distribution group that was created in the
 * same Region as the Amazon Connect instance where you are calling this API, then you can use a
 * full phone number ARN or a UUID for `OutboundCallerIdNumberId`. However, if the phone number is claimed
 * to a traffic distribution group that is in one Region, and you are calling this API from an instance in another Amazon Web Services Region that is associated with the traffic distribution group, you must provide a full phone number ARN. If a
 * UUID is provided in this scenario, you will receive a
 * `ResourceNotFoundException`.
 *
 * - Only use the phone number ARN format that doesn't contain `instance` in the path, for example,
 * `arn:aws:connect:us-east-1:1234567890:phone-number/uuid`. This is the same ARN format that is returned
 * when you call the ListPhoneNumbersV2 API.
 *
 * - If you plan to use IAM policies to allow/deny access to this API for phone number resources
 * claimed to a traffic distribution group, see Allow or Deny queue API actions for phone numbers in a replica Region.
 */
export const createQueue: (
  input: CreateQueueRequest,
) => effect.Effect<
  CreateQueueResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateQueueRequest,
  output: CreateQueueResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a user account for the specified Amazon Connect instance.
 *
 * Certain UserIdentityInfo parameters are required in some situations. For example, `Email`,
 * `FirstName` and `LastName` are required if you are using Amazon Connect or SAML for
 * identity management.
 *
 * For information about how to create users using the Amazon Connect admin website, see Add Users in the Amazon Connect
 * Administrator Guide.
 */
export const createUser: (
  input: CreateUserRequest,
) => effect.Effect<
  CreateUserResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateUserRequest,
  output: CreateUserResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Initiates a flow to start a new chat for the customer. Response of this API provides a token required to obtain
 * credentials from the CreateParticipantConnection API in the Amazon Connect Participant Service.
 *
 * When a new chat contact is successfully created, clients must subscribe to the participants connection for the
 * created chat within 5 minutes. This is achieved by invoking CreateParticipantConnection with WEBSOCKET and CONNECTION_CREDENTIALS.
 *
 * A 429 error occurs in the following situations:
 *
 * - API rate limit is exceeded. API TPS throttling returns a `TooManyRequests` exception.
 *
 * - The quota for
 * concurrent active chats is exceeded. Active chat throttling returns a
 * `LimitExceededException`.
 *
 * If you use the `ChatDurationInMinutes` parameter and receive a 400 error, your account may not
 * support the ability to configure custom chat durations. For more information, contact Amazon Web Services Support.
 *
 * For more information about chat, see the following topics in the Amazon Connect
 * Administrator Guide:
 *
 * - Concepts: Web and mobile messaging capabilities in Amazon Connect
 *
 * - Amazon Connect Chat security best practices
 */
export const startChatContact: (
  input: StartChatContactRequest,
) => effect.Effect<
  StartChatContactResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartChatContactRequest,
  output: StartChatContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
/**
 * Initiates real-time message streaming for a new chat contact.
 *
 * For more information about message streaming, see Enable real-time chat message streaming in the
 * *Amazon Connect Administrator Guide*.
 *
 * For more information about chat, see the following topics in the Amazon Connect
 * Administrator Guide:
 *
 * - Concepts: Web and mobile messaging capabilities in Amazon Connect
 *
 * - Amazon Connect Chat security best practices
 */
export const startContactStreaming: (
  input: StartContactStreamingRequest,
) => effect.Effect<
  StartContactStreamingResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactStreamingRequest,
  output: StartContactStreamingResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
/**
 * Creates an immutable snapshot of a contact flow module, preserving its content and settings at a specific point
 * in time for version control and rollback capabilities.
 */
export const createContactFlowModuleVersion: (
  input: CreateContactFlowModuleVersionRequest,
) => effect.Effect<
  CreateContactFlowModuleVersionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowModuleVersionRequest,
  output: CreateContactFlowModuleVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Publishes a new version of the flow provided. Versions are immutable and monotonically increasing. If the
 * `FlowContentSha256` provided is different from the `FlowContentSha256` of the
 * `$LATEST` published flow content, then an error is returned. This API only supports creating versions for
 * flows of type `Campaign`.
 */
export const createContactFlowVersion: (
  input: CreateContactFlowVersionRequest,
) => effect.Effect<
  CreateContactFlowVersionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowVersionRequest,
  output: CreateContactFlowVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates agent status.
 */
export const updateAgentStatus: (
  input: UpdateAgentStatusRequest,
) => effect.Effect<
  UpdateAgentStatusResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAgentStatusRequest,
  output: UpdateAgentStatusResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Associates a set of quick connects with a queue.
 */
export const associateQueueQuickConnects: (
  input: AssociateQueueQuickConnectsRequest,
) => effect.Effect<
  AssociateQueueQuickConnectsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateQueueQuickConnectsRequest,
  output: AssociateQueueQuickConnectsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the scheduled time of a task contact that is already scheduled.
 */
export const updateContactSchedule: (
  input: UpdateContactScheduleRequest,
) => effect.Effect<
  UpdateContactScheduleResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactScheduleRequest,
  output: UpdateContactScheduleResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Stops in-flight message processing for an ongoing chat session.
 */
export const stopContactMediaProcessing: (
  input: StopContactMediaProcessingRequest,
) => effect.Effect<
  StopContactMediaProcessingResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StopContactMediaProcessingRequest,
  output: StopContactMediaProcessingResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
/**
 * Creates an agent status for the specified Amazon Connect instance.
 */
export const createAgentStatus: (
  input: CreateAgentStatusRequest,
) => effect.Effect<
  CreateAgentStatusResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAgentStatusRequest,
  output: CreateAgentStatusResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a named alias that points to a specific version of a contact flow module.
 */
export const createContactFlowModuleAlias: (
  input: CreateContactFlowModuleAliasRequest,
) => effect.Effect<
  CreateContactFlowModuleAliasResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowModuleAliasRequest,
  output: CreateContactFlowModuleAliasResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a new predefined attribute for the specified Amazon Connect instance. A *predefined attribute*
 * is made up of a name and a value.
 *
 * For the predefined attributes per instance quota, see Amazon Connect
 * quotas.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Create an attribute for routing proficiency (for example, agent certification) that has predefined values (for
 * example, a list of possible certifications). For more information, see Create predefined attributes for routing contacts to
 * agents.
 *
 * - Create an attribute for business unit name that has a list of predefined business unit names used in your
 * organization. This is a use case where information for a contact varies between transfers or conferences. For more
 * information, see Use contact segment attributes.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const createPredefinedAttribute: (
  input: CreatePredefinedAttributeRequest,
) => effect.Effect<
  CreatePredefinedAttributeResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePredefinedAttributeRequest,
  output: CreatePredefinedAttributeResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a prompt. For more information about prompts, such as supported file types and maximum length, see
 * Create prompts in the
 * *Amazon Connect Administrator Guide*.
 */
export const createPrompt: (
  input: CreatePromptRequest,
) => effect.Effect<
  CreatePromptResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePromptRequest,
  output: CreatePromptResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a new user hierarchy group.
 */
export const createUserHierarchyGroup: (
  input: CreateUserHierarchyGroupRequest,
) => effect.Effect<
  CreateUserHierarchyGroupResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateUserHierarchyGroupRequest,
  output: CreateUserHierarchyGroupResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Allows pausing an ongoing task contact.
 */
export const pauseContact: (
  input: PauseContactRequest,
) => effect.Effect<
  PauseContactResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PauseContactRequest,
  output: PauseContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a flow module for the specified Amazon Connect instance.
 */
export const createContactFlowModule: (
  input: CreateContactFlowModuleRequest,
) => effect.Effect<
  CreateContactFlowModuleResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | IdempotencyException
  | InternalServiceException
  | InvalidContactFlowModuleException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowModuleRequest,
  output: CreateContactFlowModuleResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    IdempotencyException,
    InternalServiceException,
    InvalidContactFlowModuleException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a flow for the specified Amazon Connect instance.
 *
 * You can also create and update flows using the Amazon Connect
 * Flow language.
 */
export const createContactFlow: (
  input: CreateContactFlowRequest,
) => effect.Effect<
  CreateContactFlowResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidContactFlowException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactFlowRequest,
  output: CreateContactFlowResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidContactFlowException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Returns all the available versions for the specified Amazon Connect instance and view identifier.
 *
 * Results will be sorted from highest to lowest.
 */
export const listViewVersions: {
  (
    input: ListViewVersionsRequest,
  ): effect.Effect<
    ListViewVersionsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | TooManyRequestsException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListViewVersionsRequest,
  ) => stream.Stream<
    ListViewVersionsResponse,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | TooManyRequestsException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListViewVersionsRequest,
  ) => stream.Stream<
    ViewVersionSummary,
    | AccessDeniedException
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | TooManyRequestsException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListViewVersionsRequest,
  output: ListViewVersionsResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ViewVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Retrieves the view for the specified Amazon Connect instance and view identifier.
 *
 * The view identifier can be supplied as a ViewId or ARN.
 *
 * `$SAVED` needs to be supplied if a view is unpublished.
 *
 * The view identifier can contain an optional qualifier, for example, `:$SAVED`, which
 * is either an actual version number or an Amazon Connect managed qualifier `$SAVED | $LATEST`. If it is
 * not supplied, then `$LATEST` is assumed for customer managed views and an error is returned if there is no
 * published content available. Version 1 is assumed for Amazon Web Services managed views.
 */
export const describeView: (
  input: DescribeViewRequest,
) => effect.Effect<
  DescribeViewResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeViewRequest,
  output: DescribeViewResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
/**
 * Updates the view content of the given view identifier in the specified Amazon Connect instance.
 *
 * It performs content validation if `Status` is set to `SAVED` and performs full content
 * validation if `Status` is `PUBLISHED`. Note that the `$SAVED` alias' content will
 * always be updated, but the `$LATEST` alias' content will only be updated if `Status` is
 * `PUBLISHED`.
 */
export const updateViewContent: (
  input: UpdateViewContentRequest,
) => effect.Effect<
  UpdateViewContentResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateViewContentRequest,
  output: UpdateViewContentResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
/**
 * Deletes the view entirely. It deletes the view and all associated qualifiers (versions and aliases).
 */
export const deleteView: (
  input: DeleteViewRequest,
) => effect.Effect<
  DeleteViewResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteViewRequest,
  output: DeleteViewResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
/**
 * Deletes the particular version specified in `ViewVersion` identifier.
 */
export const deleteViewVersion: (
  input: DeleteViewVersionRequest,
) => effect.Effect<
  DeleteViewVersionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteViewVersionRequest,
  output: DeleteViewVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
/**
 * Updates the view metadata. Note that either `Name` or `Description` must be
 * provided.
 */
export const updateViewMetadata: (
  input: UpdateViewMetadataRequest,
) => effect.Effect<
  UpdateViewMetadataResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | TooManyRequestsException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateViewMetadataRequest,
  output: UpdateViewMetadataResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    TooManyRequestsException,
  ],
}));
/**
 * Adds an attribute to an existing data table. Creating a new primary attribute uses the empty value for the
 * specified value type for all existing records. This should not affect uniqueness of published data tables since the
 * existing primary values will already be unique. Creating attributes does not create any values. System managed tables
 * may not allow customers to create new attributes.
 */
export const createDataTableAttribute: (
  input: CreateDataTableAttributeRequest,
) => effect.Effect<
  CreateDataTableAttributeResponse,
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDataTableAttributeRequest,
  output: CreateDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a rule for the specified Amazon Connect instance.
 *
 * Use the Rules Function
 * language to code conditions for the rule.
 */
export const createRule: (
  input: CreateRuleRequest,
) => effect.Effect<
  CreateRuleResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRuleRequest,
  output: CreateRuleResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a security profile.
 *
 * For information about security profiles, see Security Profiles in the *Amazon Connect Administrator Guide*. For a mapping of the API name and user interface name of the security
 * profile permissions, see List
 * of security profile permissions.
 */
export const createSecurityProfile: (
  input: CreateSecurityProfileRequest,
) => effect.Effect<
  CreateSecurityProfileResponse,
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateSecurityProfileRequest,
  output: CreateSecurityProfileResponse,
  errors: [
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a workspace that defines the user experience by mapping views to pages. Workspaces can be assigned to
 * users or routing profiles.
 */
export const createWorkspace: (
  input: CreateWorkspaceRequest,
) => effect.Effect<
  CreateWorkspaceResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateWorkspaceRequest,
  output: CreateWorkspaceResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Describes the specified contact.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Retrieve contact information such as the caller's phone number and the specific number the caller dialed to
 * integrate into custom monitoring or custom agent experience solutions.
 *
 * - Detect when a customer chat session disconnects due to a network issue on the agent's end. Use the
 * DisconnectReason field in the ContactTraceRecord to detect
 * this event and then re-queue the chat for followup.
 *
 * - Identify after contact work (ACW) duration and call recordings information when a COMPLETED event is received
 * by using the contact event
 * stream.
 *
 * **Important things to know**
 *
 * - `SystemEndpoint` is not populated for contacts with initiation method of MONITOR, QUEUE_TRANSFER,
 * or CALLBACK
 *
 * - Contact information remains available in Amazon Connect for 24 months from the
 * `InitiationTimestamp`, and then it is deleted. Only contact information that is available in Amazon Connect is returned by this API.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const describeContact: (
  input: DescribeContactRequest,
) => effect.Effect<
  DescribeContactResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactRequest,
  output: DescribeContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Gets the real-time metric data from the specified Amazon Connect instance.
 *
 * For a description of each metric, see Metrics definitions in the *Amazon Connect Administrator Guide*.
 *
 * When you make a successful API request, you can expect the following metric values in the response:
 *
 * - **Metric value is null**: The calculation cannot be performed due to divide by
 * zero or insufficient data
 *
 * - **Metric value is a number (including 0) of defined type**: The number provided
 * is the calculation result
 *
 * - **MetricResult list is empty**: The request cannot find any data in the
 * system
 *
 * The following guidelines can help you work with the API:
 *
 * - Each dimension in the metric response must contain a value
 *
 * - Each item in MetricResult must include all requested metrics
 *
 * - If the response is slow due to large result sets, try these approaches:
 *
 * - Add filters to reduce the amount of data returned
 */
export const getCurrentMetricData: {
  (
    input: GetCurrentMetricDataRequest,
  ): effect.Effect<
    GetCurrentMetricDataResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: GetCurrentMetricDataRequest,
  ) => stream.Stream<
    GetCurrentMetricDataResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetCurrentMetricDataRequest,
  ) => stream.Stream<
    unknown,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetCurrentMetricDataRequest,
  output: GetCurrentMetricDataResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets historical metric data from the specified Amazon Connect instance.
 *
 * For a description of each historical metric, see Metrics definitions in the *Amazon Connect Administrator Guide*.
 *
 * We recommend using the GetMetricDataV2 API. It provides more flexibility, features, and the ability to query longer time ranges
 * than `GetMetricData`. Use it to retrieve historical agent and contact metrics for the last 3 months, at
 * varying intervals. You can also use it to build custom dashboards to measure historical queue and agent performance.
 * For example, you can track the number of incoming contacts for the last 7 days, with data split by day, to see how
 * contact volume changed per day of the week.
 */
export const getMetricData: {
  (
    input: GetMetricDataRequest,
  ): effect.Effect<
    GetMetricDataResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: GetMetricDataRequest,
  ) => stream.Stream<
    GetMetricDataResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetMetricDataRequest,
  ) => stream.Stream<
    unknown,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetMetricDataRequest,
  output: GetMetricDataResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Gets metric data from the specified Amazon Connect instance.
 *
 * `GetMetricDataV2` offers more features than GetMetricData, the previous version of this API. It
 * has new metrics, offers filtering at a metric level, and offers the ability to filter and group data by channels,
 * queues, routing profiles, agents, and agent hierarchy levels. It can retrieve historical data for the last 3 months,
 * at varying intervals. It does not support agent queues.
 *
 * For a description of the historical metrics that are supported by `GetMetricDataV2` and
 * `GetMetricData`, see Metrics definitions in the *Amazon Connect Administrator Guide*.
 *
 * When you make a successful API request, you can expect the following metric values in the response:
 *
 * - **Metric value is null**: The calculation cannot be performed due to divide by
 * zero or insufficient data
 *
 * - **Metric value is a number (including 0) of defined type**: The number provided
 * is the calculation result
 *
 * - **MetricResult list is empty**: The request cannot find any data in the
 * system
 *
 * The following guidelines can help you work with the API:
 *
 * - Each dimension in the metric response must contain a value
 *
 * - Each item in MetricResult must include all requested metrics
 *
 * - If the response is slow due to large result sets, try these approaches:
 *
 * - Narrow the time range of your request
 *
 * - Add filters to reduce the amount of data returned
 */
export const getMetricDataV2: {
  (
    input: GetMetricDataV2Request,
  ): effect.Effect<
    GetMetricDataV2Response,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: GetMetricDataV2Request,
  ) => stream.Stream<
    GetMetricDataV2Response,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetMetricDataV2Request,
  ) => stream.Stream<
    unknown,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetMetricDataV2Request,
  output: GetMetricDataV2Response,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches contact evaluations in an Amazon Connect instance, with optional filtering.
 *
 * **Use cases**
 *
 * Following are common uses cases for this API:
 *
 * - Find contact evaluations by using specific search criteria.
 *
 * - Find contact evaluations that are tagged with a specific set of tags.
 *
 * **Important things to know**
 *
 * - A Search operation, unlike a List operation, takes time to index changes to resource (create, update or
 * delete). If you don't see updated information for recently changed contact evaluations, try calling the API again
 * in a few seconds. Contact Evaluations may not be fully backfilled with historical data in all regions yet, however
 * all recently created Contact Evaluations should be available for search.
 *
 * **Endpoints**: See Amazon Connect endpoints and quotas.
 */
export const searchContactEvaluations: (
  input: SearchContactEvaluationsRequest,
) => effect.Effect<
  SearchContactEvaluationsResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SearchContactEvaluationsRequest,
  output: SearchContactEvaluationsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Searches tags used in an Amazon Connect instance using optional search criteria.
 */
export const searchResourceTags: {
  (
    input: SearchResourceTagsRequest,
  ): effect.Effect<
    SearchResourceTagsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | MaximumResultReturnedException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchResourceTagsRequest,
  ) => stream.Stream<
    SearchResourceTagsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | MaximumResultReturnedException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchResourceTagsRequest,
  ) => stream.Stream<
    TagSet,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | MaximumResultReturnedException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchResourceTagsRequest,
  output: SearchResourceTagsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    MaximumResultReturnedException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Tags",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Starts an empty evaluation in the specified Amazon Connect instance, using the given evaluation form for the
 * particular contact. The evaluation form version used for the contact evaluation corresponds to the currently
 * activated version. If no version is activated for the evaluation form, the contact evaluation cannot be started.
 *
 * Evaluations created through the public API do not contain answer values suggested from automation.
 */
export const startContactEvaluation: (
  input: StartContactEvaluationRequest,
) => effect.Effect<
  StartContactEvaluationResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactEvaluationRequest,
  output: StartContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Initiates an Amazon Connect instance with all the supported channels enabled. It does not attach any
 * storage, such as Amazon Simple Storage Service (Amazon S3) or Amazon Kinesis. It also does not allow for any
 * configurations on features, such as Contact Lens for Amazon Connect.
 *
 * For more information, see Create an Amazon Connect instance in the
 * *Amazon Connect Administrator Guide*.
 *
 * Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
 * If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
 * You must wait 30 days before you can restart creating and deleting instances in your account.
 */
export const createInstance: (
  input: CreateInstanceRequest,
) => effect.Effect<
  CreateInstanceResponse,
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateInstanceRequest,
  output: CreateInstanceResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a custom vocabulary associated with your Amazon Connect instance. You can set a custom vocabulary to
 * be your default vocabulary for a given language. Contact Lens for Amazon Connect uses the default vocabulary in post-call and real-time
 * contact analysis sessions for that language.
 */
export const createVocabulary: (
  input: CreateVocabularyRequest,
) => effect.Effect<
  CreateVocabularyResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVocabularyRequest,
  output: CreateVocabularyResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Associates an approved origin to an Amazon Connect instance.
 */
export const associateApprovedOrigin: (
  input: AssociateApprovedOriginRequest,
) => effect.Effect<
  AssociateApprovedOriginResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateApprovedOriginRequest,
  output: AssociateApprovedOriginResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a new data table with the specified properties. Supports the creation of all table properties except for
 * attributes and values. A table with no attributes and values is a valid state for a table. The number of tables per
 * instance is limited to 100 per instance. Customers can request an increase by using Amazon Web Services Service Quotas.
 */
export const createDataTable: (
  input: CreateDataTableRequest,
) => effect.Effect<
  CreateDataTableResponse,
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDataTableRequest,
  output: CreateDataTableResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Send outbound email for outbound campaigns. For more information about outbound campaigns, see Set up Amazon Connect
 * outbound campaigns.
 *
 * Only the Amazon Connect outbound campaigns service principal is allowed to assume a role in your account
 * and call this API.
 */
export const sendOutboundEmail: (
  input: SendOutboundEmailRequest,
) => effect.Effect<
  SendOutboundEmailResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: SendOutboundEmailRequest,
  output: SendOutboundEmailResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Associates a security key to the instance.
 */
export const associateSecurityKey: (
  input: AssociateSecurityKeyRequest,
) => effect.Effect<
  AssociateSecurityKeyResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateSecurityKeyRequest,
  output: AssociateSecurityKeyResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Initiates a flow to start a new task contact. For more information about task contacts, see Concepts: Tasks in Amazon Connect in the
 * *Amazon Connect Administrator Guide*.
 *
 * When using `PreviousContactId` and `RelatedContactId` input parameters, note the
 * following:
 *
 * - `PreviousContactId`
 *
 * - Any updates to user-defined task contact attributes on any contact linked through the same
 * `PreviousContactId` will affect every contact in the chain.
 *
 * - There can be a maximum of 12 linked task contacts in a chain. That is, 12 task contacts can be created that
 * share the same `PreviousContactId`.
 *
 * - `RelatedContactId`
 *
 * - Copies contact attributes from the related task contact to the new contact.
 *
 * - Any update on attributes in a new task contact does not update attributes on previous contact.
 *
 * - Theres no limit on the number of task contacts that can be created that use the same
 * `RelatedContactId`.
 *
 * In addition, when calling StartTaskContact include only one of these parameters: `ContactFlowID`,
 * `QuickConnectID`, or `TaskTemplateID`. Only one parameter is required as long as the task
 * template has a flow configured to run it. If more than one parameter is specified, or only the
 * `TaskTemplateID` is specified but it does not have a flow configured, the request returns an error
 * because Amazon Connect cannot identify the unique flow to run when the task is created.
 *
 * A `ServiceQuotaExceededException` occurs when the number of open tasks exceeds the active tasks quota
 * or there are already 12 tasks referencing the same `PreviousContactId`. For more information about service
 * quotas for task contacts, see Amazon Connect service quotas in the
 * *Amazon Connect Administrator Guide*.
 */
export const startTaskContact: (
  input: StartTaskContactRequest,
) => effect.Effect<
  StartTaskContactResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartTaskContactRequest,
  output: StartTaskContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Allows the specified Amazon Connect instance to access the specified Lambda function.
 */
export const associateLambdaFunction: (
  input: AssociateLambdaFunctionRequest,
) => effect.Effect<
  AssociateLambdaFunctionResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateLambdaFunctionRequest,
  output: AssociateLambdaFunctionResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Allows the specified Amazon Connect instance to access the specified Amazon Lex V1 bot. This API
 * only supports the association of Amazon Lex V1 bots.
 */
export const associateLexBot: (
  input: AssociateLexBotRequest,
) => effect.Effect<
  AssociateLexBotResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateLexBotRequest,
  output: AssociateLexBotResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Initiates silent monitoring of a contact. The Contact Control Panel (CCP) of the user specified by
 * *userId* will be set to silent monitoring mode on the contact.
 */
export const monitorContact: (
  input: MonitorContactRequest,
) => effect.Effect<
  MonitorContactResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: MonitorContactRequest,
  output: MonitorContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Initiates a flow to send an agent reply or outbound email contact (created from the CreateContact API) to a
 * customer.
 */
export const startOutboundEmailContact: (
  input: StartOutboundEmailContactRequest,
) => effect.Effect<
  StartOutboundEmailContactResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartOutboundEmailContactRequest,
  output: StartOutboundEmailContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Transfers `TASK` or `EMAIL`
 * contacts from one agent or queue to another agent or queue at any point after a contact is
 * created. You can transfer a contact to another queue by providing the flow which orchestrates the contact to the
 * destination queue. This gives you more control over contact handling and helps you adhere to the service level
 * agreement (SLA) guaranteed to your customers.
 *
 * Note the following requirements:
 *
 * - Transfer is only supported for `TASK` and `EMAIL` contacts.
 *
 * - Do not use both `QueueId` and `UserId` in the same call.
 *
 * - The following flow types are supported: Inbound flow, Transfer to agent flow, and Transfer to queue
 * flow.
 *
 * - The `TransferContact` API can be called only on active contacts.
 *
 * - A contact cannot be transferred more than 11 times.
 */
export const transferContact: (
  input: TransferContactRequest,
) => effect.Effect<
  TransferContactResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TransferContactRequest,
  output: TransferContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Create new email address in the specified Amazon Connect instance. For more information about email
 * addresses, see Create email
 * addresses in the Amazon Connect Administrator Guide.
 */
export const createEmailAddress: (
  input: CreateEmailAddressRequest,
) => effect.Effect<
  CreateEmailAddressResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEmailAddressRequest,
  output: CreateEmailAddressResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates registration for a device token and a chat contact to receive real-time push notifications. For more
 * information about push notifications, see Set up push notifications in Amazon Connect for mobile chat in the *Amazon Connect Administrator Guide*.
 */
export const createPushNotificationRegistration: (
  input: CreatePushNotificationRegistrationRequest,
) => effect.Effect<
  CreatePushNotificationRegistrationResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreatePushNotificationRegistrationRequest,
  output: CreatePushNotificationRegistrationResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates values for attributes in a data table. The value may be a default or it may be associated with a primary
 * value. The value must pass all customer defined validation as well as the default validation for the value type. The
 * operation must conform to Batch Operation API Standards. Although the standard specifies that successful and failed
 * entities are listed separately in the response, authorization fails if any primary values or attributes are
 * unauthorized. The combination of primary values and the attribute name serve as the identifier for the individual
 * item request.
 */
export const batchCreateDataTableValue: (
  input: BatchCreateDataTableValueRequest,
) => effect.Effect<
  BatchCreateDataTableValueResponse,
  | AccessDeniedException
  | ConflictException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchCreateDataTableValueRequest,
  output: BatchCreateDataTableValueResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Updates details about a specific evaluation form version in the specified Amazon Connect instance. Question
 * and section identifiers cannot be duplicated within the same evaluation form.
 *
 * This operation does not support partial updates. Instead it does a full update of evaluation form
 * content.
 */
export const updateEvaluationForm: (
  input: UpdateEvaluationFormRequest,
) => effect.Effect<
  UpdateEvaluationFormResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateEvaluationFormRequest,
  output: UpdateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Publishes a new version of the view identifier.
 *
 * Versions are immutable and monotonically increasing.
 *
 * It returns the highest version if there is no change in content compared to that version. An error is displayed
 * if the supplied ViewContentSha256 is different from the ViewContentSha256 of the `$LATEST` alias.
 */
export const createViewVersion: (
  input: CreateViewVersionRequest,
) => effect.Effect<
  CreateViewVersionResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | TooManyRequestsException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateViewVersionRequest,
  output: CreateViewVersionResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    TooManyRequestsException,
  ],
}));
/**
 * Creates a new view with the possible status of `SAVED` or `PUBLISHED`.
 *
 * The views will have a unique name for each connect instance.
 *
 * It performs basic content validation if the status is `SAVED` or full content validation if the
 * status is set to `PUBLISHED`. An error is returned if validation fails. It associates either the
 * `$SAVED` qualifier or both of the `$SAVED` and `$LATEST` qualifiers with the
 * provided view content based on the status. The view is idempotent if ClientToken is provided.
 */
export const createView: (
  input: CreateViewRequest,
) => effect.Effect<
  CreateViewResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceInUseException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | TooManyRequestsException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateViewRequest,
  output: CreateViewResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceInUseException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    TooManyRequestsException,
  ],
}));
/**
 * This API is in preview release for Amazon Connect and is subject to change.
 *
 * Allows the specified Amazon Connect instance to access the specified Amazon Lex or Amazon Lex V2
 * bot.
 */
export const associateBot: (
  input: AssociateBotRequest,
) => effect.Effect<
  AssociateBotResponse,
  | InternalServiceException
  | InvalidRequestException
  | LimitExceededException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: AssociateBotRequest,
  output: AssociateBotResponse,
  errors: [
    InternalServiceException,
    InvalidRequestException,
    LimitExceededException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Only the VOICE, EMAIL, and TASK channels are supported.
 *
 * - For VOICE: The supported initiation method is `TRANSFER`. The contacts created with this
 * initiation method have a subtype `connect:ExternalAudio`.
 *
 * - For EMAIL: The supported initiation methods are `OUTBOUND`, `AGENT_REPLY`, and
 * `FLOW`.
 *
 * - For TASK: The supported initiation method is `API`. Contacts created with this API have a sub-type
 * of `connect:ExternalTask`.
 *
 * Creates a new VOICE, EMAIL, or TASK contact.
 *
 * After a contact is created, you can move it to the desired state by using the `InitiateAs` parameter.
 * While you can use API to create task contacts that are in the `COMPLETED` state, you must contact Amazon Web Services Support before using it for bulk import use cases. Bulk import causes your requests to be throttled or
 * fail if your CreateContact limits aren't high enough.
 */
export const createContact: (
  input: CreateContactRequest,
) => effect.Effect<
  CreateContactResponse,
  | AccessDeniedException
  | ConflictException
  | IdempotencyException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateContactRequest,
  output: CreateContactResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    IdempotencyException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Adds a new participant into an on-going chat contact or webRTC call. For more information, see Customize chat flow experiences by
 * integrating custom participants or Enable multi-user web, in-app, and video
 * calling.
 */
export const createParticipant: (
  input: CreateParticipantRequest,
) => effect.Effect<
  CreateParticipantResponse,
  | ConflictException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateParticipantRequest,
  output: CreateParticipantResponse,
  errors: [
    ConflictException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Provides a pre-signed Amazon S3 URL in response for uploading your content.
 *
 * You may only use this API to upload attachments to an Amazon Connect Case or Amazon Connect Email.
 */
export const startAttachedFileUpload: (
  input: StartAttachedFileUploadRequest,
) => effect.Effect<
  StartAttachedFileUploadResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartAttachedFileUploadRequest,
  output: StartAttachedFileUploadResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates an inbound email contact and initiates a flow to start the email contact for the customer. Response of
 * this API provides the ContactId of the email contact created.
 */
export const startEmailContact: (
  input: StartEmailContactRequest,
) => effect.Effect<
  StartEmailContactResponse,
  | AccessDeniedException
  | IdempotencyException
  | InternalServiceException
  | InvalidRequestException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartEmailContactRequest,
  output: StartEmailContactResponse,
  errors: [
    AccessDeniedException,
    IdempotencyException,
    InternalServiceException,
    InvalidRequestException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Updates details about a specific task template in the specified Amazon Connect instance. This operation does
 * not support partial updates. Instead it does a full update of template content.
 */
export const updateTaskTemplate: (
  input: UpdateTaskTemplateRequest,
) => effect.Effect<
  UpdateTaskTemplateResponse,
  | InternalServiceException
  | InvalidParameterException
  | PropertyValidationException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTaskTemplateRequest,
  output: UpdateTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    PropertyValidationException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a traffic distribution group given an Amazon Connect instance that has been replicated.
 *
 * The `SignInConfig` distribution is available only on a
 * default `TrafficDistributionGroup` (see the `IsDefault` parameter in the
 * TrafficDistributionGroup
 * data type). If you call
 * `UpdateTrafficDistribution` with a modified `SignInConfig` and a non-default `TrafficDistributionGroup`,
 * an `InvalidRequestException` is returned.
 *
 * For more information about creating traffic distribution groups, see Set up traffic distribution groups in the
 * *Amazon Connect Administrator Guide*.
 */
export const createTrafficDistributionGroup: (
  input: CreateTrafficDistributionGroupRequest,
) => effect.Effect<
  CreateTrafficDistributionGroupResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ResourceNotReadyException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTrafficDistributionGroupRequest,
  output: CreateTrafficDistributionGroupResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ResourceNotReadyException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Associates a view with a page in a workspace, defining what users see when they navigate to that page.
 */
export const createWorkspacePage: (
  input: CreateWorkspacePageRequest,
) => effect.Effect<
  CreateWorkspacePageResponse,
  | AccessDeniedException
  | DuplicateResourceException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateWorkspacePageRequest,
  output: CreateWorkspacePageResponse,
  errors: [
    AccessDeniedException,
    DuplicateResourceException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Enables in-flight message processing for an ongoing chat session. Message processing will stay active for the
 * rest of the chat, even if an individual contact segment ends.
 */
export const startContactMediaProcessing: (
  input: StartContactMediaProcessingRequest,
) => effect.Effect<
  StartContactMediaProcessingResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartContactMediaProcessingRequest,
  output: StartContactMediaProcessingResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
  ],
}));
/**
 * Updates all properties for an attribute using all properties from CreateDataTableAttribute. There are no other
 * granular update endpoints. It does not act as a patch operation - all properties must be provided. System managed
 * attributes are not mutable by customers. Changing an attribute's validation does not invalidate existing values since
 * validation only runs when values are created or updated.
 */
export const updateDataTableAttribute: (
  input: UpdateDataTableAttributeRequest,
) => effect.Effect<
  UpdateDataTableAttributeResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataTableAttributeRequest,
  output: UpdateDataTableAttributeResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a new task template in the specified Amazon Connect instance.
 */
export const createTaskTemplate: (
  input: CreateTaskTemplateRequest,
) => effect.Effect<
  CreateTaskTemplateResponse,
  | InternalServiceException
  | InvalidParameterException
  | PropertyValidationException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTaskTemplateRequest,
  output: CreateTaskTemplateResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    PropertyValidationException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Replicates an Amazon Connect instance in the specified Amazon Web Services Region and copies configuration
 * information for Amazon Connect resources across Amazon Web Services Regions.
 *
 * For more information about replicating an Amazon Connect instance, see Create a replica of your existing Amazon Connect
 * instance in the *Amazon Connect Administrator Guide*.
 */
export const replicateInstance: (
  input: ReplicateInstanceRequest,
) => effect.Effect<
  ReplicateInstanceResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidRequestException
  | ResourceConflictException
  | ResourceNotFoundException
  | ResourceNotReadyException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ReplicateInstanceRequest,
  output: ReplicateInstanceResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    ResourceConflictException,
    ResourceNotFoundException,
    ResourceNotReadyException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Gets the real-time active user data from the specified Amazon Connect instance.
 */
export const getCurrentUserData: {
  (
    input: GetCurrentUserDataRequest,
  ): effect.Effect<
    GetCurrentUserDataResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: GetCurrentUserDataRequest,
  ) => stream.Stream<
    GetCurrentUserDataResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: GetCurrentUserDataRequest,
  ) => stream.Stream<
    unknown,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: GetCurrentUserDataRequest,
  output: GetCurrentUserDataResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches users in an Amazon Connect instance, with optional filtering.
 *
 * `AfterContactWorkTimeLimit` is returned in milliseconds.
 */
export const searchUsers: {
  (
    input: SearchUsersRequest,
  ): effect.Effect<
    SearchUsersResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchUsersRequest,
  ) => stream.Stream<
    SearchUsersResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchUsersRequest,
  ) => stream.Stream<
    UserSearchSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchUsersRequest,
  output: SearchUsersResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Users",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Places an inbound in-app, web, or video call to a contact, and then initiates the flow. It performs the actions
 * in the flow that are specified (in ContactFlowId) and present in the Amazon Connect instance (specified as
 * InstanceId).
 */
export const startWebRTCContact: (
  input: StartWebRTCContactRequest,
) => effect.Effect<
  StartWebRTCContactResponse,
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartWebRTCContactRequest,
  output: StartWebRTCContactResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
  ],
}));
/**
 * Updates routing priority and age on the contact (**QueuePriority** and **QueueTimeAdjustmentInSeconds**). These properties can be used to change a customer's position
 * in the queue. For example, you can move a contact to the back of the queue by setting a lower routing priority
 * relative to other contacts in queue; or you can move a contact to the front of the queue by increasing the routing
 * age which will make the contact look artificially older and therefore higher up in the first-in-first-out routing
 * order. Note that adjusting the routing age of a contact affects only its position in queue, and not its actual queue
 * wait time as reported through metrics. These properties can also be updated by using the Set routing priority / age flow
 * block.
 *
 * Either **QueuePriority** or **QueueTimeAdjustmentInSeconds** should be provided within the request body, but not both.
 */
export const updateContactRoutingData: (
  input: UpdateContactRoutingDataRequest,
) => effect.Effect<
  UpdateContactRoutingDataResponse,
  | AccessDeniedException
  | InternalServiceException
  | InvalidActiveRegionException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateContactRoutingDataRequest,
  output: UpdateContactRoutingDataResponse,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidActiveRegionException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates an evaluation form in the specified Amazon Connect instance. The form can be used to define
 * questions related to agent performance, and create sections to organize such questions. Question and section
 * identifiers cannot be duplicated within the same evaluation form.
 */
export const createEvaluationForm: (
  input: CreateEvaluationFormRequest,
) => effect.Effect<
  CreateEvaluationFormResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceConflictException
  | ResourceNotFoundException
  | ServiceQuotaExceededException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateEvaluationFormRequest,
  output: CreateEvaluationFormResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceConflictException,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ThrottlingException,
  ],
}));
/**
 * Provides a list of analysis segments for a real-time chat analysis session. This API supports CHAT channels
 * only.
 *
 * This API does not support VOICE. If you attempt to use it for VOICE, an `InvalidRequestException`
 * occurs.
 */
export const listRealtimeContactAnalysisSegmentsV2: {
  (
    input: ListRealtimeContactAnalysisSegmentsV2Request,
  ): effect.Effect<
    ListRealtimeContactAnalysisSegmentsV2Response,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | OutputTypeNotFoundException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListRealtimeContactAnalysisSegmentsV2Request,
  ) => stream.Stream<
    ListRealtimeContactAnalysisSegmentsV2Response,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | OutputTypeNotFoundException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRealtimeContactAnalysisSegmentsV2Request,
  ) => stream.Stream<
    unknown,
    | AccessDeniedException
    | InternalServiceException
    | InvalidRequestException
    | OutputTypeNotFoundException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRealtimeContactAnalysisSegmentsV2Request,
  output: ListRealtimeContactAnalysisSegmentsV2Response,
  errors: [
    AccessDeniedException,
    InternalServiceException,
    InvalidRequestException,
    OutputTypeNotFoundException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches contacts in an Amazon Connect instance.
 */
export const searchContacts: {
  (
    input: SearchContactsRequest,
  ): effect.Effect<
    SearchContactsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchContactsRequest,
  ) => stream.Stream<
    SearchContactsResponse,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchContactsRequest,
  ) => stream.Stream<
    ContactSearchSummary,
    | InternalServiceException
    | InvalidParameterException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Creds | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchContactsRequest,
  output: SearchContactsResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Contacts",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Places an outbound call to a contact, and then initiates the flow. It performs the actions in the flow that's
 * specified (in `ContactFlowId`).
 *
 * Agents do not initiate the outbound API, which means that they do not dial the contact. If the flow places an
 * outbound call to a contact, and then puts the contact in queue, the call is then routed to the agent, like any other
 * inbound case.
 *
 * Dialing timeout for this operation can be configured with the RingTimeoutInSeconds parameter. If not
 * specified, the default dialing timeout will be 60 seconds which means if the call is not connected within 60 seconds,
 * it fails.
 *
 * UK numbers with a 447 prefix are not allowed by default. Before you can dial these UK mobile numbers, you must
 * submit a service quota increase request. For more information, see Amazon Connect Service Quotas in the
 * *Amazon Connect Administrator Guide*.
 *
 * Campaign calls are not allowed by default. Before you can make a call with `TrafficType` =
 * `CAMPAIGN`, you must submit a service quota increase request to the quota Amazon Connect campaigns.
 *
 * For Preview dialing mode, only the Amazon Connect outbound campaigns service principal is allowed to assume a
 * role in your account and call this API with OutboundStrategy.
 */
export const startOutboundVoiceContact: (
  input: StartOutboundVoiceContactRequest,
) => effect.Effect<
  StartOutboundVoiceContactResponse,
  | DestinationNotAllowedException
  | InternalServiceException
  | InvalidParameterException
  | InvalidRequestException
  | LimitExceededException
  | OutboundContactNotPermittedException
  | ResourceNotFoundException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartOutboundVoiceContactRequest,
  output: StartOutboundVoiceContactResponse,
  errors: [
    DestinationNotAllowedException,
    InternalServiceException,
    InvalidParameterException,
    InvalidRequestException,
    LimitExceededException,
    OutboundContactNotPermittedException,
    ResourceNotFoundException,
  ],
}));
/**
 * Describes a contact evaluation in the specified Amazon Connect instance.
 */
export const describeContactEvaluation: (
  input: DescribeContactEvaluationRequest,
) => effect.Effect<
  DescribeContactEvaluationResponse,
  | InternalServiceException
  | InvalidParameterException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Creds | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeContactEvaluationRequest,
  output: DescribeContactEvaluationResponse,
  errors: [
    InternalServiceException,
    InvalidParameterException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
