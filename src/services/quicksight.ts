import { HttpClient } from "@effect/platform";
import * as effect from "effect/Effect";
import * as redacted from "effect/Redacted";
import * as S from "effect/Schema";
import * as stream from "effect/Stream";
import * as API from "../client/api.ts";
import * as T from "../traits.ts";
import * as C from "../category.ts";
import type { Credentials } from "../credentials.ts";
import type { CommonErrors } from "../errors.ts";
import type { Region } from "../region.ts";
import { SensitiveString, SensitiveBlob } from "../sensitive.ts";
const svc = T.AwsApiService({
  sdkId: "QuickSight",
  serviceShapeName: "QuickSight_20180401",
});
const auth = T.AwsAuthSigv4({ name: "quicksight" });
const ver = T.ServiceVersion("2018-04-01");
const proto = T.AwsProtocolsRestJson1();
const rules = T.EndpointResolver((p, _) => {
  const { Region, UseDualStack = false, UseFIPS = false, Endpoint } = p;
  const e = (u: unknown, p = {}, h = {}): T.EndpointResolverResult => ({
    type: "endpoint" as const,
    endpoint: { url: u as string, properties: p, headers: h },
  });
  const err = (m: unknown): T.EndpointResolverResult => ({
    type: "error" as const,
    message: m as string,
  });
  if (Endpoint != null) {
    if (UseFIPS === true) {
      return err(
        "Invalid Configuration: FIPS and custom endpoint are not supported",
      );
    }
    if (UseDualStack === true) {
      return err(
        "Invalid Configuration: Dualstack and custom endpoint are not supported",
      );
    }
    return e(Endpoint);
  }
  if (Region != null) {
    {
      const PartitionResult = _.partition(Region);
      if (PartitionResult != null && PartitionResult !== false) {
        if (UseFIPS === true && UseDualStack === true) {
          if (
            true === _.getAttr(PartitionResult, "supportsFIPS") &&
            true === _.getAttr(PartitionResult, "supportsDualStack")
          ) {
            return e(
              `https://quicksight-fips.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "FIPS and DualStack are enabled, but this partition does not support one or both",
          );
        }
        if (UseFIPS === true) {
          if (_.getAttr(PartitionResult, "supportsFIPS") === true) {
            return e(
              `https://quicksight-fips.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
            );
          }
          return err(
            "FIPS is enabled but this partition does not support FIPS",
          );
        }
        if (UseDualStack === true) {
          if (true === _.getAttr(PartitionResult, "supportsDualStack")) {
            return e(
              `https://quicksight.${Region}.${_.getAttr(PartitionResult, "dualStackDnsSuffix")}`,
            );
          }
          return err(
            "DualStack is enabled but this partition does not support DualStack",
          );
        }
        return e(
          `https://quicksight.${Region}.${_.getAttr(PartitionResult, "dnsSuffix")}`,
        );
      }
    }
  }
  return err("Invalid Configuration: Missing Region");
});

//# Newtypes
export type AwsAccountId = string;
export type TopicId = string;
export type AnswerId = string;
export type IngestionId = string;
export type Namespace = string;
export type AccountName = string;
export type ShortRestrictiveResourceId = string;
export type ActionConnectorName = string | redacted.Redacted<string>;
export type ActionConnectorDescription = string | redacted.Redacted<string>;
export type Arn = string;
export type AnalysisName = string;
export type CustomPermissionsName = string;
export type DashboardName = string;
export type VersionDescription = string;
export type LinkEntityArn = string;
export type ResourceId = string;
export type ResourceName = string;
export type RestrictiveResourceId = string;
export type FolderName = string;
export type GroupName = string;
export type GroupDescription = string;
export type GroupMemberName = string;
export type IAMPolicyAssignmentName = string;
export type TemplateName = string;
export type AliasName = string;
export type VersionNumber = number;
export type ThemeName = string;
export type VPCConnectionResourceIdRestricted = string;
export type SubnetId = string;
export type SecurityGroupId = string;
export type IPv4Address = string;
export type RoleArn = string;
export type RecoveryWindowInDays = number;
export type UserName = string;
export type VPCConnectionResourceIdUnrestricted = string;
export type MaxResults = number;
export type AwsAndAccountId = string;
export type SessionLifetimeInMinutes = number;
export type AccountId = string;
export type FlowId = string;
export type EntryPoint = string;
export type FlowMaxResults = number;
export type ListIdentityPropagationMaxResults = number;
export type IngestionMaxResults = number;
export type QAQueryText = string | redacted.Redacted<string>;
export type MaxTopicsToConsider = number;
export type RoleSessionName = string;
export type RoleName = string;
export type SearchActionConnectorsRequestMaxResultsInteger = number;
export type TagKey = string;
export type LimitedString = string;
export type TagValue = string;
export type Principal = string;
export type Name = string;
export type Description = string;
export type PhysicalTableId = string;
export type LogicalTableId = string;
export type FieldFolderPath = string;
export type SessionTagKey = string;
export type CopySourceArn = string;
export type SecretArn = string;
export type IdentityName = string;
export type CustomInstructionsString = string | redacted.Redacted<string>;
export type SessionTagValue = string | redacted.Redacted<string>;
export type SensitiveString = string | redacted.Redacted<string>;
export type AssetBundleImportBodyBlob =
  | Uint8Array
  | redacted.Redacted<Uint8Array>;
export type S3Uri = string;
export type ActionsListMemberString = string;
export type PermissionPrincipalString = string;
export type CIDR = string;
export type IpRestrictionRuleDescription = string;
export type VpcId = string;
export type VpcIdRestrictionRuleDescription = string;
export type VpcEndpointId = string;
export type VpcEndpointIdRestrictionRuleDescription = string;
export type StatusCode = number;
export type SensitiveS3Uri = string | redacted.Redacted<string>;
export type NonEmptyString = string;
export type EmbeddingUrl = string | redacted.Redacted<string>;
export type Title = string;
export type FlowDescription = string;
export type SensitiveLong = number;
export type SensitiveDouble = number;
export type SensitiveTimestamp = Date;
export type DataSetIdentifier = string;
export type SheetTitle = string;
export type SheetDescription = string;
export type SheetName = string;
export type ColumnName = string;
export type CalculatedFieldExpression = string | redacted.Redacted<string>;
export type LogicalTableAlias = string;
export type ColumnGroupName = string;
export type FieldFolderDescription = string;
export type RowLevelPermissionTagDelimiter = string;
export type DatasetParameterId = string;
export type DatasetParameterName = string;
export type DataSetEntityResourceId = string;
export type Domain = string;
export type WorkGroup = string;
export type Host = string;
export type Port = number;
export type Database = string;
export type DataSetName = string;
export type SiteBaseUrl = string;
export type Catalog = string;
export type InstanceId = string;
export type OptionalPort = number;
export type ClusterId = string;
export type S3Bucket = string;
export type MetadataFilesLocation = string;
export type Warehouse = string;
export type DatabaseAccessControlRole = string;
export type Query = string;
export type PositiveInteger = number;
export type SqlEndpointPath = string;
export type ProjectId = string;
export type DataSetRegion = string;
export type XpathFields = string;
export type ApplicationArn = string;
export type DbUsername = string;
export type Password = string;
export type PrivateKey = string | redacted.Redacted<string>;
export type PrivateKeyPassphrase = string | redacted.Redacted<string>;
export type HexColor = string;
export type EntryPath = string;
export type AssetBundleRestrictiveResourceId = string;
export type ActionId = string;
export type ErrorMessage = string;
export type Expression = string | redacted.Redacted<string>;
export type Endpoint = string;
export type ActionUserName = string | redacted.Redacted<string>;
export type ActionPassword = string | redacted.Redacted<string>;
export type APIKey = string | redacted.Redacted<string>;
export type Email = string | redacted.Redacted<string>;
export type SheetTextBoxContent = string;
export type LongPlainText = string;
export type ParameterName = string;
export type RelationalTableCatalog = string;
export type RelationalTableSchema = string;
export type RelationalTableName = string;
export type CustomSqlName = string;
export type SqlQuery = string | redacted.Redacted<string>;
export type StringDatasetParameterDefaultValue = string;
export type DecimalDatasetParameterDefaultValue = number;
export type IntegerDatasetParameterDefaultValue = number;
export type DateTimeDatasetParameterDefaultValue = Date;
export type DestinationTableAlias = string;
export type SemanticTableAlias = string;
export type DatabaseUser = string;
export type DatabaseGroup = string;
export type S3Key = string;
export type TokenProviderUrl = string;
export type OAuthScope = string;
export type IdentityProviderResourceUri = string;
export type DayOfMonth = string;
export type Color = string;
export type BorderRadius = string;
export type Padding = string;
export type StatusCode2 = number;
export type AltText = string;
export type ColumnId = string;
export type ColumnDescriptiveText = string | redacted.Redacted<string>;
export type NetworkInterfaceId = string;
export type VisualTitle = string;
export type VisualSubtitle = string;
export type QAUrl = string;
export type QuestionId = string;
export type ConstantValueString = string;
export type AggFunctionParamKey = string;
export type AggFunctionParamValue = string;
export type SheetControlTitle = string;
export type TextAreaControlDelimiter = string;
export type ImageCustomActionName = string;
export type SensitiveStringObject = string | redacted.Redacted<string>;
export type SensitiveDoubleObject = number;
export type SensitiveLongObject = number;
export type DateTimeFormat = string;
export type FieldValue = string | redacted.Redacted<string>;
export type ElementValue = string;
export type HexColorWithTransparency = string;
export type Delimiter = string;
export type TablePathElementName = string;
export type TablePathElementId = string;
export type TransformOperationAlias = string;
export type TypeCastFormat = string;
export type OnClause = string;
export type JoinOperationOnClause = string | redacted.Redacted<string>;
export type Width = string;
export type PixelLength = string;
export type PositiveLong = number;
export type ClientId = string;
export type ClientSecret = string | redacted.Redacted<string>;
export type VisualCustomActionName = string;
export type URLOperationTemplate = string;
export type RadarChartStartAngle = number;
export type NullString = string | redacted.Redacted<string>;
export type DataSetCalculatedFieldExpression =
  | string
  | redacted.Redacted<string>;
export type CellValue = string;
export type ResourceArn = string;
export type SheetControlInfoIconText = string;
export type ShortPlainText = string;
export type ShortRichText = string;
export type LongRichText = string;
export type FieldId = string;
export type VisiblePanelRows = number;
export type VisiblePanelColumns = number;
export type HierarchyId = string;
export type GeocoderHierarchyCountryString = string;
export type GeocoderHierarchyStateString = string;
export type GeocoderHierarchyCountyString = string;
export type GeocoderHierarchyCityString = string;
export type GeocoderHierarchyPostCodeString = string;
export type WordCloudMaximumStringLength = number;
export type NarrativeString = string;
export type GridLayoutElementColumnIndex = number;
export type GridLayoutElementColumnSpan = number;
export type GridLayoutElementRowIndex = number;
export type GridLayoutElementRowSpan = number;
export type UnlimitedPixelLength = string;
export type CategoryValue = string;
export type Prefix = string | redacted.Redacted<string>;
export type Suffix = string | redacted.Redacted<string>;
export type CurrencyCode = string;
export type PageNumber = number;
export type TableFieldHeight = number;
export type CustomLabel = string;
export type TransposedColumnIndex = number;
export type PivotTableRowsLabelText = string;
export type PeriodsForward = number;
export type PeriodsBackward = number;
export type PredictionInterval = number;
export type Seasonality = number;
export type Latitude = number;
export type Longitude = number;
export type CoordinateLatitudeDouble = number;
export type CoordinateLongitudeDouble = number;
export type LayerCustomActionName = string;
export type BinCountValue = number;
export type BinWidthValue = number;
export type BinCountLimit = number;
export type TopBottomRankedComputationResultSize = number;
export type TopBottomMoversComputationMoverSize = number;
export type GrowthRatePeriodSize = number;
export type ForecastComputationCustomSeasonalityValue = number;
export type PercentileValue = number;
export type DecimalPlaces = number;
export type DataSetStringFilterStaticValue = string | redacted.Redacted<string>;
export type Separator = string;
export type Length = string;
export type TableBorderThickness = number;
export type PercentNumber = number;
export type BodySectionDynamicDimensionLimit = number;
export type UnicodeIcon = string;
export type GeospatialWidth = number;
export type GeospatialRadius = number;
export type Opacity = number;

//# Schemas
export type AnswerIds = string[];
export const AnswerIds = S.Array(S.String);
export type Edition = "STANDARD" | "ENTERPRISE" | "ENTERPRISE_AND_Q";
export const Edition = S.Literal("STANDARD", "ENTERPRISE", "ENTERPRISE_AND_Q");
export type AuthenticationMethodOption =
  | "IAM_AND_QUICKSIGHT"
  | "IAM_ONLY"
  | "ACTIVE_DIRECTORY"
  | "IAM_IDENTITY_CENTER";
export const AuthenticationMethodOption = S.Literal(
  "IAM_AND_QUICKSIGHT",
  "IAM_ONLY",
  "ACTIVE_DIRECTORY",
  "IAM_IDENTITY_CENTER",
);
export type GroupsList = string[];
export const GroupsList = S.Array(S.String);
export type ActionConnectorType =
  | "GENERIC_HTTP"
  | "SERVICENOW_NOW_PLATFORM"
  | "SALESFORCE_CRM"
  | "MICROSOFT_OUTLOOK"
  | "PAGERDUTY_ADVANCE"
  | "JIRA_CLOUD"
  | "ATLASSIAN_CONFLUENCE"
  | "AMAZON_S3"
  | "AMAZON_BEDROCK_AGENT_RUNTIME"
  | "AMAZON_BEDROCK_RUNTIME"
  | "AMAZON_BEDROCK_DATA_AUTOMATION_RUNTIME"
  | "AMAZON_TEXTRACT"
  | "AMAZON_COMPREHEND"
  | "AMAZON_COMPREHEND_MEDICAL"
  | "MICROSOFT_ONEDRIVE"
  | "MICROSOFT_SHAREPOINT"
  | "MICROSOFT_TEAMS"
  | "SAP_BUSINESSPARTNER"
  | "SAP_PRODUCTMASTERDATA"
  | "SAP_PHYSICALINVENTORY"
  | "SAP_BILLOFMATERIALS"
  | "SAP_MATERIALSTOCK"
  | "ZENDESK_SUITE"
  | "SMARTSHEET"
  | "SLACK"
  | "ASANA"
  | "BAMBOO_HR";
export const ActionConnectorType = S.Literal(
  "GENERIC_HTTP",
  "SERVICENOW_NOW_PLATFORM",
  "SALESFORCE_CRM",
  "MICROSOFT_OUTLOOK",
  "PAGERDUTY_ADVANCE",
  "JIRA_CLOUD",
  "ATLASSIAN_CONFLUENCE",
  "AMAZON_S3",
  "AMAZON_BEDROCK_AGENT_RUNTIME",
  "AMAZON_BEDROCK_RUNTIME",
  "AMAZON_BEDROCK_DATA_AUTOMATION_RUNTIME",
  "AMAZON_TEXTRACT",
  "AMAZON_COMPREHEND",
  "AMAZON_COMPREHEND_MEDICAL",
  "MICROSOFT_ONEDRIVE",
  "MICROSOFT_SHAREPOINT",
  "MICROSOFT_TEAMS",
  "SAP_BUSINESSPARTNER",
  "SAP_PRODUCTMASTERDATA",
  "SAP_PHYSICALINVENTORY",
  "SAP_BILLOFMATERIALS",
  "SAP_MATERIALSTOCK",
  "ZENDESK_SUITE",
  "SMARTSHEET",
  "SLACK",
  "ASANA",
  "BAMBOO_HR",
);
export type FolderArnList = string[];
export const FolderArnList = S.Array(S.String);
export type LinkEntityArnList = string[];
export const LinkEntityArnList = S.Array(S.String);
export type DataSetImportMode = "SPICE" | "DIRECT_QUERY";
export const DataSetImportMode = S.Literal("SPICE", "DIRECT_QUERY");
export type DataSetUseAs = "RLS_RULES";
export const DataSetUseAs = S.Literal("RLS_RULES");
export type DataSourceType =
  | "ADOBE_ANALYTICS"
  | "AMAZON_ELASTICSEARCH"
  | "ATHENA"
  | "AURORA"
  | "AURORA_POSTGRESQL"
  | "AWS_IOT_ANALYTICS"
  | "GITHUB"
  | "JIRA"
  | "MARIADB"
  | "MYSQL"
  | "ORACLE"
  | "POSTGRESQL"
  | "PRESTO"
  | "REDSHIFT"
  | "S3"
  | "SALESFORCE"
  | "SERVICENOW"
  | "SNOWFLAKE"
  | "SPARK"
  | "SQLSERVER"
  | "TERADATA"
  | "TWITTER"
  | "TIMESTREAM"
  | "AMAZON_OPENSEARCH"
  | "EXASOL"
  | "DATABRICKS"
  | "STARBURST"
  | "TRINO"
  | "BIGQUERY"
  | "GOOGLESHEETS"
  | "GOOGLE_DRIVE"
  | "CONFLUENCE"
  | "SHAREPOINT"
  | "ONE_DRIVE"
  | "WEB_CRAWLER"
  | "S3_KNOWLEDGE_BASE"
  | "QBUSINESS";
export const DataSourceType = S.Literal(
  "ADOBE_ANALYTICS",
  "AMAZON_ELASTICSEARCH",
  "ATHENA",
  "AURORA",
  "AURORA_POSTGRESQL",
  "AWS_IOT_ANALYTICS",
  "GITHUB",
  "JIRA",
  "MARIADB",
  "MYSQL",
  "ORACLE",
  "POSTGRESQL",
  "PRESTO",
  "REDSHIFT",
  "S3",
  "SALESFORCE",
  "SERVICENOW",
  "SNOWFLAKE",
  "SPARK",
  "SQLSERVER",
  "TERADATA",
  "TWITTER",
  "TIMESTREAM",
  "AMAZON_OPENSEARCH",
  "EXASOL",
  "DATABRICKS",
  "STARBURST",
  "TRINO",
  "BIGQUERY",
  "GOOGLESHEETS",
  "GOOGLE_DRIVE",
  "CONFLUENCE",
  "SHAREPOINT",
  "ONE_DRIVE",
  "WEB_CRAWLER",
  "S3_KNOWLEDGE_BASE",
  "QBUSINESS",
);
export type FolderType = "SHARED" | "RESTRICTED";
export const FolderType = S.Literal("SHARED", "RESTRICTED");
export type SharingModel = "ACCOUNT" | "NAMESPACE";
export const SharingModel = S.Literal("ACCOUNT", "NAMESPACE");
export type MemberType =
  | "DASHBOARD"
  | "ANALYSIS"
  | "DATASET"
  | "DATASOURCE"
  | "TOPIC";
export const MemberType = S.Literal(
  "DASHBOARD",
  "ANALYSIS",
  "DATASET",
  "DATASOURCE",
  "TOPIC",
);
export type AssignmentStatus = "ENABLED" | "DRAFT" | "DISABLED";
export const AssignmentStatus = S.Literal("ENABLED", "DRAFT", "DISABLED");
export type IngestionType = "INCREMENTAL_REFRESH" | "FULL_REFRESH";
export const IngestionType = S.Literal("INCREMENTAL_REFRESH", "FULL_REFRESH");
export type IdentityStore = "QUICKSIGHT";
export const IdentityStore = S.Literal("QUICKSIGHT");
export type Role =
  | "ADMIN"
  | "AUTHOR"
  | "READER"
  | "ADMIN_PRO"
  | "AUTHOR_PRO"
  | "READER_PRO";
export const Role = S.Literal(
  "ADMIN",
  "AUTHOR",
  "READER",
  "ADMIN_PRO",
  "AUTHOR_PRO",
  "READER_PRO",
);
export type SubnetIdList = string[];
export const SubnetIdList = S.Array(S.String);
export type SecurityGroupIdList = string[];
export const SecurityGroupIdList = S.Array(S.String);
export type DnsResolverList = string[];
export const DnsResolverList = S.Array(S.String);
export type ServiceType = "REDSHIFT" | "QBUSINESS" | "ATHENA";
export const ServiceType = S.Literal("REDSHIFT", "QBUSINESS", "ATHENA");
export type ArnList = string[];
export const ArnList = S.Array(S.String);
export type StringList = string[];
export const StringList = S.Array(S.String);
export type EmbeddingIdentityType = "IAM" | "QUICKSIGHT" | "ANONYMOUS";
export const EmbeddingIdentityType = S.Literal(
  "IAM",
  "QUICKSIGHT",
  "ANONYMOUS",
);
export type AdditionalDashboardIdList = string[];
export const AdditionalDashboardIdList = S.Array(S.String);
export type ThemeType = "QUICKSIGHT" | "CUSTOM" | "ALL";
export const ThemeType = S.Literal("QUICKSIGHT", "CUSTOM", "ALL");
export type IncludeQuickSightQIndex = "INCLUDE" | "EXCLUDE";
export const IncludeQuickSightQIndex = S.Literal("INCLUDE", "EXCLUDE");
export type IncludeGeneratedAnswer = "INCLUDE" | "EXCLUDE";
export const IncludeGeneratedAnswer = S.Literal("INCLUDE", "EXCLUDE");
export type IdentityType = "IAM" | "QUICKSIGHT" | "IAM_IDENTITY_CENTER";
export const IdentityType = S.Literal(
  "IAM",
  "QUICKSIGHT",
  "IAM_IDENTITY_CENTER",
);
export type UserRole =
  | "ADMIN"
  | "AUTHOR"
  | "READER"
  | "RESTRICTED_AUTHOR"
  | "RESTRICTED_READER"
  | "ADMIN_PRO"
  | "AUTHOR_PRO"
  | "READER_PRO";
export const UserRole = S.Literal(
  "ADMIN",
  "AUTHOR",
  "READER",
  "RESTRICTED_AUTHOR",
  "RESTRICTED_READER",
  "ADMIN_PRO",
  "AUTHOR_PRO",
  "READER_PRO",
);
export type AssetBundleResourceArns = string[];
export const AssetBundleResourceArns = S.Array(S.String);
export type AssetBundleExportFormat = "CLOUDFORMATION_JSON" | "QUICKSIGHT_JSON";
export const AssetBundleExportFormat = S.Literal(
  "CLOUDFORMATION_JSON",
  "QUICKSIGHT_JSON",
);
export type IncludeFolderMembers = "RECURSE" | "ONE_LEVEL" | "NONE";
export const IncludeFolderMembers = S.Literal("RECURSE", "ONE_LEVEL", "NONE");
export type AssetBundleImportFailureAction = "DO_NOTHING" | "ROLLBACK";
export const AssetBundleImportFailureAction = S.Literal(
  "DO_NOTHING",
  "ROLLBACK",
);
export type TagKeyList = string[];
export const TagKeyList = S.Array(S.String);
export type ActionList = string[];
export const ActionList = S.Array(S.String);
export interface ResourcePermission {
  Principal: string;
  Actions: string[];
}
export const ResourcePermission = S.suspend(() =>
  S.Struct({ Principal: S.String, Actions: ActionList }),
).annotations({
  identifier: "ResourcePermission",
}) as any as S.Schema<ResourcePermission>;
export type UpdateResourcePermissionList = ResourcePermission[];
export const UpdateResourcePermissionList = S.Array(ResourcePermission);
export type UpdateLinkPermissionList = ResourcePermission[];
export const UpdateLinkPermissionList = S.Array(ResourcePermission);
export type DashboardsQAStatus = "ENABLED" | "DISABLED";
export const DashboardsQAStatus = S.Literal("ENABLED", "DISABLED");
export type ActionsList = string[];
export const ActionsList = S.Array(S.String);
export interface Permission {
  Actions: string[];
  Principal: string;
}
export const Permission = S.suspend(() =>
  S.Struct({ Actions: ActionsList, Principal: S.String }),
).annotations({ identifier: "Permission" }) as any as S.Schema<Permission>;
export type UpdateFlowPermissionsInputRevokePermissionsList = Permission[];
export const UpdateFlowPermissionsInputRevokePermissionsList =
  S.Array(Permission);
export type AuthorizedTargetsList = string[];
export const AuthorizedTargetsList = S.Array(S.String);
export type PersonalizationMode = "ENABLED" | "DISABLED";
export const PersonalizationMode = S.Literal("ENABLED", "DISABLED");
export type QSearchStatus = "ENABLED" | "DISABLED";
export const QSearchStatus = S.Literal("ENABLED", "DISABLED");
export type SelfUpgradeAdminAction = "APPROVE" | "DENY" | "VERIFY";
export const SelfUpgradeAdminAction = S.Literal("APPROVE", "DENY", "VERIFY");
export type SelfUpgradeStatus = "AUTO_APPROVAL" | "ADMIN_APPROVAL";
export const SelfUpgradeStatus = S.Literal("AUTO_APPROVAL", "ADMIN_APPROVAL");
export type PurchaseMode = "MANUAL" | "AUTO_PURCHASE";
export const PurchaseMode = S.Literal("MANUAL", "AUTO_PURCHASE");
export interface BatchDeleteTopicReviewedAnswerRequest {
  AwsAccountId: string;
  TopicId: string;
  AnswerIds?: string[];
}
export const BatchDeleteTopicReviewedAnswerRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    AnswerIds: S.optional(AnswerIds),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/batch-delete-reviewed-answers",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchDeleteTopicReviewedAnswerRequest",
}) as any as S.Schema<BatchDeleteTopicReviewedAnswerRequest>;
export interface CancelIngestionRequest {
  AwsAccountId: string;
  DataSetId: string;
  IngestionId: string;
}
export const CancelIngestionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    IngestionId: S.String.pipe(T.HttpLabel("IngestionId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions/{IngestionId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CancelIngestionRequest",
}) as any as S.Schema<CancelIngestionRequest>;
export interface CreateAccountSubscriptionRequest {
  Edition?: Edition;
  AuthenticationMethod: AuthenticationMethodOption;
  AwsAccountId: string;
  AccountName: string;
  NotificationEmail: string;
  ActiveDirectoryName?: string;
  Realm?: string;
  DirectoryId?: string;
  AdminGroup?: string[];
  AuthorGroup?: string[];
  ReaderGroup?: string[];
  AdminProGroup?: string[];
  AuthorProGroup?: string[];
  ReaderProGroup?: string[];
  FirstName?: string;
  LastName?: string;
  EmailAddress?: string;
  ContactNumber?: string;
  IAMIdentityCenterInstanceArn?: string;
}
export const CreateAccountSubscriptionRequest = S.suspend(() =>
  S.Struct({
    Edition: S.optional(Edition),
    AuthenticationMethod: AuthenticationMethodOption,
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AccountName: S.String,
    NotificationEmail: S.String,
    ActiveDirectoryName: S.optional(S.String),
    Realm: S.optional(S.String),
    DirectoryId: S.optional(S.String),
    AdminGroup: S.optional(GroupsList),
    AuthorGroup: S.optional(GroupsList),
    ReaderGroup: S.optional(GroupsList),
    AdminProGroup: S.optional(GroupsList),
    AuthorProGroup: S.optional(GroupsList),
    ReaderProGroup: S.optional(GroupsList),
    FirstName: S.optional(S.String),
    LastName: S.optional(S.String),
    EmailAddress: S.optional(S.String),
    ContactNumber: S.optional(S.String),
    IAMIdentityCenterInstanceArn: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/account/{AwsAccountId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateAccountSubscriptionRequest",
}) as any as S.Schema<CreateAccountSubscriptionRequest>;
export type ResourcePermissionList = ResourcePermission[];
export const ResourcePermissionList = S.Array(ResourcePermission);
export interface Tag {
  Key: string;
  Value: string;
}
export const Tag = S.suspend(() =>
  S.Struct({ Key: S.String, Value: S.String }),
).annotations({ identifier: "Tag" }) as any as S.Schema<Tag>;
export type TagList = Tag[];
export const TagList = S.Array(Tag);
export interface CreateFolderRequest {
  AwsAccountId: string;
  FolderId: string;
  Name?: string;
  FolderType?: FolderType;
  ParentFolderArn?: string;
  Permissions?: ResourcePermission[];
  Tags?: Tag[];
  SharingModel?: SharingModel;
}
export const CreateFolderRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    Name: S.optional(S.String),
    FolderType: S.optional(FolderType),
    ParentFolderArn: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    Tags: S.optional(TagList),
    SharingModel: S.optional(SharingModel),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateFolderRequest",
}) as any as S.Schema<CreateFolderRequest>;
export interface CreateFolderMembershipRequest {
  AwsAccountId: string;
  FolderId: string;
  MemberId: string;
  MemberType: MemberType;
}
export const CreateFolderMembershipRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    MemberId: S.String.pipe(T.HttpLabel("MemberId")),
    MemberType: MemberType.pipe(T.HttpLabel("MemberType")),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}/members/{MemberType}/{MemberId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateFolderMembershipRequest",
}) as any as S.Schema<CreateFolderMembershipRequest>;
export interface CreateGroupRequest {
  GroupName: string;
  Description?: string;
  AwsAccountId: string;
  Namespace: string;
}
export const CreateGroupRequest = S.suspend(() =>
  S.Struct({
    GroupName: S.String,
    Description: S.optional(S.String),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateGroupRequest",
}) as any as S.Schema<CreateGroupRequest>;
export interface CreateGroupMembershipRequest {
  MemberName: string;
  GroupName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const CreateGroupMembershipRequest = S.suspend(() =>
  S.Struct({
    MemberName: S.String.pipe(T.HttpLabel("MemberName")),
    GroupName: S.String.pipe(T.HttpLabel("GroupName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members/{MemberName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateGroupMembershipRequest",
}) as any as S.Schema<CreateGroupMembershipRequest>;
export interface CreateIngestionRequest {
  DataSetId: string;
  IngestionId: string;
  AwsAccountId: string;
  IngestionType?: IngestionType;
}
export const CreateIngestionRequest = S.suspend(() =>
  S.Struct({
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    IngestionId: S.String.pipe(T.HttpLabel("IngestionId")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    IngestionType: S.optional(IngestionType),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions/{IngestionId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateIngestionRequest",
}) as any as S.Schema<CreateIngestionRequest>;
export interface CreateNamespaceRequest {
  AwsAccountId: string;
  Namespace: string;
  IdentityStore: IdentityStore;
  Tags?: Tag[];
}
export const CreateNamespaceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String,
    IdentityStore: IdentityStore,
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/accounts/{AwsAccountId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateNamespaceRequest",
}) as any as S.Schema<CreateNamespaceRequest>;
export interface CreateRoleMembershipRequest {
  MemberName: string;
  AwsAccountId: string;
  Namespace: string;
  Role: Role;
}
export const CreateRoleMembershipRequest = S.suspend(() =>
  S.Struct({
    MemberName: S.String.pipe(T.HttpLabel("MemberName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    Role: Role.pipe(T.HttpLabel("Role")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/roles/{Role}/members/{MemberName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateRoleMembershipRequest",
}) as any as S.Schema<CreateRoleMembershipRequest>;
export interface CreateTemplateAliasRequest {
  AwsAccountId: string;
  TemplateId: string;
  AliasName: string;
  TemplateVersionNumber: number;
}
export const CreateTemplateAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
    TemplateVersionNumber: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateTemplateAliasRequest",
}) as any as S.Schema<CreateTemplateAliasRequest>;
export interface CreateThemeAliasRequest {
  AwsAccountId: string;
  ThemeId: string;
  AliasName: string;
  ThemeVersionNumber: number;
}
export const CreateThemeAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
    ThemeVersionNumber: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateThemeAliasRequest",
}) as any as S.Schema<CreateThemeAliasRequest>;
export interface CreateVPCConnectionRequest {
  AwsAccountId: string;
  VPCConnectionId: string;
  Name: string;
  SubnetIds: string[];
  SecurityGroupIds: string[];
  DnsResolvers?: string[];
  RoleArn: string;
  Tags?: Tag[];
}
export const CreateVPCConnectionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    VPCConnectionId: S.String,
    Name: S.String,
    SubnetIds: SubnetIdList,
    SecurityGroupIds: SecurityGroupIdList,
    DnsResolvers: S.optional(DnsResolverList),
    RoleArn: S.String,
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/vpc-connections",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateVPCConnectionRequest",
}) as any as S.Schema<CreateVPCConnectionRequest>;
export interface DeleteAccountCustomizationRequest {
  AwsAccountId: string;
  Namespace?: string;
}
export const DeleteAccountCustomizationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/customizations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteAccountCustomizationRequest",
}) as any as S.Schema<DeleteAccountCustomizationRequest>;
export interface DeleteAccountCustomPermissionRequest {
  AwsAccountId: string;
}
export const DeleteAccountCustomPermissionRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteAccountCustomPermissionRequest",
}) as any as S.Schema<DeleteAccountCustomPermissionRequest>;
export interface DeleteAccountSubscriptionRequest {
  AwsAccountId: string;
}
export const DeleteAccountSubscriptionRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/account/{AwsAccountId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteAccountSubscriptionRequest",
}) as any as S.Schema<DeleteAccountSubscriptionRequest>;
export interface DeleteActionConnectorRequest {
  AwsAccountId: string;
  ActionConnectorId: string;
}
export const DeleteActionConnectorRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ActionConnectorId: S.String.pipe(T.HttpLabel("ActionConnectorId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/action-connectors/{ActionConnectorId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteActionConnectorRequest",
}) as any as S.Schema<DeleteActionConnectorRequest>;
export interface DeleteAnalysisRequest {
  AwsAccountId: string;
  AnalysisId: string;
  RecoveryWindowInDays?: number;
  ForceDeleteWithoutRecovery?: boolean;
}
export const DeleteAnalysisRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
    RecoveryWindowInDays: S.optional(S.Number).pipe(
      T.HttpQuery("recovery-window-in-days"),
    ),
    ForceDeleteWithoutRecovery: S.optional(S.Boolean).pipe(
      T.HttpQuery("force-delete-without-recovery"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/analyses/{AnalysisId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteAnalysisRequest",
}) as any as S.Schema<DeleteAnalysisRequest>;
export interface DeleteBrandRequest {
  AwsAccountId: string;
  BrandId: string;
}
export const DeleteBrandRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    BrandId: S.String.pipe(T.HttpLabel("BrandId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/brands/{BrandId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteBrandRequest",
}) as any as S.Schema<DeleteBrandRequest>;
export interface DeleteBrandAssignmentRequest {
  AwsAccountId: string;
}
export const DeleteBrandAssignmentRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/brandassignments",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteBrandAssignmentRequest",
}) as any as S.Schema<DeleteBrandAssignmentRequest>;
export interface DeleteCustomPermissionsRequest {
  AwsAccountId: string;
  CustomPermissionsName: string;
}
export const DeleteCustomPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    CustomPermissionsName: S.String.pipe(T.HttpLabel("CustomPermissionsName")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/custom-permissions/{CustomPermissionsName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteCustomPermissionsRequest",
}) as any as S.Schema<DeleteCustomPermissionsRequest>;
export interface DeleteDashboardRequest {
  AwsAccountId: string;
  DashboardId: string;
  VersionNumber?: number;
}
export const DeleteDashboardRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteDashboardRequest",
}) as any as S.Schema<DeleteDashboardRequest>;
export interface DeleteDataSetRequest {
  AwsAccountId: string;
  DataSetId: string;
}
export const DeleteDataSetRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteDataSetRequest",
}) as any as S.Schema<DeleteDataSetRequest>;
export interface DeleteDataSetRefreshPropertiesRequest {
  AwsAccountId: string;
  DataSetId: string;
}
export const DeleteDataSetRefreshPropertiesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-properties",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteDataSetRefreshPropertiesRequest",
}) as any as S.Schema<DeleteDataSetRefreshPropertiesRequest>;
export interface DeleteDataSourceRequest {
  AwsAccountId: string;
  DataSourceId: string;
}
export const DeleteDataSourceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSourceId: S.String.pipe(T.HttpLabel("DataSourceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/data-sources/{DataSourceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteDataSourceRequest",
}) as any as S.Schema<DeleteDataSourceRequest>;
export interface DeleteDefaultQBusinessApplicationRequest {
  AwsAccountId: string;
  Namespace?: string;
}
export const DeleteDefaultQBusinessApplicationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/default-qbusiness-application",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteDefaultQBusinessApplicationRequest",
}) as any as S.Schema<DeleteDefaultQBusinessApplicationRequest>;
export interface DeleteFolderRequest {
  AwsAccountId: string;
  FolderId: string;
}
export const DeleteFolderRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteFolderRequest",
}) as any as S.Schema<DeleteFolderRequest>;
export interface DeleteFolderMembershipRequest {
  AwsAccountId: string;
  FolderId: string;
  MemberId: string;
  MemberType: MemberType;
}
export const DeleteFolderMembershipRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    MemberId: S.String.pipe(T.HttpLabel("MemberId")),
    MemberType: MemberType.pipe(T.HttpLabel("MemberType")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}/members/{MemberType}/{MemberId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteFolderMembershipRequest",
}) as any as S.Schema<DeleteFolderMembershipRequest>;
export interface DeleteGroupRequest {
  GroupName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteGroupRequest = S.suspend(() =>
  S.Struct({
    GroupName: S.String.pipe(T.HttpLabel("GroupName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteGroupRequest",
}) as any as S.Schema<DeleteGroupRequest>;
export interface DeleteGroupMembershipRequest {
  MemberName: string;
  GroupName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteGroupMembershipRequest = S.suspend(() =>
  S.Struct({
    MemberName: S.String.pipe(T.HttpLabel("MemberName")),
    GroupName: S.String.pipe(T.HttpLabel("GroupName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members/{MemberName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteGroupMembershipRequest",
}) as any as S.Schema<DeleteGroupMembershipRequest>;
export interface DeleteIAMPolicyAssignmentRequest {
  AwsAccountId: string;
  AssignmentName: string;
  Namespace: string;
}
export const DeleteIAMPolicyAssignmentRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssignmentName: S.String.pipe(T.HttpLabel("AssignmentName")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespace/{Namespace}/iam-policy-assignments/{AssignmentName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteIAMPolicyAssignmentRequest",
}) as any as S.Schema<DeleteIAMPolicyAssignmentRequest>;
export interface DeleteIdentityPropagationConfigRequest {
  AwsAccountId: string;
  Service: ServiceType;
}
export const DeleteIdentityPropagationConfigRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Service: ServiceType.pipe(T.HttpLabel("Service")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/identity-propagation-config/{Service}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteIdentityPropagationConfigRequest",
}) as any as S.Schema<DeleteIdentityPropagationConfigRequest>;
export interface DeleteNamespaceRequest {
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteNamespaceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteNamespaceRequest",
}) as any as S.Schema<DeleteNamespaceRequest>;
export interface DeleteRefreshScheduleRequest {
  DataSetId: string;
  AwsAccountId: string;
  ScheduleId: string;
}
export const DeleteRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ScheduleId: S.String.pipe(T.HttpLabel("ScheduleId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-schedules/{ScheduleId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteRefreshScheduleRequest",
}) as any as S.Schema<DeleteRefreshScheduleRequest>;
export interface DeleteRoleCustomPermissionRequest {
  Role: Role;
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteRoleCustomPermissionRequest = S.suspend(() =>
  S.Struct({
    Role: Role.pipe(T.HttpLabel("Role")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/roles/{Role}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteRoleCustomPermissionRequest",
}) as any as S.Schema<DeleteRoleCustomPermissionRequest>;
export interface DeleteRoleMembershipRequest {
  MemberName: string;
  Role: Role;
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteRoleMembershipRequest = S.suspend(() =>
  S.Struct({
    MemberName: S.String.pipe(T.HttpLabel("MemberName")),
    Role: Role.pipe(T.HttpLabel("Role")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/roles/{Role}/members/{MemberName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteRoleMembershipRequest",
}) as any as S.Schema<DeleteRoleMembershipRequest>;
export interface DeleteTemplateRequest {
  AwsAccountId: string;
  TemplateId: string;
  VersionNumber?: number;
}
export const DeleteTemplateRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteTemplateRequest",
}) as any as S.Schema<DeleteTemplateRequest>;
export interface DeleteTemplateAliasRequest {
  AwsAccountId: string;
  TemplateId: string;
  AliasName: string;
}
export const DeleteTemplateAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteTemplateAliasRequest",
}) as any as S.Schema<DeleteTemplateAliasRequest>;
export interface DeleteThemeRequest {
  AwsAccountId: string;
  ThemeId: string;
  VersionNumber?: number;
}
export const DeleteThemeRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteThemeRequest",
}) as any as S.Schema<DeleteThemeRequest>;
export interface DeleteThemeAliasRequest {
  AwsAccountId: string;
  ThemeId: string;
  AliasName: string;
}
export const DeleteThemeAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteThemeAliasRequest",
}) as any as S.Schema<DeleteThemeAliasRequest>;
export interface DeleteTopicRequest {
  AwsAccountId: string;
  TopicId: string;
}
export const DeleteTopicRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteTopicRequest",
}) as any as S.Schema<DeleteTopicRequest>;
export interface DeleteTopicRefreshScheduleRequest {
  AwsAccountId: string;
  TopicId: string;
  DatasetId: string;
}
export const DeleteTopicRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    DatasetId: S.String.pipe(T.HttpLabel("DatasetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/schedules/{DatasetId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteTopicRefreshScheduleRequest",
}) as any as S.Schema<DeleteTopicRefreshScheduleRequest>;
export interface DeleteUserRequest {
  UserName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteUserRequest = S.suspend(() =>
  S.Struct({
    UserName: S.String.pipe(T.HttpLabel("UserName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteUserRequest",
}) as any as S.Schema<DeleteUserRequest>;
export interface DeleteUserByPrincipalIdRequest {
  PrincipalId: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteUserByPrincipalIdRequest = S.suspend(() =>
  S.Struct({
    PrincipalId: S.String.pipe(T.HttpLabel("PrincipalId")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/user-principals/{PrincipalId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteUserByPrincipalIdRequest",
}) as any as S.Schema<DeleteUserByPrincipalIdRequest>;
export interface DeleteUserCustomPermissionRequest {
  UserName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DeleteUserCustomPermissionRequest = S.suspend(() =>
  S.Struct({
    UserName: S.String.pipe(T.HttpLabel("UserName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteUserCustomPermissionRequest",
}) as any as S.Schema<DeleteUserCustomPermissionRequest>;
export interface DeleteVPCConnectionRequest {
  AwsAccountId: string;
  VPCConnectionId: string;
}
export const DeleteVPCConnectionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    VPCConnectionId: S.String.pipe(T.HttpLabel("VPCConnectionId")),
  }).pipe(
    T.all(
      T.Http({
        method: "DELETE",
        uri: "/accounts/{AwsAccountId}/vpc-connections/{VPCConnectionId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DeleteVPCConnectionRequest",
}) as any as S.Schema<DeleteVPCConnectionRequest>;
export interface DescribeAccountCustomizationRequest {
  AwsAccountId: string;
  Namespace?: string;
  Resolved?: boolean;
}
export const DescribeAccountCustomizationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
    Resolved: S.optional(S.Boolean).pipe(T.HttpQuery("resolved")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/customizations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAccountCustomizationRequest",
}) as any as S.Schema<DescribeAccountCustomizationRequest>;
export interface DescribeAccountCustomPermissionRequest {
  AwsAccountId: string;
}
export const DescribeAccountCustomPermissionRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAccountCustomPermissionRequest",
}) as any as S.Schema<DescribeAccountCustomPermissionRequest>;
export interface DescribeAccountSettingsRequest {
  AwsAccountId: string;
}
export const DescribeAccountSettingsRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/settings" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAccountSettingsRequest",
}) as any as S.Schema<DescribeAccountSettingsRequest>;
export interface DescribeAccountSubscriptionRequest {
  AwsAccountId: string;
}
export const DescribeAccountSubscriptionRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/account/{AwsAccountId}" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAccountSubscriptionRequest",
}) as any as S.Schema<DescribeAccountSubscriptionRequest>;
export interface DescribeActionConnectorRequest {
  AwsAccountId: string;
  ActionConnectorId: string;
}
export const DescribeActionConnectorRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ActionConnectorId: S.String.pipe(T.HttpLabel("ActionConnectorId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/action-connectors/{ActionConnectorId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeActionConnectorRequest",
}) as any as S.Schema<DescribeActionConnectorRequest>;
export interface DescribeActionConnectorPermissionsRequest {
  AwsAccountId: string;
  ActionConnectorId: string;
}
export const DescribeActionConnectorPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ActionConnectorId: S.String.pipe(T.HttpLabel("ActionConnectorId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/action-connectors/{ActionConnectorId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeActionConnectorPermissionsRequest",
}) as any as S.Schema<DescribeActionConnectorPermissionsRequest>;
export interface DescribeAnalysisRequest {
  AwsAccountId: string;
  AnalysisId: string;
}
export const DescribeAnalysisRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/analyses/{AnalysisId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAnalysisRequest",
}) as any as S.Schema<DescribeAnalysisRequest>;
export interface DescribeAnalysisDefinitionRequest {
  AwsAccountId: string;
  AnalysisId: string;
}
export const DescribeAnalysisDefinitionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/analyses/{AnalysisId}/definition",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAnalysisDefinitionRequest",
}) as any as S.Schema<DescribeAnalysisDefinitionRequest>;
export interface DescribeAnalysisPermissionsRequest {
  AwsAccountId: string;
  AnalysisId: string;
}
export const DescribeAnalysisPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/analyses/{AnalysisId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAnalysisPermissionsRequest",
}) as any as S.Schema<DescribeAnalysisPermissionsRequest>;
export interface DescribeAssetBundleExportJobRequest {
  AwsAccountId: string;
  AssetBundleExportJobId: string;
}
export const DescribeAssetBundleExportJobRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssetBundleExportJobId: S.String.pipe(
      T.HttpLabel("AssetBundleExportJobId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/asset-bundle-export-jobs/{AssetBundleExportJobId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAssetBundleExportJobRequest",
}) as any as S.Schema<DescribeAssetBundleExportJobRequest>;
export interface DescribeAssetBundleImportJobRequest {
  AwsAccountId: string;
  AssetBundleImportJobId: string;
}
export const DescribeAssetBundleImportJobRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssetBundleImportJobId: S.String.pipe(
      T.HttpLabel("AssetBundleImportJobId"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/asset-bundle-import-jobs/{AssetBundleImportJobId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeAssetBundleImportJobRequest",
}) as any as S.Schema<DescribeAssetBundleImportJobRequest>;
export interface DescribeBrandRequest {
  AwsAccountId: string;
  BrandId: string;
  VersionId?: string;
}
export const DescribeBrandRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    BrandId: S.String.pipe(T.HttpLabel("BrandId")),
    VersionId: S.optional(S.String).pipe(T.HttpQuery("versionId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/brands/{BrandId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeBrandRequest",
}) as any as S.Schema<DescribeBrandRequest>;
export interface DescribeBrandAssignmentRequest {
  AwsAccountId: string;
}
export const DescribeBrandAssignmentRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/brandassignments",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeBrandAssignmentRequest",
}) as any as S.Schema<DescribeBrandAssignmentRequest>;
export interface DescribeBrandPublishedVersionRequest {
  AwsAccountId: string;
  BrandId: string;
}
export const DescribeBrandPublishedVersionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    BrandId: S.String.pipe(T.HttpLabel("BrandId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/brands/{BrandId}/publishedversion",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeBrandPublishedVersionRequest",
}) as any as S.Schema<DescribeBrandPublishedVersionRequest>;
export interface DescribeCustomPermissionsRequest {
  AwsAccountId: string;
  CustomPermissionsName: string;
}
export const DescribeCustomPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    CustomPermissionsName: S.String.pipe(T.HttpLabel("CustomPermissionsName")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/custom-permissions/{CustomPermissionsName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeCustomPermissionsRequest",
}) as any as S.Schema<DescribeCustomPermissionsRequest>;
export interface DescribeDashboardRequest {
  AwsAccountId: string;
  DashboardId: string;
  VersionNumber?: number;
  AliasName?: string;
}
export const DescribeDashboardRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
    AliasName: S.optional(S.String).pipe(T.HttpQuery("alias-name")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDashboardRequest",
}) as any as S.Schema<DescribeDashboardRequest>;
export interface DescribeDashboardDefinitionRequest {
  AwsAccountId: string;
  DashboardId: string;
  VersionNumber?: number;
  AliasName?: string;
}
export const DescribeDashboardDefinitionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
    AliasName: S.optional(S.String).pipe(T.HttpQuery("alias-name")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/definition",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDashboardDefinitionRequest",
}) as any as S.Schema<DescribeDashboardDefinitionRequest>;
export interface DescribeDashboardPermissionsRequest {
  AwsAccountId: string;
  DashboardId: string;
}
export const DescribeDashboardPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDashboardPermissionsRequest",
}) as any as S.Schema<DescribeDashboardPermissionsRequest>;
export interface DescribeDashboardSnapshotJobRequest {
  AwsAccountId: string;
  DashboardId: string;
  SnapshotJobId: string;
}
export const DescribeDashboardSnapshotJobRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    SnapshotJobId: S.String.pipe(T.HttpLabel("SnapshotJobId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/snapshot-jobs/{SnapshotJobId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDashboardSnapshotJobRequest",
}) as any as S.Schema<DescribeDashboardSnapshotJobRequest>;
export interface DescribeDashboardSnapshotJobResultRequest {
  AwsAccountId: string;
  DashboardId: string;
  SnapshotJobId: string;
}
export const DescribeDashboardSnapshotJobResultRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    SnapshotJobId: S.String.pipe(T.HttpLabel("SnapshotJobId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/snapshot-jobs/{SnapshotJobId}/result",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDashboardSnapshotJobResultRequest",
}) as any as S.Schema<DescribeDashboardSnapshotJobResultRequest>;
export interface DescribeDashboardsQAConfigurationRequest {
  AwsAccountId: string;
}
export const DescribeDashboardsQAConfigurationRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards-qa-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDashboardsQAConfigurationRequest",
}) as any as S.Schema<DescribeDashboardsQAConfigurationRequest>;
export interface DescribeDataSetRequest {
  AwsAccountId: string;
  DataSetId: string;
}
export const DescribeDataSetRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDataSetRequest",
}) as any as S.Schema<DescribeDataSetRequest>;
export interface DescribeDataSetPermissionsRequest {
  AwsAccountId: string;
  DataSetId: string;
}
export const DescribeDataSetPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDataSetPermissionsRequest",
}) as any as S.Schema<DescribeDataSetPermissionsRequest>;
export interface DescribeDataSetRefreshPropertiesRequest {
  AwsAccountId: string;
  DataSetId: string;
}
export const DescribeDataSetRefreshPropertiesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-properties",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDataSetRefreshPropertiesRequest",
}) as any as S.Schema<DescribeDataSetRefreshPropertiesRequest>;
export interface DescribeDataSourceRequest {
  AwsAccountId: string;
  DataSourceId: string;
}
export const DescribeDataSourceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSourceId: S.String.pipe(T.HttpLabel("DataSourceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sources/{DataSourceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDataSourceRequest",
}) as any as S.Schema<DescribeDataSourceRequest>;
export interface DescribeDataSourcePermissionsRequest {
  AwsAccountId: string;
  DataSourceId: string;
}
export const DescribeDataSourcePermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSourceId: S.String.pipe(T.HttpLabel("DataSourceId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sources/{DataSourceId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDataSourcePermissionsRequest",
}) as any as S.Schema<DescribeDataSourcePermissionsRequest>;
export interface DescribeDefaultQBusinessApplicationRequest {
  AwsAccountId: string;
  Namespace?: string;
}
export const DescribeDefaultQBusinessApplicationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/default-qbusiness-application",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeDefaultQBusinessApplicationRequest",
}) as any as S.Schema<DescribeDefaultQBusinessApplicationRequest>;
export interface DescribeFolderRequest {
  AwsAccountId: string;
  FolderId: string;
}
export const DescribeFolderRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeFolderRequest",
}) as any as S.Schema<DescribeFolderRequest>;
export interface DescribeFolderPermissionsRequest {
  AwsAccountId: string;
  FolderId: string;
  Namespace?: string;
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeFolderPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeFolderPermissionsRequest",
}) as any as S.Schema<DescribeFolderPermissionsRequest>;
export interface DescribeFolderResolvedPermissionsRequest {
  AwsAccountId: string;
  FolderId: string;
  Namespace?: string;
  MaxResults?: number;
  NextToken?: string;
}
export const DescribeFolderResolvedPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}/resolved-permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeFolderResolvedPermissionsRequest",
}) as any as S.Schema<DescribeFolderResolvedPermissionsRequest>;
export interface DescribeGroupRequest {
  GroupName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DescribeGroupRequest = S.suspend(() =>
  S.Struct({
    GroupName: S.String.pipe(T.HttpLabel("GroupName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeGroupRequest",
}) as any as S.Schema<DescribeGroupRequest>;
export interface DescribeGroupMembershipRequest {
  MemberName: string;
  GroupName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DescribeGroupMembershipRequest = S.suspend(() =>
  S.Struct({
    MemberName: S.String.pipe(T.HttpLabel("MemberName")),
    GroupName: S.String.pipe(T.HttpLabel("GroupName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members/{MemberName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeGroupMembershipRequest",
}) as any as S.Schema<DescribeGroupMembershipRequest>;
export interface DescribeIAMPolicyAssignmentRequest {
  AwsAccountId: string;
  AssignmentName: string;
  Namespace: string;
}
export const DescribeIAMPolicyAssignmentRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssignmentName: S.String.pipe(T.HttpLabel("AssignmentName")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/iam-policy-assignments/{AssignmentName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeIAMPolicyAssignmentRequest",
}) as any as S.Schema<DescribeIAMPolicyAssignmentRequest>;
export interface DescribeIngestionRequest {
  AwsAccountId: string;
  DataSetId: string;
  IngestionId: string;
}
export const DescribeIngestionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    IngestionId: S.String.pipe(T.HttpLabel("IngestionId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions/{IngestionId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeIngestionRequest",
}) as any as S.Schema<DescribeIngestionRequest>;
export interface DescribeIpRestrictionRequest {
  AwsAccountId: string;
}
export const DescribeIpRestrictionRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/ip-restriction" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeIpRestrictionRequest",
}) as any as S.Schema<DescribeIpRestrictionRequest>;
export interface DescribeKeyRegistrationRequest {
  AwsAccountId: string;
  DefaultKeyOnly?: boolean;
}
export const DescribeKeyRegistrationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DefaultKeyOnly: S.optional(S.Boolean).pipe(T.HttpQuery("default-key-only")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/key-registration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeKeyRegistrationRequest",
}) as any as S.Schema<DescribeKeyRegistrationRequest>;
export interface DescribeNamespaceRequest {
  AwsAccountId: string;
  Namespace: string;
}
export const DescribeNamespaceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeNamespaceRequest",
}) as any as S.Schema<DescribeNamespaceRequest>;
export interface DescribeQPersonalizationConfigurationRequest {
  AwsAccountId: string;
}
export const DescribeQPersonalizationConfigurationRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/q-personalization-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeQPersonalizationConfigurationRequest",
}) as any as S.Schema<DescribeQPersonalizationConfigurationRequest>;
export interface DescribeQuickSightQSearchConfigurationRequest {
  AwsAccountId: string;
}
export const DescribeQuickSightQSearchConfigurationRequest = S.suspend(() =>
  S.Struct({ AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")) }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/quicksight-q-search-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeQuickSightQSearchConfigurationRequest",
}) as any as S.Schema<DescribeQuickSightQSearchConfigurationRequest>;
export interface DescribeRefreshScheduleRequest {
  AwsAccountId: string;
  DataSetId: string;
  ScheduleId: string;
}
export const DescribeRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    ScheduleId: S.String.pipe(T.HttpLabel("ScheduleId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-schedules/{ScheduleId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeRefreshScheduleRequest",
}) as any as S.Schema<DescribeRefreshScheduleRequest>;
export interface DescribeRoleCustomPermissionRequest {
  Role: Role;
  AwsAccountId: string;
  Namespace: string;
}
export const DescribeRoleCustomPermissionRequest = S.suspend(() =>
  S.Struct({
    Role: Role.pipe(T.HttpLabel("Role")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/roles/{Role}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeRoleCustomPermissionRequest",
}) as any as S.Schema<DescribeRoleCustomPermissionRequest>;
export interface DescribeSelfUpgradeConfigurationRequest {
  AwsAccountId: string;
  Namespace: string;
}
export const DescribeSelfUpgradeConfigurationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/self-upgrade-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeSelfUpgradeConfigurationRequest",
}) as any as S.Schema<DescribeSelfUpgradeConfigurationRequest>;
export interface DescribeTemplateRequest {
  AwsAccountId: string;
  TemplateId: string;
  VersionNumber?: number;
  AliasName?: string;
}
export const DescribeTemplateRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
    AliasName: S.optional(S.String).pipe(T.HttpQuery("alias-name")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTemplateRequest",
}) as any as S.Schema<DescribeTemplateRequest>;
export interface DescribeTemplateAliasRequest {
  AwsAccountId: string;
  TemplateId: string;
  AliasName: string;
}
export const DescribeTemplateAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTemplateAliasRequest",
}) as any as S.Schema<DescribeTemplateAliasRequest>;
export interface DescribeTemplateDefinitionRequest {
  AwsAccountId: string;
  TemplateId: string;
  VersionNumber?: number;
  AliasName?: string;
}
export const DescribeTemplateDefinitionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
    AliasName: S.optional(S.String).pipe(T.HttpQuery("alias-name")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/definition",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTemplateDefinitionRequest",
}) as any as S.Schema<DescribeTemplateDefinitionRequest>;
export interface DescribeTemplatePermissionsRequest {
  AwsAccountId: string;
  TemplateId: string;
}
export const DescribeTemplatePermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTemplatePermissionsRequest",
}) as any as S.Schema<DescribeTemplatePermissionsRequest>;
export interface DescribeThemeRequest {
  AwsAccountId: string;
  ThemeId: string;
  VersionNumber?: number;
  AliasName?: string;
}
export const DescribeThemeRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    VersionNumber: S.optional(S.Number).pipe(T.HttpQuery("version-number")),
    AliasName: S.optional(S.String).pipe(T.HttpQuery("alias-name")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeThemeRequest",
}) as any as S.Schema<DescribeThemeRequest>;
export interface DescribeThemeAliasRequest {
  AwsAccountId: string;
  ThemeId: string;
  AliasName: string;
}
export const DescribeThemeAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeThemeAliasRequest",
}) as any as S.Schema<DescribeThemeAliasRequest>;
export interface DescribeThemePermissionsRequest {
  AwsAccountId: string;
  ThemeId: string;
}
export const DescribeThemePermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeThemePermissionsRequest",
}) as any as S.Schema<DescribeThemePermissionsRequest>;
export interface DescribeTopicRequest {
  AwsAccountId: string;
  TopicId: string;
}
export const DescribeTopicRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTopicRequest",
}) as any as S.Schema<DescribeTopicRequest>;
export interface DescribeTopicPermissionsRequest {
  AwsAccountId: string;
  TopicId: string;
}
export const DescribeTopicPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTopicPermissionsRequest",
}) as any as S.Schema<DescribeTopicPermissionsRequest>;
export interface DescribeTopicRefreshRequest {
  AwsAccountId: string;
  TopicId: string;
  RefreshId: string;
}
export const DescribeTopicRefreshRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    RefreshId: S.String.pipe(T.HttpLabel("RefreshId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/refresh/{RefreshId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTopicRefreshRequest",
}) as any as S.Schema<DescribeTopicRefreshRequest>;
export interface DescribeTopicRefreshScheduleRequest {
  AwsAccountId: string;
  TopicId: string;
  DatasetId: string;
}
export const DescribeTopicRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    DatasetId: S.String.pipe(T.HttpLabel("DatasetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/schedules/{DatasetId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeTopicRefreshScheduleRequest",
}) as any as S.Schema<DescribeTopicRefreshScheduleRequest>;
export interface DescribeUserRequest {
  UserName: string;
  AwsAccountId: string;
  Namespace: string;
}
export const DescribeUserRequest = S.suspend(() =>
  S.Struct({
    UserName: S.String.pipe(T.HttpLabel("UserName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeUserRequest",
}) as any as S.Schema<DescribeUserRequest>;
export interface DescribeVPCConnectionRequest {
  AwsAccountId: string;
  VPCConnectionId: string;
}
export const DescribeVPCConnectionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    VPCConnectionId: S.String.pipe(T.HttpLabel("VPCConnectionId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/vpc-connections/{VPCConnectionId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "DescribeVPCConnectionRequest",
}) as any as S.Schema<DescribeVPCConnectionRequest>;
export interface StatePersistenceConfigurations {
  Enabled: boolean;
}
export const StatePersistenceConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "StatePersistenceConfigurations",
}) as any as S.Schema<StatePersistenceConfigurations>;
export interface SharedViewConfigurations {
  Enabled: boolean;
}
export const SharedViewConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "SharedViewConfigurations",
}) as any as S.Schema<SharedViewConfigurations>;
export interface BookmarksConfigurations {
  Enabled: boolean;
}
export const BookmarksConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "BookmarksConfigurations",
}) as any as S.Schema<BookmarksConfigurations>;
export interface ExecutiveSummaryConfigurations {
  Enabled: boolean;
}
export const ExecutiveSummaryConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "ExecutiveSummaryConfigurations",
}) as any as S.Schema<ExecutiveSummaryConfigurations>;
export interface AmazonQInQuickSightDashboardConfigurations {
  ExecutiveSummary?: ExecutiveSummaryConfigurations;
}
export const AmazonQInQuickSightDashboardConfigurations = S.suspend(() =>
  S.Struct({ ExecutiveSummary: S.optional(ExecutiveSummaryConfigurations) }),
).annotations({
  identifier: "AmazonQInQuickSightDashboardConfigurations",
}) as any as S.Schema<AmazonQInQuickSightDashboardConfigurations>;
export interface SchedulesConfigurations {
  Enabled: boolean;
}
export const SchedulesConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "SchedulesConfigurations",
}) as any as S.Schema<SchedulesConfigurations>;
export interface RecentSnapshotsConfigurations {
  Enabled: boolean;
}
export const RecentSnapshotsConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "RecentSnapshotsConfigurations",
}) as any as S.Schema<RecentSnapshotsConfigurations>;
export interface ThresholdAlertsConfigurations {
  Enabled: boolean;
}
export const ThresholdAlertsConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "ThresholdAlertsConfigurations",
}) as any as S.Schema<ThresholdAlertsConfigurations>;
export interface RegisteredUserDashboardFeatureConfigurations {
  StatePersistence?: StatePersistenceConfigurations;
  SharedView?: SharedViewConfigurations;
  Bookmarks?: BookmarksConfigurations;
  AmazonQInQuickSight?: AmazonQInQuickSightDashboardConfigurations;
  Schedules?: SchedulesConfigurations;
  RecentSnapshots?: RecentSnapshotsConfigurations;
  ThresholdAlerts?: ThresholdAlertsConfigurations;
}
export const RegisteredUserDashboardFeatureConfigurations = S.suspend(() =>
  S.Struct({
    StatePersistence: S.optional(StatePersistenceConfigurations),
    SharedView: S.optional(SharedViewConfigurations),
    Bookmarks: S.optional(BookmarksConfigurations),
    AmazonQInQuickSight: S.optional(AmazonQInQuickSightDashboardConfigurations),
    Schedules: S.optional(SchedulesConfigurations),
    RecentSnapshots: S.optional(RecentSnapshotsConfigurations),
    ThresholdAlerts: S.optional(ThresholdAlertsConfigurations),
  }),
).annotations({
  identifier: "RegisteredUserDashboardFeatureConfigurations",
}) as any as S.Schema<RegisteredUserDashboardFeatureConfigurations>;
export interface RegisteredUserDashboardEmbeddingConfiguration {
  InitialDashboardId: string;
  FeatureConfigurations?: RegisteredUserDashboardFeatureConfigurations;
}
export const RegisteredUserDashboardEmbeddingConfiguration = S.suspend(() =>
  S.Struct({
    InitialDashboardId: S.String,
    FeatureConfigurations: S.optional(
      RegisteredUserDashboardFeatureConfigurations,
    ),
  }),
).annotations({
  identifier: "RegisteredUserDashboardEmbeddingConfiguration",
}) as any as S.Schema<RegisteredUserDashboardEmbeddingConfiguration>;
export interface DataQnAConfigurations {
  Enabled: boolean;
}
export const DataQnAConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "DataQnAConfigurations",
}) as any as S.Schema<DataQnAConfigurations>;
export interface GenerativeAuthoringConfigurations {
  Enabled: boolean;
}
export const GenerativeAuthoringConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "GenerativeAuthoringConfigurations",
}) as any as S.Schema<GenerativeAuthoringConfigurations>;
export interface DataStoriesConfigurations {
  Enabled: boolean;
}
export const DataStoriesConfigurations = S.suspend(() =>
  S.Struct({ Enabled: S.Boolean }),
).annotations({
  identifier: "DataStoriesConfigurations",
}) as any as S.Schema<DataStoriesConfigurations>;
export interface AmazonQInQuickSightConsoleConfigurations {
  DataQnA?: DataQnAConfigurations;
  GenerativeAuthoring?: GenerativeAuthoringConfigurations;
  ExecutiveSummary?: ExecutiveSummaryConfigurations;
  DataStories?: DataStoriesConfigurations;
}
export const AmazonQInQuickSightConsoleConfigurations = S.suspend(() =>
  S.Struct({
    DataQnA: S.optional(DataQnAConfigurations),
    GenerativeAuthoring: S.optional(GenerativeAuthoringConfigurations),
    ExecutiveSummary: S.optional(ExecutiveSummaryConfigurations),
    DataStories: S.optional(DataStoriesConfigurations),
  }),
).annotations({
  identifier: "AmazonQInQuickSightConsoleConfigurations",
}) as any as S.Schema<AmazonQInQuickSightConsoleConfigurations>;
export interface RegisteredUserConsoleFeatureConfigurations {
  StatePersistence?: StatePersistenceConfigurations;
  SharedView?: SharedViewConfigurations;
  AmazonQInQuickSight?: AmazonQInQuickSightConsoleConfigurations;
  Schedules?: SchedulesConfigurations;
  RecentSnapshots?: RecentSnapshotsConfigurations;
  ThresholdAlerts?: ThresholdAlertsConfigurations;
}
export const RegisteredUserConsoleFeatureConfigurations = S.suspend(() =>
  S.Struct({
    StatePersistence: S.optional(StatePersistenceConfigurations),
    SharedView: S.optional(SharedViewConfigurations),
    AmazonQInQuickSight: S.optional(AmazonQInQuickSightConsoleConfigurations),
    Schedules: S.optional(SchedulesConfigurations),
    RecentSnapshots: S.optional(RecentSnapshotsConfigurations),
    ThresholdAlerts: S.optional(ThresholdAlertsConfigurations),
  }),
).annotations({
  identifier: "RegisteredUserConsoleFeatureConfigurations",
}) as any as S.Schema<RegisteredUserConsoleFeatureConfigurations>;
export interface RegisteredUserQuickSightConsoleEmbeddingConfiguration {
  InitialPath?: string;
  FeatureConfigurations?: RegisteredUserConsoleFeatureConfigurations;
}
export const RegisteredUserQuickSightConsoleEmbeddingConfiguration = S.suspend(
  () =>
    S.Struct({
      InitialPath: S.optional(S.String),
      FeatureConfigurations: S.optional(
        RegisteredUserConsoleFeatureConfigurations,
      ),
    }),
).annotations({
  identifier: "RegisteredUserQuickSightConsoleEmbeddingConfiguration",
}) as any as S.Schema<RegisteredUserQuickSightConsoleEmbeddingConfiguration>;
export interface RegisteredUserQSearchBarEmbeddingConfiguration {
  InitialTopicId?: string;
}
export const RegisteredUserQSearchBarEmbeddingConfiguration = S.suspend(() =>
  S.Struct({ InitialTopicId: S.optional(S.String) }),
).annotations({
  identifier: "RegisteredUserQSearchBarEmbeddingConfiguration",
}) as any as S.Schema<RegisteredUserQSearchBarEmbeddingConfiguration>;
export interface DashboardVisualId {
  DashboardId: string;
  SheetId: string;
  VisualId: string;
}
export const DashboardVisualId = S.suspend(() =>
  S.Struct({ DashboardId: S.String, SheetId: S.String, VisualId: S.String }),
).annotations({
  identifier: "DashboardVisualId",
}) as any as S.Schema<DashboardVisualId>;
export interface RegisteredUserDashboardVisualEmbeddingConfiguration {
  InitialDashboardVisualId: DashboardVisualId;
}
export const RegisteredUserDashboardVisualEmbeddingConfiguration = S.suspend(
  () => S.Struct({ InitialDashboardVisualId: DashboardVisualId }),
).annotations({
  identifier: "RegisteredUserDashboardVisualEmbeddingConfiguration",
}) as any as S.Schema<RegisteredUserDashboardVisualEmbeddingConfiguration>;
export interface RegisteredUserGenerativeQnAEmbeddingConfiguration {
  InitialTopicId?: string;
}
export const RegisteredUserGenerativeQnAEmbeddingConfiguration = S.suspend(() =>
  S.Struct({ InitialTopicId: S.optional(S.String) }),
).annotations({
  identifier: "RegisteredUserGenerativeQnAEmbeddingConfiguration",
}) as any as S.Schema<RegisteredUserGenerativeQnAEmbeddingConfiguration>;
export interface RegisteredUserQuickChatEmbeddingConfiguration {}
export const RegisteredUserQuickChatEmbeddingConfiguration = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "RegisteredUserQuickChatEmbeddingConfiguration",
}) as any as S.Schema<RegisteredUserQuickChatEmbeddingConfiguration>;
export interface RegisteredUserEmbeddingExperienceConfiguration {
  Dashboard?: RegisteredUserDashboardEmbeddingConfiguration;
  QuickSightConsole?: RegisteredUserQuickSightConsoleEmbeddingConfiguration;
  QSearchBar?: RegisteredUserQSearchBarEmbeddingConfiguration;
  DashboardVisual?: RegisteredUserDashboardVisualEmbeddingConfiguration;
  GenerativeQnA?: RegisteredUserGenerativeQnAEmbeddingConfiguration;
  QuickChat?: RegisteredUserQuickChatEmbeddingConfiguration;
}
export const RegisteredUserEmbeddingExperienceConfiguration = S.suspend(() =>
  S.Struct({
    Dashboard: S.optional(RegisteredUserDashboardEmbeddingConfiguration),
    QuickSightConsole: S.optional(
      RegisteredUserQuickSightConsoleEmbeddingConfiguration,
    ),
    QSearchBar: S.optional(RegisteredUserQSearchBarEmbeddingConfiguration),
    DashboardVisual: S.optional(
      RegisteredUserDashboardVisualEmbeddingConfiguration,
    ),
    GenerativeQnA: S.optional(
      RegisteredUserGenerativeQnAEmbeddingConfiguration,
    ),
    QuickChat: S.optional(RegisteredUserQuickChatEmbeddingConfiguration),
  }),
).annotations({
  identifier: "RegisteredUserEmbeddingExperienceConfiguration",
}) as any as S.Schema<RegisteredUserEmbeddingExperienceConfiguration>;
export interface GenerateEmbedUrlForRegisteredUserWithIdentityRequest {
  AwsAccountId: string;
  SessionLifetimeInMinutes?: number;
  ExperienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration;
  AllowedDomains?: string[];
}
export const GenerateEmbedUrlForRegisteredUserWithIdentityRequest = S.suspend(
  () =>
    S.Struct({
      AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
      SessionLifetimeInMinutes: S.optional(S.Number),
      ExperienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration,
      AllowedDomains: S.optional(StringList),
    }).pipe(
      T.all(
        T.Http({
          method: "POST",
          uri: "/accounts/{AwsAccountId}/embed-url/registered-user-with-identity",
        }),
        svc,
        auth,
        proto,
        ver,
        rules,
      ),
    ),
).annotations({
  identifier: "GenerateEmbedUrlForRegisteredUserWithIdentityRequest",
}) as any as S.Schema<GenerateEmbedUrlForRegisteredUserWithIdentityRequest>;
export interface GetDashboardEmbedUrlRequest {
  AwsAccountId: string;
  DashboardId: string;
  IdentityType: EmbeddingIdentityType;
  SessionLifetimeInMinutes?: number;
  UndoRedoDisabled?: boolean;
  ResetDisabled?: boolean;
  StatePersistenceEnabled?: boolean;
  UserArn?: string;
  Namespace?: string;
  AdditionalDashboardIds?: string[];
}
export const GetDashboardEmbedUrlRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    IdentityType: EmbeddingIdentityType.pipe(T.HttpQuery("creds-type")),
    SessionLifetimeInMinutes: S.optional(S.Number).pipe(
      T.HttpQuery("session-lifetime"),
    ),
    UndoRedoDisabled: S.optional(S.Boolean).pipe(
      T.HttpQuery("undo-redo-disabled"),
    ),
    ResetDisabled: S.optional(S.Boolean).pipe(T.HttpQuery("reset-disabled")),
    StatePersistenceEnabled: S.optional(S.Boolean).pipe(
      T.HttpQuery("state-persistence-enabled"),
    ),
    UserArn: S.optional(S.String).pipe(T.HttpQuery("user-arn")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
    AdditionalDashboardIds: S.optional(AdditionalDashboardIdList).pipe(
      T.HttpQuery("additional-dashboard-ids"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/embed-url",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetDashboardEmbedUrlRequest",
}) as any as S.Schema<GetDashboardEmbedUrlRequest>;
export interface GetFlowMetadataInput {
  AwsAccountId: string;
  FlowId: string;
}
export const GetFlowMetadataInput = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FlowId: S.String.pipe(T.HttpLabel("FlowId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/flows/{FlowId}/metadata",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetFlowMetadataInput",
}) as any as S.Schema<GetFlowMetadataInput>;
export interface GetFlowPermissionsInput {
  AwsAccountId: string;
  FlowId: string;
}
export const GetFlowPermissionsInput = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FlowId: S.String.pipe(T.HttpLabel("FlowId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/flows/{FlowId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetFlowPermissionsInput",
}) as any as S.Schema<GetFlowPermissionsInput>;
export interface GetSessionEmbedUrlRequest {
  AwsAccountId: string;
  EntryPoint?: string;
  SessionLifetimeInMinutes?: number;
  UserArn?: string;
}
export const GetSessionEmbedUrlRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    EntryPoint: S.optional(S.String).pipe(T.HttpQuery("entry-point")),
    SessionLifetimeInMinutes: S.optional(S.Number).pipe(
      T.HttpQuery("session-lifetime"),
    ),
    UserArn: S.optional(S.String).pipe(T.HttpQuery("user-arn")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/session-embed-url",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetSessionEmbedUrlRequest",
}) as any as S.Schema<GetSessionEmbedUrlRequest>;
export interface ListActionConnectorsRequest {
  AwsAccountId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListActionConnectorsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/action-connectors",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListActionConnectorsRequest",
}) as any as S.Schema<ListActionConnectorsRequest>;
export interface ListAnalysesRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAnalysesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/analyses" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAnalysesRequest",
}) as any as S.Schema<ListAnalysesRequest>;
export interface ListAssetBundleExportJobsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAssetBundleExportJobsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/asset-bundle-export-jobs",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAssetBundleExportJobsRequest",
}) as any as S.Schema<ListAssetBundleExportJobsRequest>;
export interface ListAssetBundleImportJobsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListAssetBundleImportJobsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/asset-bundle-import-jobs",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListAssetBundleImportJobsRequest",
}) as any as S.Schema<ListAssetBundleImportJobsRequest>;
export interface ListBrandsRequest {
  AwsAccountId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListBrandsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/brands" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListBrandsRequest",
}) as any as S.Schema<ListBrandsRequest>;
export interface ListCustomPermissionsRequest {
  AwsAccountId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListCustomPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/custom-permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListCustomPermissionsRequest",
}) as any as S.Schema<ListCustomPermissionsRequest>;
export interface ListDashboardsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListDashboardsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/dashboards" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDashboardsRequest",
}) as any as S.Schema<ListDashboardsRequest>;
export interface ListDashboardVersionsRequest {
  AwsAccountId: string;
  DashboardId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListDashboardVersionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDashboardVersionsRequest",
}) as any as S.Schema<ListDashboardVersionsRequest>;
export interface ListDataSetsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataSetsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/data-sets" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDataSetsRequest",
}) as any as S.Schema<ListDataSetsRequest>;
export interface ListDataSourcesRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListDataSourcesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/data-sources" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListDataSourcesRequest",
}) as any as S.Schema<ListDataSourcesRequest>;
export interface ListFlowsInput {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListFlowsInput = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/flows" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListFlowsInput",
}) as any as S.Schema<ListFlowsInput>;
export interface ListFolderMembersRequest {
  AwsAccountId: string;
  FolderId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListFolderMembersRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}/members",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListFolderMembersRequest",
}) as any as S.Schema<ListFolderMembersRequest>;
export interface ListFoldersRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListFoldersRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/folders" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListFoldersRequest",
}) as any as S.Schema<ListFoldersRequest>;
export interface ListFoldersForResourceRequest {
  AwsAccountId: string;
  ResourceArn: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListFoldersForResourceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ResourceArn: S.String.pipe(T.HttpLabel("ResourceArn")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/resource/{ResourceArn}/folders",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListFoldersForResourceRequest",
}) as any as S.Schema<ListFoldersForResourceRequest>;
export interface ListGroupMembershipsRequest {
  GroupName: string;
  NextToken?: string;
  MaxResults?: number;
  AwsAccountId: string;
  Namespace: string;
}
export const ListGroupMembershipsRequest = S.suspend(() =>
  S.Struct({
    GroupName: S.String.pipe(T.HttpLabel("GroupName")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListGroupMembershipsRequest",
}) as any as S.Schema<ListGroupMembershipsRequest>;
export interface ListGroupsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
  Namespace: string;
}
export const ListGroupsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListGroupsRequest",
}) as any as S.Schema<ListGroupsRequest>;
export interface ListIAMPolicyAssignmentsRequest {
  AwsAccountId: string;
  AssignmentStatus?: AssignmentStatus;
  Namespace: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListIAMPolicyAssignmentsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssignmentStatus: S.optional(AssignmentStatus).pipe(
      T.HttpQuery("assignment-status"),
    ),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/v2/iam-policy-assignments",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListIAMPolicyAssignmentsRequest",
}) as any as S.Schema<ListIAMPolicyAssignmentsRequest>;
export interface ListIAMPolicyAssignmentsForUserRequest {
  AwsAccountId: string;
  UserName: string;
  NextToken?: string;
  MaxResults?: number;
  Namespace: string;
}
export const ListIAMPolicyAssignmentsForUserRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    UserName: S.String.pipe(T.HttpLabel("UserName")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}/iam-policy-assignments",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListIAMPolicyAssignmentsForUserRequest",
}) as any as S.Schema<ListIAMPolicyAssignmentsForUserRequest>;
export interface ListIdentityPropagationConfigsRequest {
  AwsAccountId: string;
  MaxResults?: number;
  NextToken?: string;
}
export const ListIdentityPropagationConfigsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/identity-propagation-config",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListIdentityPropagationConfigsRequest",
}) as any as S.Schema<ListIdentityPropagationConfigsRequest>;
export interface ListIngestionsRequest {
  DataSetId: string;
  NextToken?: string;
  AwsAccountId: string;
  MaxResults?: number;
}
export const ListIngestionsRequest = S.suspend(() =>
  S.Struct({
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListIngestionsRequest",
}) as any as S.Schema<ListIngestionsRequest>;
export interface ListNamespacesRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListNamespacesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/namespaces" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListNamespacesRequest",
}) as any as S.Schema<ListNamespacesRequest>;
export interface ListRefreshSchedulesRequest {
  AwsAccountId: string;
  DataSetId: string;
}
export const ListRefreshSchedulesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-schedules",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListRefreshSchedulesRequest",
}) as any as S.Schema<ListRefreshSchedulesRequest>;
export interface ListRoleMembershipsRequest {
  Role: Role;
  NextToken?: string;
  MaxResults?: number;
  AwsAccountId: string;
  Namespace: string;
}
export const ListRoleMembershipsRequest = S.suspend(() =>
  S.Struct({
    Role: Role.pipe(T.HttpLabel("Role")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/roles/{Role}/members",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListRoleMembershipsRequest",
}) as any as S.Schema<ListRoleMembershipsRequest>;
export interface ListSelfUpgradesRequest {
  AwsAccountId: string;
  Namespace: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListSelfUpgradesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/self-upgrade-requests",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListSelfUpgradesRequest",
}) as any as S.Schema<ListSelfUpgradesRequest>;
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}
export const ListTagsForResourceRequest = S.suspend(() =>
  S.Struct({ ResourceArn: S.String.pipe(T.HttpLabel("ResourceArn")) }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/resources/{ResourceArn}/tags" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTagsForResourceRequest",
}) as any as S.Schema<ListTagsForResourceRequest>;
export interface ListTemplateAliasesRequest {
  AwsAccountId: string;
  TemplateId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTemplateAliasesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-result")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTemplateAliasesRequest",
}) as any as S.Schema<ListTemplateAliasesRequest>;
export interface ListTemplatesRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTemplatesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-result")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/templates" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTemplatesRequest",
}) as any as S.Schema<ListTemplatesRequest>;
export interface ListTemplateVersionsRequest {
  AwsAccountId: string;
  TemplateId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTemplateVersionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTemplateVersionsRequest",
}) as any as S.Schema<ListTemplateVersionsRequest>;
export interface ListThemeAliasesRequest {
  AwsAccountId: string;
  ThemeId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListThemeAliasesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-result")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/aliases",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListThemeAliasesRequest",
}) as any as S.Schema<ListThemeAliasesRequest>;
export interface ListThemesRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
  Type?: ThemeType;
}
export const ListThemesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    Type: S.optional(ThemeType).pipe(T.HttpQuery("type")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/themes" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListThemesRequest",
}) as any as S.Schema<ListThemesRequest>;
export interface ListThemeVersionsRequest {
  AwsAccountId: string;
  ThemeId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListThemeVersionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/versions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListThemeVersionsRequest",
}) as any as S.Schema<ListThemeVersionsRequest>;
export interface ListTopicRefreshSchedulesRequest {
  AwsAccountId: string;
  TopicId: string;
}
export const ListTopicRefreshSchedulesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/schedules",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTopicRefreshSchedulesRequest",
}) as any as S.Schema<ListTopicRefreshSchedulesRequest>;
export interface ListTopicReviewedAnswersRequest {
  AwsAccountId: string;
  TopicId: string;
}
export const ListTopicReviewedAnswersRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/reviewed-answers",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTopicReviewedAnswersRequest",
}) as any as S.Schema<ListTopicReviewedAnswersRequest>;
export interface ListTopicsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListTopicsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({ method: "GET", uri: "/accounts/{AwsAccountId}/topics" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListTopicsRequest",
}) as any as S.Schema<ListTopicsRequest>;
export interface ListUserGroupsRequest {
  UserName: string;
  AwsAccountId: string;
  Namespace: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListUserGroupsRequest = S.suspend(() =>
  S.Struct({
    UserName: S.String.pipe(T.HttpLabel("UserName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}/groups",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListUserGroupsRequest",
}) as any as S.Schema<ListUserGroupsRequest>;
export interface ListUsersRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
  Namespace: string;
}
export const ListUsersRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListUsersRequest",
}) as any as S.Schema<ListUsersRequest>;
export interface ListVPCConnectionsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
}
export const ListVPCConnectionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
  }).pipe(
    T.all(
      T.Http({
        method: "GET",
        uri: "/accounts/{AwsAccountId}/vpc-connections",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "ListVPCConnectionsRequest",
}) as any as S.Schema<ListVPCConnectionsRequest>;
export interface PredictQAResultsRequest {
  AwsAccountId: string;
  QueryText: string | redacted.Redacted<string>;
  IncludeQuickSightQIndex?: IncludeQuickSightQIndex;
  IncludeGeneratedAnswer?: IncludeGeneratedAnswer;
  MaxTopicsToConsider?: number;
}
export const PredictQAResultsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    QueryText: SensitiveString,
    IncludeQuickSightQIndex: S.optional(IncludeQuickSightQIndex),
    IncludeGeneratedAnswer: S.optional(IncludeGeneratedAnswer),
    MaxTopicsToConsider: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/accounts/{AwsAccountId}/qa/predict" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "PredictQAResultsRequest",
}) as any as S.Schema<PredictQAResultsRequest>;
export interface RegisterUserRequest {
  IdentityType: IdentityType;
  Email: string;
  UserRole: UserRole;
  IamArn?: string;
  SessionName?: string;
  AwsAccountId: string;
  Namespace: string;
  UserName?: string;
  CustomPermissionsName?: string;
  ExternalLoginFederationProviderType?: string;
  CustomFederationProviderUrl?: string;
  ExternalLoginId?: string;
  Tags?: Tag[];
}
export const RegisterUserRequest = S.suspend(() =>
  S.Struct({
    IdentityType: IdentityType,
    Email: S.String,
    UserRole: UserRole,
    IamArn: S.optional(S.String),
    SessionName: S.optional(S.String),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    UserName: S.optional(S.String),
    CustomPermissionsName: S.optional(S.String),
    ExternalLoginFederationProviderType: S.optional(S.String),
    CustomFederationProviderUrl: S.optional(S.String),
    ExternalLoginId: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "RegisterUserRequest",
}) as any as S.Schema<RegisterUserRequest>;
export interface RestoreAnalysisRequest {
  AwsAccountId: string;
  AnalysisId: string;
  RestoreToFolders?: boolean;
}
export const RestoreAnalysisRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
    RestoreToFolders: S.optional(S.Boolean).pipe(
      T.HttpQuery("restore-to-folders"),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/restore/analyses/{AnalysisId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "RestoreAnalysisRequest",
}) as any as S.Schema<RestoreAnalysisRequest>;
export interface StartDashboardSnapshotJobScheduleRequest {
  AwsAccountId: string;
  DashboardId: string;
  ScheduleId: string;
}
export const StartDashboardSnapshotJobScheduleRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    ScheduleId: S.String.pipe(T.HttpLabel("ScheduleId")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/schedules/{ScheduleId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartDashboardSnapshotJobScheduleRequest",
}) as any as S.Schema<StartDashboardSnapshotJobScheduleRequest>;
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: Tag[];
}
export const TagResourceRequest = S.suspend(() =>
  S.Struct({
    ResourceArn: S.String.pipe(T.HttpLabel("ResourceArn")),
    Tags: TagList,
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/resources/{ResourceArn}/tags" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "TagResourceRequest",
}) as any as S.Schema<TagResourceRequest>;
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}
export const UntagResourceRequest = S.suspend(() =>
  S.Struct({
    ResourceArn: S.String.pipe(T.HttpLabel("ResourceArn")),
    TagKeys: TagKeyList.pipe(T.HttpQuery("keys")),
  }).pipe(
    T.all(
      T.Http({ method: "DELETE", uri: "/resources/{ResourceArn}/tags" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UntagResourceRequest",
}) as any as S.Schema<UntagResourceRequest>;
export interface AccountCustomization {
  DefaultTheme?: string;
  DefaultEmailCustomizationTemplate?: string;
}
export const AccountCustomization = S.suspend(() =>
  S.Struct({
    DefaultTheme: S.optional(S.String),
    DefaultEmailCustomizationTemplate: S.optional(S.String),
  }),
).annotations({
  identifier: "AccountCustomization",
}) as any as S.Schema<AccountCustomization>;
export interface UpdateAccountCustomizationRequest {
  AwsAccountId: string;
  Namespace?: string;
  AccountCustomization: AccountCustomization;
}
export const UpdateAccountCustomizationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
    AccountCustomization: AccountCustomization,
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/accounts/{AwsAccountId}/customizations" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateAccountCustomizationRequest",
}) as any as S.Schema<UpdateAccountCustomizationRequest>;
export interface UpdateAccountCustomPermissionRequest {
  CustomPermissionsName: string;
  AwsAccountId: string;
}
export const UpdateAccountCustomPermissionRequest = S.suspend(() =>
  S.Struct({
    CustomPermissionsName: S.String,
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateAccountCustomPermissionRequest",
}) as any as S.Schema<UpdateAccountCustomPermissionRequest>;
export interface UpdateAccountSettingsRequest {
  AwsAccountId: string;
  DefaultNamespace: string;
  NotificationEmail?: string;
  TerminationProtectionEnabled?: boolean;
}
export const UpdateAccountSettingsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DefaultNamespace: S.String,
    NotificationEmail: S.optional(S.String),
    TerminationProtectionEnabled: S.optional(S.Boolean),
  }).pipe(
    T.all(
      T.Http({ method: "PUT", uri: "/accounts/{AwsAccountId}/settings" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateAccountSettingsRequest",
}) as any as S.Schema<UpdateAccountSettingsRequest>;
export type ConnectionAuthType =
  | "BASIC"
  | "API_KEY"
  | "OAUTH2_CLIENT_CREDENTIALS"
  | "NONE"
  | "IAM"
  | "OAUTH2_AUTHORIZATION_CODE";
export const ConnectionAuthType = S.Literal(
  "BASIC",
  "API_KEY",
  "OAUTH2_CLIENT_CREDENTIALS",
  "NONE",
  "IAM",
  "OAUTH2_AUTHORIZATION_CODE",
);
export type AuthorizationCodeGrantCredentialsSource = "PLAIN_CREDENTIALS";
export const AuthorizationCodeGrantCredentialsSource =
  S.Literal("PLAIN_CREDENTIALS");
export interface AuthorizationCodeGrantDetails {
  ClientId: string;
  ClientSecret: string | redacted.Redacted<string>;
  TokenEndpoint: string;
  AuthorizationEndpoint: string;
}
export const AuthorizationCodeGrantDetails = S.suspend(() =>
  S.Struct({
    ClientId: S.String,
    ClientSecret: SensitiveString,
    TokenEndpoint: S.String,
    AuthorizationEndpoint: S.String,
  }),
).annotations({
  identifier: "AuthorizationCodeGrantDetails",
}) as any as S.Schema<AuthorizationCodeGrantDetails>;
export type AuthorizationCodeGrantCredentialsDetails = {
  AuthorizationCodeGrantDetails: AuthorizationCodeGrantDetails;
};
export const AuthorizationCodeGrantCredentialsDetails = S.Union(
  S.Struct({ AuthorizationCodeGrantDetails: AuthorizationCodeGrantDetails }),
);
export interface AuthorizationCodeGrantMetadata {
  BaseEndpoint: string;
  RedirectUrl: string;
  AuthorizationCodeGrantCredentialsSource?: AuthorizationCodeGrantCredentialsSource;
  AuthorizationCodeGrantCredentialsDetails?: AuthorizationCodeGrantCredentialsDetails;
}
export const AuthorizationCodeGrantMetadata = S.suspend(() =>
  S.Struct({
    BaseEndpoint: S.String,
    RedirectUrl: S.String,
    AuthorizationCodeGrantCredentialsSource: S.optional(
      AuthorizationCodeGrantCredentialsSource,
    ),
    AuthorizationCodeGrantCredentialsDetails: S.optional(
      AuthorizationCodeGrantCredentialsDetails,
    ),
  }),
).annotations({
  identifier: "AuthorizationCodeGrantMetadata",
}) as any as S.Schema<AuthorizationCodeGrantMetadata>;
export type ClientCredentialsSource = "PLAIN_CREDENTIALS";
export const ClientCredentialsSource = S.Literal("PLAIN_CREDENTIALS");
export interface ClientCredentialsGrantDetails {
  ClientId: string;
  ClientSecret: string | redacted.Redacted<string>;
  TokenEndpoint: string;
}
export const ClientCredentialsGrantDetails = S.suspend(() =>
  S.Struct({
    ClientId: S.String,
    ClientSecret: SensitiveString,
    TokenEndpoint: S.String,
  }),
).annotations({
  identifier: "ClientCredentialsGrantDetails",
}) as any as S.Schema<ClientCredentialsGrantDetails>;
export type ClientCredentialsDetails = {
  ClientCredentialsGrantDetails: ClientCredentialsGrantDetails;
};
export const ClientCredentialsDetails = S.Union(
  S.Struct({ ClientCredentialsGrantDetails: ClientCredentialsGrantDetails }),
);
export interface ClientCredentialsGrantMetadata {
  BaseEndpoint: string;
  ClientCredentialsSource?: ClientCredentialsSource;
  ClientCredentialsDetails?: ClientCredentialsDetails;
}
export const ClientCredentialsGrantMetadata = S.suspend(() =>
  S.Struct({
    BaseEndpoint: S.String,
    ClientCredentialsSource: S.optional(ClientCredentialsSource),
    ClientCredentialsDetails: S.optional(ClientCredentialsDetails),
  }),
).annotations({
  identifier: "ClientCredentialsGrantMetadata",
}) as any as S.Schema<ClientCredentialsGrantMetadata>;
export interface BasicAuthConnectionMetadata {
  BaseEndpoint: string;
  Username: string | redacted.Redacted<string>;
  Password: string | redacted.Redacted<string>;
}
export const BasicAuthConnectionMetadata = S.suspend(() =>
  S.Struct({
    BaseEndpoint: S.String,
    Username: SensitiveString,
    Password: SensitiveString,
  }),
).annotations({
  identifier: "BasicAuthConnectionMetadata",
}) as any as S.Schema<BasicAuthConnectionMetadata>;
export interface APIKeyConnectionMetadata {
  BaseEndpoint: string;
  ApiKey: string | redacted.Redacted<string>;
  Email?: string | redacted.Redacted<string>;
}
export const APIKeyConnectionMetadata = S.suspend(() =>
  S.Struct({
    BaseEndpoint: S.String,
    ApiKey: SensitiveString,
    Email: S.optional(SensitiveString),
  }),
).annotations({
  identifier: "APIKeyConnectionMetadata",
}) as any as S.Schema<APIKeyConnectionMetadata>;
export interface NoneConnectionMetadata {
  BaseEndpoint: string;
}
export const NoneConnectionMetadata = S.suspend(() =>
  S.Struct({ BaseEndpoint: S.String }),
).annotations({
  identifier: "NoneConnectionMetadata",
}) as any as S.Schema<NoneConnectionMetadata>;
export interface IAMConnectionMetadata {
  RoleArn: string;
}
export const IAMConnectionMetadata = S.suspend(() =>
  S.Struct({ RoleArn: S.String }),
).annotations({
  identifier: "IAMConnectionMetadata",
}) as any as S.Schema<IAMConnectionMetadata>;
export type AuthenticationMetadata =
  | { AuthorizationCodeGrantMetadata: AuthorizationCodeGrantMetadata }
  | { ClientCredentialsGrantMetadata: ClientCredentialsGrantMetadata }
  | { BasicAuthConnectionMetadata: BasicAuthConnectionMetadata }
  | { ApiKeyConnectionMetadata: APIKeyConnectionMetadata }
  | { NoneConnectionMetadata: NoneConnectionMetadata }
  | { IamConnectionMetadata: IAMConnectionMetadata };
export const AuthenticationMetadata = S.Union(
  S.Struct({ AuthorizationCodeGrantMetadata: AuthorizationCodeGrantMetadata }),
  S.Struct({ ClientCredentialsGrantMetadata: ClientCredentialsGrantMetadata }),
  S.Struct({ BasicAuthConnectionMetadata: BasicAuthConnectionMetadata }),
  S.Struct({ ApiKeyConnectionMetadata: APIKeyConnectionMetadata }),
  S.Struct({ NoneConnectionMetadata: NoneConnectionMetadata }),
  S.Struct({ IamConnectionMetadata: IAMConnectionMetadata }),
);
export interface AuthConfig {
  AuthenticationType: ConnectionAuthType;
  AuthenticationMetadata: AuthenticationMetadata;
}
export const AuthConfig = S.suspend(() =>
  S.Struct({
    AuthenticationType: ConnectionAuthType,
    AuthenticationMetadata: AuthenticationMetadata,
  }),
).annotations({ identifier: "AuthConfig" }) as any as S.Schema<AuthConfig>;
export interface UpdateActionConnectorRequest {
  AwsAccountId: string;
  ActionConnectorId: string;
  Name: string | redacted.Redacted<string>;
  AuthenticationConfig: AuthConfig;
  Description?: string | redacted.Redacted<string>;
  VpcConnectionArn?: string;
}
export const UpdateActionConnectorRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ActionConnectorId: S.String.pipe(T.HttpLabel("ActionConnectorId")),
    Name: SensitiveString,
    AuthenticationConfig: AuthConfig,
    Description: S.optional(SensitiveString),
    VpcConnectionArn: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/action-connectors/{ActionConnectorId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateActionConnectorRequest",
}) as any as S.Schema<UpdateActionConnectorRequest>;
export interface UpdateActionConnectorPermissionsRequest {
  AwsAccountId: string;
  ActionConnectorId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateActionConnectorPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ActionConnectorId: S.String.pipe(T.HttpLabel("ActionConnectorId")),
    GrantPermissions: S.optional(ResourcePermissionList),
    RevokePermissions: S.optional(ResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/action-connectors/{ActionConnectorId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateActionConnectorPermissionsRequest",
}) as any as S.Schema<UpdateActionConnectorPermissionsRequest>;
export type SensitiveStringList = string | redacted.Redacted<string>[];
export const SensitiveStringList = S.Array(SensitiveString);
export interface StringParameter {
  Name: string;
  Values: string | redacted.Redacted<string>[];
}
export const StringParameter = S.suspend(() =>
  S.Struct({ Name: S.String, Values: SensitiveStringList }),
).annotations({
  identifier: "StringParameter",
}) as any as S.Schema<StringParameter>;
export type StringParameterList = StringParameter[];
export const StringParameterList = S.Array(StringParameter);
export type SensitiveLongList = number[];
export const SensitiveLongList = S.Array(S.Number);
export interface IntegerParameter {
  Name: string;
  Values: number[];
}
export const IntegerParameter = S.suspend(() =>
  S.Struct({ Name: S.String, Values: SensitiveLongList }),
).annotations({
  identifier: "IntegerParameter",
}) as any as S.Schema<IntegerParameter>;
export type IntegerParameterList = IntegerParameter[];
export const IntegerParameterList = S.Array(IntegerParameter);
export type SensitiveDoubleList = number[];
export const SensitiveDoubleList = S.Array(S.Number);
export interface DecimalParameter {
  Name: string;
  Values: number[];
}
export const DecimalParameter = S.suspend(() =>
  S.Struct({ Name: S.String, Values: SensitiveDoubleList }),
).annotations({
  identifier: "DecimalParameter",
}) as any as S.Schema<DecimalParameter>;
export type DecimalParameterList = DecimalParameter[];
export const DecimalParameterList = S.Array(DecimalParameter);
export type SensitiveTimestampList = Date[];
export const SensitiveTimestampList = S.Array(
  S.Date.pipe(T.TimestampFormat("epoch-seconds")),
);
export interface DateTimeParameter {
  Name: string;
  Values: Date[];
}
export const DateTimeParameter = S.suspend(() =>
  S.Struct({ Name: S.String, Values: SensitiveTimestampList }),
).annotations({
  identifier: "DateTimeParameter",
}) as any as S.Schema<DateTimeParameter>;
export type DateTimeParameterList = DateTimeParameter[];
export const DateTimeParameterList = S.Array(DateTimeParameter);
export interface Parameters {
  StringParameters?: StringParameter[];
  IntegerParameters?: IntegerParameter[];
  DecimalParameters?: DecimalParameter[];
  DateTimeParameters?: DateTimeParameter[];
}
export const Parameters = S.suspend(() =>
  S.Struct({
    StringParameters: S.optional(StringParameterList),
    IntegerParameters: S.optional(IntegerParameterList),
    DecimalParameters: S.optional(DecimalParameterList),
    DateTimeParameters: S.optional(DateTimeParameterList),
  }),
).annotations({ identifier: "Parameters" }) as any as S.Schema<Parameters>;
export interface DataSetReference {
  DataSetPlaceholder: string;
  DataSetArn: string;
}
export const DataSetReference = S.suspend(() =>
  S.Struct({ DataSetPlaceholder: S.String, DataSetArn: S.String }),
).annotations({
  identifier: "DataSetReference",
}) as any as S.Schema<DataSetReference>;
export type DataSetReferenceList = DataSetReference[];
export const DataSetReferenceList = S.Array(DataSetReference);
export interface AnalysisSourceTemplate {
  DataSetReferences: DataSetReference[];
  Arn: string;
}
export const AnalysisSourceTemplate = S.suspend(() =>
  S.Struct({ DataSetReferences: DataSetReferenceList, Arn: S.String }),
).annotations({
  identifier: "AnalysisSourceTemplate",
}) as any as S.Schema<AnalysisSourceTemplate>;
export interface AnalysisSourceEntity {
  SourceTemplate?: AnalysisSourceTemplate;
}
export const AnalysisSourceEntity = S.suspend(() =>
  S.Struct({ SourceTemplate: S.optional(AnalysisSourceTemplate) }),
).annotations({
  identifier: "AnalysisSourceEntity",
}) as any as S.Schema<AnalysisSourceEntity>;
export interface DataSetIdentifierDeclaration {
  Identifier: string;
  DataSetArn: string;
}
export const DataSetIdentifierDeclaration = S.suspend(() =>
  S.Struct({ Identifier: S.String, DataSetArn: S.String }),
).annotations({
  identifier: "DataSetIdentifierDeclaration",
}) as any as S.Schema<DataSetIdentifierDeclaration>;
export type DataSetIdentifierDeclarationList = DataSetIdentifierDeclaration[];
export const DataSetIdentifierDeclarationList = S.Array(
  DataSetIdentifierDeclaration,
);
export type Visibility = "HIDDEN" | "VISIBLE";
export const Visibility = S.Literal("HIDDEN", "VISIBLE");
export type RelativeFontSize =
  | "EXTRA_SMALL"
  | "SMALL"
  | "MEDIUM"
  | "LARGE"
  | "EXTRA_LARGE";
export const RelativeFontSize = S.Literal(
  "EXTRA_SMALL",
  "SMALL",
  "MEDIUM",
  "LARGE",
  "EXTRA_LARGE",
);
export interface FontSize {
  Relative?: RelativeFontSize;
  Absolute?: string;
}
export const FontSize = S.suspend(() =>
  S.Struct({
    Relative: S.optional(RelativeFontSize),
    Absolute: S.optional(S.String),
  }),
).annotations({ identifier: "FontSize" }) as any as S.Schema<FontSize>;
export type FontDecoration = "UNDERLINE" | "NONE";
export const FontDecoration = S.Literal("UNDERLINE", "NONE");
export type FontWeightName = "NORMAL" | "BOLD";
export const FontWeightName = S.Literal("NORMAL", "BOLD");
export interface FontWeight {
  Name?: FontWeightName;
}
export const FontWeight = S.suspend(() =>
  S.Struct({ Name: S.optional(FontWeightName) }),
).annotations({ identifier: "FontWeight" }) as any as S.Schema<FontWeight>;
export type FontStyle = "NORMAL" | "ITALIC";
export const FontStyle = S.Literal("NORMAL", "ITALIC");
export interface FontConfiguration {
  FontSize?: FontSize;
  FontDecoration?: FontDecoration;
  FontColor?: string;
  FontWeight?: FontWeight;
  FontStyle?: FontStyle;
  FontFamily?: string;
}
export const FontConfiguration = S.suspend(() =>
  S.Struct({
    FontSize: S.optional(FontSize),
    FontDecoration: S.optional(FontDecoration),
    FontColor: S.optional(S.String),
    FontWeight: S.optional(FontWeight),
    FontStyle: S.optional(FontStyle),
    FontFamily: S.optional(S.String),
  }),
).annotations({
  identifier: "FontConfiguration",
}) as any as S.Schema<FontConfiguration>;
export interface LabelOptions {
  Visibility?: Visibility;
  FontConfiguration?: FontConfiguration;
  CustomLabel?: string;
}
export const LabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    FontConfiguration: S.optional(FontConfiguration),
    CustomLabel: S.optional(S.String),
  }),
).annotations({ identifier: "LabelOptions" }) as any as S.Schema<LabelOptions>;
export interface SheetControlInfoIconLabelOptions {
  Visibility?: Visibility;
  InfoIconText?: string;
}
export const SheetControlInfoIconLabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    InfoIconText: S.optional(S.String),
  }),
).annotations({
  identifier: "SheetControlInfoIconLabelOptions",
}) as any as S.Schema<SheetControlInfoIconLabelOptions>;
export interface DateTimePickerControlDisplayOptions {
  TitleOptions?: LabelOptions;
  DateTimeFormat?: string;
  InfoIconLabelOptions?: SheetControlInfoIconLabelOptions;
  HelperTextVisibility?: Visibility;
  DateIconVisibility?: Visibility;
}
export const DateTimePickerControlDisplayOptions = S.suspend(() =>
  S.Struct({
    TitleOptions: S.optional(LabelOptions),
    DateTimeFormat: S.optional(S.String),
    InfoIconLabelOptions: S.optional(SheetControlInfoIconLabelOptions),
    HelperTextVisibility: S.optional(Visibility),
    DateIconVisibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "DateTimePickerControlDisplayOptions",
}) as any as S.Schema<DateTimePickerControlDisplayOptions>;
export interface ParameterDateTimePickerControl {
  ParameterControlId: string;
  Title: string;
  SourceParameterName: string;
  DisplayOptions?: DateTimePickerControlDisplayOptions;
}
export const ParameterDateTimePickerControl = S.suspend(() =>
  S.Struct({
    ParameterControlId: S.String,
    Title: S.String,
    SourceParameterName: S.String,
    DisplayOptions: S.optional(DateTimePickerControlDisplayOptions),
  }),
).annotations({
  identifier: "ParameterDateTimePickerControl",
}) as any as S.Schema<ParameterDateTimePickerControl>;
export interface ListControlSearchOptions {
  Visibility?: Visibility;
}
export const ListControlSearchOptions = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "ListControlSearchOptions",
}) as any as S.Schema<ListControlSearchOptions>;
export interface ListControlSelectAllOptions {
  Visibility?: Visibility;
}
export const ListControlSelectAllOptions = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "ListControlSelectAllOptions",
}) as any as S.Schema<ListControlSelectAllOptions>;
export interface ListControlDisplayOptions {
  SearchOptions?: ListControlSearchOptions;
  SelectAllOptions?: ListControlSelectAllOptions;
  TitleOptions?: LabelOptions;
  InfoIconLabelOptions?: SheetControlInfoIconLabelOptions;
}
export const ListControlDisplayOptions = S.suspend(() =>
  S.Struct({
    SearchOptions: S.optional(ListControlSearchOptions),
    SelectAllOptions: S.optional(ListControlSelectAllOptions),
    TitleOptions: S.optional(LabelOptions),
    InfoIconLabelOptions: S.optional(SheetControlInfoIconLabelOptions),
  }),
).annotations({
  identifier: "ListControlDisplayOptions",
}) as any as S.Schema<ListControlDisplayOptions>;
export type SheetControlListType = "MULTI_SELECT" | "SINGLE_SELECT";
export const SheetControlListType = S.Literal("MULTI_SELECT", "SINGLE_SELECT");
export type ParameterSelectableValueList = string[];
export const ParameterSelectableValueList = S.Array(S.String);
export interface ColumnIdentifier {
  DataSetIdentifier: string;
  ColumnName: string;
}
export const ColumnIdentifier = S.suspend(() =>
  S.Struct({ DataSetIdentifier: S.String, ColumnName: S.String }),
).annotations({
  identifier: "ColumnIdentifier",
}) as any as S.Schema<ColumnIdentifier>;
export interface ParameterSelectableValues {
  Values?: string[];
  LinkToDataSetColumn?: ColumnIdentifier;
}
export const ParameterSelectableValues = S.suspend(() =>
  S.Struct({
    Values: S.optional(ParameterSelectableValueList),
    LinkToDataSetColumn: S.optional(ColumnIdentifier),
  }),
).annotations({
  identifier: "ParameterSelectableValues",
}) as any as S.Schema<ParameterSelectableValues>;
export interface CascadingControlSource {
  SourceSheetControlId?: string;
  ColumnToMatch?: ColumnIdentifier;
}
export const CascadingControlSource = S.suspend(() =>
  S.Struct({
    SourceSheetControlId: S.optional(S.String),
    ColumnToMatch: S.optional(ColumnIdentifier),
  }),
).annotations({
  identifier: "CascadingControlSource",
}) as any as S.Schema<CascadingControlSource>;
export type CascadingControlSourceList = CascadingControlSource[];
export const CascadingControlSourceList = S.Array(CascadingControlSource);
export interface CascadingControlConfiguration {
  SourceControls?: CascadingControlSource[];
}
export const CascadingControlConfiguration = S.suspend(() =>
  S.Struct({ SourceControls: S.optional(CascadingControlSourceList) }),
).annotations({
  identifier: "CascadingControlConfiguration",
}) as any as S.Schema<CascadingControlConfiguration>;
export interface ParameterListControl {
  ParameterControlId: string;
  Title: string;
  SourceParameterName: string;
  DisplayOptions?: ListControlDisplayOptions;
  Type?: SheetControlListType;
  SelectableValues?: ParameterSelectableValues;
  CascadingControlConfiguration?: CascadingControlConfiguration;
}
export const ParameterListControl = S.suspend(() =>
  S.Struct({
    ParameterControlId: S.String,
    Title: S.String,
    SourceParameterName: S.String,
    DisplayOptions: S.optional(ListControlDisplayOptions),
    Type: S.optional(SheetControlListType),
    SelectableValues: S.optional(ParameterSelectableValues),
    CascadingControlConfiguration: S.optional(CascadingControlConfiguration),
  }),
).annotations({
  identifier: "ParameterListControl",
}) as any as S.Schema<ParameterListControl>;
export interface DropDownControlDisplayOptions {
  SelectAllOptions?: ListControlSelectAllOptions;
  TitleOptions?: LabelOptions;
  InfoIconLabelOptions?: SheetControlInfoIconLabelOptions;
}
export const DropDownControlDisplayOptions = S.suspend(() =>
  S.Struct({
    SelectAllOptions: S.optional(ListControlSelectAllOptions),
    TitleOptions: S.optional(LabelOptions),
    InfoIconLabelOptions: S.optional(SheetControlInfoIconLabelOptions),
  }),
).annotations({
  identifier: "DropDownControlDisplayOptions",
}) as any as S.Schema<DropDownControlDisplayOptions>;
export type CommitMode = "AUTO" | "MANUAL";
export const CommitMode = S.Literal("AUTO", "MANUAL");
export interface ParameterDropDownControl {
  ParameterControlId: string;
  Title: string;
  SourceParameterName: string;
  DisplayOptions?: DropDownControlDisplayOptions;
  Type?: SheetControlListType;
  SelectableValues?: ParameterSelectableValues;
  CascadingControlConfiguration?: CascadingControlConfiguration;
  CommitMode?: CommitMode;
}
export const ParameterDropDownControl = S.suspend(() =>
  S.Struct({
    ParameterControlId: S.String,
    Title: S.String,
    SourceParameterName: S.String,
    DisplayOptions: S.optional(DropDownControlDisplayOptions),
    Type: S.optional(SheetControlListType),
    SelectableValues: S.optional(ParameterSelectableValues),
    CascadingControlConfiguration: S.optional(CascadingControlConfiguration),
    CommitMode: S.optional(CommitMode),
  }),
).annotations({
  identifier: "ParameterDropDownControl",
}) as any as S.Schema<ParameterDropDownControl>;
export interface TextControlPlaceholderOptions {
  Visibility?: Visibility;
}
export const TextControlPlaceholderOptions = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "TextControlPlaceholderOptions",
}) as any as S.Schema<TextControlPlaceholderOptions>;
export interface TextFieldControlDisplayOptions {
  TitleOptions?: LabelOptions;
  PlaceholderOptions?: TextControlPlaceholderOptions;
  InfoIconLabelOptions?: SheetControlInfoIconLabelOptions;
}
export const TextFieldControlDisplayOptions = S.suspend(() =>
  S.Struct({
    TitleOptions: S.optional(LabelOptions),
    PlaceholderOptions: S.optional(TextControlPlaceholderOptions),
    InfoIconLabelOptions: S.optional(SheetControlInfoIconLabelOptions),
  }),
).annotations({
  identifier: "TextFieldControlDisplayOptions",
}) as any as S.Schema<TextFieldControlDisplayOptions>;
export interface ParameterTextFieldControl {
  ParameterControlId: string;
  Title: string;
  SourceParameterName: string;
  DisplayOptions?: TextFieldControlDisplayOptions;
}
export const ParameterTextFieldControl = S.suspend(() =>
  S.Struct({
    ParameterControlId: S.String,
    Title: S.String,
    SourceParameterName: S.String,
    DisplayOptions: S.optional(TextFieldControlDisplayOptions),
  }),
).annotations({
  identifier: "ParameterTextFieldControl",
}) as any as S.Schema<ParameterTextFieldControl>;
export interface TextAreaControlDisplayOptions {
  TitleOptions?: LabelOptions;
  PlaceholderOptions?: TextControlPlaceholderOptions;
  InfoIconLabelOptions?: SheetControlInfoIconLabelOptions;
}
export const TextAreaControlDisplayOptions = S.suspend(() =>
  S.Struct({
    TitleOptions: S.optional(LabelOptions),
    PlaceholderOptions: S.optional(TextControlPlaceholderOptions),
    InfoIconLabelOptions: S.optional(SheetControlInfoIconLabelOptions),
  }),
).annotations({
  identifier: "TextAreaControlDisplayOptions",
}) as any as S.Schema<TextAreaControlDisplayOptions>;
export interface ParameterTextAreaControl {
  ParameterControlId: string;
  Title: string;
  SourceParameterName: string;
  Delimiter?: string;
  DisplayOptions?: TextAreaControlDisplayOptions;
}
export const ParameterTextAreaControl = S.suspend(() =>
  S.Struct({
    ParameterControlId: S.String,
    Title: S.String,
    SourceParameterName: S.String,
    Delimiter: S.optional(S.String),
    DisplayOptions: S.optional(TextAreaControlDisplayOptions),
  }),
).annotations({
  identifier: "ParameterTextAreaControl",
}) as any as S.Schema<ParameterTextAreaControl>;
export interface SliderControlDisplayOptions {
  TitleOptions?: LabelOptions;
  InfoIconLabelOptions?: SheetControlInfoIconLabelOptions;
}
export const SliderControlDisplayOptions = S.suspend(() =>
  S.Struct({
    TitleOptions: S.optional(LabelOptions),
    InfoIconLabelOptions: S.optional(SheetControlInfoIconLabelOptions),
  }),
).annotations({
  identifier: "SliderControlDisplayOptions",
}) as any as S.Schema<SliderControlDisplayOptions>;
export interface ParameterSliderControl {
  ParameterControlId: string;
  Title: string;
  SourceParameterName: string;
  DisplayOptions?: SliderControlDisplayOptions;
  MaximumValue: number;
  MinimumValue: number;
  StepSize: number;
}
export const ParameterSliderControl = S.suspend(() =>
  S.Struct({
    ParameterControlId: S.String,
    Title: S.String,
    SourceParameterName: S.String,
    DisplayOptions: S.optional(SliderControlDisplayOptions),
    MaximumValue: S.Number,
    MinimumValue: S.Number,
    StepSize: S.Number,
  }),
).annotations({
  identifier: "ParameterSliderControl",
}) as any as S.Schema<ParameterSliderControl>;
export interface ParameterControl {
  DateTimePicker?: ParameterDateTimePickerControl;
  List?: ParameterListControl;
  Dropdown?: ParameterDropDownControl;
  TextField?: ParameterTextFieldControl;
  TextArea?: ParameterTextAreaControl;
  Slider?: ParameterSliderControl;
}
export const ParameterControl = S.suspend(() =>
  S.Struct({
    DateTimePicker: S.optional(ParameterDateTimePickerControl),
    List: S.optional(ParameterListControl),
    Dropdown: S.optional(ParameterDropDownControl),
    TextField: S.optional(ParameterTextFieldControl),
    TextArea: S.optional(ParameterTextAreaControl),
    Slider: S.optional(ParameterSliderControl),
  }),
).annotations({
  identifier: "ParameterControl",
}) as any as S.Schema<ParameterControl>;
export type ParameterControlList = ParameterControl[];
export const ParameterControlList = S.Array(ParameterControl);
export type SheetControlDateTimePickerType = "SINGLE_VALUED" | "DATE_RANGE";
export const SheetControlDateTimePickerType = S.Literal(
  "SINGLE_VALUED",
  "DATE_RANGE",
);
export interface FilterDateTimePickerControl {
  FilterControlId: string;
  Title: string;
  SourceFilterId: string;
  DisplayOptions?: DateTimePickerControlDisplayOptions;
  Type?: SheetControlDateTimePickerType;
  CommitMode?: CommitMode;
}
export const FilterDateTimePickerControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    Title: S.String,
    SourceFilterId: S.String,
    DisplayOptions: S.optional(DateTimePickerControlDisplayOptions),
    Type: S.optional(SheetControlDateTimePickerType),
    CommitMode: S.optional(CommitMode),
  }),
).annotations({
  identifier: "FilterDateTimePickerControl",
}) as any as S.Schema<FilterDateTimePickerControl>;
export interface FilterSelectableValues {
  Values?: string[];
}
export const FilterSelectableValues = S.suspend(() =>
  S.Struct({ Values: S.optional(ParameterSelectableValueList) }),
).annotations({
  identifier: "FilterSelectableValues",
}) as any as S.Schema<FilterSelectableValues>;
export interface FilterListControl {
  FilterControlId: string;
  Title: string;
  SourceFilterId: string;
  DisplayOptions?: ListControlDisplayOptions;
  Type?: SheetControlListType;
  SelectableValues?: FilterSelectableValues;
  CascadingControlConfiguration?: CascadingControlConfiguration;
}
export const FilterListControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    Title: S.String,
    SourceFilterId: S.String,
    DisplayOptions: S.optional(ListControlDisplayOptions),
    Type: S.optional(SheetControlListType),
    SelectableValues: S.optional(FilterSelectableValues),
    CascadingControlConfiguration: S.optional(CascadingControlConfiguration),
  }),
).annotations({
  identifier: "FilterListControl",
}) as any as S.Schema<FilterListControl>;
export interface FilterDropDownControl {
  FilterControlId: string;
  Title: string;
  SourceFilterId: string;
  DisplayOptions?: DropDownControlDisplayOptions;
  Type?: SheetControlListType;
  SelectableValues?: FilterSelectableValues;
  CascadingControlConfiguration?: CascadingControlConfiguration;
  CommitMode?: CommitMode;
}
export const FilterDropDownControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    Title: S.String,
    SourceFilterId: S.String,
    DisplayOptions: S.optional(DropDownControlDisplayOptions),
    Type: S.optional(SheetControlListType),
    SelectableValues: S.optional(FilterSelectableValues),
    CascadingControlConfiguration: S.optional(CascadingControlConfiguration),
    CommitMode: S.optional(CommitMode),
  }),
).annotations({
  identifier: "FilterDropDownControl",
}) as any as S.Schema<FilterDropDownControl>;
export interface FilterTextFieldControl {
  FilterControlId: string;
  Title: string;
  SourceFilterId: string;
  DisplayOptions?: TextFieldControlDisplayOptions;
}
export const FilterTextFieldControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    Title: S.String,
    SourceFilterId: S.String,
    DisplayOptions: S.optional(TextFieldControlDisplayOptions),
  }),
).annotations({
  identifier: "FilterTextFieldControl",
}) as any as S.Schema<FilterTextFieldControl>;
export interface FilterTextAreaControl {
  FilterControlId: string;
  Title: string;
  SourceFilterId: string;
  Delimiter?: string;
  DisplayOptions?: TextAreaControlDisplayOptions;
}
export const FilterTextAreaControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    Title: S.String,
    SourceFilterId: S.String,
    Delimiter: S.optional(S.String),
    DisplayOptions: S.optional(TextAreaControlDisplayOptions),
  }),
).annotations({
  identifier: "FilterTextAreaControl",
}) as any as S.Schema<FilterTextAreaControl>;
export type SheetControlSliderType = "SINGLE_POINT" | "RANGE";
export const SheetControlSliderType = S.Literal("SINGLE_POINT", "RANGE");
export interface FilterSliderControl {
  FilterControlId: string;
  Title: string;
  SourceFilterId: string;
  DisplayOptions?: SliderControlDisplayOptions;
  Type?: SheetControlSliderType;
  MaximumValue: number;
  MinimumValue: number;
  StepSize: number;
}
export const FilterSliderControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    Title: S.String,
    SourceFilterId: S.String,
    DisplayOptions: S.optional(SliderControlDisplayOptions),
    Type: S.optional(SheetControlSliderType),
    MaximumValue: S.Number,
    MinimumValue: S.Number,
    StepSize: S.Number,
  }),
).annotations({
  identifier: "FilterSliderControl",
}) as any as S.Schema<FilterSliderControl>;
export interface RelativeDateTimeControlDisplayOptions {
  TitleOptions?: LabelOptions;
  DateTimeFormat?: string;
  InfoIconLabelOptions?: SheetControlInfoIconLabelOptions;
}
export const RelativeDateTimeControlDisplayOptions = S.suspend(() =>
  S.Struct({
    TitleOptions: S.optional(LabelOptions),
    DateTimeFormat: S.optional(S.String),
    InfoIconLabelOptions: S.optional(SheetControlInfoIconLabelOptions),
  }),
).annotations({
  identifier: "RelativeDateTimeControlDisplayOptions",
}) as any as S.Schema<RelativeDateTimeControlDisplayOptions>;
export interface FilterRelativeDateTimeControl {
  FilterControlId: string;
  Title: string;
  SourceFilterId: string;
  DisplayOptions?: RelativeDateTimeControlDisplayOptions;
  CommitMode?: CommitMode;
}
export const FilterRelativeDateTimeControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    Title: S.String,
    SourceFilterId: S.String,
    DisplayOptions: S.optional(RelativeDateTimeControlDisplayOptions),
    CommitMode: S.optional(CommitMode),
  }),
).annotations({
  identifier: "FilterRelativeDateTimeControl",
}) as any as S.Schema<FilterRelativeDateTimeControl>;
export interface FilterCrossSheetControl {
  FilterControlId: string;
  SourceFilterId: string;
  CascadingControlConfiguration?: CascadingControlConfiguration;
}
export const FilterCrossSheetControl = S.suspend(() =>
  S.Struct({
    FilterControlId: S.String,
    SourceFilterId: S.String,
    CascadingControlConfiguration: S.optional(CascadingControlConfiguration),
  }),
).annotations({
  identifier: "FilterCrossSheetControl",
}) as any as S.Schema<FilterCrossSheetControl>;
export interface FilterControl {
  DateTimePicker?: FilterDateTimePickerControl;
  List?: FilterListControl;
  Dropdown?: FilterDropDownControl;
  TextField?: FilterTextFieldControl;
  TextArea?: FilterTextAreaControl;
  Slider?: FilterSliderControl;
  RelativeDateTime?: FilterRelativeDateTimeControl;
  CrossSheet?: FilterCrossSheetControl;
}
export const FilterControl = S.suspend(() =>
  S.Struct({
    DateTimePicker: S.optional(FilterDateTimePickerControl),
    List: S.optional(FilterListControl),
    Dropdown: S.optional(FilterDropDownControl),
    TextField: S.optional(FilterTextFieldControl),
    TextArea: S.optional(FilterTextAreaControl),
    Slider: S.optional(FilterSliderControl),
    RelativeDateTime: S.optional(FilterRelativeDateTimeControl),
    CrossSheet: S.optional(FilterCrossSheetControl),
  }),
).annotations({
  identifier: "FilterControl",
}) as any as S.Schema<FilterControl>;
export type FilterControlList = FilterControl[];
export const FilterControlList = S.Array(FilterControl);
export interface ShortFormatText {
  PlainText?: string;
  RichText?: string;
}
export const ShortFormatText = S.suspend(() =>
  S.Struct({ PlainText: S.optional(S.String), RichText: S.optional(S.String) }),
).annotations({
  identifier: "ShortFormatText",
}) as any as S.Schema<ShortFormatText>;
export interface VisualTitleLabelOptions {
  Visibility?: Visibility;
  FormatText?: ShortFormatText;
}
export const VisualTitleLabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    FormatText: S.optional(ShortFormatText),
  }),
).annotations({
  identifier: "VisualTitleLabelOptions",
}) as any as S.Schema<VisualTitleLabelOptions>;
export interface LongFormatText {
  PlainText?: string;
  RichText?: string;
}
export const LongFormatText = S.suspend(() =>
  S.Struct({ PlainText: S.optional(S.String), RichText: S.optional(S.String) }),
).annotations({
  identifier: "LongFormatText",
}) as any as S.Schema<LongFormatText>;
export interface VisualSubtitleLabelOptions {
  Visibility?: Visibility;
  FormatText?: LongFormatText;
}
export const VisualSubtitleLabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    FormatText: S.optional(LongFormatText),
  }),
).annotations({
  identifier: "VisualSubtitleLabelOptions",
}) as any as S.Schema<VisualSubtitleLabelOptions>;
export type NumericSeparatorSymbol = "COMMA" | "DOT" | "SPACE";
export const NumericSeparatorSymbol = S.Literal("COMMA", "DOT", "SPACE");
export type DigitGroupingStyle = "DEFAULT" | "LAKHS";
export const DigitGroupingStyle = S.Literal("DEFAULT", "LAKHS");
export interface ThousandSeparatorOptions {
  Symbol?: NumericSeparatorSymbol;
  Visibility?: Visibility;
  GroupingStyle?: DigitGroupingStyle;
}
export const ThousandSeparatorOptions = S.suspend(() =>
  S.Struct({
    Symbol: S.optional(NumericSeparatorSymbol),
    Visibility: S.optional(Visibility),
    GroupingStyle: S.optional(DigitGroupingStyle),
  }),
).annotations({
  identifier: "ThousandSeparatorOptions",
}) as any as S.Schema<ThousandSeparatorOptions>;
export interface NumericSeparatorConfiguration {
  DecimalSeparator?: NumericSeparatorSymbol;
  ThousandsSeparator?: ThousandSeparatorOptions;
}
export const NumericSeparatorConfiguration = S.suspend(() =>
  S.Struct({
    DecimalSeparator: S.optional(NumericSeparatorSymbol),
    ThousandsSeparator: S.optional(ThousandSeparatorOptions),
  }),
).annotations({
  identifier: "NumericSeparatorConfiguration",
}) as any as S.Schema<NumericSeparatorConfiguration>;
export interface DecimalPlacesConfiguration {
  DecimalPlaces: number;
}
export const DecimalPlacesConfiguration = S.suspend(() =>
  S.Struct({ DecimalPlaces: S.Number }),
).annotations({
  identifier: "DecimalPlacesConfiguration",
}) as any as S.Schema<DecimalPlacesConfiguration>;
export type NumberScale =
  | "NONE"
  | "AUTO"
  | "THOUSANDS"
  | "MILLIONS"
  | "BILLIONS"
  | "TRILLIONS"
  | "LAKHS"
  | "CRORES";
export const NumberScale = S.Literal(
  "NONE",
  "AUTO",
  "THOUSANDS",
  "MILLIONS",
  "BILLIONS",
  "TRILLIONS",
  "LAKHS",
  "CRORES",
);
export type NegativeValueDisplayMode = "POSITIVE" | "NEGATIVE";
export const NegativeValueDisplayMode = S.Literal("POSITIVE", "NEGATIVE");
export interface NegativeValueConfiguration {
  DisplayMode: NegativeValueDisplayMode;
}
export const NegativeValueConfiguration = S.suspend(() =>
  S.Struct({ DisplayMode: NegativeValueDisplayMode }),
).annotations({
  identifier: "NegativeValueConfiguration",
}) as any as S.Schema<NegativeValueConfiguration>;
export interface NullValueFormatConfiguration {
  NullString: string | redacted.Redacted<string>;
}
export const NullValueFormatConfiguration = S.suspend(() =>
  S.Struct({ NullString: SensitiveString }),
).annotations({
  identifier: "NullValueFormatConfiguration",
}) as any as S.Schema<NullValueFormatConfiguration>;
export interface NumberDisplayFormatConfiguration {
  Prefix?: string | redacted.Redacted<string>;
  Suffix?: string | redacted.Redacted<string>;
  SeparatorConfiguration?: NumericSeparatorConfiguration;
  DecimalPlacesConfiguration?: DecimalPlacesConfiguration;
  NumberScale?: NumberScale;
  NegativeValueConfiguration?: NegativeValueConfiguration;
  NullValueFormatConfiguration?: NullValueFormatConfiguration;
}
export const NumberDisplayFormatConfiguration = S.suspend(() =>
  S.Struct({
    Prefix: S.optional(SensitiveString),
    Suffix: S.optional(SensitiveString),
    SeparatorConfiguration: S.optional(NumericSeparatorConfiguration),
    DecimalPlacesConfiguration: S.optional(DecimalPlacesConfiguration),
    NumberScale: S.optional(NumberScale),
    NegativeValueConfiguration: S.optional(NegativeValueConfiguration),
    NullValueFormatConfiguration: S.optional(NullValueFormatConfiguration),
  }),
).annotations({
  identifier: "NumberDisplayFormatConfiguration",
}) as any as S.Schema<NumberDisplayFormatConfiguration>;
export interface CurrencyDisplayFormatConfiguration {
  Prefix?: string | redacted.Redacted<string>;
  Suffix?: string | redacted.Redacted<string>;
  SeparatorConfiguration?: NumericSeparatorConfiguration;
  Symbol?: string;
  DecimalPlacesConfiguration?: DecimalPlacesConfiguration;
  NumberScale?: NumberScale;
  NegativeValueConfiguration?: NegativeValueConfiguration;
  NullValueFormatConfiguration?: NullValueFormatConfiguration;
}
export const CurrencyDisplayFormatConfiguration = S.suspend(() =>
  S.Struct({
    Prefix: S.optional(SensitiveString),
    Suffix: S.optional(SensitiveString),
    SeparatorConfiguration: S.optional(NumericSeparatorConfiguration),
    Symbol: S.optional(S.String),
    DecimalPlacesConfiguration: S.optional(DecimalPlacesConfiguration),
    NumberScale: S.optional(NumberScale),
    NegativeValueConfiguration: S.optional(NegativeValueConfiguration),
    NullValueFormatConfiguration: S.optional(NullValueFormatConfiguration),
  }),
).annotations({
  identifier: "CurrencyDisplayFormatConfiguration",
}) as any as S.Schema<CurrencyDisplayFormatConfiguration>;
export interface PercentageDisplayFormatConfiguration {
  Prefix?: string | redacted.Redacted<string>;
  Suffix?: string | redacted.Redacted<string>;
  SeparatorConfiguration?: NumericSeparatorConfiguration;
  DecimalPlacesConfiguration?: DecimalPlacesConfiguration;
  NegativeValueConfiguration?: NegativeValueConfiguration;
  NullValueFormatConfiguration?: NullValueFormatConfiguration;
}
export const PercentageDisplayFormatConfiguration = S.suspend(() =>
  S.Struct({
    Prefix: S.optional(SensitiveString),
    Suffix: S.optional(SensitiveString),
    SeparatorConfiguration: S.optional(NumericSeparatorConfiguration),
    DecimalPlacesConfiguration: S.optional(DecimalPlacesConfiguration),
    NegativeValueConfiguration: S.optional(NegativeValueConfiguration),
    NullValueFormatConfiguration: S.optional(NullValueFormatConfiguration),
  }),
).annotations({
  identifier: "PercentageDisplayFormatConfiguration",
}) as any as S.Schema<PercentageDisplayFormatConfiguration>;
export interface NumericFormatConfiguration {
  NumberDisplayFormatConfiguration?: NumberDisplayFormatConfiguration;
  CurrencyDisplayFormatConfiguration?: CurrencyDisplayFormatConfiguration;
  PercentageDisplayFormatConfiguration?: PercentageDisplayFormatConfiguration;
}
export const NumericFormatConfiguration = S.suspend(() =>
  S.Struct({
    NumberDisplayFormatConfiguration: S.optional(
      NumberDisplayFormatConfiguration,
    ),
    CurrencyDisplayFormatConfiguration: S.optional(
      CurrencyDisplayFormatConfiguration,
    ),
    PercentageDisplayFormatConfiguration: S.optional(
      PercentageDisplayFormatConfiguration,
    ),
  }),
).annotations({
  identifier: "NumericFormatConfiguration",
}) as any as S.Schema<NumericFormatConfiguration>;
export interface NumberFormatConfiguration {
  FormatConfiguration?: NumericFormatConfiguration;
}
export const NumberFormatConfiguration = S.suspend(() =>
  S.Struct({ FormatConfiguration: S.optional(NumericFormatConfiguration) }),
).annotations({
  identifier: "NumberFormatConfiguration",
}) as any as S.Schema<NumberFormatConfiguration>;
export interface NumericalDimensionField {
  FieldId: string;
  Column: ColumnIdentifier;
  HierarchyId?: string;
  FormatConfiguration?: NumberFormatConfiguration;
}
export const NumericalDimensionField = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Column: ColumnIdentifier,
    HierarchyId: S.optional(S.String),
    FormatConfiguration: S.optional(NumberFormatConfiguration),
  }),
).annotations({
  identifier: "NumericalDimensionField",
}) as any as S.Schema<NumericalDimensionField>;
export interface StringFormatConfiguration {
  NullValueFormatConfiguration?: NullValueFormatConfiguration;
  NumericFormatConfiguration?: NumericFormatConfiguration;
}
export const StringFormatConfiguration = S.suspend(() =>
  S.Struct({
    NullValueFormatConfiguration: S.optional(NullValueFormatConfiguration),
    NumericFormatConfiguration: S.optional(NumericFormatConfiguration),
  }),
).annotations({
  identifier: "StringFormatConfiguration",
}) as any as S.Schema<StringFormatConfiguration>;
export interface CategoricalDimensionField {
  FieldId: string;
  Column: ColumnIdentifier;
  HierarchyId?: string;
  FormatConfiguration?: StringFormatConfiguration;
}
export const CategoricalDimensionField = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Column: ColumnIdentifier,
    HierarchyId: S.optional(S.String),
    FormatConfiguration: S.optional(StringFormatConfiguration),
  }),
).annotations({
  identifier: "CategoricalDimensionField",
}) as any as S.Schema<CategoricalDimensionField>;
export type TimeGranularity =
  | "YEAR"
  | "QUARTER"
  | "MONTH"
  | "WEEK"
  | "DAY"
  | "HOUR"
  | "MINUTE"
  | "SECOND"
  | "MILLISECOND";
export const TimeGranularity = S.Literal(
  "YEAR",
  "QUARTER",
  "MONTH",
  "WEEK",
  "DAY",
  "HOUR",
  "MINUTE",
  "SECOND",
  "MILLISECOND",
);
export interface DateTimeFormatConfiguration {
  DateTimeFormat?: string;
  NullValueFormatConfiguration?: NullValueFormatConfiguration;
  NumericFormatConfiguration?: NumericFormatConfiguration;
}
export const DateTimeFormatConfiguration = S.suspend(() =>
  S.Struct({
    DateTimeFormat: S.optional(S.String),
    NullValueFormatConfiguration: S.optional(NullValueFormatConfiguration),
    NumericFormatConfiguration: S.optional(NumericFormatConfiguration),
  }),
).annotations({
  identifier: "DateTimeFormatConfiguration",
}) as any as S.Schema<DateTimeFormatConfiguration>;
export interface DateDimensionField {
  FieldId: string;
  Column: ColumnIdentifier;
  DateGranularity?: TimeGranularity;
  HierarchyId?: string;
  FormatConfiguration?: DateTimeFormatConfiguration;
}
export const DateDimensionField = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Column: ColumnIdentifier,
    DateGranularity: S.optional(TimeGranularity),
    HierarchyId: S.optional(S.String),
    FormatConfiguration: S.optional(DateTimeFormatConfiguration),
  }),
).annotations({
  identifier: "DateDimensionField",
}) as any as S.Schema<DateDimensionField>;
export interface DimensionField {
  NumericalDimensionField?: NumericalDimensionField;
  CategoricalDimensionField?: CategoricalDimensionField;
  DateDimensionField?: DateDimensionField;
}
export const DimensionField = S.suspend(() =>
  S.Struct({
    NumericalDimensionField: S.optional(NumericalDimensionField),
    CategoricalDimensionField: S.optional(CategoricalDimensionField),
    DateDimensionField: S.optional(DateDimensionField),
  }),
).annotations({
  identifier: "DimensionField",
}) as any as S.Schema<DimensionField>;
export type DimensionFieldList = DimensionField[];
export const DimensionFieldList = S.Array(DimensionField);
export type SimpleNumericalAggregationFunction =
  | "SUM"
  | "AVERAGE"
  | "MIN"
  | "MAX"
  | "COUNT"
  | "DISTINCT_COUNT"
  | "VAR"
  | "VARP"
  | "STDEV"
  | "STDEVP"
  | "MEDIAN";
export const SimpleNumericalAggregationFunction = S.Literal(
  "SUM",
  "AVERAGE",
  "MIN",
  "MAX",
  "COUNT",
  "DISTINCT_COUNT",
  "VAR",
  "VARP",
  "STDEV",
  "STDEVP",
  "MEDIAN",
);
export interface PercentileAggregation {
  PercentileValue?: number;
}
export const PercentileAggregation = S.suspend(() =>
  S.Struct({ PercentileValue: S.optional(S.Number) }),
).annotations({
  identifier: "PercentileAggregation",
}) as any as S.Schema<PercentileAggregation>;
export interface NumericalAggregationFunction {
  SimpleNumericalAggregation?: SimpleNumericalAggregationFunction;
  PercentileAggregation?: PercentileAggregation;
}
export const NumericalAggregationFunction = S.suspend(() =>
  S.Struct({
    SimpleNumericalAggregation: S.optional(SimpleNumericalAggregationFunction),
    PercentileAggregation: S.optional(PercentileAggregation),
  }),
).annotations({
  identifier: "NumericalAggregationFunction",
}) as any as S.Schema<NumericalAggregationFunction>;
export interface NumericalMeasureField {
  FieldId: string;
  Column: ColumnIdentifier;
  AggregationFunction?: NumericalAggregationFunction;
  FormatConfiguration?: NumberFormatConfiguration;
}
export const NumericalMeasureField = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Column: ColumnIdentifier,
    AggregationFunction: S.optional(NumericalAggregationFunction),
    FormatConfiguration: S.optional(NumberFormatConfiguration),
  }),
).annotations({
  identifier: "NumericalMeasureField",
}) as any as S.Schema<NumericalMeasureField>;
export type CategoricalAggregationFunction = "COUNT" | "DISTINCT_COUNT";
export const CategoricalAggregationFunction = S.Literal(
  "COUNT",
  "DISTINCT_COUNT",
);
export interface CategoricalMeasureField {
  FieldId: string;
  Column: ColumnIdentifier;
  AggregationFunction?: CategoricalAggregationFunction;
  FormatConfiguration?: StringFormatConfiguration;
}
export const CategoricalMeasureField = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Column: ColumnIdentifier,
    AggregationFunction: S.optional(CategoricalAggregationFunction),
    FormatConfiguration: S.optional(StringFormatConfiguration),
  }),
).annotations({
  identifier: "CategoricalMeasureField",
}) as any as S.Schema<CategoricalMeasureField>;
export type DateAggregationFunction =
  | "COUNT"
  | "DISTINCT_COUNT"
  | "MIN"
  | "MAX";
export const DateAggregationFunction = S.Literal(
  "COUNT",
  "DISTINCT_COUNT",
  "MIN",
  "MAX",
);
export interface DateMeasureField {
  FieldId: string;
  Column: ColumnIdentifier;
  AggregationFunction?: DateAggregationFunction;
  FormatConfiguration?: DateTimeFormatConfiguration;
}
export const DateMeasureField = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Column: ColumnIdentifier,
    AggregationFunction: S.optional(DateAggregationFunction),
    FormatConfiguration: S.optional(DateTimeFormatConfiguration),
  }),
).annotations({
  identifier: "DateMeasureField",
}) as any as S.Schema<DateMeasureField>;
export interface CalculatedMeasureField {
  FieldId: string;
  Expression: string | redacted.Redacted<string>;
}
export const CalculatedMeasureField = S.suspend(() =>
  S.Struct({ FieldId: S.String, Expression: SensitiveString }),
).annotations({
  identifier: "CalculatedMeasureField",
}) as any as S.Schema<CalculatedMeasureField>;
export interface MeasureField {
  NumericalMeasureField?: NumericalMeasureField;
  CategoricalMeasureField?: CategoricalMeasureField;
  DateMeasureField?: DateMeasureField;
  CalculatedMeasureField?: CalculatedMeasureField;
}
export const MeasureField = S.suspend(() =>
  S.Struct({
    NumericalMeasureField: S.optional(NumericalMeasureField),
    CategoricalMeasureField: S.optional(CategoricalMeasureField),
    DateMeasureField: S.optional(DateMeasureField),
    CalculatedMeasureField: S.optional(CalculatedMeasureField),
  }),
).annotations({ identifier: "MeasureField" }) as any as S.Schema<MeasureField>;
export type MeasureFieldList = MeasureField[];
export const MeasureFieldList = S.Array(MeasureField);
export interface TableAggregatedFieldWells {
  GroupBy?: DimensionField[];
  Values?: MeasureField[];
}
export const TableAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    GroupBy: S.optional(DimensionFieldList),
    Values: S.optional(MeasureFieldList),
  }),
).annotations({
  identifier: "TableAggregatedFieldWells",
}) as any as S.Schema<TableAggregatedFieldWells>;
export interface FormatConfiguration {
  StringFormatConfiguration?: StringFormatConfiguration;
  NumberFormatConfiguration?: NumberFormatConfiguration;
  DateTimeFormatConfiguration?: DateTimeFormatConfiguration;
}
export const FormatConfiguration = S.suspend(() =>
  S.Struct({
    StringFormatConfiguration: S.optional(StringFormatConfiguration),
    NumberFormatConfiguration: S.optional(NumberFormatConfiguration),
    DateTimeFormatConfiguration: S.optional(DateTimeFormatConfiguration),
  }),
).annotations({
  identifier: "FormatConfiguration",
}) as any as S.Schema<FormatConfiguration>;
export interface UnaggregatedField {
  FieldId: string;
  Column: ColumnIdentifier;
  FormatConfiguration?: FormatConfiguration;
}
export const UnaggregatedField = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Column: ColumnIdentifier,
    FormatConfiguration: S.optional(FormatConfiguration),
  }),
).annotations({
  identifier: "UnaggregatedField",
}) as any as S.Schema<UnaggregatedField>;
export type TableUnaggregatedFieldList = UnaggregatedField[];
export const TableUnaggregatedFieldList = S.Array(UnaggregatedField);
export interface TableUnaggregatedFieldWells {
  Values?: UnaggregatedField[];
}
export const TableUnaggregatedFieldWells = S.suspend(() =>
  S.Struct({ Values: S.optional(TableUnaggregatedFieldList) }),
).annotations({
  identifier: "TableUnaggregatedFieldWells",
}) as any as S.Schema<TableUnaggregatedFieldWells>;
export interface TableFieldWells {
  TableAggregatedFieldWells?: TableAggregatedFieldWells;
  TableUnaggregatedFieldWells?: TableUnaggregatedFieldWells;
}
export const TableFieldWells = S.suspend(() =>
  S.Struct({
    TableAggregatedFieldWells: S.optional(TableAggregatedFieldWells),
    TableUnaggregatedFieldWells: S.optional(TableUnaggregatedFieldWells),
  }),
).annotations({
  identifier: "TableFieldWells",
}) as any as S.Schema<TableFieldWells>;
export type SortDirection = "ASC" | "DESC";
export const SortDirection = S.Literal("ASC", "DESC");
export interface FieldSort {
  FieldId: string;
  Direction: SortDirection;
}
export const FieldSort = S.suspend(() =>
  S.Struct({ FieldId: S.String, Direction: SortDirection }),
).annotations({ identifier: "FieldSort" }) as any as S.Schema<FieldSort>;
export type SimpleAttributeAggregationFunction = "UNIQUE_VALUE";
export const SimpleAttributeAggregationFunction = S.Literal("UNIQUE_VALUE");
export interface AttributeAggregationFunction {
  SimpleAttributeAggregation?: SimpleAttributeAggregationFunction;
  ValueForMultipleValues?: string;
}
export const AttributeAggregationFunction = S.suspend(() =>
  S.Struct({
    SimpleAttributeAggregation: S.optional(SimpleAttributeAggregationFunction),
    ValueForMultipleValues: S.optional(S.String),
  }),
).annotations({
  identifier: "AttributeAggregationFunction",
}) as any as S.Schema<AttributeAggregationFunction>;
export interface AggregationFunction {
  NumericalAggregationFunction?: NumericalAggregationFunction;
  CategoricalAggregationFunction?: CategoricalAggregationFunction;
  DateAggregationFunction?: DateAggregationFunction;
  AttributeAggregationFunction?: AttributeAggregationFunction;
}
export const AggregationFunction = S.suspend(() =>
  S.Struct({
    NumericalAggregationFunction: S.optional(NumericalAggregationFunction),
    CategoricalAggregationFunction: S.optional(CategoricalAggregationFunction),
    DateAggregationFunction: S.optional(DateAggregationFunction),
    AttributeAggregationFunction: S.optional(AttributeAggregationFunction),
  }),
).annotations({
  identifier: "AggregationFunction",
}) as any as S.Schema<AggregationFunction>;
export interface ColumnSort {
  SortBy: ColumnIdentifier;
  Direction: SortDirection;
  AggregationFunction?: AggregationFunction;
}
export const ColumnSort = S.suspend(() =>
  S.Struct({
    SortBy: ColumnIdentifier,
    Direction: SortDirection,
    AggregationFunction: S.optional(AggregationFunction),
  }),
).annotations({ identifier: "ColumnSort" }) as any as S.Schema<ColumnSort>;
export interface FieldSortOptions {
  FieldSort?: FieldSort;
  ColumnSort?: ColumnSort;
}
export const FieldSortOptions = S.suspend(() =>
  S.Struct({
    FieldSort: S.optional(FieldSort),
    ColumnSort: S.optional(ColumnSort),
  }),
).annotations({
  identifier: "FieldSortOptions",
}) as any as S.Schema<FieldSortOptions>;
export type RowSortList = FieldSortOptions[];
export const RowSortList = S.Array(FieldSortOptions);
export interface PaginationConfiguration {
  PageSize: number;
  PageNumber: number;
}
export const PaginationConfiguration = S.suspend(() =>
  S.Struct({ PageSize: S.Number, PageNumber: S.Number }),
).annotations({
  identifier: "PaginationConfiguration",
}) as any as S.Schema<PaginationConfiguration>;
export interface TableSortConfiguration {
  RowSort?: FieldSortOptions[];
  PaginationConfiguration?: PaginationConfiguration;
}
export const TableSortConfiguration = S.suspend(() =>
  S.Struct({
    RowSort: S.optional(RowSortList),
    PaginationConfiguration: S.optional(PaginationConfiguration),
  }),
).annotations({
  identifier: "TableSortConfiguration",
}) as any as S.Schema<TableSortConfiguration>;
export type TableOrientation = "VERTICAL" | "HORIZONTAL";
export const TableOrientation = S.Literal("VERTICAL", "HORIZONTAL");
export type TextWrap = "NONE" | "WRAP";
export const TextWrap = S.Literal("NONE", "WRAP");
export type HorizontalTextAlignment = "LEFT" | "CENTER" | "RIGHT" | "AUTO";
export const HorizontalTextAlignment = S.Literal(
  "LEFT",
  "CENTER",
  "RIGHT",
  "AUTO",
);
export type VerticalTextAlignment = "TOP" | "MIDDLE" | "BOTTOM" | "AUTO";
export const VerticalTextAlignment = S.Literal(
  "TOP",
  "MIDDLE",
  "BOTTOM",
  "AUTO",
);
export type TableBorderStyle = "NONE" | "SOLID";
export const TableBorderStyle = S.Literal("NONE", "SOLID");
export interface TableBorderOptions {
  Color?: string;
  Thickness?: number;
  Style?: TableBorderStyle;
}
export const TableBorderOptions = S.suspend(() =>
  S.Struct({
    Color: S.optional(S.String),
    Thickness: S.optional(S.Number),
    Style: S.optional(TableBorderStyle),
  }),
).annotations({
  identifier: "TableBorderOptions",
}) as any as S.Schema<TableBorderOptions>;
export interface TableSideBorderOptions {
  InnerVertical?: TableBorderOptions;
  InnerHorizontal?: TableBorderOptions;
  Left?: TableBorderOptions;
  Right?: TableBorderOptions;
  Top?: TableBorderOptions;
  Bottom?: TableBorderOptions;
}
export const TableSideBorderOptions = S.suspend(() =>
  S.Struct({
    InnerVertical: S.optional(TableBorderOptions),
    InnerHorizontal: S.optional(TableBorderOptions),
    Left: S.optional(TableBorderOptions),
    Right: S.optional(TableBorderOptions),
    Top: S.optional(TableBorderOptions),
    Bottom: S.optional(TableBorderOptions),
  }),
).annotations({
  identifier: "TableSideBorderOptions",
}) as any as S.Schema<TableSideBorderOptions>;
export interface GlobalTableBorderOptions {
  UniformBorder?: TableBorderOptions;
  SideSpecificBorder?: TableSideBorderOptions;
}
export const GlobalTableBorderOptions = S.suspend(() =>
  S.Struct({
    UniformBorder: S.optional(TableBorderOptions),
    SideSpecificBorder: S.optional(TableSideBorderOptions),
  }),
).annotations({
  identifier: "GlobalTableBorderOptions",
}) as any as S.Schema<GlobalTableBorderOptions>;
export interface TableCellStyle {
  Visibility?: Visibility;
  FontConfiguration?: FontConfiguration;
  TextWrap?: TextWrap;
  HorizontalTextAlignment?: HorizontalTextAlignment;
  VerticalTextAlignment?: VerticalTextAlignment;
  BackgroundColor?: string;
  Height?: number;
  Border?: GlobalTableBorderOptions;
}
export const TableCellStyle = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    FontConfiguration: S.optional(FontConfiguration),
    TextWrap: S.optional(TextWrap),
    HorizontalTextAlignment: S.optional(HorizontalTextAlignment),
    VerticalTextAlignment: S.optional(VerticalTextAlignment),
    BackgroundColor: S.optional(S.String),
    Height: S.optional(S.Number),
    Border: S.optional(GlobalTableBorderOptions),
  }),
).annotations({
  identifier: "TableCellStyle",
}) as any as S.Schema<TableCellStyle>;
export type WidgetStatus = "ENABLED" | "DISABLED";
export const WidgetStatus = S.Literal("ENABLED", "DISABLED");
export type RowAlternateColorList = string[];
export const RowAlternateColorList = S.Array(S.String);
export interface RowAlternateColorOptions {
  Status?: WidgetStatus;
  RowAlternateColors?: string[];
  UsePrimaryBackgroundColor?: WidgetStatus;
}
export const RowAlternateColorOptions = S.suspend(() =>
  S.Struct({
    Status: S.optional(WidgetStatus),
    RowAlternateColors: S.optional(RowAlternateColorList),
    UsePrimaryBackgroundColor: S.optional(WidgetStatus),
  }),
).annotations({
  identifier: "RowAlternateColorOptions",
}) as any as S.Schema<RowAlternateColorOptions>;
export interface TableOptions {
  Orientation?: TableOrientation;
  HeaderStyle?: TableCellStyle;
  CellStyle?: TableCellStyle;
  RowAlternateColorOptions?: RowAlternateColorOptions;
}
export const TableOptions = S.suspend(() =>
  S.Struct({
    Orientation: S.optional(TableOrientation),
    HeaderStyle: S.optional(TableCellStyle),
    CellStyle: S.optional(TableCellStyle),
    RowAlternateColorOptions: S.optional(RowAlternateColorOptions),
  }),
).annotations({ identifier: "TableOptions" }) as any as S.Schema<TableOptions>;
export type TableTotalsPlacement = "START" | "END" | "AUTO";
export const TableTotalsPlacement = S.Literal("START", "END", "AUTO");
export type TableTotalsScrollStatus = "PINNED" | "SCROLLED";
export const TableTotalsScrollStatus = S.Literal("PINNED", "SCROLLED");
export type SimpleTotalAggregationFunction =
  | "DEFAULT"
  | "SUM"
  | "AVERAGE"
  | "MIN"
  | "MAX"
  | "NONE";
export const SimpleTotalAggregationFunction = S.Literal(
  "DEFAULT",
  "SUM",
  "AVERAGE",
  "MIN",
  "MAX",
  "NONE",
);
export interface TotalAggregationFunction {
  SimpleTotalAggregationFunction?: SimpleTotalAggregationFunction;
}
export const TotalAggregationFunction = S.suspend(() =>
  S.Struct({
    SimpleTotalAggregationFunction: S.optional(SimpleTotalAggregationFunction),
  }),
).annotations({
  identifier: "TotalAggregationFunction",
}) as any as S.Schema<TotalAggregationFunction>;
export interface TotalAggregationOption {
  FieldId: string;
  TotalAggregationFunction: TotalAggregationFunction;
}
export const TotalAggregationOption = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    TotalAggregationFunction: TotalAggregationFunction,
  }),
).annotations({
  identifier: "TotalAggregationOption",
}) as any as S.Schema<TotalAggregationOption>;
export type TotalAggregationOptionList = TotalAggregationOption[];
export const TotalAggregationOptionList = S.Array(TotalAggregationOption);
export interface TotalOptions {
  TotalsVisibility?: Visibility;
  Placement?: TableTotalsPlacement;
  ScrollStatus?: TableTotalsScrollStatus;
  CustomLabel?: string;
  TotalCellStyle?: TableCellStyle;
  TotalAggregationOptions?: TotalAggregationOption[];
}
export const TotalOptions = S.suspend(() =>
  S.Struct({
    TotalsVisibility: S.optional(Visibility),
    Placement: S.optional(TableTotalsPlacement),
    ScrollStatus: S.optional(TableTotalsScrollStatus),
    CustomLabel: S.optional(S.String),
    TotalCellStyle: S.optional(TableCellStyle),
    TotalAggregationOptions: S.optional(TotalAggregationOptionList),
  }),
).annotations({ identifier: "TotalOptions" }) as any as S.Schema<TotalOptions>;
export type URLTargetConfiguration = "NEW_TAB" | "NEW_WINDOW" | "SAME_TAB";
export const URLTargetConfiguration = S.Literal(
  "NEW_TAB",
  "NEW_WINDOW",
  "SAME_TAB",
);
export interface TableFieldCustomTextContent {
  Value?: string;
  FontConfiguration: FontConfiguration;
}
export const TableFieldCustomTextContent = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.String),
    FontConfiguration: FontConfiguration,
  }),
).annotations({
  identifier: "TableFieldCustomTextContent",
}) as any as S.Schema<TableFieldCustomTextContent>;
export type TableFieldIconSetType = "LINK";
export const TableFieldIconSetType = S.Literal("LINK");
export interface TableFieldCustomIconContent {
  Icon?: TableFieldIconSetType;
}
export const TableFieldCustomIconContent = S.suspend(() =>
  S.Struct({ Icon: S.optional(TableFieldIconSetType) }),
).annotations({
  identifier: "TableFieldCustomIconContent",
}) as any as S.Schema<TableFieldCustomIconContent>;
export interface TableFieldLinkContentConfiguration {
  CustomTextContent?: TableFieldCustomTextContent;
  CustomIconContent?: TableFieldCustomIconContent;
}
export const TableFieldLinkContentConfiguration = S.suspend(() =>
  S.Struct({
    CustomTextContent: S.optional(TableFieldCustomTextContent),
    CustomIconContent: S.optional(TableFieldCustomIconContent),
  }),
).annotations({
  identifier: "TableFieldLinkContentConfiguration",
}) as any as S.Schema<TableFieldLinkContentConfiguration>;
export interface TableFieldLinkConfiguration {
  Target: URLTargetConfiguration;
  Content: TableFieldLinkContentConfiguration;
}
export const TableFieldLinkConfiguration = S.suspend(() =>
  S.Struct({
    Target: URLTargetConfiguration,
    Content: TableFieldLinkContentConfiguration,
  }),
).annotations({
  identifier: "TableFieldLinkConfiguration",
}) as any as S.Schema<TableFieldLinkConfiguration>;
export type TableCellImageScalingConfiguration =
  | "FIT_TO_CELL_HEIGHT"
  | "FIT_TO_CELL_WIDTH"
  | "DO_NOT_SCALE";
export const TableCellImageScalingConfiguration = S.Literal(
  "FIT_TO_CELL_HEIGHT",
  "FIT_TO_CELL_WIDTH",
  "DO_NOT_SCALE",
);
export interface TableCellImageSizingConfiguration {
  TableCellImageScalingConfiguration?: TableCellImageScalingConfiguration;
}
export const TableCellImageSizingConfiguration = S.suspend(() =>
  S.Struct({
    TableCellImageScalingConfiguration: S.optional(
      TableCellImageScalingConfiguration,
    ),
  }),
).annotations({
  identifier: "TableCellImageSizingConfiguration",
}) as any as S.Schema<TableCellImageSizingConfiguration>;
export interface TableFieldImageConfiguration {
  SizingOptions?: TableCellImageSizingConfiguration;
}
export const TableFieldImageConfiguration = S.suspend(() =>
  S.Struct({ SizingOptions: S.optional(TableCellImageSizingConfiguration) }),
).annotations({
  identifier: "TableFieldImageConfiguration",
}) as any as S.Schema<TableFieldImageConfiguration>;
export interface TableFieldURLConfiguration {
  LinkConfiguration?: TableFieldLinkConfiguration;
  ImageConfiguration?: TableFieldImageConfiguration;
}
export const TableFieldURLConfiguration = S.suspend(() =>
  S.Struct({
    LinkConfiguration: S.optional(TableFieldLinkConfiguration),
    ImageConfiguration: S.optional(TableFieldImageConfiguration),
  }),
).annotations({
  identifier: "TableFieldURLConfiguration",
}) as any as S.Schema<TableFieldURLConfiguration>;
export interface TableFieldOption {
  FieldId: string;
  Width?: string;
  CustomLabel?: string;
  Visibility?: Visibility;
  URLStyling?: TableFieldURLConfiguration;
}
export const TableFieldOption = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Width: S.optional(S.String),
    CustomLabel: S.optional(S.String),
    Visibility: S.optional(Visibility),
    URLStyling: S.optional(TableFieldURLConfiguration),
  }),
).annotations({
  identifier: "TableFieldOption",
}) as any as S.Schema<TableFieldOption>;
export type TableFieldOptionList = TableFieldOption[];
export const TableFieldOptionList = S.Array(TableFieldOption);
export type FieldOrderList = string[];
export const FieldOrderList = S.Array(S.String);
export type TableFieldOrderList = string[];
export const TableFieldOrderList = S.Array(S.String);
export interface TablePinnedFieldOptions {
  PinnedLeftFields?: string[];
}
export const TablePinnedFieldOptions = S.suspend(() =>
  S.Struct({ PinnedLeftFields: S.optional(TableFieldOrderList) }),
).annotations({
  identifier: "TablePinnedFieldOptions",
}) as any as S.Schema<TablePinnedFieldOptions>;
export type TransposedColumnType = "ROW_HEADER_COLUMN" | "VALUE_COLUMN";
export const TransposedColumnType = S.Literal(
  "ROW_HEADER_COLUMN",
  "VALUE_COLUMN",
);
export interface TransposedTableOption {
  ColumnIndex?: number;
  ColumnWidth?: string;
  ColumnType: TransposedColumnType;
}
export const TransposedTableOption = S.suspend(() =>
  S.Struct({
    ColumnIndex: S.optional(S.Number),
    ColumnWidth: S.optional(S.String),
    ColumnType: TransposedColumnType,
  }),
).annotations({
  identifier: "TransposedTableOption",
}) as any as S.Schema<TransposedTableOption>;
export type TransposedTableOptionList = TransposedTableOption[];
export const TransposedTableOptionList = S.Array(TransposedTableOption);
export interface TableFieldOptions {
  SelectedFieldOptions?: TableFieldOption[];
  Order?: string[];
  PinnedFieldOptions?: TablePinnedFieldOptions;
  TransposedTableOptions?: TransposedTableOption[];
}
export const TableFieldOptions = S.suspend(() =>
  S.Struct({
    SelectedFieldOptions: S.optional(TableFieldOptionList),
    Order: S.optional(FieldOrderList),
    PinnedFieldOptions: S.optional(TablePinnedFieldOptions),
    TransposedTableOptions: S.optional(TransposedTableOptionList),
  }),
).annotations({
  identifier: "TableFieldOptions",
}) as any as S.Schema<TableFieldOptions>;
export interface TablePaginatedReportOptions {
  VerticalOverflowVisibility?: Visibility;
  OverflowColumnHeaderVisibility?: Visibility;
}
export const TablePaginatedReportOptions = S.suspend(() =>
  S.Struct({
    VerticalOverflowVisibility: S.optional(Visibility),
    OverflowColumnHeaderVisibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "TablePaginatedReportOptions",
}) as any as S.Schema<TablePaginatedReportOptions>;
export interface DataBarsOptions {
  FieldId: string;
  PositiveColor?: string;
  NegativeColor?: string;
}
export const DataBarsOptions = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    PositiveColor: S.optional(S.String),
    NegativeColor: S.optional(S.String),
  }),
).annotations({
  identifier: "DataBarsOptions",
}) as any as S.Schema<DataBarsOptions>;
export interface TableInlineVisualization {
  DataBars?: DataBarsOptions;
}
export const TableInlineVisualization = S.suspend(() =>
  S.Struct({ DataBars: S.optional(DataBarsOptions) }),
).annotations({
  identifier: "TableInlineVisualization",
}) as any as S.Schema<TableInlineVisualization>;
export type TableInlineVisualizationList = TableInlineVisualization[];
export const TableInlineVisualizationList = S.Array(TableInlineVisualization);
export type DashboardCustomizationStatus = "ENABLED" | "DISABLED";
export const DashboardCustomizationStatus = S.Literal("ENABLED", "DISABLED");
export type VisualCustomizationAdditionalFieldsList = ColumnIdentifier[];
export const VisualCustomizationAdditionalFieldsList =
  S.Array(ColumnIdentifier);
export interface VisualCustomizationFieldsConfiguration {
  Status?: DashboardCustomizationStatus;
  AdditionalFields?: ColumnIdentifier[];
}
export const VisualCustomizationFieldsConfiguration = S.suspend(() =>
  S.Struct({
    Status: S.optional(DashboardCustomizationStatus),
    AdditionalFields: S.optional(VisualCustomizationAdditionalFieldsList),
  }),
).annotations({
  identifier: "VisualCustomizationFieldsConfiguration",
}) as any as S.Schema<VisualCustomizationFieldsConfiguration>;
export interface DashboardCustomizationVisualOptions {
  FieldsConfiguration?: VisualCustomizationFieldsConfiguration;
}
export const DashboardCustomizationVisualOptions = S.suspend(() =>
  S.Struct({
    FieldsConfiguration: S.optional(VisualCustomizationFieldsConfiguration),
  }),
).annotations({
  identifier: "DashboardCustomizationVisualOptions",
}) as any as S.Schema<DashboardCustomizationVisualOptions>;
export type DashboardBehavior = "ENABLED" | "DISABLED";
export const DashboardBehavior = S.Literal("ENABLED", "DISABLED");
export interface VisualMenuOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const VisualMenuOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "VisualMenuOption",
}) as any as S.Schema<VisualMenuOption>;
export interface ContextMenuOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const ContextMenuOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "ContextMenuOption",
}) as any as S.Schema<ContextMenuOption>;
export interface VisualInteractionOptions {
  VisualMenuOption?: VisualMenuOption;
  ContextMenuOption?: ContextMenuOption;
}
export const VisualInteractionOptions = S.suspend(() =>
  S.Struct({
    VisualMenuOption: S.optional(VisualMenuOption),
    ContextMenuOption: S.optional(ContextMenuOption),
  }),
).annotations({
  identifier: "VisualInteractionOptions",
}) as any as S.Schema<VisualInteractionOptions>;
export interface TableConfiguration {
  FieldWells?: TableFieldWells;
  SortConfiguration?: TableSortConfiguration;
  TableOptions?: TableOptions;
  TotalOptions?: TotalOptions;
  FieldOptions?: TableFieldOptions;
  PaginatedReportOptions?: TablePaginatedReportOptions;
  TableInlineVisualizations?: TableInlineVisualization[];
  DashboardCustomizationVisualOptions?: DashboardCustomizationVisualOptions;
  Interactions?: VisualInteractionOptions;
}
export const TableConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(TableFieldWells),
    SortConfiguration: S.optional(TableSortConfiguration),
    TableOptions: S.optional(TableOptions),
    TotalOptions: S.optional(TotalOptions),
    FieldOptions: S.optional(TableFieldOptions),
    PaginatedReportOptions: S.optional(TablePaginatedReportOptions),
    TableInlineVisualizations: S.optional(TableInlineVisualizationList),
    DashboardCustomizationVisualOptions: S.optional(
      DashboardCustomizationVisualOptions,
    ),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "TableConfiguration",
}) as any as S.Schema<TableConfiguration>;
export interface ConditionalFormattingSolidColor {
  Expression: string | redacted.Redacted<string>;
  Color?: string;
}
export const ConditionalFormattingSolidColor = S.suspend(() =>
  S.Struct({ Expression: SensitiveString, Color: S.optional(S.String) }),
).annotations({
  identifier: "ConditionalFormattingSolidColor",
}) as any as S.Schema<ConditionalFormattingSolidColor>;
export interface GradientStop {
  GradientOffset: number;
  DataValue?: number;
  Color?: string;
}
export const GradientStop = S.suspend(() =>
  S.Struct({
    GradientOffset: S.Number,
    DataValue: S.optional(S.Number),
    Color: S.optional(S.String),
  }),
).annotations({ identifier: "GradientStop" }) as any as S.Schema<GradientStop>;
export type GradientStopList = GradientStop[];
export const GradientStopList = S.Array(GradientStop);
export interface GradientColor {
  Stops?: GradientStop[];
}
export const GradientColor = S.suspend(() =>
  S.Struct({ Stops: S.optional(GradientStopList) }),
).annotations({
  identifier: "GradientColor",
}) as any as S.Schema<GradientColor>;
export interface ConditionalFormattingGradientColor {
  Expression: string | redacted.Redacted<string>;
  Color: GradientColor;
}
export const ConditionalFormattingGradientColor = S.suspend(() =>
  S.Struct({ Expression: SensitiveString, Color: GradientColor }),
).annotations({
  identifier: "ConditionalFormattingGradientColor",
}) as any as S.Schema<ConditionalFormattingGradientColor>;
export interface ConditionalFormattingColor {
  Solid?: ConditionalFormattingSolidColor;
  Gradient?: ConditionalFormattingGradientColor;
}
export const ConditionalFormattingColor = S.suspend(() =>
  S.Struct({
    Solid: S.optional(ConditionalFormattingSolidColor),
    Gradient: S.optional(ConditionalFormattingGradientColor),
  }),
).annotations({
  identifier: "ConditionalFormattingColor",
}) as any as S.Schema<ConditionalFormattingColor>;
export type ConditionalFormattingIconSetType =
  | "PLUS_MINUS"
  | "CHECK_X"
  | "THREE_COLOR_ARROW"
  | "THREE_GRAY_ARROW"
  | "CARET_UP_MINUS_DOWN"
  | "THREE_SHAPE"
  | "THREE_CIRCLE"
  | "FLAGS"
  | "BARS"
  | "FOUR_COLOR_ARROW"
  | "FOUR_GRAY_ARROW";
export const ConditionalFormattingIconSetType = S.Literal(
  "PLUS_MINUS",
  "CHECK_X",
  "THREE_COLOR_ARROW",
  "THREE_GRAY_ARROW",
  "CARET_UP_MINUS_DOWN",
  "THREE_SHAPE",
  "THREE_CIRCLE",
  "FLAGS",
  "BARS",
  "FOUR_COLOR_ARROW",
  "FOUR_GRAY_ARROW",
);
export interface ConditionalFormattingIconSet {
  Expression: string | redacted.Redacted<string>;
  IconSetType?: ConditionalFormattingIconSetType;
}
export const ConditionalFormattingIconSet = S.suspend(() =>
  S.Struct({
    Expression: SensitiveString,
    IconSetType: S.optional(ConditionalFormattingIconSetType),
  }),
).annotations({
  identifier: "ConditionalFormattingIconSet",
}) as any as S.Schema<ConditionalFormattingIconSet>;
export type Icon =
  | "CARET_UP"
  | "CARET_DOWN"
  | "PLUS"
  | "MINUS"
  | "ARROW_UP"
  | "ARROW_DOWN"
  | "ARROW_LEFT"
  | "ARROW_UP_LEFT"
  | "ARROW_DOWN_LEFT"
  | "ARROW_RIGHT"
  | "ARROW_UP_RIGHT"
  | "ARROW_DOWN_RIGHT"
  | "FACE_UP"
  | "FACE_DOWN"
  | "FACE_FLAT"
  | "ONE_BAR"
  | "TWO_BAR"
  | "THREE_BAR"
  | "CIRCLE"
  | "TRIANGLE"
  | "SQUARE"
  | "FLAG"
  | "THUMBS_UP"
  | "THUMBS_DOWN"
  | "CHECKMARK"
  | "X";
export const Icon = S.Literal(
  "CARET_UP",
  "CARET_DOWN",
  "PLUS",
  "MINUS",
  "ARROW_UP",
  "ARROW_DOWN",
  "ARROW_LEFT",
  "ARROW_UP_LEFT",
  "ARROW_DOWN_LEFT",
  "ARROW_RIGHT",
  "ARROW_UP_RIGHT",
  "ARROW_DOWN_RIGHT",
  "FACE_UP",
  "FACE_DOWN",
  "FACE_FLAT",
  "ONE_BAR",
  "TWO_BAR",
  "THREE_BAR",
  "CIRCLE",
  "TRIANGLE",
  "SQUARE",
  "FLAG",
  "THUMBS_UP",
  "THUMBS_DOWN",
  "CHECKMARK",
  "X",
);
export interface ConditionalFormattingCustomIconOptions {
  Icon?: Icon;
  UnicodeIcon?: string;
}
export const ConditionalFormattingCustomIconOptions = S.suspend(() =>
  S.Struct({ Icon: S.optional(Icon), UnicodeIcon: S.optional(S.String) }),
).annotations({
  identifier: "ConditionalFormattingCustomIconOptions",
}) as any as S.Schema<ConditionalFormattingCustomIconOptions>;
export type ConditionalFormattingIconDisplayOption = "ICON_ONLY";
export const ConditionalFormattingIconDisplayOption = S.Literal("ICON_ONLY");
export interface ConditionalFormattingIconDisplayConfiguration {
  IconDisplayOption?: ConditionalFormattingIconDisplayOption;
}
export const ConditionalFormattingIconDisplayConfiguration = S.suspend(() =>
  S.Struct({
    IconDisplayOption: S.optional(ConditionalFormattingIconDisplayOption),
  }),
).annotations({
  identifier: "ConditionalFormattingIconDisplayConfiguration",
}) as any as S.Schema<ConditionalFormattingIconDisplayConfiguration>;
export interface ConditionalFormattingCustomIconCondition {
  Expression: string | redacted.Redacted<string>;
  IconOptions: ConditionalFormattingCustomIconOptions;
  Color?: string;
  DisplayConfiguration?: ConditionalFormattingIconDisplayConfiguration;
}
export const ConditionalFormattingCustomIconCondition = S.suspend(() =>
  S.Struct({
    Expression: SensitiveString,
    IconOptions: ConditionalFormattingCustomIconOptions,
    Color: S.optional(S.String),
    DisplayConfiguration: S.optional(
      ConditionalFormattingIconDisplayConfiguration,
    ),
  }),
).annotations({
  identifier: "ConditionalFormattingCustomIconCondition",
}) as any as S.Schema<ConditionalFormattingCustomIconCondition>;
export interface ConditionalFormattingIcon {
  IconSet?: ConditionalFormattingIconSet;
  CustomCondition?: ConditionalFormattingCustomIconCondition;
}
export const ConditionalFormattingIcon = S.suspend(() =>
  S.Struct({
    IconSet: S.optional(ConditionalFormattingIconSet),
    CustomCondition: S.optional(ConditionalFormattingCustomIconCondition),
  }),
).annotations({
  identifier: "ConditionalFormattingIcon",
}) as any as S.Schema<ConditionalFormattingIcon>;
export interface TextConditionalFormat {
  BackgroundColor?: ConditionalFormattingColor;
  TextColor?: ConditionalFormattingColor;
  Icon?: ConditionalFormattingIcon;
}
export const TextConditionalFormat = S.suspend(() =>
  S.Struct({
    BackgroundColor: S.optional(ConditionalFormattingColor),
    TextColor: S.optional(ConditionalFormattingColor),
    Icon: S.optional(ConditionalFormattingIcon),
  }),
).annotations({
  identifier: "TextConditionalFormat",
}) as any as S.Schema<TextConditionalFormat>;
export interface TableCellConditionalFormatting {
  FieldId: string;
  TextFormat?: TextConditionalFormat;
}
export const TableCellConditionalFormatting = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    TextFormat: S.optional(TextConditionalFormat),
  }),
).annotations({
  identifier: "TableCellConditionalFormatting",
}) as any as S.Schema<TableCellConditionalFormatting>;
export interface TableRowConditionalFormatting {
  BackgroundColor?: ConditionalFormattingColor;
  TextColor?: ConditionalFormattingColor;
}
export const TableRowConditionalFormatting = S.suspend(() =>
  S.Struct({
    BackgroundColor: S.optional(ConditionalFormattingColor),
    TextColor: S.optional(ConditionalFormattingColor),
  }),
).annotations({
  identifier: "TableRowConditionalFormatting",
}) as any as S.Schema<TableRowConditionalFormatting>;
export interface TableConditionalFormattingOption {
  Cell?: TableCellConditionalFormatting;
  Row?: TableRowConditionalFormatting;
}
export const TableConditionalFormattingOption = S.suspend(() =>
  S.Struct({
    Cell: S.optional(TableCellConditionalFormatting),
    Row: S.optional(TableRowConditionalFormatting),
  }),
).annotations({
  identifier: "TableConditionalFormattingOption",
}) as any as S.Schema<TableConditionalFormattingOption>;
export type TableConditionalFormattingOptionList =
  TableConditionalFormattingOption[];
export const TableConditionalFormattingOptionList = S.Array(
  TableConditionalFormattingOption,
);
export interface TableConditionalFormatting {
  ConditionalFormattingOptions?: TableConditionalFormattingOption[];
}
export const TableConditionalFormatting = S.suspend(() =>
  S.Struct({
    ConditionalFormattingOptions: S.optional(
      TableConditionalFormattingOptionList,
    ),
  }),
).annotations({
  identifier: "TableConditionalFormatting",
}) as any as S.Schema<TableConditionalFormatting>;
export type VisualCustomActionTrigger = "DATA_POINT_CLICK" | "DATA_POINT_MENU";
export const VisualCustomActionTrigger = S.Literal(
  "DATA_POINT_CLICK",
  "DATA_POINT_MENU",
);
export type SelectedFieldList = string[];
export const SelectedFieldList = S.Array(S.String);
export type SelectedFieldOptions = "ALL_FIELDS";
export const SelectedFieldOptions = S.Literal("ALL_FIELDS");
export type CustomActionColumnList = ColumnIdentifier[];
export const CustomActionColumnList = S.Array(ColumnIdentifier);
export interface FilterOperationSelectedFieldsConfiguration {
  SelectedFields?: string[];
  SelectedFieldOptions?: SelectedFieldOptions;
  SelectedColumns?: ColumnIdentifier[];
}
export const FilterOperationSelectedFieldsConfiguration = S.suspend(() =>
  S.Struct({
    SelectedFields: S.optional(SelectedFieldList),
    SelectedFieldOptions: S.optional(SelectedFieldOptions),
    SelectedColumns: S.optional(CustomActionColumnList),
  }),
).annotations({
  identifier: "FilterOperationSelectedFieldsConfiguration",
}) as any as S.Schema<FilterOperationSelectedFieldsConfiguration>;
export type TargetVisualList = string[];
export const TargetVisualList = S.Array(S.String);
export type TargetVisualOptions = "ALL_VISUALS";
export const TargetVisualOptions = S.Literal("ALL_VISUALS");
export interface SameSheetTargetVisualConfiguration {
  TargetVisuals?: string[];
  TargetVisualOptions?: TargetVisualOptions;
}
export const SameSheetTargetVisualConfiguration = S.suspend(() =>
  S.Struct({
    TargetVisuals: S.optional(TargetVisualList),
    TargetVisualOptions: S.optional(TargetVisualOptions),
  }),
).annotations({
  identifier: "SameSheetTargetVisualConfiguration",
}) as any as S.Schema<SameSheetTargetVisualConfiguration>;
export interface FilterOperationTargetVisualsConfiguration {
  SameSheetTargetVisualConfiguration?: SameSheetTargetVisualConfiguration;
}
export const FilterOperationTargetVisualsConfiguration = S.suspend(() =>
  S.Struct({
    SameSheetTargetVisualConfiguration: S.optional(
      SameSheetTargetVisualConfiguration,
    ),
  }),
).annotations({
  identifier: "FilterOperationTargetVisualsConfiguration",
}) as any as S.Schema<FilterOperationTargetVisualsConfiguration>;
export interface CustomActionFilterOperation {
  SelectedFieldsConfiguration: FilterOperationSelectedFieldsConfiguration;
  TargetVisualsConfiguration: FilterOperationTargetVisualsConfiguration;
}
export const CustomActionFilterOperation = S.suspend(() =>
  S.Struct({
    SelectedFieldsConfiguration: FilterOperationSelectedFieldsConfiguration,
    TargetVisualsConfiguration: FilterOperationTargetVisualsConfiguration,
  }),
).annotations({
  identifier: "CustomActionFilterOperation",
}) as any as S.Schema<CustomActionFilterOperation>;
export interface LocalNavigationConfiguration {
  TargetSheetId: string;
}
export const LocalNavigationConfiguration = S.suspend(() =>
  S.Struct({ TargetSheetId: S.String }),
).annotations({
  identifier: "LocalNavigationConfiguration",
}) as any as S.Schema<LocalNavigationConfiguration>;
export interface CustomActionNavigationOperation {
  LocalNavigationConfiguration?: LocalNavigationConfiguration;
}
export const CustomActionNavigationOperation = S.suspend(() =>
  S.Struct({
    LocalNavigationConfiguration: S.optional(LocalNavigationConfiguration),
  }),
).annotations({
  identifier: "CustomActionNavigationOperation",
}) as any as S.Schema<CustomActionNavigationOperation>;
export interface CustomActionURLOperation {
  URLTemplate: string;
  URLTarget: URLTargetConfiguration;
}
export const CustomActionURLOperation = S.suspend(() =>
  S.Struct({ URLTemplate: S.String, URLTarget: URLTargetConfiguration }),
).annotations({
  identifier: "CustomActionURLOperation",
}) as any as S.Schema<CustomActionURLOperation>;
export type StringDefaultValueList = string | redacted.Redacted<string>[];
export const StringDefaultValueList = S.Array(SensitiveString);
export type IntegerDefaultValueList = number[];
export const IntegerDefaultValueList = S.Array(S.Number);
export type DecimalDefaultValueList = number[];
export const DecimalDefaultValueList = S.Array(S.Number);
export type DateTimeDefaultValueList = Date[];
export const DateTimeDefaultValueList = S.Array(
  S.Date.pipe(T.TimestampFormat("epoch-seconds")),
);
export interface CustomParameterValues {
  StringValues?: string | redacted.Redacted<string>[];
  IntegerValues?: number[];
  DecimalValues?: number[];
  DateTimeValues?: Date[];
}
export const CustomParameterValues = S.suspend(() =>
  S.Struct({
    StringValues: S.optional(StringDefaultValueList),
    IntegerValues: S.optional(IntegerDefaultValueList),
    DecimalValues: S.optional(DecimalDefaultValueList),
    DateTimeValues: S.optional(DateTimeDefaultValueList),
  }),
).annotations({
  identifier: "CustomParameterValues",
}) as any as S.Schema<CustomParameterValues>;
export interface CustomValuesConfiguration {
  IncludeNullValue?: boolean;
  CustomValues: CustomParameterValues;
}
export const CustomValuesConfiguration = S.suspend(() =>
  S.Struct({
    IncludeNullValue: S.optional(S.Boolean),
    CustomValues: CustomParameterValues,
  }),
).annotations({
  identifier: "CustomValuesConfiguration",
}) as any as S.Schema<CustomValuesConfiguration>;
export type SelectAllValueOptions = "ALL_VALUES";
export const SelectAllValueOptions = S.Literal("ALL_VALUES");
export interface DestinationParameterValueConfiguration {
  CustomValuesConfiguration?: CustomValuesConfiguration;
  SelectAllValueOptions?: SelectAllValueOptions;
  SourceParameterName?: string;
  SourceField?: string;
  SourceColumn?: ColumnIdentifier;
}
export const DestinationParameterValueConfiguration = S.suspend(() =>
  S.Struct({
    CustomValuesConfiguration: S.optional(CustomValuesConfiguration),
    SelectAllValueOptions: S.optional(SelectAllValueOptions),
    SourceParameterName: S.optional(S.String),
    SourceField: S.optional(S.String),
    SourceColumn: S.optional(ColumnIdentifier),
  }),
).annotations({
  identifier: "DestinationParameterValueConfiguration",
}) as any as S.Schema<DestinationParameterValueConfiguration>;
export interface SetParameterValueConfiguration {
  DestinationParameterName: string;
  Value: DestinationParameterValueConfiguration;
}
export const SetParameterValueConfiguration = S.suspend(() =>
  S.Struct({
    DestinationParameterName: S.String,
    Value: DestinationParameterValueConfiguration,
  }),
).annotations({
  identifier: "SetParameterValueConfiguration",
}) as any as S.Schema<SetParameterValueConfiguration>;
export type SetParameterValueConfigurationList =
  SetParameterValueConfiguration[];
export const SetParameterValueConfigurationList = S.Array(
  SetParameterValueConfiguration,
);
export interface CustomActionSetParametersOperation {
  ParameterValueConfigurations: SetParameterValueConfiguration[];
}
export const CustomActionSetParametersOperation = S.suspend(() =>
  S.Struct({
    ParameterValueConfigurations: SetParameterValueConfigurationList,
  }),
).annotations({
  identifier: "CustomActionSetParametersOperation",
}) as any as S.Schema<CustomActionSetParametersOperation>;
export interface VisualCustomActionOperation {
  FilterOperation?: CustomActionFilterOperation;
  NavigationOperation?: CustomActionNavigationOperation;
  URLOperation?: CustomActionURLOperation;
  SetParametersOperation?: CustomActionSetParametersOperation;
}
export const VisualCustomActionOperation = S.suspend(() =>
  S.Struct({
    FilterOperation: S.optional(CustomActionFilterOperation),
    NavigationOperation: S.optional(CustomActionNavigationOperation),
    URLOperation: S.optional(CustomActionURLOperation),
    SetParametersOperation: S.optional(CustomActionSetParametersOperation),
  }),
).annotations({
  identifier: "VisualCustomActionOperation",
}) as any as S.Schema<VisualCustomActionOperation>;
export type VisualCustomActionOperationList = VisualCustomActionOperation[];
export const VisualCustomActionOperationList = S.Array(
  VisualCustomActionOperation,
);
export interface VisualCustomAction {
  CustomActionId: string;
  Name: string;
  Status?: WidgetStatus;
  Trigger: VisualCustomActionTrigger;
  ActionOperations: VisualCustomActionOperation[];
}
export const VisualCustomAction = S.suspend(() =>
  S.Struct({
    CustomActionId: S.String,
    Name: S.String,
    Status: S.optional(WidgetStatus),
    Trigger: VisualCustomActionTrigger,
    ActionOperations: VisualCustomActionOperationList,
  }),
).annotations({
  identifier: "VisualCustomAction",
}) as any as S.Schema<VisualCustomAction>;
export type VisualCustomActionList = VisualCustomAction[];
export const VisualCustomActionList = S.Array(VisualCustomAction);
export interface TableVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: TableConfiguration;
  ConditionalFormatting?: TableConditionalFormatting;
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
}
export const TableVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(TableConfiguration),
    ConditionalFormatting: S.optional(TableConditionalFormatting),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({ identifier: "TableVisual" }) as any as S.Schema<TableVisual>;
export type PivotTableDimensionList = DimensionField[];
export const PivotTableDimensionList = S.Array(DimensionField);
export type PivotMeasureFieldList = MeasureField[];
export const PivotMeasureFieldList = S.Array(MeasureField);
export interface PivotTableAggregatedFieldWells {
  Rows?: DimensionField[];
  Columns?: DimensionField[];
  Values?: MeasureField[];
}
export const PivotTableAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Rows: S.optional(PivotTableDimensionList),
    Columns: S.optional(PivotTableDimensionList),
    Values: S.optional(PivotMeasureFieldList),
  }),
).annotations({
  identifier: "PivotTableAggregatedFieldWells",
}) as any as S.Schema<PivotTableAggregatedFieldWells>;
export interface PivotTableFieldWells {
  PivotTableAggregatedFieldWells?: PivotTableAggregatedFieldWells;
}
export const PivotTableFieldWells = S.suspend(() =>
  S.Struct({
    PivotTableAggregatedFieldWells: S.optional(PivotTableAggregatedFieldWells),
  }),
).annotations({
  identifier: "PivotTableFieldWells",
}) as any as S.Schema<PivotTableFieldWells>;
export type PivotTableDataPathType =
  | "HIERARCHY_ROWS_LAYOUT_COLUMN"
  | "MULTIPLE_ROW_METRICS_COLUMN"
  | "EMPTY_COLUMN_HEADER"
  | "COUNT_METRIC_COLUMN";
export const PivotTableDataPathType = S.Literal(
  "HIERARCHY_ROWS_LAYOUT_COLUMN",
  "MULTIPLE_ROW_METRICS_COLUMN",
  "EMPTY_COLUMN_HEADER",
  "COUNT_METRIC_COLUMN",
);
export interface DataPathType {
  PivotTableDataPathType?: PivotTableDataPathType;
}
export const DataPathType = S.suspend(() =>
  S.Struct({ PivotTableDataPathType: S.optional(PivotTableDataPathType) }),
).annotations({ identifier: "DataPathType" }) as any as S.Schema<DataPathType>;
export interface DataPathValue {
  FieldId?: string;
  FieldValue?: string | redacted.Redacted<string>;
  DataPathType?: DataPathType;
}
export const DataPathValue = S.suspend(() =>
  S.Struct({
    FieldId: S.optional(S.String),
    FieldValue: S.optional(SensitiveString),
    DataPathType: S.optional(DataPathType),
  }),
).annotations({
  identifier: "DataPathValue",
}) as any as S.Schema<DataPathValue>;
export type DataPathValueList = DataPathValue[];
export const DataPathValueList = S.Array(DataPathValue);
export interface DataPathSort {
  Direction: SortDirection;
  SortPaths: DataPathValue[];
}
export const DataPathSort = S.suspend(() =>
  S.Struct({ Direction: SortDirection, SortPaths: DataPathValueList }),
).annotations({ identifier: "DataPathSort" }) as any as S.Schema<DataPathSort>;
export interface PivotTableSortBy {
  Field?: FieldSort;
  Column?: ColumnSort;
  DataPath?: DataPathSort;
}
export const PivotTableSortBy = S.suspend(() =>
  S.Struct({
    Field: S.optional(FieldSort),
    Column: S.optional(ColumnSort),
    DataPath: S.optional(DataPathSort),
  }),
).annotations({
  identifier: "PivotTableSortBy",
}) as any as S.Schema<PivotTableSortBy>;
export interface PivotFieldSortOptions {
  FieldId: string;
  SortBy: PivotTableSortBy;
}
export const PivotFieldSortOptions = S.suspend(() =>
  S.Struct({ FieldId: S.String, SortBy: PivotTableSortBy }),
).annotations({
  identifier: "PivotFieldSortOptions",
}) as any as S.Schema<PivotFieldSortOptions>;
export type PivotFieldSortOptionsList = PivotFieldSortOptions[];
export const PivotFieldSortOptionsList = S.Array(PivotFieldSortOptions);
export interface PivotTableSortConfiguration {
  FieldSortOptions?: PivotFieldSortOptions[];
}
export const PivotTableSortConfiguration = S.suspend(() =>
  S.Struct({ FieldSortOptions: S.optional(PivotFieldSortOptionsList) }),
).annotations({
  identifier: "PivotTableSortConfiguration",
}) as any as S.Schema<PivotTableSortConfiguration>;
export type PivotTableMetricPlacement = "ROW" | "COLUMN";
export const PivotTableMetricPlacement = S.Literal("ROW", "COLUMN");
export type PivotTableRowsLayout = "TABULAR" | "HIERARCHY";
export const PivotTableRowsLayout = S.Literal("TABULAR", "HIERARCHY");
export interface PivotTableRowsLabelOptions {
  Visibility?: Visibility;
  CustomLabel?: string;
}
export const PivotTableRowsLabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    CustomLabel: S.optional(S.String),
  }),
).annotations({
  identifier: "PivotTableRowsLabelOptions",
}) as any as S.Schema<PivotTableRowsLabelOptions>;
export interface PivotTableOptions {
  MetricPlacement?: PivotTableMetricPlacement;
  SingleMetricVisibility?: Visibility;
  ColumnNamesVisibility?: Visibility;
  ToggleButtonsVisibility?: Visibility;
  ColumnHeaderStyle?: TableCellStyle;
  RowHeaderStyle?: TableCellStyle;
  CellStyle?: TableCellStyle;
  RowFieldNamesStyle?: TableCellStyle;
  RowAlternateColorOptions?: RowAlternateColorOptions;
  CollapsedRowDimensionsVisibility?: Visibility;
  RowsLayout?: PivotTableRowsLayout;
  RowsLabelOptions?: PivotTableRowsLabelOptions;
  DefaultCellWidth?: string;
}
export const PivotTableOptions = S.suspend(() =>
  S.Struct({
    MetricPlacement: S.optional(PivotTableMetricPlacement),
    SingleMetricVisibility: S.optional(Visibility),
    ColumnNamesVisibility: S.optional(Visibility),
    ToggleButtonsVisibility: S.optional(Visibility),
    ColumnHeaderStyle: S.optional(TableCellStyle),
    RowHeaderStyle: S.optional(TableCellStyle),
    CellStyle: S.optional(TableCellStyle),
    RowFieldNamesStyle: S.optional(TableCellStyle),
    RowAlternateColorOptions: S.optional(RowAlternateColorOptions),
    CollapsedRowDimensionsVisibility: S.optional(Visibility),
    RowsLayout: S.optional(PivotTableRowsLayout),
    RowsLabelOptions: S.optional(PivotTableRowsLabelOptions),
    DefaultCellWidth: S.optional(S.String),
  }),
).annotations({
  identifier: "PivotTableOptions",
}) as any as S.Schema<PivotTableOptions>;
export type PivotTableSubtotalLevel = "ALL" | "CUSTOM" | "LAST";
export const PivotTableSubtotalLevel = S.Literal("ALL", "CUSTOM", "LAST");
export interface PivotTableFieldSubtotalOptions {
  FieldId?: string;
}
export const PivotTableFieldSubtotalOptions = S.suspend(() =>
  S.Struct({ FieldId: S.optional(S.String) }),
).annotations({
  identifier: "PivotTableFieldSubtotalOptions",
}) as any as S.Schema<PivotTableFieldSubtotalOptions>;
export type PivotTableFieldSubtotalOptionsList =
  PivotTableFieldSubtotalOptions[];
export const PivotTableFieldSubtotalOptionsList = S.Array(
  PivotTableFieldSubtotalOptions,
);
export type StyledCellType = "TOTAL" | "METRIC_HEADER" | "VALUE";
export const StyledCellType = S.Literal("TOTAL", "METRIC_HEADER", "VALUE");
export interface TableStyleTarget {
  CellType: StyledCellType;
}
export const TableStyleTarget = S.suspend(() =>
  S.Struct({ CellType: StyledCellType }),
).annotations({
  identifier: "TableStyleTarget",
}) as any as S.Schema<TableStyleTarget>;
export type TableStyleTargetList = TableStyleTarget[];
export const TableStyleTargetList = S.Array(TableStyleTarget);
export interface SubtotalOptions {
  TotalsVisibility?: Visibility;
  CustomLabel?: string;
  FieldLevel?: PivotTableSubtotalLevel;
  FieldLevelOptions?: PivotTableFieldSubtotalOptions[];
  TotalCellStyle?: TableCellStyle;
  ValueCellStyle?: TableCellStyle;
  MetricHeaderCellStyle?: TableCellStyle;
  StyleTargets?: TableStyleTarget[];
}
export const SubtotalOptions = S.suspend(() =>
  S.Struct({
    TotalsVisibility: S.optional(Visibility),
    CustomLabel: S.optional(S.String),
    FieldLevel: S.optional(PivotTableSubtotalLevel),
    FieldLevelOptions: S.optional(PivotTableFieldSubtotalOptionsList),
    TotalCellStyle: S.optional(TableCellStyle),
    ValueCellStyle: S.optional(TableCellStyle),
    MetricHeaderCellStyle: S.optional(TableCellStyle),
    StyleTargets: S.optional(TableStyleTargetList),
  }),
).annotations({
  identifier: "SubtotalOptions",
}) as any as S.Schema<SubtotalOptions>;
export interface PivotTotalOptions {
  TotalsVisibility?: Visibility;
  Placement?: TableTotalsPlacement;
  ScrollStatus?: TableTotalsScrollStatus;
  CustomLabel?: string;
  TotalCellStyle?: TableCellStyle;
  ValueCellStyle?: TableCellStyle;
  MetricHeaderCellStyle?: TableCellStyle;
  TotalAggregationOptions?: TotalAggregationOption[];
}
export const PivotTotalOptions = S.suspend(() =>
  S.Struct({
    TotalsVisibility: S.optional(Visibility),
    Placement: S.optional(TableTotalsPlacement),
    ScrollStatus: S.optional(TableTotalsScrollStatus),
    CustomLabel: S.optional(S.String),
    TotalCellStyle: S.optional(TableCellStyle),
    ValueCellStyle: S.optional(TableCellStyle),
    MetricHeaderCellStyle: S.optional(TableCellStyle),
    TotalAggregationOptions: S.optional(TotalAggregationOptionList),
  }),
).annotations({
  identifier: "PivotTotalOptions",
}) as any as S.Schema<PivotTotalOptions>;
export interface PivotTableTotalOptions {
  RowSubtotalOptions?: SubtotalOptions;
  ColumnSubtotalOptions?: SubtotalOptions;
  RowTotalOptions?: PivotTotalOptions;
  ColumnTotalOptions?: PivotTotalOptions;
}
export const PivotTableTotalOptions = S.suspend(() =>
  S.Struct({
    RowSubtotalOptions: S.optional(SubtotalOptions),
    ColumnSubtotalOptions: S.optional(SubtotalOptions),
    RowTotalOptions: S.optional(PivotTotalOptions),
    ColumnTotalOptions: S.optional(PivotTotalOptions),
  }),
).annotations({
  identifier: "PivotTableTotalOptions",
}) as any as S.Schema<PivotTableTotalOptions>;
export interface PivotTableFieldOption {
  FieldId: string;
  CustomLabel?: string;
  Visibility?: Visibility;
}
export const PivotTableFieldOption = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    CustomLabel: S.optional(S.String),
    Visibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "PivotTableFieldOption",
}) as any as S.Schema<PivotTableFieldOption>;
export type PivotTableFieldOptionList = PivotTableFieldOption[];
export const PivotTableFieldOptionList = S.Array(PivotTableFieldOption);
export interface PivotTableDataPathOption {
  DataPathList: DataPathValue[];
  Width?: string;
}
export const PivotTableDataPathOption = S.suspend(() =>
  S.Struct({ DataPathList: DataPathValueList, Width: S.optional(S.String) }),
).annotations({
  identifier: "PivotTableDataPathOption",
}) as any as S.Schema<PivotTableDataPathOption>;
export type PivotTableDataPathOptionList = PivotTableDataPathOption[];
export const PivotTableDataPathOptionList = S.Array(PivotTableDataPathOption);
export interface PivotTableFieldCollapseStateTarget {
  FieldId?: string;
  FieldDataPathValues?: DataPathValue[];
}
export const PivotTableFieldCollapseStateTarget = S.suspend(() =>
  S.Struct({
    FieldId: S.optional(S.String),
    FieldDataPathValues: S.optional(DataPathValueList),
  }),
).annotations({
  identifier: "PivotTableFieldCollapseStateTarget",
}) as any as S.Schema<PivotTableFieldCollapseStateTarget>;
export type PivotTableFieldCollapseState = "COLLAPSED" | "EXPANDED";
export const PivotTableFieldCollapseState = S.Literal("COLLAPSED", "EXPANDED");
export interface PivotTableFieldCollapseStateOption {
  Target: PivotTableFieldCollapseStateTarget;
  State?: PivotTableFieldCollapseState;
}
export const PivotTableFieldCollapseStateOption = S.suspend(() =>
  S.Struct({
    Target: PivotTableFieldCollapseStateTarget,
    State: S.optional(PivotTableFieldCollapseState),
  }),
).annotations({
  identifier: "PivotTableFieldCollapseStateOption",
}) as any as S.Schema<PivotTableFieldCollapseStateOption>;
export type PivotTableFieldCollapseStateOptionList =
  PivotTableFieldCollapseStateOption[];
export const PivotTableFieldCollapseStateOptionList = S.Array(
  PivotTableFieldCollapseStateOption,
);
export interface PivotTableFieldOptions {
  SelectedFieldOptions?: PivotTableFieldOption[];
  DataPathOptions?: PivotTableDataPathOption[];
  CollapseStateOptions?: PivotTableFieldCollapseStateOption[];
}
export const PivotTableFieldOptions = S.suspend(() =>
  S.Struct({
    SelectedFieldOptions: S.optional(PivotTableFieldOptionList),
    DataPathOptions: S.optional(PivotTableDataPathOptionList),
    CollapseStateOptions: S.optional(PivotTableFieldCollapseStateOptionList),
  }),
).annotations({
  identifier: "PivotTableFieldOptions",
}) as any as S.Schema<PivotTableFieldOptions>;
export interface PivotTablePaginatedReportOptions {
  VerticalOverflowVisibility?: Visibility;
  OverflowColumnHeaderVisibility?: Visibility;
}
export const PivotTablePaginatedReportOptions = S.suspend(() =>
  S.Struct({
    VerticalOverflowVisibility: S.optional(Visibility),
    OverflowColumnHeaderVisibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "PivotTablePaginatedReportOptions",
}) as any as S.Schema<PivotTablePaginatedReportOptions>;
export interface PivotTableConfiguration {
  FieldWells?: PivotTableFieldWells;
  SortConfiguration?: PivotTableSortConfiguration;
  TableOptions?: PivotTableOptions;
  TotalOptions?: PivotTableTotalOptions;
  FieldOptions?: PivotTableFieldOptions;
  PaginatedReportOptions?: PivotTablePaginatedReportOptions;
  DashboardCustomizationVisualOptions?: DashboardCustomizationVisualOptions;
  Interactions?: VisualInteractionOptions;
}
export const PivotTableConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(PivotTableFieldWells),
    SortConfiguration: S.optional(PivotTableSortConfiguration),
    TableOptions: S.optional(PivotTableOptions),
    TotalOptions: S.optional(PivotTableTotalOptions),
    FieldOptions: S.optional(PivotTableFieldOptions),
    PaginatedReportOptions: S.optional(PivotTablePaginatedReportOptions),
    DashboardCustomizationVisualOptions: S.optional(
      DashboardCustomizationVisualOptions,
    ),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "PivotTableConfiguration",
}) as any as S.Schema<PivotTableConfiguration>;
export type PivotTableConditionalFormattingScopeRole =
  | "FIELD"
  | "FIELD_TOTAL"
  | "GRAND_TOTAL";
export const PivotTableConditionalFormattingScopeRole = S.Literal(
  "FIELD",
  "FIELD_TOTAL",
  "GRAND_TOTAL",
);
export interface PivotTableConditionalFormattingScope {
  Role?: PivotTableConditionalFormattingScopeRole;
}
export const PivotTableConditionalFormattingScope = S.suspend(() =>
  S.Struct({ Role: S.optional(PivotTableConditionalFormattingScopeRole) }),
).annotations({
  identifier: "PivotTableConditionalFormattingScope",
}) as any as S.Schema<PivotTableConditionalFormattingScope>;
export type PivotTableConditionalFormattingScopeList =
  PivotTableConditionalFormattingScope[];
export const PivotTableConditionalFormattingScopeList = S.Array(
  PivotTableConditionalFormattingScope,
);
export interface PivotTableCellConditionalFormatting {
  FieldId: string;
  TextFormat?: TextConditionalFormat;
  Scope?: PivotTableConditionalFormattingScope;
  Scopes?: PivotTableConditionalFormattingScope[];
}
export const PivotTableCellConditionalFormatting = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    TextFormat: S.optional(TextConditionalFormat),
    Scope: S.optional(PivotTableConditionalFormattingScope),
    Scopes: S.optional(PivotTableConditionalFormattingScopeList),
  }),
).annotations({
  identifier: "PivotTableCellConditionalFormatting",
}) as any as S.Schema<PivotTableCellConditionalFormatting>;
export interface PivotTableConditionalFormattingOption {
  Cell?: PivotTableCellConditionalFormatting;
}
export const PivotTableConditionalFormattingOption = S.suspend(() =>
  S.Struct({ Cell: S.optional(PivotTableCellConditionalFormatting) }),
).annotations({
  identifier: "PivotTableConditionalFormattingOption",
}) as any as S.Schema<PivotTableConditionalFormattingOption>;
export type PivotTableConditionalFormattingOptionList =
  PivotTableConditionalFormattingOption[];
export const PivotTableConditionalFormattingOptionList = S.Array(
  PivotTableConditionalFormattingOption,
);
export interface PivotTableConditionalFormatting {
  ConditionalFormattingOptions?: PivotTableConditionalFormattingOption[];
}
export const PivotTableConditionalFormatting = S.suspend(() =>
  S.Struct({
    ConditionalFormattingOptions: S.optional(
      PivotTableConditionalFormattingOptionList,
    ),
  }),
).annotations({
  identifier: "PivotTableConditionalFormatting",
}) as any as S.Schema<PivotTableConditionalFormatting>;
export interface PivotTableVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: PivotTableConfiguration;
  ConditionalFormatting?: PivotTableConditionalFormatting;
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
}
export const PivotTableVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(PivotTableConfiguration),
    ConditionalFormatting: S.optional(PivotTableConditionalFormatting),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "PivotTableVisual",
}) as any as S.Schema<PivotTableVisual>;
export type SmallMultiplesDimensionFieldList = DimensionField[];
export const SmallMultiplesDimensionFieldList = S.Array(DimensionField);
export interface BarChartAggregatedFieldWells {
  Category?: DimensionField[];
  Values?: MeasureField[];
  Colors?: DimensionField[];
  SmallMultiples?: DimensionField[];
}
export const BarChartAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Category: S.optional(DimensionFieldList),
    Values: S.optional(MeasureFieldList),
    Colors: S.optional(DimensionFieldList),
    SmallMultiples: S.optional(SmallMultiplesDimensionFieldList),
  }),
).annotations({
  identifier: "BarChartAggregatedFieldWells",
}) as any as S.Schema<BarChartAggregatedFieldWells>;
export interface BarChartFieldWells {
  BarChartAggregatedFieldWells?: BarChartAggregatedFieldWells;
}
export const BarChartFieldWells = S.suspend(() =>
  S.Struct({
    BarChartAggregatedFieldWells: S.optional(BarChartAggregatedFieldWells),
  }),
).annotations({
  identifier: "BarChartFieldWells",
}) as any as S.Schema<BarChartFieldWells>;
export type FieldSortOptionsList = FieldSortOptions[];
export const FieldSortOptionsList = S.Array(FieldSortOptions);
export type OtherCategories = "INCLUDE" | "EXCLUDE";
export const OtherCategories = S.Literal("INCLUDE", "EXCLUDE");
export interface ItemsLimitConfiguration {
  ItemsLimit?: number;
  OtherCategories?: OtherCategories;
}
export const ItemsLimitConfiguration = S.suspend(() =>
  S.Struct({
    ItemsLimit: S.optional(S.Number),
    OtherCategories: S.optional(OtherCategories),
  }),
).annotations({
  identifier: "ItemsLimitConfiguration",
}) as any as S.Schema<ItemsLimitConfiguration>;
export interface BarChartSortConfiguration {
  CategorySort?: FieldSortOptions[];
  CategoryItemsLimit?: ItemsLimitConfiguration;
  ColorSort?: FieldSortOptions[];
  ColorItemsLimit?: ItemsLimitConfiguration;
  SmallMultiplesSort?: FieldSortOptions[];
  SmallMultiplesLimitConfiguration?: ItemsLimitConfiguration;
}
export const BarChartSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    CategoryItemsLimit: S.optional(ItemsLimitConfiguration),
    ColorSort: S.optional(FieldSortOptionsList),
    ColorItemsLimit: S.optional(ItemsLimitConfiguration),
    SmallMultiplesSort: S.optional(FieldSortOptionsList),
    SmallMultiplesLimitConfiguration: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "BarChartSortConfiguration",
}) as any as S.Schema<BarChartSortConfiguration>;
export type BarChartOrientation = "HORIZONTAL" | "VERTICAL";
export const BarChartOrientation = S.Literal("HORIZONTAL", "VERTICAL");
export type BarsArrangement = "CLUSTERED" | "STACKED" | "STACKED_PERCENT";
export const BarsArrangement = S.Literal(
  "CLUSTERED",
  "STACKED",
  "STACKED_PERCENT",
);
export interface DataPathColor {
  Element: DataPathValue;
  Color: string;
  TimeGranularity?: TimeGranularity;
}
export const DataPathColor = S.suspend(() =>
  S.Struct({
    Element: DataPathValue,
    Color: S.String,
    TimeGranularity: S.optional(TimeGranularity),
  }),
).annotations({
  identifier: "DataPathColor",
}) as any as S.Schema<DataPathColor>;
export type DataPathColorList = DataPathColor[];
export const DataPathColorList = S.Array(DataPathColor);
export interface VisualPalette {
  ChartColor?: string;
  ColorMap?: DataPathColor[];
}
export const VisualPalette = S.suspend(() =>
  S.Struct({
    ChartColor: S.optional(S.String),
    ColorMap: S.optional(DataPathColorList),
  }),
).annotations({
  identifier: "VisualPalette",
}) as any as S.Schema<VisualPalette>;
export interface PanelTitleOptions {
  Visibility?: Visibility;
  FontConfiguration?: FontConfiguration;
  HorizontalTextAlignment?: HorizontalTextAlignment;
}
export const PanelTitleOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    FontConfiguration: S.optional(FontConfiguration),
    HorizontalTextAlignment: S.optional(HorizontalTextAlignment),
  }),
).annotations({
  identifier: "PanelTitleOptions",
}) as any as S.Schema<PanelTitleOptions>;
export type PanelBorderStyle = "SOLID" | "DASHED" | "DOTTED";
export const PanelBorderStyle = S.Literal("SOLID", "DASHED", "DOTTED");
export interface PanelConfiguration {
  Title?: PanelTitleOptions;
  BorderVisibility?: Visibility;
  BorderThickness?: string;
  BorderStyle?: PanelBorderStyle;
  BorderColor?: string;
  GutterVisibility?: Visibility;
  GutterSpacing?: string;
  BackgroundVisibility?: Visibility;
  BackgroundColor?: string;
}
export const PanelConfiguration = S.suspend(() =>
  S.Struct({
    Title: S.optional(PanelTitleOptions),
    BorderVisibility: S.optional(Visibility),
    BorderThickness: S.optional(S.String),
    BorderStyle: S.optional(PanelBorderStyle),
    BorderColor: S.optional(S.String),
    GutterVisibility: S.optional(Visibility),
    GutterSpacing: S.optional(S.String),
    BackgroundVisibility: S.optional(Visibility),
    BackgroundColor: S.optional(S.String),
  }),
).annotations({
  identifier: "PanelConfiguration",
}) as any as S.Schema<PanelConfiguration>;
export type SmallMultiplesAxisScale = "SHARED" | "INDEPENDENT";
export const SmallMultiplesAxisScale = S.Literal("SHARED", "INDEPENDENT");
export type SmallMultiplesAxisPlacement = "OUTSIDE" | "INSIDE";
export const SmallMultiplesAxisPlacement = S.Literal("OUTSIDE", "INSIDE");
export interface SmallMultiplesAxisProperties {
  Scale?: SmallMultiplesAxisScale;
  Placement?: SmallMultiplesAxisPlacement;
}
export const SmallMultiplesAxisProperties = S.suspend(() =>
  S.Struct({
    Scale: S.optional(SmallMultiplesAxisScale),
    Placement: S.optional(SmallMultiplesAxisPlacement),
  }),
).annotations({
  identifier: "SmallMultiplesAxisProperties",
}) as any as S.Schema<SmallMultiplesAxisProperties>;
export interface SmallMultiplesOptions {
  MaxVisibleRows?: number;
  MaxVisibleColumns?: number;
  PanelConfiguration?: PanelConfiguration;
  XAxis?: SmallMultiplesAxisProperties;
  YAxis?: SmallMultiplesAxisProperties;
}
export const SmallMultiplesOptions = S.suspend(() =>
  S.Struct({
    MaxVisibleRows: S.optional(S.Number),
    MaxVisibleColumns: S.optional(S.Number),
    PanelConfiguration: S.optional(PanelConfiguration),
    XAxis: S.optional(SmallMultiplesAxisProperties),
    YAxis: S.optional(SmallMultiplesAxisProperties),
  }),
).annotations({
  identifier: "SmallMultiplesOptions",
}) as any as S.Schema<SmallMultiplesOptions>;
export interface AxisTickLabelOptions {
  LabelOptions?: LabelOptions;
  RotationAngle?: number;
}
export const AxisTickLabelOptions = S.suspend(() =>
  S.Struct({
    LabelOptions: S.optional(LabelOptions),
    RotationAngle: S.optional(S.Number),
  }),
).annotations({
  identifier: "AxisTickLabelOptions",
}) as any as S.Schema<AxisTickLabelOptions>;
export interface AxisLinearScale {
  StepCount?: number;
  StepSize?: number;
}
export const AxisLinearScale = S.suspend(() =>
  S.Struct({ StepCount: S.optional(S.Number), StepSize: S.optional(S.Number) }),
).annotations({
  identifier: "AxisLinearScale",
}) as any as S.Schema<AxisLinearScale>;
export interface AxisLogarithmicScale {
  Base?: number;
}
export const AxisLogarithmicScale = S.suspend(() =>
  S.Struct({ Base: S.optional(S.Number) }),
).annotations({
  identifier: "AxisLogarithmicScale",
}) as any as S.Schema<AxisLogarithmicScale>;
export interface AxisScale {
  Linear?: AxisLinearScale;
  Logarithmic?: AxisLogarithmicScale;
}
export const AxisScale = S.suspend(() =>
  S.Struct({
    Linear: S.optional(AxisLinearScale),
    Logarithmic: S.optional(AxisLogarithmicScale),
  }),
).annotations({ identifier: "AxisScale" }) as any as S.Schema<AxisScale>;
export interface AxisDisplayMinMaxRange {
  Minimum?: number;
  Maximum?: number;
}
export const AxisDisplayMinMaxRange = S.suspend(() =>
  S.Struct({ Minimum: S.optional(S.Number), Maximum: S.optional(S.Number) }),
).annotations({
  identifier: "AxisDisplayMinMaxRange",
}) as any as S.Schema<AxisDisplayMinMaxRange>;
export interface AxisDisplayDataDrivenRange {}
export const AxisDisplayDataDrivenRange = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AxisDisplayDataDrivenRange",
}) as any as S.Schema<AxisDisplayDataDrivenRange>;
export interface AxisDisplayRange {
  MinMax?: AxisDisplayMinMaxRange;
  DataDriven?: AxisDisplayDataDrivenRange;
}
export const AxisDisplayRange = S.suspend(() =>
  S.Struct({
    MinMax: S.optional(AxisDisplayMinMaxRange),
    DataDriven: S.optional(AxisDisplayDataDrivenRange),
  }),
).annotations({
  identifier: "AxisDisplayRange",
}) as any as S.Schema<AxisDisplayRange>;
export interface NumericAxisOptions {
  Scale?: AxisScale;
  Range?: AxisDisplayRange;
}
export const NumericAxisOptions = S.suspend(() =>
  S.Struct({
    Scale: S.optional(AxisScale),
    Range: S.optional(AxisDisplayRange),
  }),
).annotations({
  identifier: "NumericAxisOptions",
}) as any as S.Schema<NumericAxisOptions>;
export interface DateAxisOptions {
  MissingDateVisibility?: Visibility;
}
export const DateAxisOptions = S.suspend(() =>
  S.Struct({ MissingDateVisibility: S.optional(Visibility) }),
).annotations({
  identifier: "DateAxisOptions",
}) as any as S.Schema<DateAxisOptions>;
export interface AxisDataOptions {
  NumericAxisOptions?: NumericAxisOptions;
  DateAxisOptions?: DateAxisOptions;
}
export const AxisDataOptions = S.suspend(() =>
  S.Struct({
    NumericAxisOptions: S.optional(NumericAxisOptions),
    DateAxisOptions: S.optional(DateAxisOptions),
  }),
).annotations({
  identifier: "AxisDataOptions",
}) as any as S.Schema<AxisDataOptions>;
export interface PercentVisibleRange {
  From?: number;
  To?: number;
}
export const PercentVisibleRange = S.suspend(() =>
  S.Struct({ From: S.optional(S.Number), To: S.optional(S.Number) }),
).annotations({
  identifier: "PercentVisibleRange",
}) as any as S.Schema<PercentVisibleRange>;
export interface VisibleRangeOptions {
  PercentRange?: PercentVisibleRange;
}
export const VisibleRangeOptions = S.suspend(() =>
  S.Struct({ PercentRange: S.optional(PercentVisibleRange) }),
).annotations({
  identifier: "VisibleRangeOptions",
}) as any as S.Schema<VisibleRangeOptions>;
export interface ScrollBarOptions {
  Visibility?: Visibility;
  VisibleRange?: VisibleRangeOptions;
}
export const ScrollBarOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    VisibleRange: S.optional(VisibleRangeOptions),
  }),
).annotations({
  identifier: "ScrollBarOptions",
}) as any as S.Schema<ScrollBarOptions>;
export interface AxisDisplayOptions {
  TickLabelOptions?: AxisTickLabelOptions;
  AxisLineVisibility?: Visibility;
  GridLineVisibility?: Visibility;
  DataOptions?: AxisDataOptions;
  ScrollbarOptions?: ScrollBarOptions;
  AxisOffset?: string;
}
export const AxisDisplayOptions = S.suspend(() =>
  S.Struct({
    TickLabelOptions: S.optional(AxisTickLabelOptions),
    AxisLineVisibility: S.optional(Visibility),
    GridLineVisibility: S.optional(Visibility),
    DataOptions: S.optional(AxisDataOptions),
    ScrollbarOptions: S.optional(ScrollBarOptions),
    AxisOffset: S.optional(S.String),
  }),
).annotations({
  identifier: "AxisDisplayOptions",
}) as any as S.Schema<AxisDisplayOptions>;
export interface AxisLabelReferenceOptions {
  FieldId: string;
  Column: ColumnIdentifier;
}
export const AxisLabelReferenceOptions = S.suspend(() =>
  S.Struct({ FieldId: S.String, Column: ColumnIdentifier }),
).annotations({
  identifier: "AxisLabelReferenceOptions",
}) as any as S.Schema<AxisLabelReferenceOptions>;
export interface AxisLabelOptions {
  FontConfiguration?: FontConfiguration;
  CustomLabel?: string;
  ApplyTo?: AxisLabelReferenceOptions;
}
export const AxisLabelOptions = S.suspend(() =>
  S.Struct({
    FontConfiguration: S.optional(FontConfiguration),
    CustomLabel: S.optional(S.String),
    ApplyTo: S.optional(AxisLabelReferenceOptions),
  }),
).annotations({
  identifier: "AxisLabelOptions",
}) as any as S.Schema<AxisLabelOptions>;
export type AxisLabelOptionsList = AxisLabelOptions[];
export const AxisLabelOptionsList = S.Array(AxisLabelOptions);
export interface ChartAxisLabelOptions {
  Visibility?: Visibility;
  SortIconVisibility?: Visibility;
  AxisLabelOptions?: AxisLabelOptions[];
}
export const ChartAxisLabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    SortIconVisibility: S.optional(Visibility),
    AxisLabelOptions: S.optional(AxisLabelOptionsList),
  }),
).annotations({
  identifier: "ChartAxisLabelOptions",
}) as any as S.Schema<ChartAxisLabelOptions>;
export type DecalPatternType =
  | "SOLID"
  | "DIAGONAL_MEDIUM"
  | "CIRCLE_MEDIUM"
  | "DIAMOND_GRID_MEDIUM"
  | "CHECKERBOARD_MEDIUM"
  | "TRIANGLE_MEDIUM"
  | "DIAGONAL_OPPOSITE_MEDIUM"
  | "DIAMOND_MEDIUM"
  | "DIAGONAL_LARGE"
  | "CIRCLE_LARGE"
  | "DIAMOND_GRID_LARGE"
  | "CHECKERBOARD_LARGE"
  | "TRIANGLE_LARGE"
  | "DIAGONAL_OPPOSITE_LARGE"
  | "DIAMOND_LARGE"
  | "DIAGONAL_SMALL"
  | "CIRCLE_SMALL"
  | "DIAMOND_GRID_SMALL"
  | "CHECKERBOARD_SMALL"
  | "TRIANGLE_SMALL"
  | "DIAGONAL_OPPOSITE_SMALL"
  | "DIAMOND_SMALL";
export const DecalPatternType = S.Literal(
  "SOLID",
  "DIAGONAL_MEDIUM",
  "CIRCLE_MEDIUM",
  "DIAMOND_GRID_MEDIUM",
  "CHECKERBOARD_MEDIUM",
  "TRIANGLE_MEDIUM",
  "DIAGONAL_OPPOSITE_MEDIUM",
  "DIAMOND_MEDIUM",
  "DIAGONAL_LARGE",
  "CIRCLE_LARGE",
  "DIAMOND_GRID_LARGE",
  "CHECKERBOARD_LARGE",
  "TRIANGLE_LARGE",
  "DIAGONAL_OPPOSITE_LARGE",
  "DIAMOND_LARGE",
  "DIAGONAL_SMALL",
  "CIRCLE_SMALL",
  "DIAMOND_GRID_SMALL",
  "CHECKERBOARD_SMALL",
  "TRIANGLE_SMALL",
  "DIAGONAL_OPPOSITE_SMALL",
  "DIAMOND_SMALL",
);
export type DecalStyleType = "Manual" | "Auto";
export const DecalStyleType = S.Literal("Manual", "Auto");
export interface DecalSettings {
  ElementValue?: string;
  DecalVisibility?: Visibility;
  DecalColor?: string;
  DecalPatternType?: DecalPatternType;
  DecalStyleType?: DecalStyleType;
}
export const DecalSettings = S.suspend(() =>
  S.Struct({
    ElementValue: S.optional(S.String),
    DecalVisibility: S.optional(Visibility),
    DecalColor: S.optional(S.String),
    DecalPatternType: S.optional(DecalPatternType),
    DecalStyleType: S.optional(DecalStyleType),
  }),
).annotations({
  identifier: "DecalSettings",
}) as any as S.Schema<DecalSettings>;
export interface BorderSettings {
  BorderVisibility?: Visibility;
  BorderWidth?: string;
  BorderColor?: string;
}
export const BorderSettings = S.suspend(() =>
  S.Struct({
    BorderVisibility: S.optional(Visibility),
    BorderWidth: S.optional(S.String),
    BorderColor: S.optional(S.String),
  }),
).annotations({
  identifier: "BorderSettings",
}) as any as S.Schema<BorderSettings>;
export interface BarChartDefaultSeriesSettings {
  DecalSettings?: DecalSettings;
  BorderSettings?: BorderSettings;
}
export const BarChartDefaultSeriesSettings = S.suspend(() =>
  S.Struct({
    DecalSettings: S.optional(DecalSettings),
    BorderSettings: S.optional(BorderSettings),
  }),
).annotations({
  identifier: "BarChartDefaultSeriesSettings",
}) as any as S.Schema<BarChartDefaultSeriesSettings>;
export interface BarChartSeriesSettings {
  DecalSettings?: DecalSettings;
  BorderSettings?: BorderSettings;
}
export const BarChartSeriesSettings = S.suspend(() =>
  S.Struct({
    DecalSettings: S.optional(DecalSettings),
    BorderSettings: S.optional(BorderSettings),
  }),
).annotations({
  identifier: "BarChartSeriesSettings",
}) as any as S.Schema<BarChartSeriesSettings>;
export interface FieldBarSeriesItem {
  FieldId: string;
  Settings?: BarChartSeriesSettings;
}
export const FieldBarSeriesItem = S.suspend(() =>
  S.Struct({ FieldId: S.String, Settings: S.optional(BarChartSeriesSettings) }),
).annotations({
  identifier: "FieldBarSeriesItem",
}) as any as S.Schema<FieldBarSeriesItem>;
export interface DataFieldBarSeriesItem {
  FieldId: string;
  FieldValue?: string | redacted.Redacted<string>;
  Settings?: BarChartSeriesSettings;
}
export const DataFieldBarSeriesItem = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    FieldValue: S.optional(SensitiveString),
    Settings: S.optional(BarChartSeriesSettings),
  }),
).annotations({
  identifier: "DataFieldBarSeriesItem",
}) as any as S.Schema<DataFieldBarSeriesItem>;
export interface BarSeriesItem {
  FieldBarSeriesItem?: FieldBarSeriesItem;
  DataFieldBarSeriesItem?: DataFieldBarSeriesItem;
}
export const BarSeriesItem = S.suspend(() =>
  S.Struct({
    FieldBarSeriesItem: S.optional(FieldBarSeriesItem),
    DataFieldBarSeriesItem: S.optional(DataFieldBarSeriesItem),
  }),
).annotations({
  identifier: "BarSeriesItem",
}) as any as S.Schema<BarSeriesItem>;
export type BarSeriesItemList = BarSeriesItem[];
export const BarSeriesItemList = S.Array(BarSeriesItem);
export type LegendPosition = "AUTO" | "RIGHT" | "BOTTOM" | "TOP";
export const LegendPosition = S.Literal("AUTO", "RIGHT", "BOTTOM", "TOP");
export interface LegendOptions {
  Visibility?: Visibility;
  Title?: LabelOptions;
  Position?: LegendPosition;
  Width?: string;
  Height?: string;
  ValueFontConfiguration?: FontConfiguration;
}
export const LegendOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    Title: S.optional(LabelOptions),
    Position: S.optional(LegendPosition),
    Width: S.optional(S.String),
    Height: S.optional(S.String),
    ValueFontConfiguration: S.optional(FontConfiguration),
  }),
).annotations({
  identifier: "LegendOptions",
}) as any as S.Schema<LegendOptions>;
export interface FieldLabelType {
  FieldId?: string;
  Visibility?: Visibility;
}
export const FieldLabelType = S.suspend(() =>
  S.Struct({
    FieldId: S.optional(S.String),
    Visibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "FieldLabelType",
}) as any as S.Schema<FieldLabelType>;
export interface DataPathLabelType {
  FieldId?: string;
  FieldValue?: string | redacted.Redacted<string>;
  Visibility?: Visibility;
}
export const DataPathLabelType = S.suspend(() =>
  S.Struct({
    FieldId: S.optional(S.String),
    FieldValue: S.optional(SensitiveString),
    Visibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "DataPathLabelType",
}) as any as S.Schema<DataPathLabelType>;
export interface RangeEndsLabelType {
  Visibility?: Visibility;
}
export const RangeEndsLabelType = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "RangeEndsLabelType",
}) as any as S.Schema<RangeEndsLabelType>;
export interface MinimumLabelType {
  Visibility?: Visibility;
}
export const MinimumLabelType = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "MinimumLabelType",
}) as any as S.Schema<MinimumLabelType>;
export interface MaximumLabelType {
  Visibility?: Visibility;
}
export const MaximumLabelType = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "MaximumLabelType",
}) as any as S.Schema<MaximumLabelType>;
export interface DataLabelType {
  FieldLabelType?: FieldLabelType;
  DataPathLabelType?: DataPathLabelType;
  RangeEndsLabelType?: RangeEndsLabelType;
  MinimumLabelType?: MinimumLabelType;
  MaximumLabelType?: MaximumLabelType;
}
export const DataLabelType = S.suspend(() =>
  S.Struct({
    FieldLabelType: S.optional(FieldLabelType),
    DataPathLabelType: S.optional(DataPathLabelType),
    RangeEndsLabelType: S.optional(RangeEndsLabelType),
    MinimumLabelType: S.optional(MinimumLabelType),
    MaximumLabelType: S.optional(MaximumLabelType),
  }),
).annotations({
  identifier: "DataLabelType",
}) as any as S.Schema<DataLabelType>;
export type DataLabelTypes = DataLabelType[];
export const DataLabelTypes = S.Array(DataLabelType);
export type DataLabelPosition =
  | "INSIDE"
  | "OUTSIDE"
  | "LEFT"
  | "TOP"
  | "BOTTOM"
  | "RIGHT";
export const DataLabelPosition = S.Literal(
  "INSIDE",
  "OUTSIDE",
  "LEFT",
  "TOP",
  "BOTTOM",
  "RIGHT",
);
export type DataLabelContent = "VALUE" | "PERCENT" | "VALUE_AND_PERCENT";
export const DataLabelContent = S.Literal(
  "VALUE",
  "PERCENT",
  "VALUE_AND_PERCENT",
);
export type DataLabelOverlap = "DISABLE_OVERLAP" | "ENABLE_OVERLAP";
export const DataLabelOverlap = S.Literal("DISABLE_OVERLAP", "ENABLE_OVERLAP");
export interface DataLabelOptions {
  Visibility?: Visibility;
  CategoryLabelVisibility?: Visibility;
  MeasureLabelVisibility?: Visibility;
  DataLabelTypes?: DataLabelType[];
  Position?: DataLabelPosition;
  LabelContent?: DataLabelContent;
  LabelFontConfiguration?: FontConfiguration;
  LabelColor?: string;
  Overlap?: DataLabelOverlap;
  TotalsVisibility?: Visibility;
}
export const DataLabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    CategoryLabelVisibility: S.optional(Visibility),
    MeasureLabelVisibility: S.optional(Visibility),
    DataLabelTypes: S.optional(DataLabelTypes),
    Position: S.optional(DataLabelPosition),
    LabelContent: S.optional(DataLabelContent),
    LabelFontConfiguration: S.optional(FontConfiguration),
    LabelColor: S.optional(S.String),
    Overlap: S.optional(DataLabelOverlap),
    TotalsVisibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "DataLabelOptions",
}) as any as S.Schema<DataLabelOptions>;
export type SelectedTooltipType = "BASIC" | "DETAILED";
export const SelectedTooltipType = S.Literal("BASIC", "DETAILED");
export type TooltipTitleType = "NONE" | "PRIMARY_VALUE";
export const TooltipTitleType = S.Literal("NONE", "PRIMARY_VALUE");
export type TooltipTarget = "BOTH" | "BAR" | "LINE";
export const TooltipTarget = S.Literal("BOTH", "BAR", "LINE");
export interface FieldTooltipItem {
  FieldId: string;
  Label?: string;
  Visibility?: Visibility;
  TooltipTarget?: TooltipTarget;
}
export const FieldTooltipItem = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Label: S.optional(S.String),
    Visibility: S.optional(Visibility),
    TooltipTarget: S.optional(TooltipTarget),
  }),
).annotations({
  identifier: "FieldTooltipItem",
}) as any as S.Schema<FieldTooltipItem>;
export interface ColumnTooltipItem {
  Column: ColumnIdentifier;
  Label?: string;
  Visibility?: Visibility;
  Aggregation?: AggregationFunction;
  TooltipTarget?: TooltipTarget;
}
export const ColumnTooltipItem = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    Label: S.optional(S.String),
    Visibility: S.optional(Visibility),
    Aggregation: S.optional(AggregationFunction),
    TooltipTarget: S.optional(TooltipTarget),
  }),
).annotations({
  identifier: "ColumnTooltipItem",
}) as any as S.Schema<ColumnTooltipItem>;
export interface TooltipItem {
  FieldTooltipItem?: FieldTooltipItem;
  ColumnTooltipItem?: ColumnTooltipItem;
}
export const TooltipItem = S.suspend(() =>
  S.Struct({
    FieldTooltipItem: S.optional(FieldTooltipItem),
    ColumnTooltipItem: S.optional(ColumnTooltipItem),
  }),
).annotations({ identifier: "TooltipItem" }) as any as S.Schema<TooltipItem>;
export type TooltipItemList = TooltipItem[];
export const TooltipItemList = S.Array(TooltipItem);
export interface FieldBasedTooltip {
  AggregationVisibility?: Visibility;
  TooltipTitleType?: TooltipTitleType;
  TooltipFields?: TooltipItem[];
}
export const FieldBasedTooltip = S.suspend(() =>
  S.Struct({
    AggregationVisibility: S.optional(Visibility),
    TooltipTitleType: S.optional(TooltipTitleType),
    TooltipFields: S.optional(TooltipItemList),
  }),
).annotations({
  identifier: "FieldBasedTooltip",
}) as any as S.Schema<FieldBasedTooltip>;
export interface TooltipOptions {
  TooltipVisibility?: Visibility;
  SelectedTooltipType?: SelectedTooltipType;
  FieldBasedTooltip?: FieldBasedTooltip;
}
export const TooltipOptions = S.suspend(() =>
  S.Struct({
    TooltipVisibility: S.optional(Visibility),
    SelectedTooltipType: S.optional(SelectedTooltipType),
    FieldBasedTooltip: S.optional(FieldBasedTooltip),
  }),
).annotations({
  identifier: "TooltipOptions",
}) as any as S.Schema<TooltipOptions>;
export interface ReferenceLineStaticDataConfiguration {
  Value: number;
}
export const ReferenceLineStaticDataConfiguration = S.suspend(() =>
  S.Struct({ Value: S.Number }),
).annotations({
  identifier: "ReferenceLineStaticDataConfiguration",
}) as any as S.Schema<ReferenceLineStaticDataConfiguration>;
export interface ReferenceLineDynamicDataConfiguration {
  Column: ColumnIdentifier;
  MeasureAggregationFunction?: AggregationFunction;
  Calculation: NumericalAggregationFunction;
}
export const ReferenceLineDynamicDataConfiguration = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    MeasureAggregationFunction: S.optional(AggregationFunction),
    Calculation: NumericalAggregationFunction,
  }),
).annotations({
  identifier: "ReferenceLineDynamicDataConfiguration",
}) as any as S.Schema<ReferenceLineDynamicDataConfiguration>;
export type AxisBinding = "PRIMARY_YAXIS" | "SECONDARY_YAXIS";
export const AxisBinding = S.Literal("PRIMARY_YAXIS", "SECONDARY_YAXIS");
export type ReferenceLineSeriesType = "BAR" | "LINE";
export const ReferenceLineSeriesType = S.Literal("BAR", "LINE");
export interface ReferenceLineDataConfiguration {
  StaticConfiguration?: ReferenceLineStaticDataConfiguration;
  DynamicConfiguration?: ReferenceLineDynamicDataConfiguration;
  AxisBinding?: AxisBinding;
  SeriesType?: ReferenceLineSeriesType;
}
export const ReferenceLineDataConfiguration = S.suspend(() =>
  S.Struct({
    StaticConfiguration: S.optional(ReferenceLineStaticDataConfiguration),
    DynamicConfiguration: S.optional(ReferenceLineDynamicDataConfiguration),
    AxisBinding: S.optional(AxisBinding),
    SeriesType: S.optional(ReferenceLineSeriesType),
  }),
).annotations({
  identifier: "ReferenceLineDataConfiguration",
}) as any as S.Schema<ReferenceLineDataConfiguration>;
export type ReferenceLinePatternType = "SOLID" | "DASHED" | "DOTTED";
export const ReferenceLinePatternType = S.Literal("SOLID", "DASHED", "DOTTED");
export interface ReferenceLineStyleConfiguration {
  Pattern?: ReferenceLinePatternType;
  Color?: string;
}
export const ReferenceLineStyleConfiguration = S.suspend(() =>
  S.Struct({
    Pattern: S.optional(ReferenceLinePatternType),
    Color: S.optional(S.String),
  }),
).annotations({
  identifier: "ReferenceLineStyleConfiguration",
}) as any as S.Schema<ReferenceLineStyleConfiguration>;
export type ReferenceLineValueLabelRelativePosition =
  | "BEFORE_CUSTOM_LABEL"
  | "AFTER_CUSTOM_LABEL";
export const ReferenceLineValueLabelRelativePosition = S.Literal(
  "BEFORE_CUSTOM_LABEL",
  "AFTER_CUSTOM_LABEL",
);
export interface ReferenceLineValueLabelConfiguration {
  RelativePosition?: ReferenceLineValueLabelRelativePosition;
  FormatConfiguration?: NumericFormatConfiguration;
}
export const ReferenceLineValueLabelConfiguration = S.suspend(() =>
  S.Struct({
    RelativePosition: S.optional(ReferenceLineValueLabelRelativePosition),
    FormatConfiguration: S.optional(NumericFormatConfiguration),
  }),
).annotations({
  identifier: "ReferenceLineValueLabelConfiguration",
}) as any as S.Schema<ReferenceLineValueLabelConfiguration>;
export interface ReferenceLineCustomLabelConfiguration {
  CustomLabel: string;
}
export const ReferenceLineCustomLabelConfiguration = S.suspend(() =>
  S.Struct({ CustomLabel: S.String }),
).annotations({
  identifier: "ReferenceLineCustomLabelConfiguration",
}) as any as S.Schema<ReferenceLineCustomLabelConfiguration>;
export type ReferenceLineLabelHorizontalPosition = "LEFT" | "CENTER" | "RIGHT";
export const ReferenceLineLabelHorizontalPosition = S.Literal(
  "LEFT",
  "CENTER",
  "RIGHT",
);
export type ReferenceLineLabelVerticalPosition = "ABOVE" | "BELOW";
export const ReferenceLineLabelVerticalPosition = S.Literal("ABOVE", "BELOW");
export interface ReferenceLineLabelConfiguration {
  ValueLabelConfiguration?: ReferenceLineValueLabelConfiguration;
  CustomLabelConfiguration?: ReferenceLineCustomLabelConfiguration;
  FontConfiguration?: FontConfiguration;
  FontColor?: string;
  HorizontalPosition?: ReferenceLineLabelHorizontalPosition;
  VerticalPosition?: ReferenceLineLabelVerticalPosition;
}
export const ReferenceLineLabelConfiguration = S.suspend(() =>
  S.Struct({
    ValueLabelConfiguration: S.optional(ReferenceLineValueLabelConfiguration),
    CustomLabelConfiguration: S.optional(ReferenceLineCustomLabelConfiguration),
    FontConfiguration: S.optional(FontConfiguration),
    FontColor: S.optional(S.String),
    HorizontalPosition: S.optional(ReferenceLineLabelHorizontalPosition),
    VerticalPosition: S.optional(ReferenceLineLabelVerticalPosition),
  }),
).annotations({
  identifier: "ReferenceLineLabelConfiguration",
}) as any as S.Schema<ReferenceLineLabelConfiguration>;
export interface ReferenceLine {
  Status?: WidgetStatus;
  DataConfiguration: ReferenceLineDataConfiguration;
  StyleConfiguration?: ReferenceLineStyleConfiguration;
  LabelConfiguration?: ReferenceLineLabelConfiguration;
}
export const ReferenceLine = S.suspend(() =>
  S.Struct({
    Status: S.optional(WidgetStatus),
    DataConfiguration: ReferenceLineDataConfiguration,
    StyleConfiguration: S.optional(ReferenceLineStyleConfiguration),
    LabelConfiguration: S.optional(ReferenceLineLabelConfiguration),
  }),
).annotations({
  identifier: "ReferenceLine",
}) as any as S.Schema<ReferenceLine>;
export type ReferenceLineList = ReferenceLine[];
export const ReferenceLineList = S.Array(ReferenceLine);
export type ContributorDimensionList = ColumnIdentifier[];
export const ContributorDimensionList = S.Array(ColumnIdentifier);
export interface ContributionAnalysisDefault {
  MeasureFieldId: string;
  ContributorDimensions: ColumnIdentifier[];
}
export const ContributionAnalysisDefault = S.suspend(() =>
  S.Struct({
    MeasureFieldId: S.String,
    ContributorDimensions: ContributorDimensionList,
  }),
).annotations({
  identifier: "ContributionAnalysisDefault",
}) as any as S.Schema<ContributionAnalysisDefault>;
export type ContributionAnalysisDefaultList = ContributionAnalysisDefault[];
export const ContributionAnalysisDefaultList = S.Array(
  ContributionAnalysisDefault,
);
export interface BarChartConfiguration {
  FieldWells?: BarChartFieldWells;
  SortConfiguration?: BarChartSortConfiguration;
  Orientation?: BarChartOrientation;
  BarsArrangement?: BarsArrangement;
  VisualPalette?: VisualPalette;
  SmallMultiplesOptions?: SmallMultiplesOptions;
  CategoryAxis?: AxisDisplayOptions;
  CategoryLabelOptions?: ChartAxisLabelOptions;
  ValueAxis?: AxisDisplayOptions;
  ValueLabelOptions?: ChartAxisLabelOptions;
  ColorLabelOptions?: ChartAxisLabelOptions;
  DefaultSeriesSettings?: BarChartDefaultSeriesSettings;
  Series?: BarSeriesItem[];
  Legend?: LegendOptions;
  DataLabels?: DataLabelOptions;
  Tooltip?: TooltipOptions;
  ReferenceLines?: ReferenceLine[];
  ContributionAnalysisDefaults?: ContributionAnalysisDefault[];
  Interactions?: VisualInteractionOptions;
}
export const BarChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(BarChartFieldWells),
    SortConfiguration: S.optional(BarChartSortConfiguration),
    Orientation: S.optional(BarChartOrientation),
    BarsArrangement: S.optional(BarsArrangement),
    VisualPalette: S.optional(VisualPalette),
    SmallMultiplesOptions: S.optional(SmallMultiplesOptions),
    CategoryAxis: S.optional(AxisDisplayOptions),
    CategoryLabelOptions: S.optional(ChartAxisLabelOptions),
    ValueAxis: S.optional(AxisDisplayOptions),
    ValueLabelOptions: S.optional(ChartAxisLabelOptions),
    ColorLabelOptions: S.optional(ChartAxisLabelOptions),
    DefaultSeriesSettings: S.optional(BarChartDefaultSeriesSettings),
    Series: S.optional(BarSeriesItemList),
    Legend: S.optional(LegendOptions),
    DataLabels: S.optional(DataLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    ReferenceLines: S.optional(ReferenceLineList),
    ContributionAnalysisDefaults: S.optional(ContributionAnalysisDefaultList),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "BarChartConfiguration",
}) as any as S.Schema<BarChartConfiguration>;
export type ExplicitHierarchyColumnList = ColumnIdentifier[];
export const ExplicitHierarchyColumnList = S.Array(ColumnIdentifier);
export interface NumericEqualityDrillDownFilter {
  Column: ColumnIdentifier;
  Value: number;
}
export const NumericEqualityDrillDownFilter = S.suspend(() =>
  S.Struct({ Column: ColumnIdentifier, Value: S.Number }),
).annotations({
  identifier: "NumericEqualityDrillDownFilter",
}) as any as S.Schema<NumericEqualityDrillDownFilter>;
export type CategoryValueList = string[];
export const CategoryValueList = S.Array(S.String);
export interface CategoryDrillDownFilter {
  Column: ColumnIdentifier;
  CategoryValues: string[];
}
export const CategoryDrillDownFilter = S.suspend(() =>
  S.Struct({ Column: ColumnIdentifier, CategoryValues: CategoryValueList }),
).annotations({
  identifier: "CategoryDrillDownFilter",
}) as any as S.Schema<CategoryDrillDownFilter>;
export interface TimeRangeDrillDownFilter {
  Column: ColumnIdentifier;
  RangeMinimum: Date;
  RangeMaximum: Date;
  TimeGranularity: TimeGranularity;
}
export const TimeRangeDrillDownFilter = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    RangeMinimum: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    RangeMaximum: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    TimeGranularity: TimeGranularity,
  }),
).annotations({
  identifier: "TimeRangeDrillDownFilter",
}) as any as S.Schema<TimeRangeDrillDownFilter>;
export interface DrillDownFilter {
  NumericEqualityFilter?: NumericEqualityDrillDownFilter;
  CategoryFilter?: CategoryDrillDownFilter;
  TimeRangeFilter?: TimeRangeDrillDownFilter;
}
export const DrillDownFilter = S.suspend(() =>
  S.Struct({
    NumericEqualityFilter: S.optional(NumericEqualityDrillDownFilter),
    CategoryFilter: S.optional(CategoryDrillDownFilter),
    TimeRangeFilter: S.optional(TimeRangeDrillDownFilter),
  }),
).annotations({
  identifier: "DrillDownFilter",
}) as any as S.Schema<DrillDownFilter>;
export type DrillDownFilterList = DrillDownFilter[];
export const DrillDownFilterList = S.Array(DrillDownFilter);
export interface ExplicitHierarchy {
  HierarchyId: string;
  Columns: ColumnIdentifier[];
  DrillDownFilters?: DrillDownFilter[];
}
export const ExplicitHierarchy = S.suspend(() =>
  S.Struct({
    HierarchyId: S.String,
    Columns: ExplicitHierarchyColumnList,
    DrillDownFilters: S.optional(DrillDownFilterList),
  }),
).annotations({
  identifier: "ExplicitHierarchy",
}) as any as S.Schema<ExplicitHierarchy>;
export interface DateTimeHierarchy {
  HierarchyId: string;
  DrillDownFilters?: DrillDownFilter[];
}
export const DateTimeHierarchy = S.suspend(() =>
  S.Struct({
    HierarchyId: S.String,
    DrillDownFilters: S.optional(DrillDownFilterList),
  }),
).annotations({
  identifier: "DateTimeHierarchy",
}) as any as S.Schema<DateTimeHierarchy>;
export type PredefinedHierarchyColumnList = ColumnIdentifier[];
export const PredefinedHierarchyColumnList = S.Array(ColumnIdentifier);
export interface PredefinedHierarchy {
  HierarchyId: string;
  Columns: ColumnIdentifier[];
  DrillDownFilters?: DrillDownFilter[];
}
export const PredefinedHierarchy = S.suspend(() =>
  S.Struct({
    HierarchyId: S.String,
    Columns: PredefinedHierarchyColumnList,
    DrillDownFilters: S.optional(DrillDownFilterList),
  }),
).annotations({
  identifier: "PredefinedHierarchy",
}) as any as S.Schema<PredefinedHierarchy>;
export interface ColumnHierarchy {
  ExplicitHierarchy?: ExplicitHierarchy;
  DateTimeHierarchy?: DateTimeHierarchy;
  PredefinedHierarchy?: PredefinedHierarchy;
}
export const ColumnHierarchy = S.suspend(() =>
  S.Struct({
    ExplicitHierarchy: S.optional(ExplicitHierarchy),
    DateTimeHierarchy: S.optional(DateTimeHierarchy),
    PredefinedHierarchy: S.optional(PredefinedHierarchy),
  }),
).annotations({
  identifier: "ColumnHierarchy",
}) as any as S.Schema<ColumnHierarchy>;
export type ColumnHierarchyList = ColumnHierarchy[];
export const ColumnHierarchyList = S.Array(ColumnHierarchy);
export interface BarChartVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: BarChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const BarChartVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(BarChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "BarChartVisual",
}) as any as S.Schema<BarChartVisual>;
export interface KPIFieldWells {
  Values?: MeasureField[];
  TargetValues?: MeasureField[];
  TrendGroups?: DimensionField[];
}
export const KPIFieldWells = S.suspend(() =>
  S.Struct({
    Values: S.optional(MeasureFieldList),
    TargetValues: S.optional(MeasureFieldList),
    TrendGroups: S.optional(DimensionFieldList),
  }),
).annotations({
  identifier: "KPIFieldWells",
}) as any as S.Schema<KPIFieldWells>;
export interface KPISortConfiguration {
  TrendGroupSort?: FieldSortOptions[];
}
export const KPISortConfiguration = S.suspend(() =>
  S.Struct({ TrendGroupSort: S.optional(FieldSortOptionsList) }),
).annotations({
  identifier: "KPISortConfiguration",
}) as any as S.Schema<KPISortConfiguration>;
export interface ProgressBarOptions {
  Visibility?: Visibility;
}
export const ProgressBarOptions = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "ProgressBarOptions",
}) as any as S.Schema<ProgressBarOptions>;
export interface TrendArrowOptions {
  Visibility?: Visibility;
}
export const TrendArrowOptions = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "TrendArrowOptions",
}) as any as S.Schema<TrendArrowOptions>;
export interface SecondaryValueOptions {
  Visibility?: Visibility;
}
export const SecondaryValueOptions = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "SecondaryValueOptions",
}) as any as S.Schema<SecondaryValueOptions>;
export type ComparisonMethod = "DIFFERENCE" | "PERCENT_DIFFERENCE" | "PERCENT";
export const ComparisonMethod = S.Literal(
  "DIFFERENCE",
  "PERCENT_DIFFERENCE",
  "PERCENT",
);
export interface ComparisonFormatConfiguration {
  NumberDisplayFormatConfiguration?: NumberDisplayFormatConfiguration;
  PercentageDisplayFormatConfiguration?: PercentageDisplayFormatConfiguration;
}
export const ComparisonFormatConfiguration = S.suspend(() =>
  S.Struct({
    NumberDisplayFormatConfiguration: S.optional(
      NumberDisplayFormatConfiguration,
    ),
    PercentageDisplayFormatConfiguration: S.optional(
      PercentageDisplayFormatConfiguration,
    ),
  }),
).annotations({
  identifier: "ComparisonFormatConfiguration",
}) as any as S.Schema<ComparisonFormatConfiguration>;
export interface ComparisonConfiguration {
  ComparisonMethod?: ComparisonMethod;
  ComparisonFormat?: ComparisonFormatConfiguration;
}
export const ComparisonConfiguration = S.suspend(() =>
  S.Struct({
    ComparisonMethod: S.optional(ComparisonMethod),
    ComparisonFormat: S.optional(ComparisonFormatConfiguration),
  }),
).annotations({
  identifier: "ComparisonConfiguration",
}) as any as S.Schema<ComparisonConfiguration>;
export type PrimaryValueDisplayType = "HIDDEN" | "COMPARISON" | "ACTUAL";
export const PrimaryValueDisplayType = S.Literal(
  "HIDDEN",
  "COMPARISON",
  "ACTUAL",
);
export type KPISparklineType = "LINE" | "AREA";
export const KPISparklineType = S.Literal("LINE", "AREA");
export interface KPISparklineOptions {
  Visibility?: Visibility;
  Type: KPISparklineType;
  Color?: string;
  TooltipVisibility?: Visibility;
}
export const KPISparklineOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    Type: KPISparklineType,
    Color: S.optional(S.String),
    TooltipVisibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "KPISparklineOptions",
}) as any as S.Schema<KPISparklineOptions>;
export type KPIVisualStandardLayoutType = "CLASSIC" | "VERTICAL";
export const KPIVisualStandardLayoutType = S.Literal("CLASSIC", "VERTICAL");
export interface KPIVisualStandardLayout {
  Type: KPIVisualStandardLayoutType;
}
export const KPIVisualStandardLayout = S.suspend(() =>
  S.Struct({ Type: KPIVisualStandardLayoutType }),
).annotations({
  identifier: "KPIVisualStandardLayout",
}) as any as S.Schema<KPIVisualStandardLayout>;
export interface KPIVisualLayoutOptions {
  StandardLayout?: KPIVisualStandardLayout;
}
export const KPIVisualLayoutOptions = S.suspend(() =>
  S.Struct({ StandardLayout: S.optional(KPIVisualStandardLayout) }),
).annotations({
  identifier: "KPIVisualLayoutOptions",
}) as any as S.Schema<KPIVisualLayoutOptions>;
export interface KPIOptions {
  ProgressBar?: ProgressBarOptions;
  TrendArrows?: TrendArrowOptions;
  SecondaryValue?: SecondaryValueOptions;
  Comparison?: ComparisonConfiguration;
  PrimaryValueDisplayType?: PrimaryValueDisplayType;
  PrimaryValueFontConfiguration?: FontConfiguration;
  SecondaryValueFontConfiguration?: FontConfiguration;
  Sparkline?: KPISparklineOptions;
  VisualLayoutOptions?: KPIVisualLayoutOptions;
}
export const KPIOptions = S.suspend(() =>
  S.Struct({
    ProgressBar: S.optional(ProgressBarOptions),
    TrendArrows: S.optional(TrendArrowOptions),
    SecondaryValue: S.optional(SecondaryValueOptions),
    Comparison: S.optional(ComparisonConfiguration),
    PrimaryValueDisplayType: S.optional(PrimaryValueDisplayType),
    PrimaryValueFontConfiguration: S.optional(FontConfiguration),
    SecondaryValueFontConfiguration: S.optional(FontConfiguration),
    Sparkline: S.optional(KPISparklineOptions),
    VisualLayoutOptions: S.optional(KPIVisualLayoutOptions),
  }),
).annotations({ identifier: "KPIOptions" }) as any as S.Schema<KPIOptions>;
export interface KPIConfiguration {
  FieldWells?: KPIFieldWells;
  SortConfiguration?: KPISortConfiguration;
  KPIOptions?: KPIOptions;
  Interactions?: VisualInteractionOptions;
}
export const KPIConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(KPIFieldWells),
    SortConfiguration: S.optional(KPISortConfiguration),
    KPIOptions: S.optional(KPIOptions),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "KPIConfiguration",
}) as any as S.Schema<KPIConfiguration>;
export interface KPIPrimaryValueConditionalFormatting {
  TextColor?: ConditionalFormattingColor;
  Icon?: ConditionalFormattingIcon;
}
export const KPIPrimaryValueConditionalFormatting = S.suspend(() =>
  S.Struct({
    TextColor: S.optional(ConditionalFormattingColor),
    Icon: S.optional(ConditionalFormattingIcon),
  }),
).annotations({
  identifier: "KPIPrimaryValueConditionalFormatting",
}) as any as S.Schema<KPIPrimaryValueConditionalFormatting>;
export interface KPIProgressBarConditionalFormatting {
  ForegroundColor?: ConditionalFormattingColor;
}
export const KPIProgressBarConditionalFormatting = S.suspend(() =>
  S.Struct({ ForegroundColor: S.optional(ConditionalFormattingColor) }),
).annotations({
  identifier: "KPIProgressBarConditionalFormatting",
}) as any as S.Schema<KPIProgressBarConditionalFormatting>;
export interface KPIActualValueConditionalFormatting {
  TextColor?: ConditionalFormattingColor;
  Icon?: ConditionalFormattingIcon;
}
export const KPIActualValueConditionalFormatting = S.suspend(() =>
  S.Struct({
    TextColor: S.optional(ConditionalFormattingColor),
    Icon: S.optional(ConditionalFormattingIcon),
  }),
).annotations({
  identifier: "KPIActualValueConditionalFormatting",
}) as any as S.Schema<KPIActualValueConditionalFormatting>;
export interface KPIComparisonValueConditionalFormatting {
  TextColor?: ConditionalFormattingColor;
  Icon?: ConditionalFormattingIcon;
}
export const KPIComparisonValueConditionalFormatting = S.suspend(() =>
  S.Struct({
    TextColor: S.optional(ConditionalFormattingColor),
    Icon: S.optional(ConditionalFormattingIcon),
  }),
).annotations({
  identifier: "KPIComparisonValueConditionalFormatting",
}) as any as S.Schema<KPIComparisonValueConditionalFormatting>;
export interface KPIConditionalFormattingOption {
  PrimaryValue?: KPIPrimaryValueConditionalFormatting;
  ProgressBar?: KPIProgressBarConditionalFormatting;
  ActualValue?: KPIActualValueConditionalFormatting;
  ComparisonValue?: KPIComparisonValueConditionalFormatting;
}
export const KPIConditionalFormattingOption = S.suspend(() =>
  S.Struct({
    PrimaryValue: S.optional(KPIPrimaryValueConditionalFormatting),
    ProgressBar: S.optional(KPIProgressBarConditionalFormatting),
    ActualValue: S.optional(KPIActualValueConditionalFormatting),
    ComparisonValue: S.optional(KPIComparisonValueConditionalFormatting),
  }),
).annotations({
  identifier: "KPIConditionalFormattingOption",
}) as any as S.Schema<KPIConditionalFormattingOption>;
export type KPIConditionalFormattingOptionList =
  KPIConditionalFormattingOption[];
export const KPIConditionalFormattingOptionList = S.Array(
  KPIConditionalFormattingOption,
);
export interface KPIConditionalFormatting {
  ConditionalFormattingOptions?: KPIConditionalFormattingOption[];
}
export const KPIConditionalFormatting = S.suspend(() =>
  S.Struct({
    ConditionalFormattingOptions: S.optional(
      KPIConditionalFormattingOptionList,
    ),
  }),
).annotations({
  identifier: "KPIConditionalFormatting",
}) as any as S.Schema<KPIConditionalFormatting>;
export interface KPIVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: KPIConfiguration;
  ConditionalFormatting?: KPIConditionalFormatting;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const KPIVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(KPIConfiguration),
    ConditionalFormatting: S.optional(KPIConditionalFormatting),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({ identifier: "KPIVisual" }) as any as S.Schema<KPIVisual>;
export interface PieChartAggregatedFieldWells {
  Category?: DimensionField[];
  Values?: MeasureField[];
  SmallMultiples?: DimensionField[];
}
export const PieChartAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Category: S.optional(DimensionFieldList),
    Values: S.optional(MeasureFieldList),
    SmallMultiples: S.optional(SmallMultiplesDimensionFieldList),
  }),
).annotations({
  identifier: "PieChartAggregatedFieldWells",
}) as any as S.Schema<PieChartAggregatedFieldWells>;
export interface PieChartFieldWells {
  PieChartAggregatedFieldWells?: PieChartAggregatedFieldWells;
}
export const PieChartFieldWells = S.suspend(() =>
  S.Struct({
    PieChartAggregatedFieldWells: S.optional(PieChartAggregatedFieldWells),
  }),
).annotations({
  identifier: "PieChartFieldWells",
}) as any as S.Schema<PieChartFieldWells>;
export interface PieChartSortConfiguration {
  CategorySort?: FieldSortOptions[];
  CategoryItemsLimit?: ItemsLimitConfiguration;
  SmallMultiplesSort?: FieldSortOptions[];
  SmallMultiplesLimitConfiguration?: ItemsLimitConfiguration;
}
export const PieChartSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    CategoryItemsLimit: S.optional(ItemsLimitConfiguration),
    SmallMultiplesSort: S.optional(FieldSortOptionsList),
    SmallMultiplesLimitConfiguration: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "PieChartSortConfiguration",
}) as any as S.Schema<PieChartSortConfiguration>;
export type ArcThickness = "SMALL" | "MEDIUM" | "LARGE" | "WHOLE";
export const ArcThickness = S.Literal("SMALL", "MEDIUM", "LARGE", "WHOLE");
export interface ArcOptions {
  ArcThickness?: ArcThickness;
}
export const ArcOptions = S.suspend(() =>
  S.Struct({ ArcThickness: S.optional(ArcThickness) }),
).annotations({ identifier: "ArcOptions" }) as any as S.Schema<ArcOptions>;
export interface DonutCenterOptions {
  LabelVisibility?: Visibility;
}
export const DonutCenterOptions = S.suspend(() =>
  S.Struct({ LabelVisibility: S.optional(Visibility) }),
).annotations({
  identifier: "DonutCenterOptions",
}) as any as S.Schema<DonutCenterOptions>;
export interface DonutOptions {
  ArcOptions?: ArcOptions;
  DonutCenterOptions?: DonutCenterOptions;
}
export const DonutOptions = S.suspend(() =>
  S.Struct({
    ArcOptions: S.optional(ArcOptions),
    DonutCenterOptions: S.optional(DonutCenterOptions),
  }),
).annotations({ identifier: "DonutOptions" }) as any as S.Schema<DonutOptions>;
export interface PieChartConfiguration {
  FieldWells?: PieChartFieldWells;
  SortConfiguration?: PieChartSortConfiguration;
  DonutOptions?: DonutOptions;
  SmallMultiplesOptions?: SmallMultiplesOptions;
  CategoryLabelOptions?: ChartAxisLabelOptions;
  ValueLabelOptions?: ChartAxisLabelOptions;
  Legend?: LegendOptions;
  DataLabels?: DataLabelOptions;
  Tooltip?: TooltipOptions;
  VisualPalette?: VisualPalette;
  ContributionAnalysisDefaults?: ContributionAnalysisDefault[];
  Interactions?: VisualInteractionOptions;
}
export const PieChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(PieChartFieldWells),
    SortConfiguration: S.optional(PieChartSortConfiguration),
    DonutOptions: S.optional(DonutOptions),
    SmallMultiplesOptions: S.optional(SmallMultiplesOptions),
    CategoryLabelOptions: S.optional(ChartAxisLabelOptions),
    ValueLabelOptions: S.optional(ChartAxisLabelOptions),
    Legend: S.optional(LegendOptions),
    DataLabels: S.optional(DataLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    VisualPalette: S.optional(VisualPalette),
    ContributionAnalysisDefaults: S.optional(ContributionAnalysisDefaultList),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "PieChartConfiguration",
}) as any as S.Schema<PieChartConfiguration>;
export interface PieChartVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: PieChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const PieChartVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(PieChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "PieChartVisual",
}) as any as S.Schema<PieChartVisual>;
export interface GaugeChartFieldWells {
  Values?: MeasureField[];
  TargetValues?: MeasureField[];
}
export const GaugeChartFieldWells = S.suspend(() =>
  S.Struct({
    Values: S.optional(MeasureFieldList),
    TargetValues: S.optional(MeasureFieldList),
  }),
).annotations({
  identifier: "GaugeChartFieldWells",
}) as any as S.Schema<GaugeChartFieldWells>;
export interface ArcAxisDisplayRange {
  Min?: number;
  Max?: number;
}
export const ArcAxisDisplayRange = S.suspend(() =>
  S.Struct({ Min: S.optional(S.Number), Max: S.optional(S.Number) }),
).annotations({
  identifier: "ArcAxisDisplayRange",
}) as any as S.Schema<ArcAxisDisplayRange>;
export interface ArcAxisConfiguration {
  Range?: ArcAxisDisplayRange;
  ReserveRange?: number;
}
export const ArcAxisConfiguration = S.suspend(() =>
  S.Struct({
    Range: S.optional(ArcAxisDisplayRange),
    ReserveRange: S.optional(S.Number),
  }),
).annotations({
  identifier: "ArcAxisConfiguration",
}) as any as S.Schema<ArcAxisConfiguration>;
export type ArcThicknessOptions = "SMALL" | "MEDIUM" | "LARGE";
export const ArcThicknessOptions = S.Literal("SMALL", "MEDIUM", "LARGE");
export interface ArcConfiguration {
  ArcAngle?: number;
  ArcThickness?: ArcThicknessOptions;
}
export const ArcConfiguration = S.suspend(() =>
  S.Struct({
    ArcAngle: S.optional(S.Number),
    ArcThickness: S.optional(ArcThicknessOptions),
  }),
).annotations({
  identifier: "ArcConfiguration",
}) as any as S.Schema<ArcConfiguration>;
export interface GaugeChartOptions {
  PrimaryValueDisplayType?: PrimaryValueDisplayType;
  Comparison?: ComparisonConfiguration;
  ArcAxis?: ArcAxisConfiguration;
  Arc?: ArcConfiguration;
  PrimaryValueFontConfiguration?: FontConfiguration;
}
export const GaugeChartOptions = S.suspend(() =>
  S.Struct({
    PrimaryValueDisplayType: S.optional(PrimaryValueDisplayType),
    Comparison: S.optional(ComparisonConfiguration),
    ArcAxis: S.optional(ArcAxisConfiguration),
    Arc: S.optional(ArcConfiguration),
    PrimaryValueFontConfiguration: S.optional(FontConfiguration),
  }),
).annotations({
  identifier: "GaugeChartOptions",
}) as any as S.Schema<GaugeChartOptions>;
export interface GaugeChartColorConfiguration {
  ForegroundColor?: string;
  BackgroundColor?: string;
}
export const GaugeChartColorConfiguration = S.suspend(() =>
  S.Struct({
    ForegroundColor: S.optional(S.String),
    BackgroundColor: S.optional(S.String),
  }),
).annotations({
  identifier: "GaugeChartColorConfiguration",
}) as any as S.Schema<GaugeChartColorConfiguration>;
export interface GaugeChartConfiguration {
  FieldWells?: GaugeChartFieldWells;
  GaugeChartOptions?: GaugeChartOptions;
  DataLabels?: DataLabelOptions;
  TooltipOptions?: TooltipOptions;
  VisualPalette?: VisualPalette;
  ColorConfiguration?: GaugeChartColorConfiguration;
  Interactions?: VisualInteractionOptions;
}
export const GaugeChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(GaugeChartFieldWells),
    GaugeChartOptions: S.optional(GaugeChartOptions),
    DataLabels: S.optional(DataLabelOptions),
    TooltipOptions: S.optional(TooltipOptions),
    VisualPalette: S.optional(VisualPalette),
    ColorConfiguration: S.optional(GaugeChartColorConfiguration),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "GaugeChartConfiguration",
}) as any as S.Schema<GaugeChartConfiguration>;
export interface GaugeChartPrimaryValueConditionalFormatting {
  TextColor?: ConditionalFormattingColor;
  Icon?: ConditionalFormattingIcon;
}
export const GaugeChartPrimaryValueConditionalFormatting = S.suspend(() =>
  S.Struct({
    TextColor: S.optional(ConditionalFormattingColor),
    Icon: S.optional(ConditionalFormattingIcon),
  }),
).annotations({
  identifier: "GaugeChartPrimaryValueConditionalFormatting",
}) as any as S.Schema<GaugeChartPrimaryValueConditionalFormatting>;
export interface GaugeChartArcConditionalFormatting {
  ForegroundColor?: ConditionalFormattingColor;
}
export const GaugeChartArcConditionalFormatting = S.suspend(() =>
  S.Struct({ ForegroundColor: S.optional(ConditionalFormattingColor) }),
).annotations({
  identifier: "GaugeChartArcConditionalFormatting",
}) as any as S.Schema<GaugeChartArcConditionalFormatting>;
export interface GaugeChartConditionalFormattingOption {
  PrimaryValue?: GaugeChartPrimaryValueConditionalFormatting;
  Arc?: GaugeChartArcConditionalFormatting;
}
export const GaugeChartConditionalFormattingOption = S.suspend(() =>
  S.Struct({
    PrimaryValue: S.optional(GaugeChartPrimaryValueConditionalFormatting),
    Arc: S.optional(GaugeChartArcConditionalFormatting),
  }),
).annotations({
  identifier: "GaugeChartConditionalFormattingOption",
}) as any as S.Schema<GaugeChartConditionalFormattingOption>;
export type GaugeChartConditionalFormattingOptionList =
  GaugeChartConditionalFormattingOption[];
export const GaugeChartConditionalFormattingOptionList = S.Array(
  GaugeChartConditionalFormattingOption,
);
export interface GaugeChartConditionalFormatting {
  ConditionalFormattingOptions?: GaugeChartConditionalFormattingOption[];
}
export const GaugeChartConditionalFormatting = S.suspend(() =>
  S.Struct({
    ConditionalFormattingOptions: S.optional(
      GaugeChartConditionalFormattingOptionList,
    ),
  }),
).annotations({
  identifier: "GaugeChartConditionalFormatting",
}) as any as S.Schema<GaugeChartConditionalFormatting>;
export interface GaugeChartVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: GaugeChartConfiguration;
  ConditionalFormatting?: GaugeChartConditionalFormatting;
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
}
export const GaugeChartVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(GaugeChartConfiguration),
    ConditionalFormatting: S.optional(GaugeChartConditionalFormatting),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "GaugeChartVisual",
}) as any as S.Schema<GaugeChartVisual>;
export interface LineChartAggregatedFieldWells {
  Category?: DimensionField[];
  Values?: MeasureField[];
  Colors?: DimensionField[];
  SmallMultiples?: DimensionField[];
}
export const LineChartAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Category: S.optional(DimensionFieldList),
    Values: S.optional(MeasureFieldList),
    Colors: S.optional(DimensionFieldList),
    SmallMultiples: S.optional(SmallMultiplesDimensionFieldList),
  }),
).annotations({
  identifier: "LineChartAggregatedFieldWells",
}) as any as S.Schema<LineChartAggregatedFieldWells>;
export interface LineChartFieldWells {
  LineChartAggregatedFieldWells?: LineChartAggregatedFieldWells;
}
export const LineChartFieldWells = S.suspend(() =>
  S.Struct({
    LineChartAggregatedFieldWells: S.optional(LineChartAggregatedFieldWells),
  }),
).annotations({
  identifier: "LineChartFieldWells",
}) as any as S.Schema<LineChartFieldWells>;
export interface LineChartSortConfiguration {
  CategorySort?: FieldSortOptions[];
  CategoryItemsLimitConfiguration?: ItemsLimitConfiguration;
  ColorItemsLimitConfiguration?: ItemsLimitConfiguration;
  SmallMultiplesSort?: FieldSortOptions[];
  SmallMultiplesLimitConfiguration?: ItemsLimitConfiguration;
}
export const LineChartSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    CategoryItemsLimitConfiguration: S.optional(ItemsLimitConfiguration),
    ColorItemsLimitConfiguration: S.optional(ItemsLimitConfiguration),
    SmallMultiplesSort: S.optional(FieldSortOptionsList),
    SmallMultiplesLimitConfiguration: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "LineChartSortConfiguration",
}) as any as S.Schema<LineChartSortConfiguration>;
export interface TimeBasedForecastProperties {
  PeriodsForward?: number;
  PeriodsBackward?: number;
  UpperBoundary?: number;
  LowerBoundary?: number;
  PredictionInterval?: number;
  Seasonality?: number;
}
export const TimeBasedForecastProperties = S.suspend(() =>
  S.Struct({
    PeriodsForward: S.optional(S.Number),
    PeriodsBackward: S.optional(S.Number),
    UpperBoundary: S.optional(S.Number),
    LowerBoundary: S.optional(S.Number),
    PredictionInterval: S.optional(S.Number),
    Seasonality: S.optional(S.Number),
  }),
).annotations({
  identifier: "TimeBasedForecastProperties",
}) as any as S.Schema<TimeBasedForecastProperties>;
export interface WhatIfPointScenario {
  Date: Date;
  Value: number;
}
export const WhatIfPointScenario = S.suspend(() =>
  S.Struct({
    Date: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Value: S.Number,
  }),
).annotations({
  identifier: "WhatIfPointScenario",
}) as any as S.Schema<WhatIfPointScenario>;
export interface WhatIfRangeScenario {
  StartDate: Date;
  EndDate: Date;
  Value: number;
}
export const WhatIfRangeScenario = S.suspend(() =>
  S.Struct({
    StartDate: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    EndDate: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Value: S.Number,
  }),
).annotations({
  identifier: "WhatIfRangeScenario",
}) as any as S.Schema<WhatIfRangeScenario>;
export interface ForecastScenario {
  WhatIfPointScenario?: WhatIfPointScenario;
  WhatIfRangeScenario?: WhatIfRangeScenario;
}
export const ForecastScenario = S.suspend(() =>
  S.Struct({
    WhatIfPointScenario: S.optional(WhatIfPointScenario),
    WhatIfRangeScenario: S.optional(WhatIfRangeScenario),
  }),
).annotations({
  identifier: "ForecastScenario",
}) as any as S.Schema<ForecastScenario>;
export interface ForecastConfiguration {
  ForecastProperties?: TimeBasedForecastProperties;
  Scenario?: ForecastScenario;
}
export const ForecastConfiguration = S.suspend(() =>
  S.Struct({
    ForecastProperties: S.optional(TimeBasedForecastProperties),
    Scenario: S.optional(ForecastScenario),
  }),
).annotations({
  identifier: "ForecastConfiguration",
}) as any as S.Schema<ForecastConfiguration>;
export type ForecastConfigurationList = ForecastConfiguration[];
export const ForecastConfigurationList = S.Array(ForecastConfiguration);
export type LineChartType = "LINE" | "AREA" | "STACKED_AREA";
export const LineChartType = S.Literal("LINE", "AREA", "STACKED_AREA");
export type MissingDataTreatmentOption =
  | "INTERPOLATE"
  | "SHOW_AS_ZERO"
  | "SHOW_AS_BLANK";
export const MissingDataTreatmentOption = S.Literal(
  "INTERPOLATE",
  "SHOW_AS_ZERO",
  "SHOW_AS_BLANK",
);
export interface MissingDataConfiguration {
  TreatmentOption?: MissingDataTreatmentOption;
}
export const MissingDataConfiguration = S.suspend(() =>
  S.Struct({ TreatmentOption: S.optional(MissingDataTreatmentOption) }),
).annotations({
  identifier: "MissingDataConfiguration",
}) as any as S.Schema<MissingDataConfiguration>;
export type MissingDataConfigurationList = MissingDataConfiguration[];
export const MissingDataConfigurationList = S.Array(MissingDataConfiguration);
export interface LineSeriesAxisDisplayOptions {
  AxisOptions?: AxisDisplayOptions;
  MissingDataConfigurations?: MissingDataConfiguration[];
}
export const LineSeriesAxisDisplayOptions = S.suspend(() =>
  S.Struct({
    AxisOptions: S.optional(AxisDisplayOptions),
    MissingDataConfigurations: S.optional(MissingDataConfigurationList),
  }),
).annotations({
  identifier: "LineSeriesAxisDisplayOptions",
}) as any as S.Schema<LineSeriesAxisDisplayOptions>;
export type SingleYAxisOption = "PRIMARY_Y_AXIS";
export const SingleYAxisOption = S.Literal("PRIMARY_Y_AXIS");
export interface YAxisOptions {
  YAxis: SingleYAxisOption;
}
export const YAxisOptions = S.suspend(() =>
  S.Struct({ YAxis: SingleYAxisOption }),
).annotations({ identifier: "YAxisOptions" }) as any as S.Schema<YAxisOptions>;
export interface SingleAxisOptions {
  YAxisOptions?: YAxisOptions;
}
export const SingleAxisOptions = S.suspend(() =>
  S.Struct({ YAxisOptions: S.optional(YAxisOptions) }),
).annotations({
  identifier: "SingleAxisOptions",
}) as any as S.Schema<SingleAxisOptions>;
export type LineInterpolation = "LINEAR" | "SMOOTH" | "STEPPED";
export const LineInterpolation = S.Literal("LINEAR", "SMOOTH", "STEPPED");
export type LineChartLineStyle = "SOLID" | "DOTTED" | "DASHED";
export const LineChartLineStyle = S.Literal("SOLID", "DOTTED", "DASHED");
export interface LineChartLineStyleSettings {
  LineVisibility?: Visibility;
  LineInterpolation?: LineInterpolation;
  LineStyle?: LineChartLineStyle;
  LineWidth?: string;
}
export const LineChartLineStyleSettings = S.suspend(() =>
  S.Struct({
    LineVisibility: S.optional(Visibility),
    LineInterpolation: S.optional(LineInterpolation),
    LineStyle: S.optional(LineChartLineStyle),
    LineWidth: S.optional(S.String),
  }),
).annotations({
  identifier: "LineChartLineStyleSettings",
}) as any as S.Schema<LineChartLineStyleSettings>;
export type LineChartMarkerShape =
  | "CIRCLE"
  | "TRIANGLE"
  | "SQUARE"
  | "DIAMOND"
  | "ROUNDED_SQUARE";
export const LineChartMarkerShape = S.Literal(
  "CIRCLE",
  "TRIANGLE",
  "SQUARE",
  "DIAMOND",
  "ROUNDED_SQUARE",
);
export interface LineChartMarkerStyleSettings {
  MarkerVisibility?: Visibility;
  MarkerShape?: LineChartMarkerShape;
  MarkerSize?: string;
  MarkerColor?: string;
}
export const LineChartMarkerStyleSettings = S.suspend(() =>
  S.Struct({
    MarkerVisibility: S.optional(Visibility),
    MarkerShape: S.optional(LineChartMarkerShape),
    MarkerSize: S.optional(S.String),
    MarkerColor: S.optional(S.String),
  }),
).annotations({
  identifier: "LineChartMarkerStyleSettings",
}) as any as S.Schema<LineChartMarkerStyleSettings>;
export interface LineChartDefaultSeriesSettings {
  AxisBinding?: AxisBinding;
  LineStyleSettings?: LineChartLineStyleSettings;
  MarkerStyleSettings?: LineChartMarkerStyleSettings;
  DecalSettings?: DecalSettings;
}
export const LineChartDefaultSeriesSettings = S.suspend(() =>
  S.Struct({
    AxisBinding: S.optional(AxisBinding),
    LineStyleSettings: S.optional(LineChartLineStyleSettings),
    MarkerStyleSettings: S.optional(LineChartMarkerStyleSettings),
    DecalSettings: S.optional(DecalSettings),
  }),
).annotations({
  identifier: "LineChartDefaultSeriesSettings",
}) as any as S.Schema<LineChartDefaultSeriesSettings>;
export interface LineChartSeriesSettings {
  LineStyleSettings?: LineChartLineStyleSettings;
  MarkerStyleSettings?: LineChartMarkerStyleSettings;
  DecalSettings?: DecalSettings;
}
export const LineChartSeriesSettings = S.suspend(() =>
  S.Struct({
    LineStyleSettings: S.optional(LineChartLineStyleSettings),
    MarkerStyleSettings: S.optional(LineChartMarkerStyleSettings),
    DecalSettings: S.optional(DecalSettings),
  }),
).annotations({
  identifier: "LineChartSeriesSettings",
}) as any as S.Schema<LineChartSeriesSettings>;
export interface FieldSeriesItem {
  FieldId: string;
  AxisBinding: AxisBinding;
  Settings?: LineChartSeriesSettings;
}
export const FieldSeriesItem = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    AxisBinding: AxisBinding,
    Settings: S.optional(LineChartSeriesSettings),
  }),
).annotations({
  identifier: "FieldSeriesItem",
}) as any as S.Schema<FieldSeriesItem>;
export interface DataFieldSeriesItem {
  FieldId: string;
  FieldValue?: string | redacted.Redacted<string>;
  AxisBinding: AxisBinding;
  Settings?: LineChartSeriesSettings;
}
export const DataFieldSeriesItem = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    FieldValue: S.optional(SensitiveString),
    AxisBinding: AxisBinding,
    Settings: S.optional(LineChartSeriesSettings),
  }),
).annotations({
  identifier: "DataFieldSeriesItem",
}) as any as S.Schema<DataFieldSeriesItem>;
export interface SeriesItem {
  FieldSeriesItem?: FieldSeriesItem;
  DataFieldSeriesItem?: DataFieldSeriesItem;
}
export const SeriesItem = S.suspend(() =>
  S.Struct({
    FieldSeriesItem: S.optional(FieldSeriesItem),
    DataFieldSeriesItem: S.optional(DataFieldSeriesItem),
  }),
).annotations({ identifier: "SeriesItem" }) as any as S.Schema<SeriesItem>;
export type SeriesItemList = SeriesItem[];
export const SeriesItemList = S.Array(SeriesItem);
export interface LineChartConfiguration {
  FieldWells?: LineChartFieldWells;
  SortConfiguration?: LineChartSortConfiguration;
  ForecastConfigurations?: ForecastConfiguration[];
  Type?: LineChartType;
  SmallMultiplesOptions?: SmallMultiplesOptions;
  XAxisDisplayOptions?: AxisDisplayOptions;
  XAxisLabelOptions?: ChartAxisLabelOptions;
  PrimaryYAxisDisplayOptions?: LineSeriesAxisDisplayOptions;
  PrimaryYAxisLabelOptions?: ChartAxisLabelOptions;
  SecondaryYAxisDisplayOptions?: LineSeriesAxisDisplayOptions;
  SecondaryYAxisLabelOptions?: ChartAxisLabelOptions;
  SingleAxisOptions?: SingleAxisOptions;
  DefaultSeriesSettings?: LineChartDefaultSeriesSettings;
  Series?: SeriesItem[];
  Legend?: LegendOptions;
  DataLabels?: DataLabelOptions;
  ReferenceLines?: ReferenceLine[];
  Tooltip?: TooltipOptions;
  ContributionAnalysisDefaults?: ContributionAnalysisDefault[];
  VisualPalette?: VisualPalette;
  Interactions?: VisualInteractionOptions;
}
export const LineChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(LineChartFieldWells),
    SortConfiguration: S.optional(LineChartSortConfiguration),
    ForecastConfigurations: S.optional(ForecastConfigurationList),
    Type: S.optional(LineChartType),
    SmallMultiplesOptions: S.optional(SmallMultiplesOptions),
    XAxisDisplayOptions: S.optional(AxisDisplayOptions),
    XAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    PrimaryYAxisDisplayOptions: S.optional(LineSeriesAxisDisplayOptions),
    PrimaryYAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    SecondaryYAxisDisplayOptions: S.optional(LineSeriesAxisDisplayOptions),
    SecondaryYAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    SingleAxisOptions: S.optional(SingleAxisOptions),
    DefaultSeriesSettings: S.optional(LineChartDefaultSeriesSettings),
    Series: S.optional(SeriesItemList),
    Legend: S.optional(LegendOptions),
    DataLabels: S.optional(DataLabelOptions),
    ReferenceLines: S.optional(ReferenceLineList),
    Tooltip: S.optional(TooltipOptions),
    ContributionAnalysisDefaults: S.optional(ContributionAnalysisDefaultList),
    VisualPalette: S.optional(VisualPalette),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "LineChartConfiguration",
}) as any as S.Schema<LineChartConfiguration>;
export interface LineChartVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: LineChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const LineChartVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(LineChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "LineChartVisual",
}) as any as S.Schema<LineChartVisual>;
export type HeatMapDimensionFieldList = DimensionField[];
export const HeatMapDimensionFieldList = S.Array(DimensionField);
export type HeatMapMeasureFieldList = MeasureField[];
export const HeatMapMeasureFieldList = S.Array(MeasureField);
export interface HeatMapAggregatedFieldWells {
  Rows?: DimensionField[];
  Columns?: DimensionField[];
  Values?: MeasureField[];
}
export const HeatMapAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Rows: S.optional(HeatMapDimensionFieldList),
    Columns: S.optional(HeatMapDimensionFieldList),
    Values: S.optional(HeatMapMeasureFieldList),
  }),
).annotations({
  identifier: "HeatMapAggregatedFieldWells",
}) as any as S.Schema<HeatMapAggregatedFieldWells>;
export interface HeatMapFieldWells {
  HeatMapAggregatedFieldWells?: HeatMapAggregatedFieldWells;
}
export const HeatMapFieldWells = S.suspend(() =>
  S.Struct({
    HeatMapAggregatedFieldWells: S.optional(HeatMapAggregatedFieldWells),
  }),
).annotations({
  identifier: "HeatMapFieldWells",
}) as any as S.Schema<HeatMapFieldWells>;
export interface HeatMapSortConfiguration {
  HeatMapRowSort?: FieldSortOptions[];
  HeatMapColumnSort?: FieldSortOptions[];
  HeatMapRowItemsLimitConfiguration?: ItemsLimitConfiguration;
  HeatMapColumnItemsLimitConfiguration?: ItemsLimitConfiguration;
}
export const HeatMapSortConfiguration = S.suspend(() =>
  S.Struct({
    HeatMapRowSort: S.optional(FieldSortOptionsList),
    HeatMapColumnSort: S.optional(FieldSortOptionsList),
    HeatMapRowItemsLimitConfiguration: S.optional(ItemsLimitConfiguration),
    HeatMapColumnItemsLimitConfiguration: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "HeatMapSortConfiguration",
}) as any as S.Schema<HeatMapSortConfiguration>;
export interface DataColor {
  Color?: string;
  DataValue?: number;
}
export const DataColor = S.suspend(() =>
  S.Struct({ Color: S.optional(S.String), DataValue: S.optional(S.Number) }),
).annotations({ identifier: "DataColor" }) as any as S.Schema<DataColor>;
export type ColorScaleColorList = DataColor[];
export const ColorScaleColorList = S.Array(DataColor);
export type ColorFillType = "DISCRETE" | "GRADIENT";
export const ColorFillType = S.Literal("DISCRETE", "GRADIENT");
export interface ColorScale {
  Colors: DataColor[];
  ColorFillType: ColorFillType;
  NullValueColor?: DataColor;
}
export const ColorScale = S.suspend(() =>
  S.Struct({
    Colors: ColorScaleColorList,
    ColorFillType: ColorFillType,
    NullValueColor: S.optional(DataColor),
  }),
).annotations({ identifier: "ColorScale" }) as any as S.Schema<ColorScale>;
export interface HeatMapConfiguration {
  FieldWells?: HeatMapFieldWells;
  SortConfiguration?: HeatMapSortConfiguration;
  RowAxisDisplayOptions?: AxisDisplayOptions;
  RowLabelOptions?: ChartAxisLabelOptions;
  ColumnAxisDisplayOptions?: AxisDisplayOptions;
  ColumnLabelOptions?: ChartAxisLabelOptions;
  ColorScale?: ColorScale;
  Legend?: LegendOptions;
  DataLabels?: DataLabelOptions;
  Tooltip?: TooltipOptions;
  Interactions?: VisualInteractionOptions;
}
export const HeatMapConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(HeatMapFieldWells),
    SortConfiguration: S.optional(HeatMapSortConfiguration),
    RowAxisDisplayOptions: S.optional(AxisDisplayOptions),
    RowLabelOptions: S.optional(ChartAxisLabelOptions),
    ColumnAxisDisplayOptions: S.optional(AxisDisplayOptions),
    ColumnLabelOptions: S.optional(ChartAxisLabelOptions),
    ColorScale: S.optional(ColorScale),
    Legend: S.optional(LegendOptions),
    DataLabels: S.optional(DataLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "HeatMapConfiguration",
}) as any as S.Schema<HeatMapConfiguration>;
export interface HeatMapVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: HeatMapConfiguration;
  ColumnHierarchies?: ColumnHierarchy[];
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
}
export const HeatMapVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(HeatMapConfiguration),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "HeatMapVisual",
}) as any as S.Schema<HeatMapVisual>;
export type TreeMapDimensionFieldList = DimensionField[];
export const TreeMapDimensionFieldList = S.Array(DimensionField);
export type TreeMapMeasureFieldList = MeasureField[];
export const TreeMapMeasureFieldList = S.Array(MeasureField);
export interface TreeMapAggregatedFieldWells {
  Groups?: DimensionField[];
  Sizes?: MeasureField[];
  Colors?: MeasureField[];
}
export const TreeMapAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Groups: S.optional(TreeMapDimensionFieldList),
    Sizes: S.optional(TreeMapMeasureFieldList),
    Colors: S.optional(TreeMapMeasureFieldList),
  }),
).annotations({
  identifier: "TreeMapAggregatedFieldWells",
}) as any as S.Schema<TreeMapAggregatedFieldWells>;
export interface TreeMapFieldWells {
  TreeMapAggregatedFieldWells?: TreeMapAggregatedFieldWells;
}
export const TreeMapFieldWells = S.suspend(() =>
  S.Struct({
    TreeMapAggregatedFieldWells: S.optional(TreeMapAggregatedFieldWells),
  }),
).annotations({
  identifier: "TreeMapFieldWells",
}) as any as S.Schema<TreeMapFieldWells>;
export interface TreeMapSortConfiguration {
  TreeMapSort?: FieldSortOptions[];
  TreeMapGroupItemsLimitConfiguration?: ItemsLimitConfiguration;
}
export const TreeMapSortConfiguration = S.suspend(() =>
  S.Struct({
    TreeMapSort: S.optional(FieldSortOptionsList),
    TreeMapGroupItemsLimitConfiguration: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "TreeMapSortConfiguration",
}) as any as S.Schema<TreeMapSortConfiguration>;
export interface TreeMapConfiguration {
  FieldWells?: TreeMapFieldWells;
  SortConfiguration?: TreeMapSortConfiguration;
  GroupLabelOptions?: ChartAxisLabelOptions;
  SizeLabelOptions?: ChartAxisLabelOptions;
  ColorLabelOptions?: ChartAxisLabelOptions;
  ColorScale?: ColorScale;
  Legend?: LegendOptions;
  DataLabels?: DataLabelOptions;
  Tooltip?: TooltipOptions;
  Interactions?: VisualInteractionOptions;
}
export const TreeMapConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(TreeMapFieldWells),
    SortConfiguration: S.optional(TreeMapSortConfiguration),
    GroupLabelOptions: S.optional(ChartAxisLabelOptions),
    SizeLabelOptions: S.optional(ChartAxisLabelOptions),
    ColorLabelOptions: S.optional(ChartAxisLabelOptions),
    ColorScale: S.optional(ColorScale),
    Legend: S.optional(LegendOptions),
    DataLabels: S.optional(DataLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "TreeMapConfiguration",
}) as any as S.Schema<TreeMapConfiguration>;
export interface TreeMapVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: TreeMapConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const TreeMapVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(TreeMapConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "TreeMapVisual",
}) as any as S.Schema<TreeMapVisual>;
export interface GeospatialMapAggregatedFieldWells {
  Geospatial?: DimensionField[];
  Values?: MeasureField[];
  Colors?: DimensionField[];
}
export const GeospatialMapAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Geospatial: S.optional(DimensionFieldList),
    Values: S.optional(MeasureFieldList),
    Colors: S.optional(DimensionFieldList),
  }),
).annotations({
  identifier: "GeospatialMapAggregatedFieldWells",
}) as any as S.Schema<GeospatialMapAggregatedFieldWells>;
export interface GeospatialMapFieldWells {
  GeospatialMapAggregatedFieldWells?: GeospatialMapAggregatedFieldWells;
}
export const GeospatialMapFieldWells = S.suspend(() =>
  S.Struct({
    GeospatialMapAggregatedFieldWells: S.optional(
      GeospatialMapAggregatedFieldWells,
    ),
  }),
).annotations({
  identifier: "GeospatialMapFieldWells",
}) as any as S.Schema<GeospatialMapFieldWells>;
export interface GeospatialCoordinateBounds {
  North: number;
  South: number;
  West: number;
  East: number;
}
export const GeospatialCoordinateBounds = S.suspend(() =>
  S.Struct({
    North: S.Number,
    South: S.Number,
    West: S.Number,
    East: S.Number,
  }),
).annotations({
  identifier: "GeospatialCoordinateBounds",
}) as any as S.Schema<GeospatialCoordinateBounds>;
export type MapZoomMode = "AUTO" | "MANUAL";
export const MapZoomMode = S.Literal("AUTO", "MANUAL");
export interface GeospatialWindowOptions {
  Bounds?: GeospatialCoordinateBounds;
  MapZoomMode?: MapZoomMode;
}
export const GeospatialWindowOptions = S.suspend(() =>
  S.Struct({
    Bounds: S.optional(GeospatialCoordinateBounds),
    MapZoomMode: S.optional(MapZoomMode),
  }),
).annotations({
  identifier: "GeospatialWindowOptions",
}) as any as S.Schema<GeospatialWindowOptions>;
export type BaseMapStyleType =
  | "LIGHT_GRAY"
  | "DARK_GRAY"
  | "STREET"
  | "IMAGERY";
export const BaseMapStyleType = S.Literal(
  "LIGHT_GRAY",
  "DARK_GRAY",
  "STREET",
  "IMAGERY",
);
export interface GeospatialMapStyleOptions {
  BaseMapStyle?: BaseMapStyleType;
}
export const GeospatialMapStyleOptions = S.suspend(() =>
  S.Struct({ BaseMapStyle: S.optional(BaseMapStyleType) }),
).annotations({
  identifier: "GeospatialMapStyleOptions",
}) as any as S.Schema<GeospatialMapStyleOptions>;
export type GeospatialSelectedPointStyle = "POINT" | "CLUSTER" | "HEATMAP";
export const GeospatialSelectedPointStyle = S.Literal(
  "POINT",
  "CLUSTER",
  "HEATMAP",
);
export interface SimpleClusterMarker {
  Color?: string;
}
export const SimpleClusterMarker = S.suspend(() =>
  S.Struct({ Color: S.optional(S.String) }),
).annotations({
  identifier: "SimpleClusterMarker",
}) as any as S.Schema<SimpleClusterMarker>;
export interface ClusterMarker {
  SimpleClusterMarker?: SimpleClusterMarker;
}
export const ClusterMarker = S.suspend(() =>
  S.Struct({ SimpleClusterMarker: S.optional(SimpleClusterMarker) }),
).annotations({
  identifier: "ClusterMarker",
}) as any as S.Schema<ClusterMarker>;
export interface ClusterMarkerConfiguration {
  ClusterMarker?: ClusterMarker;
}
export const ClusterMarkerConfiguration = S.suspend(() =>
  S.Struct({ ClusterMarker: S.optional(ClusterMarker) }),
).annotations({
  identifier: "ClusterMarkerConfiguration",
}) as any as S.Schema<ClusterMarkerConfiguration>;
export interface GeospatialHeatmapDataColor {
  Color: string;
}
export const GeospatialHeatmapDataColor = S.suspend(() =>
  S.Struct({ Color: S.String }),
).annotations({
  identifier: "GeospatialHeatmapDataColor",
}) as any as S.Schema<GeospatialHeatmapDataColor>;
export type GeospatialHeatmapDataColorList = GeospatialHeatmapDataColor[];
export const GeospatialHeatmapDataColorList = S.Array(
  GeospatialHeatmapDataColor,
);
export interface GeospatialHeatmapColorScale {
  Colors?: GeospatialHeatmapDataColor[];
}
export const GeospatialHeatmapColorScale = S.suspend(() =>
  S.Struct({ Colors: S.optional(GeospatialHeatmapDataColorList) }),
).annotations({
  identifier: "GeospatialHeatmapColorScale",
}) as any as S.Schema<GeospatialHeatmapColorScale>;
export interface GeospatialHeatmapConfiguration {
  HeatmapColor?: GeospatialHeatmapColorScale;
}
export const GeospatialHeatmapConfiguration = S.suspend(() =>
  S.Struct({ HeatmapColor: S.optional(GeospatialHeatmapColorScale) }),
).annotations({
  identifier: "GeospatialHeatmapConfiguration",
}) as any as S.Schema<GeospatialHeatmapConfiguration>;
export interface GeospatialPointStyleOptions {
  SelectedPointStyle?: GeospatialSelectedPointStyle;
  ClusterMarkerConfiguration?: ClusterMarkerConfiguration;
  HeatmapConfiguration?: GeospatialHeatmapConfiguration;
}
export const GeospatialPointStyleOptions = S.suspend(() =>
  S.Struct({
    SelectedPointStyle: S.optional(GeospatialSelectedPointStyle),
    ClusterMarkerConfiguration: S.optional(ClusterMarkerConfiguration),
    HeatmapConfiguration: S.optional(GeospatialHeatmapConfiguration),
  }),
).annotations({
  identifier: "GeospatialPointStyleOptions",
}) as any as S.Schema<GeospatialPointStyleOptions>;
export interface GeospatialMapConfiguration {
  FieldWells?: GeospatialMapFieldWells;
  Legend?: LegendOptions;
  Tooltip?: TooltipOptions;
  WindowOptions?: GeospatialWindowOptions;
  MapStyleOptions?: GeospatialMapStyleOptions;
  PointStyleOptions?: GeospatialPointStyleOptions;
  VisualPalette?: VisualPalette;
  Interactions?: VisualInteractionOptions;
}
export const GeospatialMapConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(GeospatialMapFieldWells),
    Legend: S.optional(LegendOptions),
    Tooltip: S.optional(TooltipOptions),
    WindowOptions: S.optional(GeospatialWindowOptions),
    MapStyleOptions: S.optional(GeospatialMapStyleOptions),
    PointStyleOptions: S.optional(GeospatialPointStyleOptions),
    VisualPalette: S.optional(VisualPalette),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "GeospatialMapConfiguration",
}) as any as S.Schema<GeospatialMapConfiguration>;
export interface GeocoderHierarchy {
  Country?: string;
  State?: string;
  County?: string;
  City?: string;
  PostCode?: string;
}
export const GeocoderHierarchy = S.suspend(() =>
  S.Struct({
    Country: S.optional(S.String),
    State: S.optional(S.String),
    County: S.optional(S.String),
    City: S.optional(S.String),
    PostCode: S.optional(S.String),
  }),
).annotations({
  identifier: "GeocoderHierarchy",
}) as any as S.Schema<GeocoderHierarchy>;
export interface Coordinate {
  Latitude: number;
  Longitude: number;
}
export const Coordinate = S.suspend(() =>
  S.Struct({ Latitude: S.Number, Longitude: S.Number }),
).annotations({ identifier: "Coordinate" }) as any as S.Schema<Coordinate>;
export type GeocodePreferenceValue =
  | { GeocoderHierarchy: GeocoderHierarchy }
  | { Coordinate: Coordinate };
export const GeocodePreferenceValue = S.Union(
  S.Struct({ GeocoderHierarchy: GeocoderHierarchy }),
  S.Struct({ Coordinate: Coordinate }),
);
export interface GeocodePreference {
  RequestKey: GeocoderHierarchy;
  Preference: GeocodePreferenceValue;
}
export const GeocodePreference = S.suspend(() =>
  S.Struct({
    RequestKey: GeocoderHierarchy,
    Preference: GeocodePreferenceValue,
  }),
).annotations({
  identifier: "GeocodePreference",
}) as any as S.Schema<GeocodePreference>;
export type GeocodePreferenceList = GeocodePreference[];
export const GeocodePreferenceList = S.Array(GeocodePreference);
export interface GeospatialMapVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: GeospatialMapConfiguration;
  ColumnHierarchies?: ColumnHierarchy[];
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
  GeocodingPreferences?: GeocodePreference[];
}
export const GeospatialMapVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(GeospatialMapConfiguration),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
    GeocodingPreferences: S.optional(GeocodePreferenceList),
  }),
).annotations({
  identifier: "GeospatialMapVisual",
}) as any as S.Schema<GeospatialMapVisual>;
export type FilledMapDimensionFieldList = DimensionField[];
export const FilledMapDimensionFieldList = S.Array(DimensionField);
export type FilledMapMeasureFieldList = MeasureField[];
export const FilledMapMeasureFieldList = S.Array(MeasureField);
export interface FilledMapAggregatedFieldWells {
  Geospatial?: DimensionField[];
  Values?: MeasureField[];
}
export const FilledMapAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Geospatial: S.optional(FilledMapDimensionFieldList),
    Values: S.optional(FilledMapMeasureFieldList),
  }),
).annotations({
  identifier: "FilledMapAggregatedFieldWells",
}) as any as S.Schema<FilledMapAggregatedFieldWells>;
export interface FilledMapFieldWells {
  FilledMapAggregatedFieldWells?: FilledMapAggregatedFieldWells;
}
export const FilledMapFieldWells = S.suspend(() =>
  S.Struct({
    FilledMapAggregatedFieldWells: S.optional(FilledMapAggregatedFieldWells),
  }),
).annotations({
  identifier: "FilledMapFieldWells",
}) as any as S.Schema<FilledMapFieldWells>;
export interface FilledMapSortConfiguration {
  CategorySort?: FieldSortOptions[];
}
export const FilledMapSortConfiguration = S.suspend(() =>
  S.Struct({ CategorySort: S.optional(FieldSortOptionsList) }),
).annotations({
  identifier: "FilledMapSortConfiguration",
}) as any as S.Schema<FilledMapSortConfiguration>;
export interface FilledMapConfiguration {
  FieldWells?: FilledMapFieldWells;
  SortConfiguration?: FilledMapSortConfiguration;
  Legend?: LegendOptions;
  Tooltip?: TooltipOptions;
  WindowOptions?: GeospatialWindowOptions;
  MapStyleOptions?: GeospatialMapStyleOptions;
  Interactions?: VisualInteractionOptions;
}
export const FilledMapConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(FilledMapFieldWells),
    SortConfiguration: S.optional(FilledMapSortConfiguration),
    Legend: S.optional(LegendOptions),
    Tooltip: S.optional(TooltipOptions),
    WindowOptions: S.optional(GeospatialWindowOptions),
    MapStyleOptions: S.optional(GeospatialMapStyleOptions),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "FilledMapConfiguration",
}) as any as S.Schema<FilledMapConfiguration>;
export interface ShapeConditionalFormat {
  BackgroundColor: ConditionalFormattingColor;
}
export const ShapeConditionalFormat = S.suspend(() =>
  S.Struct({ BackgroundColor: ConditionalFormattingColor }),
).annotations({
  identifier: "ShapeConditionalFormat",
}) as any as S.Schema<ShapeConditionalFormat>;
export interface FilledMapShapeConditionalFormatting {
  FieldId: string;
  Format?: ShapeConditionalFormat;
}
export const FilledMapShapeConditionalFormatting = S.suspend(() =>
  S.Struct({ FieldId: S.String, Format: S.optional(ShapeConditionalFormat) }),
).annotations({
  identifier: "FilledMapShapeConditionalFormatting",
}) as any as S.Schema<FilledMapShapeConditionalFormatting>;
export interface FilledMapConditionalFormattingOption {
  Shape: FilledMapShapeConditionalFormatting;
}
export const FilledMapConditionalFormattingOption = S.suspend(() =>
  S.Struct({ Shape: FilledMapShapeConditionalFormatting }),
).annotations({
  identifier: "FilledMapConditionalFormattingOption",
}) as any as S.Schema<FilledMapConditionalFormattingOption>;
export type FilledMapConditionalFormattingOptionList =
  FilledMapConditionalFormattingOption[];
export const FilledMapConditionalFormattingOptionList = S.Array(
  FilledMapConditionalFormattingOption,
);
export interface FilledMapConditionalFormatting {
  ConditionalFormattingOptions: FilledMapConditionalFormattingOption[];
}
export const FilledMapConditionalFormatting = S.suspend(() =>
  S.Struct({
    ConditionalFormattingOptions: FilledMapConditionalFormattingOptionList,
  }),
).annotations({
  identifier: "FilledMapConditionalFormatting",
}) as any as S.Schema<FilledMapConditionalFormatting>;
export interface FilledMapVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: FilledMapConfiguration;
  ConditionalFormatting?: FilledMapConditionalFormatting;
  ColumnHierarchies?: ColumnHierarchy[];
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
  GeocodingPreferences?: GeocodePreference[];
}
export const FilledMapVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(FilledMapConfiguration),
    ConditionalFormatting: S.optional(FilledMapConditionalFormatting),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
    GeocodingPreferences: S.optional(GeocodePreferenceList),
  }),
).annotations({
  identifier: "FilledMapVisual",
}) as any as S.Schema<FilledMapVisual>;
export type GeospatialLayerType = "POINT" | "LINE" | "POLYGON";
export const GeospatialLayerType = S.Literal("POINT", "LINE", "POLYGON");
export interface GeospatialStaticFileSource {
  StaticFileId: string;
}
export const GeospatialStaticFileSource = S.suspend(() =>
  S.Struct({ StaticFileId: S.String }),
).annotations({
  identifier: "GeospatialStaticFileSource",
}) as any as S.Schema<GeospatialStaticFileSource>;
export interface GeospatialDataSourceItem {
  StaticFileDataSource?: GeospatialStaticFileSource;
}
export const GeospatialDataSourceItem = S.suspend(() =>
  S.Struct({ StaticFileDataSource: S.optional(GeospatialStaticFileSource) }),
).annotations({
  identifier: "GeospatialDataSourceItem",
}) as any as S.Schema<GeospatialDataSourceItem>;
export type GeospatialColorState = "ENABLED" | "DISABLED";
export const GeospatialColorState = S.Literal("ENABLED", "DISABLED");
export interface GeospatialSolidColor {
  Color: string;
  State?: GeospatialColorState;
}
export const GeospatialSolidColor = S.suspend(() =>
  S.Struct({ Color: S.String, State: S.optional(GeospatialColorState) }),
).annotations({
  identifier: "GeospatialSolidColor",
}) as any as S.Schema<GeospatialSolidColor>;
export interface GeospatialGradientStepColor {
  Color: string;
  DataValue: number;
}
export const GeospatialGradientStepColor = S.suspend(() =>
  S.Struct({ Color: S.String, DataValue: S.Number }),
).annotations({
  identifier: "GeospatialGradientStepColor",
}) as any as S.Schema<GeospatialGradientStepColor>;
export type GeospatialGradientStepColorList = GeospatialGradientStepColor[];
export const GeospatialGradientStepColorList = S.Array(
  GeospatialGradientStepColor,
);
export interface GeospatialNullSymbolStyle {
  FillColor?: string;
  StrokeColor?: string;
  StrokeWidth?: number;
}
export const GeospatialNullSymbolStyle = S.suspend(() =>
  S.Struct({
    FillColor: S.optional(S.String),
    StrokeColor: S.optional(S.String),
    StrokeWidth: S.optional(S.Number),
  }),
).annotations({
  identifier: "GeospatialNullSymbolStyle",
}) as any as S.Schema<GeospatialNullSymbolStyle>;
export interface GeospatialNullDataSettings {
  SymbolStyle: GeospatialNullSymbolStyle;
}
export const GeospatialNullDataSettings = S.suspend(() =>
  S.Struct({ SymbolStyle: GeospatialNullSymbolStyle }),
).annotations({
  identifier: "GeospatialNullDataSettings",
}) as any as S.Schema<GeospatialNullDataSettings>;
export interface GeospatialGradientColor {
  StepColors: GeospatialGradientStepColor[];
  NullDataVisibility?: Visibility;
  NullDataSettings?: GeospatialNullDataSettings;
  DefaultOpacity?: number;
}
export const GeospatialGradientColor = S.suspend(() =>
  S.Struct({
    StepColors: GeospatialGradientStepColorList,
    NullDataVisibility: S.optional(Visibility),
    NullDataSettings: S.optional(GeospatialNullDataSettings),
    DefaultOpacity: S.optional(S.Number),
  }),
).annotations({
  identifier: "GeospatialGradientColor",
}) as any as S.Schema<GeospatialGradientColor>;
export interface GeospatialCategoricalDataColor {
  Color: string;
  DataValue: string;
}
export const GeospatialCategoricalDataColor = S.suspend(() =>
  S.Struct({ Color: S.String, DataValue: S.String }),
).annotations({
  identifier: "GeospatialCategoricalDataColor",
}) as any as S.Schema<GeospatialCategoricalDataColor>;
export type GeospatialCategoricalDataColorList =
  GeospatialCategoricalDataColor[];
export const GeospatialCategoricalDataColorList = S.Array(
  GeospatialCategoricalDataColor,
);
export interface GeospatialCategoricalColor {
  CategoryDataColors: GeospatialCategoricalDataColor[];
  NullDataVisibility?: Visibility;
  NullDataSettings?: GeospatialNullDataSettings;
  DefaultOpacity?: number;
}
export const GeospatialCategoricalColor = S.suspend(() =>
  S.Struct({
    CategoryDataColors: GeospatialCategoricalDataColorList,
    NullDataVisibility: S.optional(Visibility),
    NullDataSettings: S.optional(GeospatialNullDataSettings),
    DefaultOpacity: S.optional(S.Number),
  }),
).annotations({
  identifier: "GeospatialCategoricalColor",
}) as any as S.Schema<GeospatialCategoricalColor>;
export interface GeospatialColor {
  Solid?: GeospatialSolidColor;
  Gradient?: GeospatialGradientColor;
  Categorical?: GeospatialCategoricalColor;
}
export const GeospatialColor = S.suspend(() =>
  S.Struct({
    Solid: S.optional(GeospatialSolidColor),
    Gradient: S.optional(GeospatialGradientColor),
    Categorical: S.optional(GeospatialCategoricalColor),
  }),
).annotations({
  identifier: "GeospatialColor",
}) as any as S.Schema<GeospatialColor>;
export interface GeospatialLineWidth {
  LineWidth?: number;
}
export const GeospatialLineWidth = S.suspend(() =>
  S.Struct({ LineWidth: S.optional(S.Number) }),
).annotations({
  identifier: "GeospatialLineWidth",
}) as any as S.Schema<GeospatialLineWidth>;
export interface GeospatialCircleRadius {
  Radius?: number;
}
export const GeospatialCircleRadius = S.suspend(() =>
  S.Struct({ Radius: S.optional(S.Number) }),
).annotations({
  identifier: "GeospatialCircleRadius",
}) as any as S.Schema<GeospatialCircleRadius>;
export interface GeospatialCircleSymbolStyle {
  FillColor?: GeospatialColor;
  StrokeColor?: GeospatialColor;
  StrokeWidth?: GeospatialLineWidth;
  CircleRadius?: GeospatialCircleRadius;
}
export const GeospatialCircleSymbolStyle = S.suspend(() =>
  S.Struct({
    FillColor: S.optional(GeospatialColor),
    StrokeColor: S.optional(GeospatialColor),
    StrokeWidth: S.optional(GeospatialLineWidth),
    CircleRadius: S.optional(GeospatialCircleRadius),
  }),
).annotations({
  identifier: "GeospatialCircleSymbolStyle",
}) as any as S.Schema<GeospatialCircleSymbolStyle>;
export interface GeospatialPointStyle {
  CircleSymbolStyle?: GeospatialCircleSymbolStyle;
}
export const GeospatialPointStyle = S.suspend(() =>
  S.Struct({ CircleSymbolStyle: S.optional(GeospatialCircleSymbolStyle) }),
).annotations({
  identifier: "GeospatialPointStyle",
}) as any as S.Schema<GeospatialPointStyle>;
export interface GeospatialPointLayer {
  Style: GeospatialPointStyle;
}
export const GeospatialPointLayer = S.suspend(() =>
  S.Struct({ Style: GeospatialPointStyle }),
).annotations({
  identifier: "GeospatialPointLayer",
}) as any as S.Schema<GeospatialPointLayer>;
export interface GeospatialLineSymbolStyle {
  FillColor?: GeospatialColor;
  LineWidth?: GeospatialLineWidth;
}
export const GeospatialLineSymbolStyle = S.suspend(() =>
  S.Struct({
    FillColor: S.optional(GeospatialColor),
    LineWidth: S.optional(GeospatialLineWidth),
  }),
).annotations({
  identifier: "GeospatialLineSymbolStyle",
}) as any as S.Schema<GeospatialLineSymbolStyle>;
export interface GeospatialLineStyle {
  LineSymbolStyle?: GeospatialLineSymbolStyle;
}
export const GeospatialLineStyle = S.suspend(() =>
  S.Struct({ LineSymbolStyle: S.optional(GeospatialLineSymbolStyle) }),
).annotations({
  identifier: "GeospatialLineStyle",
}) as any as S.Schema<GeospatialLineStyle>;
export interface GeospatialLineLayer {
  Style: GeospatialLineStyle;
}
export const GeospatialLineLayer = S.suspend(() =>
  S.Struct({ Style: GeospatialLineStyle }),
).annotations({
  identifier: "GeospatialLineLayer",
}) as any as S.Schema<GeospatialLineLayer>;
export interface GeospatialPolygonSymbolStyle {
  FillColor?: GeospatialColor;
  StrokeColor?: GeospatialColor;
  StrokeWidth?: GeospatialLineWidth;
}
export const GeospatialPolygonSymbolStyle = S.suspend(() =>
  S.Struct({
    FillColor: S.optional(GeospatialColor),
    StrokeColor: S.optional(GeospatialColor),
    StrokeWidth: S.optional(GeospatialLineWidth),
  }),
).annotations({
  identifier: "GeospatialPolygonSymbolStyle",
}) as any as S.Schema<GeospatialPolygonSymbolStyle>;
export interface GeospatialPolygonStyle {
  PolygonSymbolStyle?: GeospatialPolygonSymbolStyle;
}
export const GeospatialPolygonStyle = S.suspend(() =>
  S.Struct({ PolygonSymbolStyle: S.optional(GeospatialPolygonSymbolStyle) }),
).annotations({
  identifier: "GeospatialPolygonStyle",
}) as any as S.Schema<GeospatialPolygonStyle>;
export interface GeospatialPolygonLayer {
  Style: GeospatialPolygonStyle;
}
export const GeospatialPolygonLayer = S.suspend(() =>
  S.Struct({ Style: GeospatialPolygonStyle }),
).annotations({
  identifier: "GeospatialPolygonLayer",
}) as any as S.Schema<GeospatialPolygonLayer>;
export interface GeospatialLayerDefinition {
  PointLayer?: GeospatialPointLayer;
  LineLayer?: GeospatialLineLayer;
  PolygonLayer?: GeospatialPolygonLayer;
}
export const GeospatialLayerDefinition = S.suspend(() =>
  S.Struct({
    PointLayer: S.optional(GeospatialPointLayer),
    LineLayer: S.optional(GeospatialLineLayer),
    PolygonLayer: S.optional(GeospatialPolygonLayer),
  }),
).annotations({
  identifier: "GeospatialLayerDefinition",
}) as any as S.Schema<GeospatialLayerDefinition>;
export type GeospatialLayerDimensionFieldList = DimensionField[];
export const GeospatialLayerDimensionFieldList = S.Array(DimensionField);
export type GeospatialLayerMeasureFieldList = MeasureField[];
export const GeospatialLayerMeasureFieldList = S.Array(MeasureField);
export interface GeospatialLayerColorField {
  ColorDimensionsFields?: DimensionField[];
  ColorValuesFields?: MeasureField[];
}
export const GeospatialLayerColorField = S.suspend(() =>
  S.Struct({
    ColorDimensionsFields: S.optional(GeospatialLayerDimensionFieldList),
    ColorValuesFields: S.optional(GeospatialLayerMeasureFieldList),
  }),
).annotations({
  identifier: "GeospatialLayerColorField",
}) as any as S.Schema<GeospatialLayerColorField>;
export interface GeospatialLayerJoinDefinition {
  ShapeKeyField?: string;
  DatasetKeyField?: UnaggregatedField;
  ColorField?: GeospatialLayerColorField;
}
export const GeospatialLayerJoinDefinition = S.suspend(() =>
  S.Struct({
    ShapeKeyField: S.optional(S.String),
    DatasetKeyField: S.optional(UnaggregatedField),
    ColorField: S.optional(GeospatialLayerColorField),
  }),
).annotations({
  identifier: "GeospatialLayerJoinDefinition",
}) as any as S.Schema<GeospatialLayerJoinDefinition>;
export type LayerCustomActionTrigger = "DATA_POINT_CLICK" | "DATA_POINT_MENU";
export const LayerCustomActionTrigger = S.Literal(
  "DATA_POINT_CLICK",
  "DATA_POINT_MENU",
);
export interface LayerCustomActionOperation {
  FilterOperation?: CustomActionFilterOperation;
  NavigationOperation?: CustomActionNavigationOperation;
  URLOperation?: CustomActionURLOperation;
  SetParametersOperation?: CustomActionSetParametersOperation;
}
export const LayerCustomActionOperation = S.suspend(() =>
  S.Struct({
    FilterOperation: S.optional(CustomActionFilterOperation),
    NavigationOperation: S.optional(CustomActionNavigationOperation),
    URLOperation: S.optional(CustomActionURLOperation),
    SetParametersOperation: S.optional(CustomActionSetParametersOperation),
  }),
).annotations({
  identifier: "LayerCustomActionOperation",
}) as any as S.Schema<LayerCustomActionOperation>;
export type LayerCustomActionOperationList = LayerCustomActionOperation[];
export const LayerCustomActionOperationList = S.Array(
  LayerCustomActionOperation,
);
export interface LayerCustomAction {
  CustomActionId: string;
  Name: string;
  Status?: WidgetStatus;
  Trigger: LayerCustomActionTrigger;
  ActionOperations: LayerCustomActionOperation[];
}
export const LayerCustomAction = S.suspend(() =>
  S.Struct({
    CustomActionId: S.String,
    Name: S.String,
    Status: S.optional(WidgetStatus),
    Trigger: LayerCustomActionTrigger,
    ActionOperations: LayerCustomActionOperationList,
  }),
).annotations({
  identifier: "LayerCustomAction",
}) as any as S.Schema<LayerCustomAction>;
export type LayerCustomActionList = LayerCustomAction[];
export const LayerCustomActionList = S.Array(LayerCustomAction);
export interface GeospatialLayerItem {
  LayerId: string;
  LayerType?: GeospatialLayerType;
  DataSource?: GeospatialDataSourceItem;
  Label?: string;
  Visibility?: Visibility;
  LayerDefinition?: GeospatialLayerDefinition;
  Tooltip?: TooltipOptions;
  JoinDefinition?: GeospatialLayerJoinDefinition;
  Actions?: LayerCustomAction[];
}
export const GeospatialLayerItem = S.suspend(() =>
  S.Struct({
    LayerId: S.String,
    LayerType: S.optional(GeospatialLayerType),
    DataSource: S.optional(GeospatialDataSourceItem),
    Label: S.optional(S.String),
    Visibility: S.optional(Visibility),
    LayerDefinition: S.optional(GeospatialLayerDefinition),
    Tooltip: S.optional(TooltipOptions),
    JoinDefinition: S.optional(GeospatialLayerJoinDefinition),
    Actions: S.optional(LayerCustomActionList),
  }),
).annotations({
  identifier: "GeospatialLayerItem",
}) as any as S.Schema<GeospatialLayerItem>;
export type GeospatialMapLayerList = GeospatialLayerItem[];
export const GeospatialMapLayerList = S.Array(GeospatialLayerItem);
export type GeospatialMapNavigation = "ENABLED" | "DISABLED";
export const GeospatialMapNavigation = S.Literal("ENABLED", "DISABLED");
export interface GeospatialMapState {
  Bounds?: GeospatialCoordinateBounds;
  MapNavigation?: GeospatialMapNavigation;
}
export const GeospatialMapState = S.suspend(() =>
  S.Struct({
    Bounds: S.optional(GeospatialCoordinateBounds),
    MapNavigation: S.optional(GeospatialMapNavigation),
  }),
).annotations({
  identifier: "GeospatialMapState",
}) as any as S.Schema<GeospatialMapState>;
export interface GeospatialMapStyle {
  BaseMapStyle?: BaseMapStyleType;
  BackgroundColor?: string;
  BaseMapVisibility?: Visibility;
}
export const GeospatialMapStyle = S.suspend(() =>
  S.Struct({
    BaseMapStyle: S.optional(BaseMapStyleType),
    BackgroundColor: S.optional(S.String),
    BaseMapVisibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "GeospatialMapStyle",
}) as any as S.Schema<GeospatialMapStyle>;
export interface GeospatialLayerMapConfiguration {
  Legend?: LegendOptions;
  MapLayers?: GeospatialLayerItem[];
  MapState?: GeospatialMapState;
  MapStyle?: GeospatialMapStyle;
  Interactions?: VisualInteractionOptions;
}
export const GeospatialLayerMapConfiguration = S.suspend(() =>
  S.Struct({
    Legend: S.optional(LegendOptions),
    MapLayers: S.optional(GeospatialMapLayerList),
    MapState: S.optional(GeospatialMapState),
    MapStyle: S.optional(GeospatialMapStyle),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "GeospatialLayerMapConfiguration",
}) as any as S.Schema<GeospatialLayerMapConfiguration>;
export interface LayerMapVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: GeospatialLayerMapConfiguration;
  DataSetIdentifier: string;
  VisualContentAltText?: string;
}
export const LayerMapVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(GeospatialLayerMapConfiguration),
    DataSetIdentifier: S.String,
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "LayerMapVisual",
}) as any as S.Schema<LayerMapVisual>;
export type FunnelChartDimensionFieldList = DimensionField[];
export const FunnelChartDimensionFieldList = S.Array(DimensionField);
export type FunnelChartMeasureFieldList = MeasureField[];
export const FunnelChartMeasureFieldList = S.Array(MeasureField);
export interface FunnelChartAggregatedFieldWells {
  Category?: DimensionField[];
  Values?: MeasureField[];
}
export const FunnelChartAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Category: S.optional(FunnelChartDimensionFieldList),
    Values: S.optional(FunnelChartMeasureFieldList),
  }),
).annotations({
  identifier: "FunnelChartAggregatedFieldWells",
}) as any as S.Schema<FunnelChartAggregatedFieldWells>;
export interface FunnelChartFieldWells {
  FunnelChartAggregatedFieldWells?: FunnelChartAggregatedFieldWells;
}
export const FunnelChartFieldWells = S.suspend(() =>
  S.Struct({
    FunnelChartAggregatedFieldWells: S.optional(
      FunnelChartAggregatedFieldWells,
    ),
  }),
).annotations({
  identifier: "FunnelChartFieldWells",
}) as any as S.Schema<FunnelChartFieldWells>;
export interface FunnelChartSortConfiguration {
  CategorySort?: FieldSortOptions[];
  CategoryItemsLimit?: ItemsLimitConfiguration;
}
export const FunnelChartSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    CategoryItemsLimit: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "FunnelChartSortConfiguration",
}) as any as S.Schema<FunnelChartSortConfiguration>;
export type FunnelChartMeasureDataLabelStyle =
  | "VALUE_ONLY"
  | "PERCENTAGE_BY_FIRST_STAGE"
  | "PERCENTAGE_BY_PREVIOUS_STAGE"
  | "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE"
  | "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE";
export const FunnelChartMeasureDataLabelStyle = S.Literal(
  "VALUE_ONLY",
  "PERCENTAGE_BY_FIRST_STAGE",
  "PERCENTAGE_BY_PREVIOUS_STAGE",
  "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE",
  "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE",
);
export interface FunnelChartDataLabelOptions {
  Visibility?: Visibility;
  CategoryLabelVisibility?: Visibility;
  MeasureLabelVisibility?: Visibility;
  Position?: DataLabelPosition;
  LabelFontConfiguration?: FontConfiguration;
  LabelColor?: string;
  MeasureDataLabelStyle?: FunnelChartMeasureDataLabelStyle;
}
export const FunnelChartDataLabelOptions = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    CategoryLabelVisibility: S.optional(Visibility),
    MeasureLabelVisibility: S.optional(Visibility),
    Position: S.optional(DataLabelPosition),
    LabelFontConfiguration: S.optional(FontConfiguration),
    LabelColor: S.optional(S.String),
    MeasureDataLabelStyle: S.optional(FunnelChartMeasureDataLabelStyle),
  }),
).annotations({
  identifier: "FunnelChartDataLabelOptions",
}) as any as S.Schema<FunnelChartDataLabelOptions>;
export interface FunnelChartConfiguration {
  FieldWells?: FunnelChartFieldWells;
  SortConfiguration?: FunnelChartSortConfiguration;
  CategoryLabelOptions?: ChartAxisLabelOptions;
  ValueLabelOptions?: ChartAxisLabelOptions;
  Tooltip?: TooltipOptions;
  DataLabelOptions?: FunnelChartDataLabelOptions;
  VisualPalette?: VisualPalette;
  Interactions?: VisualInteractionOptions;
}
export const FunnelChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(FunnelChartFieldWells),
    SortConfiguration: S.optional(FunnelChartSortConfiguration),
    CategoryLabelOptions: S.optional(ChartAxisLabelOptions),
    ValueLabelOptions: S.optional(ChartAxisLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    DataLabelOptions: S.optional(FunnelChartDataLabelOptions),
    VisualPalette: S.optional(VisualPalette),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "FunnelChartConfiguration",
}) as any as S.Schema<FunnelChartConfiguration>;
export interface FunnelChartVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: FunnelChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const FunnelChartVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(FunnelChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "FunnelChartVisual",
}) as any as S.Schema<FunnelChartVisual>;
export interface ScatterPlotCategoricallyAggregatedFieldWells {
  XAxis?: MeasureField[];
  YAxis?: MeasureField[];
  Category?: DimensionField[];
  Size?: MeasureField[];
  Label?: DimensionField[];
}
export const ScatterPlotCategoricallyAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    XAxis: S.optional(MeasureFieldList),
    YAxis: S.optional(MeasureFieldList),
    Category: S.optional(DimensionFieldList),
    Size: S.optional(MeasureFieldList),
    Label: S.optional(DimensionFieldList),
  }),
).annotations({
  identifier: "ScatterPlotCategoricallyAggregatedFieldWells",
}) as any as S.Schema<ScatterPlotCategoricallyAggregatedFieldWells>;
export interface ScatterPlotUnaggregatedFieldWells {
  XAxis?: DimensionField[];
  YAxis?: DimensionField[];
  Size?: MeasureField[];
  Category?: DimensionField[];
  Label?: DimensionField[];
}
export const ScatterPlotUnaggregatedFieldWells = S.suspend(() =>
  S.Struct({
    XAxis: S.optional(DimensionFieldList),
    YAxis: S.optional(DimensionFieldList),
    Size: S.optional(MeasureFieldList),
    Category: S.optional(DimensionFieldList),
    Label: S.optional(DimensionFieldList),
  }),
).annotations({
  identifier: "ScatterPlotUnaggregatedFieldWells",
}) as any as S.Schema<ScatterPlotUnaggregatedFieldWells>;
export interface ScatterPlotFieldWells {
  ScatterPlotCategoricallyAggregatedFieldWells?: ScatterPlotCategoricallyAggregatedFieldWells;
  ScatterPlotUnaggregatedFieldWells?: ScatterPlotUnaggregatedFieldWells;
}
export const ScatterPlotFieldWells = S.suspend(() =>
  S.Struct({
    ScatterPlotCategoricallyAggregatedFieldWells: S.optional(
      ScatterPlotCategoricallyAggregatedFieldWells,
    ),
    ScatterPlotUnaggregatedFieldWells: S.optional(
      ScatterPlotUnaggregatedFieldWells,
    ),
  }),
).annotations({
  identifier: "ScatterPlotFieldWells",
}) as any as S.Schema<ScatterPlotFieldWells>;
export interface ScatterPlotSortConfiguration {
  ScatterPlotLimitConfiguration?: ItemsLimitConfiguration;
}
export const ScatterPlotSortConfiguration = S.suspend(() =>
  S.Struct({
    ScatterPlotLimitConfiguration: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "ScatterPlotSortConfiguration",
}) as any as S.Schema<ScatterPlotSortConfiguration>;
export interface ScatterPlotConfiguration {
  FieldWells?: ScatterPlotFieldWells;
  SortConfiguration?: ScatterPlotSortConfiguration;
  XAxisLabelOptions?: ChartAxisLabelOptions;
  XAxisDisplayOptions?: AxisDisplayOptions;
  YAxisLabelOptions?: ChartAxisLabelOptions;
  YAxisDisplayOptions?: AxisDisplayOptions;
  Legend?: LegendOptions;
  DataLabels?: DataLabelOptions;
  Tooltip?: TooltipOptions;
  VisualPalette?: VisualPalette;
  Interactions?: VisualInteractionOptions;
}
export const ScatterPlotConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(ScatterPlotFieldWells),
    SortConfiguration: S.optional(ScatterPlotSortConfiguration),
    XAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    XAxisDisplayOptions: S.optional(AxisDisplayOptions),
    YAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    YAxisDisplayOptions: S.optional(AxisDisplayOptions),
    Legend: S.optional(LegendOptions),
    DataLabels: S.optional(DataLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    VisualPalette: S.optional(VisualPalette),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "ScatterPlotConfiguration",
}) as any as S.Schema<ScatterPlotConfiguration>;
export interface ScatterPlotVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: ScatterPlotConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const ScatterPlotVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(ScatterPlotConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "ScatterPlotVisual",
}) as any as S.Schema<ScatterPlotVisual>;
export interface ComboChartAggregatedFieldWells {
  Category?: DimensionField[];
  BarValues?: MeasureField[];
  Colors?: DimensionField[];
  LineValues?: MeasureField[];
}
export const ComboChartAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Category: S.optional(DimensionFieldList),
    BarValues: S.optional(MeasureFieldList),
    Colors: S.optional(DimensionFieldList),
    LineValues: S.optional(MeasureFieldList),
  }),
).annotations({
  identifier: "ComboChartAggregatedFieldWells",
}) as any as S.Schema<ComboChartAggregatedFieldWells>;
export interface ComboChartFieldWells {
  ComboChartAggregatedFieldWells?: ComboChartAggregatedFieldWells;
}
export const ComboChartFieldWells = S.suspend(() =>
  S.Struct({
    ComboChartAggregatedFieldWells: S.optional(ComboChartAggregatedFieldWells),
  }),
).annotations({
  identifier: "ComboChartFieldWells",
}) as any as S.Schema<ComboChartFieldWells>;
export interface ComboChartSortConfiguration {
  CategorySort?: FieldSortOptions[];
  CategoryItemsLimit?: ItemsLimitConfiguration;
  ColorSort?: FieldSortOptions[];
  ColorItemsLimit?: ItemsLimitConfiguration;
}
export const ComboChartSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    CategoryItemsLimit: S.optional(ItemsLimitConfiguration),
    ColorSort: S.optional(FieldSortOptionsList),
    ColorItemsLimit: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "ComboChartSortConfiguration",
}) as any as S.Schema<ComboChartSortConfiguration>;
export interface ComboChartDefaultSeriesSettings {
  LineStyleSettings?: LineChartLineStyleSettings;
  MarkerStyleSettings?: LineChartMarkerStyleSettings;
  DecalSettings?: DecalSettings;
  BorderSettings?: BorderSettings;
}
export const ComboChartDefaultSeriesSettings = S.suspend(() =>
  S.Struct({
    LineStyleSettings: S.optional(LineChartLineStyleSettings),
    MarkerStyleSettings: S.optional(LineChartMarkerStyleSettings),
    DecalSettings: S.optional(DecalSettings),
    BorderSettings: S.optional(BorderSettings),
  }),
).annotations({
  identifier: "ComboChartDefaultSeriesSettings",
}) as any as S.Schema<ComboChartDefaultSeriesSettings>;
export interface ComboChartSeriesSettings {
  LineStyleSettings?: LineChartLineStyleSettings;
  MarkerStyleSettings?: LineChartMarkerStyleSettings;
  DecalSettings?: DecalSettings;
  BorderSettings?: BorderSettings;
}
export const ComboChartSeriesSettings = S.suspend(() =>
  S.Struct({
    LineStyleSettings: S.optional(LineChartLineStyleSettings),
    MarkerStyleSettings: S.optional(LineChartMarkerStyleSettings),
    DecalSettings: S.optional(DecalSettings),
    BorderSettings: S.optional(BorderSettings),
  }),
).annotations({
  identifier: "ComboChartSeriesSettings",
}) as any as S.Schema<ComboChartSeriesSettings>;
export interface FieldComboSeriesItem {
  FieldId: string;
  Settings?: ComboChartSeriesSettings;
}
export const FieldComboSeriesItem = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    Settings: S.optional(ComboChartSeriesSettings),
  }),
).annotations({
  identifier: "FieldComboSeriesItem",
}) as any as S.Schema<FieldComboSeriesItem>;
export interface DataFieldComboSeriesItem {
  FieldId: string;
  FieldValue?: string | redacted.Redacted<string>;
  Settings?: ComboChartSeriesSettings;
}
export const DataFieldComboSeriesItem = S.suspend(() =>
  S.Struct({
    FieldId: S.String,
    FieldValue: S.optional(SensitiveString),
    Settings: S.optional(ComboChartSeriesSettings),
  }),
).annotations({
  identifier: "DataFieldComboSeriesItem",
}) as any as S.Schema<DataFieldComboSeriesItem>;
export interface ComboSeriesItem {
  FieldComboSeriesItem?: FieldComboSeriesItem;
  DataFieldComboSeriesItem?: DataFieldComboSeriesItem;
}
export const ComboSeriesItem = S.suspend(() =>
  S.Struct({
    FieldComboSeriesItem: S.optional(FieldComboSeriesItem),
    DataFieldComboSeriesItem: S.optional(DataFieldComboSeriesItem),
  }),
).annotations({
  identifier: "ComboSeriesItem",
}) as any as S.Schema<ComboSeriesItem>;
export type ComboSeriesItemList = ComboSeriesItem[];
export const ComboSeriesItemList = S.Array(ComboSeriesItem);
export interface ComboChartConfiguration {
  FieldWells?: ComboChartFieldWells;
  SortConfiguration?: ComboChartSortConfiguration;
  BarsArrangement?: BarsArrangement;
  CategoryAxis?: AxisDisplayOptions;
  CategoryLabelOptions?: ChartAxisLabelOptions;
  PrimaryYAxisDisplayOptions?: AxisDisplayOptions;
  PrimaryYAxisLabelOptions?: ChartAxisLabelOptions;
  SecondaryYAxisDisplayOptions?: AxisDisplayOptions;
  SecondaryYAxisLabelOptions?: ChartAxisLabelOptions;
  SingleAxisOptions?: SingleAxisOptions;
  ColorLabelOptions?: ChartAxisLabelOptions;
  DefaultSeriesSettings?: ComboChartDefaultSeriesSettings;
  Series?: ComboSeriesItem[];
  Legend?: LegendOptions;
  BarDataLabels?: DataLabelOptions;
  LineDataLabels?: DataLabelOptions;
  Tooltip?: TooltipOptions;
  ReferenceLines?: ReferenceLine[];
  VisualPalette?: VisualPalette;
  Interactions?: VisualInteractionOptions;
}
export const ComboChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(ComboChartFieldWells),
    SortConfiguration: S.optional(ComboChartSortConfiguration),
    BarsArrangement: S.optional(BarsArrangement),
    CategoryAxis: S.optional(AxisDisplayOptions),
    CategoryLabelOptions: S.optional(ChartAxisLabelOptions),
    PrimaryYAxisDisplayOptions: S.optional(AxisDisplayOptions),
    PrimaryYAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    SecondaryYAxisDisplayOptions: S.optional(AxisDisplayOptions),
    SecondaryYAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    SingleAxisOptions: S.optional(SingleAxisOptions),
    ColorLabelOptions: S.optional(ChartAxisLabelOptions),
    DefaultSeriesSettings: S.optional(ComboChartDefaultSeriesSettings),
    Series: S.optional(ComboSeriesItemList),
    Legend: S.optional(LegendOptions),
    BarDataLabels: S.optional(DataLabelOptions),
    LineDataLabels: S.optional(DataLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    ReferenceLines: S.optional(ReferenceLineList),
    VisualPalette: S.optional(VisualPalette),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "ComboChartConfiguration",
}) as any as S.Schema<ComboChartConfiguration>;
export interface ComboChartVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: ComboChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const ComboChartVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(ComboChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "ComboChartVisual",
}) as any as S.Schema<ComboChartVisual>;
export type BoxPlotDimensionFieldList = DimensionField[];
export const BoxPlotDimensionFieldList = S.Array(DimensionField);
export type BoxPlotMeasureFieldList = MeasureField[];
export const BoxPlotMeasureFieldList = S.Array(MeasureField);
export interface BoxPlotAggregatedFieldWells {
  GroupBy?: DimensionField[];
  Values?: MeasureField[];
}
export const BoxPlotAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    GroupBy: S.optional(BoxPlotDimensionFieldList),
    Values: S.optional(BoxPlotMeasureFieldList),
  }),
).annotations({
  identifier: "BoxPlotAggregatedFieldWells",
}) as any as S.Schema<BoxPlotAggregatedFieldWells>;
export interface BoxPlotFieldWells {
  BoxPlotAggregatedFieldWells?: BoxPlotAggregatedFieldWells;
}
export const BoxPlotFieldWells = S.suspend(() =>
  S.Struct({
    BoxPlotAggregatedFieldWells: S.optional(BoxPlotAggregatedFieldWells),
  }),
).annotations({
  identifier: "BoxPlotFieldWells",
}) as any as S.Schema<BoxPlotFieldWells>;
export interface BoxPlotSortConfiguration {
  CategorySort?: FieldSortOptions[];
  PaginationConfiguration?: PaginationConfiguration;
}
export const BoxPlotSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    PaginationConfiguration: S.optional(PaginationConfiguration),
  }),
).annotations({
  identifier: "BoxPlotSortConfiguration",
}) as any as S.Schema<BoxPlotSortConfiguration>;
export type BoxPlotFillStyle = "SOLID" | "TRANSPARENT";
export const BoxPlotFillStyle = S.Literal("SOLID", "TRANSPARENT");
export interface BoxPlotStyleOptions {
  FillStyle?: BoxPlotFillStyle;
}
export const BoxPlotStyleOptions = S.suspend(() =>
  S.Struct({ FillStyle: S.optional(BoxPlotFillStyle) }),
).annotations({
  identifier: "BoxPlotStyleOptions",
}) as any as S.Schema<BoxPlotStyleOptions>;
export interface BoxPlotOptions {
  StyleOptions?: BoxPlotStyleOptions;
  OutlierVisibility?: Visibility;
  AllDataPointsVisibility?: Visibility;
}
export const BoxPlotOptions = S.suspend(() =>
  S.Struct({
    StyleOptions: S.optional(BoxPlotStyleOptions),
    OutlierVisibility: S.optional(Visibility),
    AllDataPointsVisibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "BoxPlotOptions",
}) as any as S.Schema<BoxPlotOptions>;
export interface BoxPlotChartConfiguration {
  FieldWells?: BoxPlotFieldWells;
  SortConfiguration?: BoxPlotSortConfiguration;
  BoxPlotOptions?: BoxPlotOptions;
  CategoryAxis?: AxisDisplayOptions;
  CategoryLabelOptions?: ChartAxisLabelOptions;
  PrimaryYAxisDisplayOptions?: AxisDisplayOptions;
  PrimaryYAxisLabelOptions?: ChartAxisLabelOptions;
  Legend?: LegendOptions;
  Tooltip?: TooltipOptions;
  ReferenceLines?: ReferenceLine[];
  VisualPalette?: VisualPalette;
  Interactions?: VisualInteractionOptions;
}
export const BoxPlotChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(BoxPlotFieldWells),
    SortConfiguration: S.optional(BoxPlotSortConfiguration),
    BoxPlotOptions: S.optional(BoxPlotOptions),
    CategoryAxis: S.optional(AxisDisplayOptions),
    CategoryLabelOptions: S.optional(ChartAxisLabelOptions),
    PrimaryYAxisDisplayOptions: S.optional(AxisDisplayOptions),
    PrimaryYAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    Legend: S.optional(LegendOptions),
    Tooltip: S.optional(TooltipOptions),
    ReferenceLines: S.optional(ReferenceLineList),
    VisualPalette: S.optional(VisualPalette),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "BoxPlotChartConfiguration",
}) as any as S.Schema<BoxPlotChartConfiguration>;
export interface BoxPlotVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: BoxPlotChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const BoxPlotVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(BoxPlotChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "BoxPlotVisual",
}) as any as S.Schema<BoxPlotVisual>;
export interface WaterfallChartAggregatedFieldWells {
  Categories?: DimensionField[];
  Values?: MeasureField[];
  Breakdowns?: DimensionField[];
}
export const WaterfallChartAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Categories: S.optional(DimensionFieldList),
    Values: S.optional(MeasureFieldList),
    Breakdowns: S.optional(DimensionFieldList),
  }),
).annotations({
  identifier: "WaterfallChartAggregatedFieldWells",
}) as any as S.Schema<WaterfallChartAggregatedFieldWells>;
export interface WaterfallChartFieldWells {
  WaterfallChartAggregatedFieldWells?: WaterfallChartAggregatedFieldWells;
}
export const WaterfallChartFieldWells = S.suspend(() =>
  S.Struct({
    WaterfallChartAggregatedFieldWells: S.optional(
      WaterfallChartAggregatedFieldWells,
    ),
  }),
).annotations({
  identifier: "WaterfallChartFieldWells",
}) as any as S.Schema<WaterfallChartFieldWells>;
export interface WaterfallChartSortConfiguration {
  CategorySort?: FieldSortOptions[];
  BreakdownItemsLimit?: ItemsLimitConfiguration;
}
export const WaterfallChartSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    BreakdownItemsLimit: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "WaterfallChartSortConfiguration",
}) as any as S.Schema<WaterfallChartSortConfiguration>;
export interface WaterfallChartOptions {
  TotalBarLabel?: string;
}
export const WaterfallChartOptions = S.suspend(() =>
  S.Struct({ TotalBarLabel: S.optional(S.String) }),
).annotations({
  identifier: "WaterfallChartOptions",
}) as any as S.Schema<WaterfallChartOptions>;
export interface WaterfallChartGroupColorConfiguration {
  PositiveBarColor?: string;
  NegativeBarColor?: string;
  TotalBarColor?: string;
}
export const WaterfallChartGroupColorConfiguration = S.suspend(() =>
  S.Struct({
    PositiveBarColor: S.optional(S.String),
    NegativeBarColor: S.optional(S.String),
    TotalBarColor: S.optional(S.String),
  }),
).annotations({
  identifier: "WaterfallChartGroupColorConfiguration",
}) as any as S.Schema<WaterfallChartGroupColorConfiguration>;
export interface WaterfallChartColorConfiguration {
  GroupColorConfiguration?: WaterfallChartGroupColorConfiguration;
}
export const WaterfallChartColorConfiguration = S.suspend(() =>
  S.Struct({
    GroupColorConfiguration: S.optional(WaterfallChartGroupColorConfiguration),
  }),
).annotations({
  identifier: "WaterfallChartColorConfiguration",
}) as any as S.Schema<WaterfallChartColorConfiguration>;
export interface WaterfallChartConfiguration {
  FieldWells?: WaterfallChartFieldWells;
  SortConfiguration?: WaterfallChartSortConfiguration;
  WaterfallChartOptions?: WaterfallChartOptions;
  CategoryAxisLabelOptions?: ChartAxisLabelOptions;
  CategoryAxisDisplayOptions?: AxisDisplayOptions;
  PrimaryYAxisLabelOptions?: ChartAxisLabelOptions;
  PrimaryYAxisDisplayOptions?: AxisDisplayOptions;
  Legend?: LegendOptions;
  DataLabels?: DataLabelOptions;
  VisualPalette?: VisualPalette;
  ColorConfiguration?: WaterfallChartColorConfiguration;
  Interactions?: VisualInteractionOptions;
}
export const WaterfallChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(WaterfallChartFieldWells),
    SortConfiguration: S.optional(WaterfallChartSortConfiguration),
    WaterfallChartOptions: S.optional(WaterfallChartOptions),
    CategoryAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    CategoryAxisDisplayOptions: S.optional(AxisDisplayOptions),
    PrimaryYAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    PrimaryYAxisDisplayOptions: S.optional(AxisDisplayOptions),
    Legend: S.optional(LegendOptions),
    DataLabels: S.optional(DataLabelOptions),
    VisualPalette: S.optional(VisualPalette),
    ColorConfiguration: S.optional(WaterfallChartColorConfiguration),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "WaterfallChartConfiguration",
}) as any as S.Schema<WaterfallChartConfiguration>;
export interface WaterfallVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: WaterfallChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const WaterfallVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(WaterfallChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "WaterfallVisual",
}) as any as S.Schema<WaterfallVisual>;
export type HistogramMeasureFieldList = MeasureField[];
export const HistogramMeasureFieldList = S.Array(MeasureField);
export interface HistogramAggregatedFieldWells {
  Values?: MeasureField[];
}
export const HistogramAggregatedFieldWells = S.suspend(() =>
  S.Struct({ Values: S.optional(HistogramMeasureFieldList) }),
).annotations({
  identifier: "HistogramAggregatedFieldWells",
}) as any as S.Schema<HistogramAggregatedFieldWells>;
export interface HistogramFieldWells {
  HistogramAggregatedFieldWells?: HistogramAggregatedFieldWells;
}
export const HistogramFieldWells = S.suspend(() =>
  S.Struct({
    HistogramAggregatedFieldWells: S.optional(HistogramAggregatedFieldWells),
  }),
).annotations({
  identifier: "HistogramFieldWells",
}) as any as S.Schema<HistogramFieldWells>;
export type HistogramBinType = "BIN_COUNT" | "BIN_WIDTH";
export const HistogramBinType = S.Literal("BIN_COUNT", "BIN_WIDTH");
export interface BinCountOptions {
  Value?: number;
}
export const BinCountOptions = S.suspend(() =>
  S.Struct({ Value: S.optional(S.Number) }),
).annotations({
  identifier: "BinCountOptions",
}) as any as S.Schema<BinCountOptions>;
export interface BinWidthOptions {
  Value?: number;
  BinCountLimit?: number;
}
export const BinWidthOptions = S.suspend(() =>
  S.Struct({
    Value: S.optional(S.Number),
    BinCountLimit: S.optional(S.Number),
  }),
).annotations({
  identifier: "BinWidthOptions",
}) as any as S.Schema<BinWidthOptions>;
export interface HistogramBinOptions {
  SelectedBinType?: HistogramBinType;
  BinCount?: BinCountOptions;
  BinWidth?: BinWidthOptions;
  StartValue?: number;
}
export const HistogramBinOptions = S.suspend(() =>
  S.Struct({
    SelectedBinType: S.optional(HistogramBinType),
    BinCount: S.optional(BinCountOptions),
    BinWidth: S.optional(BinWidthOptions),
    StartValue: S.optional(S.Number),
  }),
).annotations({
  identifier: "HistogramBinOptions",
}) as any as S.Schema<HistogramBinOptions>;
export interface HistogramConfiguration {
  FieldWells?: HistogramFieldWells;
  XAxisDisplayOptions?: AxisDisplayOptions;
  XAxisLabelOptions?: ChartAxisLabelOptions;
  YAxisDisplayOptions?: AxisDisplayOptions;
  BinOptions?: HistogramBinOptions;
  DataLabels?: DataLabelOptions;
  Tooltip?: TooltipOptions;
  VisualPalette?: VisualPalette;
  Interactions?: VisualInteractionOptions;
}
export const HistogramConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(HistogramFieldWells),
    XAxisDisplayOptions: S.optional(AxisDisplayOptions),
    XAxisLabelOptions: S.optional(ChartAxisLabelOptions),
    YAxisDisplayOptions: S.optional(AxisDisplayOptions),
    BinOptions: S.optional(HistogramBinOptions),
    DataLabels: S.optional(DataLabelOptions),
    Tooltip: S.optional(TooltipOptions),
    VisualPalette: S.optional(VisualPalette),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "HistogramConfiguration",
}) as any as S.Schema<HistogramConfiguration>;
export interface HistogramVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: HistogramConfiguration;
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
}
export const HistogramVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(HistogramConfiguration),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "HistogramVisual",
}) as any as S.Schema<HistogramVisual>;
export type WordCloudDimensionFieldList = DimensionField[];
export const WordCloudDimensionFieldList = S.Array(DimensionField);
export type WordCloudMeasureFieldList = MeasureField[];
export const WordCloudMeasureFieldList = S.Array(MeasureField);
export interface WordCloudAggregatedFieldWells {
  GroupBy?: DimensionField[];
  Size?: MeasureField[];
}
export const WordCloudAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    GroupBy: S.optional(WordCloudDimensionFieldList),
    Size: S.optional(WordCloudMeasureFieldList),
  }),
).annotations({
  identifier: "WordCloudAggregatedFieldWells",
}) as any as S.Schema<WordCloudAggregatedFieldWells>;
export interface WordCloudFieldWells {
  WordCloudAggregatedFieldWells?: WordCloudAggregatedFieldWells;
}
export const WordCloudFieldWells = S.suspend(() =>
  S.Struct({
    WordCloudAggregatedFieldWells: S.optional(WordCloudAggregatedFieldWells),
  }),
).annotations({
  identifier: "WordCloudFieldWells",
}) as any as S.Schema<WordCloudFieldWells>;
export interface WordCloudSortConfiguration {
  CategoryItemsLimit?: ItemsLimitConfiguration;
  CategorySort?: FieldSortOptions[];
}
export const WordCloudSortConfiguration = S.suspend(() =>
  S.Struct({
    CategoryItemsLimit: S.optional(ItemsLimitConfiguration),
    CategorySort: S.optional(FieldSortOptionsList),
  }),
).annotations({
  identifier: "WordCloudSortConfiguration",
}) as any as S.Schema<WordCloudSortConfiguration>;
export type WordCloudWordOrientation = "HORIZONTAL" | "HORIZONTAL_AND_VERTICAL";
export const WordCloudWordOrientation = S.Literal(
  "HORIZONTAL",
  "HORIZONTAL_AND_VERTICAL",
);
export type WordCloudWordScaling = "EMPHASIZE" | "NORMAL";
export const WordCloudWordScaling = S.Literal("EMPHASIZE", "NORMAL");
export type WordCloudCloudLayout = "FLUID" | "NORMAL";
export const WordCloudCloudLayout = S.Literal("FLUID", "NORMAL");
export type WordCloudWordCasing = "LOWER_CASE" | "EXISTING_CASE";
export const WordCloudWordCasing = S.Literal("LOWER_CASE", "EXISTING_CASE");
export type WordCloudWordPadding = "NONE" | "SMALL" | "MEDIUM" | "LARGE";
export const WordCloudWordPadding = S.Literal(
  "NONE",
  "SMALL",
  "MEDIUM",
  "LARGE",
);
export interface WordCloudOptions {
  WordOrientation?: WordCloudWordOrientation;
  WordScaling?: WordCloudWordScaling;
  CloudLayout?: WordCloudCloudLayout;
  WordCasing?: WordCloudWordCasing;
  WordPadding?: WordCloudWordPadding;
  MaximumStringLength?: number;
}
export const WordCloudOptions = S.suspend(() =>
  S.Struct({
    WordOrientation: S.optional(WordCloudWordOrientation),
    WordScaling: S.optional(WordCloudWordScaling),
    CloudLayout: S.optional(WordCloudCloudLayout),
    WordCasing: S.optional(WordCloudWordCasing),
    WordPadding: S.optional(WordCloudWordPadding),
    MaximumStringLength: S.optional(S.Number),
  }),
).annotations({
  identifier: "WordCloudOptions",
}) as any as S.Schema<WordCloudOptions>;
export interface WordCloudChartConfiguration {
  FieldWells?: WordCloudFieldWells;
  SortConfiguration?: WordCloudSortConfiguration;
  CategoryLabelOptions?: ChartAxisLabelOptions;
  WordCloudOptions?: WordCloudOptions;
  Interactions?: VisualInteractionOptions;
}
export const WordCloudChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(WordCloudFieldWells),
    SortConfiguration: S.optional(WordCloudSortConfiguration),
    CategoryLabelOptions: S.optional(ChartAxisLabelOptions),
    WordCloudOptions: S.optional(WordCloudOptions),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "WordCloudChartConfiguration",
}) as any as S.Schema<WordCloudChartConfiguration>;
export interface WordCloudVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: WordCloudChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const WordCloudVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(WordCloudChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "WordCloudVisual",
}) as any as S.Schema<WordCloudVisual>;
export type TopBottomComputationType = "TOP" | "BOTTOM";
export const TopBottomComputationType = S.Literal("TOP", "BOTTOM");
export interface TopBottomRankedComputation {
  ComputationId: string;
  Name?: string;
  Category?: DimensionField;
  Value?: MeasureField;
  ResultSize?: number;
  Type: TopBottomComputationType;
}
export const TopBottomRankedComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Category: S.optional(DimensionField),
    Value: S.optional(MeasureField),
    ResultSize: S.optional(S.Number),
    Type: TopBottomComputationType,
  }),
).annotations({
  identifier: "TopBottomRankedComputation",
}) as any as S.Schema<TopBottomRankedComputation>;
export type TopBottomSortOrder = "PERCENT_DIFFERENCE" | "ABSOLUTE_DIFFERENCE";
export const TopBottomSortOrder = S.Literal(
  "PERCENT_DIFFERENCE",
  "ABSOLUTE_DIFFERENCE",
);
export interface TopBottomMoversComputation {
  ComputationId: string;
  Name?: string;
  Time?: DimensionField;
  Category?: DimensionField;
  Value?: MeasureField;
  MoverSize?: number;
  SortOrder?: TopBottomSortOrder;
  Type: TopBottomComputationType;
}
export const TopBottomMoversComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Time: S.optional(DimensionField),
    Category: S.optional(DimensionField),
    Value: S.optional(MeasureField),
    MoverSize: S.optional(S.Number),
    SortOrder: S.optional(TopBottomSortOrder),
    Type: TopBottomComputationType,
  }),
).annotations({
  identifier: "TopBottomMoversComputation",
}) as any as S.Schema<TopBottomMoversComputation>;
export interface TotalAggregationComputation {
  ComputationId: string;
  Name?: string;
  Value?: MeasureField;
}
export const TotalAggregationComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Value: S.optional(MeasureField),
  }),
).annotations({
  identifier: "TotalAggregationComputation",
}) as any as S.Schema<TotalAggregationComputation>;
export type MaximumMinimumComputationType = "MAXIMUM" | "MINIMUM";
export const MaximumMinimumComputationType = S.Literal("MAXIMUM", "MINIMUM");
export interface MaximumMinimumComputation {
  ComputationId: string;
  Name?: string;
  Time?: DimensionField;
  Value?: MeasureField;
  Type: MaximumMinimumComputationType;
}
export const MaximumMinimumComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Time: S.optional(DimensionField),
    Value: S.optional(MeasureField),
    Type: MaximumMinimumComputationType,
  }),
).annotations({
  identifier: "MaximumMinimumComputation",
}) as any as S.Schema<MaximumMinimumComputation>;
export interface MetricComparisonComputation {
  ComputationId: string;
  Name?: string;
  Time?: DimensionField;
  FromValue?: MeasureField;
  TargetValue?: MeasureField;
}
export const MetricComparisonComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Time: S.optional(DimensionField),
    FromValue: S.optional(MeasureField),
    TargetValue: S.optional(MeasureField),
  }),
).annotations({
  identifier: "MetricComparisonComputation",
}) as any as S.Schema<MetricComparisonComputation>;
export interface PeriodOverPeriodComputation {
  ComputationId: string;
  Name?: string;
  Time?: DimensionField;
  Value?: MeasureField;
}
export const PeriodOverPeriodComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Time: S.optional(DimensionField),
    Value: S.optional(MeasureField),
  }),
).annotations({
  identifier: "PeriodOverPeriodComputation",
}) as any as S.Schema<PeriodOverPeriodComputation>;
export interface PeriodToDateComputation {
  ComputationId: string;
  Name?: string;
  Time?: DimensionField;
  Value?: MeasureField;
  PeriodTimeGranularity?: TimeGranularity;
}
export const PeriodToDateComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Time: S.optional(DimensionField),
    Value: S.optional(MeasureField),
    PeriodTimeGranularity: S.optional(TimeGranularity),
  }),
).annotations({
  identifier: "PeriodToDateComputation",
}) as any as S.Schema<PeriodToDateComputation>;
export interface GrowthRateComputation {
  ComputationId: string;
  Name?: string;
  Time?: DimensionField;
  Value?: MeasureField;
  PeriodSize?: number;
}
export const GrowthRateComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Time: S.optional(DimensionField),
    Value: S.optional(MeasureField),
    PeriodSize: S.optional(S.Number),
  }),
).annotations({
  identifier: "GrowthRateComputation",
}) as any as S.Schema<GrowthRateComputation>;
export interface UniqueValuesComputation {
  ComputationId: string;
  Name?: string;
  Category?: DimensionField;
}
export const UniqueValuesComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Category: S.optional(DimensionField),
  }),
).annotations({
  identifier: "UniqueValuesComputation",
}) as any as S.Schema<UniqueValuesComputation>;
export type ForecastComputationSeasonality = "AUTOMATIC" | "CUSTOM";
export const ForecastComputationSeasonality = S.Literal("AUTOMATIC", "CUSTOM");
export interface ForecastComputation {
  ComputationId: string;
  Name?: string;
  Time?: DimensionField;
  Value?: MeasureField;
  PeriodsForward?: number;
  PeriodsBackward?: number;
  UpperBoundary?: number;
  LowerBoundary?: number;
  PredictionInterval?: number;
  Seasonality?: ForecastComputationSeasonality;
  CustomSeasonalityValue?: number;
}
export const ForecastComputation = S.suspend(() =>
  S.Struct({
    ComputationId: S.String,
    Name: S.optional(S.String),
    Time: S.optional(DimensionField),
    Value: S.optional(MeasureField),
    PeriodsForward: S.optional(S.Number),
    PeriodsBackward: S.optional(S.Number),
    UpperBoundary: S.optional(S.Number),
    LowerBoundary: S.optional(S.Number),
    PredictionInterval: S.optional(S.Number),
    Seasonality: S.optional(ForecastComputationSeasonality),
    CustomSeasonalityValue: S.optional(S.Number),
  }),
).annotations({
  identifier: "ForecastComputation",
}) as any as S.Schema<ForecastComputation>;
export interface Computation {
  TopBottomRanked?: TopBottomRankedComputation;
  TopBottomMovers?: TopBottomMoversComputation;
  TotalAggregation?: TotalAggregationComputation;
  MaximumMinimum?: MaximumMinimumComputation;
  MetricComparison?: MetricComparisonComputation;
  PeriodOverPeriod?: PeriodOverPeriodComputation;
  PeriodToDate?: PeriodToDateComputation;
  GrowthRate?: GrowthRateComputation;
  UniqueValues?: UniqueValuesComputation;
  Forecast?: ForecastComputation;
}
export const Computation = S.suspend(() =>
  S.Struct({
    TopBottomRanked: S.optional(TopBottomRankedComputation),
    TopBottomMovers: S.optional(TopBottomMoversComputation),
    TotalAggregation: S.optional(TotalAggregationComputation),
    MaximumMinimum: S.optional(MaximumMinimumComputation),
    MetricComparison: S.optional(MetricComparisonComputation),
    PeriodOverPeriod: S.optional(PeriodOverPeriodComputation),
    PeriodToDate: S.optional(PeriodToDateComputation),
    GrowthRate: S.optional(GrowthRateComputation),
    UniqueValues: S.optional(UniqueValuesComputation),
    Forecast: S.optional(ForecastComputation),
  }),
).annotations({ identifier: "Computation" }) as any as S.Schema<Computation>;
export type ComputationList = Computation[];
export const ComputationList = S.Array(Computation);
export interface CustomNarrativeOptions {
  Narrative: string;
}
export const CustomNarrativeOptions = S.suspend(() =>
  S.Struct({ Narrative: S.String }),
).annotations({
  identifier: "CustomNarrativeOptions",
}) as any as S.Schema<CustomNarrativeOptions>;
export interface InsightConfiguration {
  Computations?: Computation[];
  CustomNarrative?: CustomNarrativeOptions;
  Interactions?: VisualInteractionOptions;
}
export const InsightConfiguration = S.suspend(() =>
  S.Struct({
    Computations: S.optional(ComputationList),
    CustomNarrative: S.optional(CustomNarrativeOptions),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "InsightConfiguration",
}) as any as S.Schema<InsightConfiguration>;
export interface InsightVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  InsightConfiguration?: InsightConfiguration;
  Actions?: VisualCustomAction[];
  DataSetIdentifier: string;
  VisualContentAltText?: string;
}
export const InsightVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    InsightConfiguration: S.optional(InsightConfiguration),
    Actions: S.optional(VisualCustomActionList),
    DataSetIdentifier: S.String,
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "InsightVisual",
}) as any as S.Schema<InsightVisual>;
export interface SankeyDiagramAggregatedFieldWells {
  Source?: DimensionField[];
  Destination?: DimensionField[];
  Weight?: MeasureField[];
}
export const SankeyDiagramAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Source: S.optional(DimensionFieldList),
    Destination: S.optional(DimensionFieldList),
    Weight: S.optional(MeasureFieldList),
  }),
).annotations({
  identifier: "SankeyDiagramAggregatedFieldWells",
}) as any as S.Schema<SankeyDiagramAggregatedFieldWells>;
export interface SankeyDiagramFieldWells {
  SankeyDiagramAggregatedFieldWells?: SankeyDiagramAggregatedFieldWells;
}
export const SankeyDiagramFieldWells = S.suspend(() =>
  S.Struct({
    SankeyDiagramAggregatedFieldWells: S.optional(
      SankeyDiagramAggregatedFieldWells,
    ),
  }),
).annotations({
  identifier: "SankeyDiagramFieldWells",
}) as any as S.Schema<SankeyDiagramFieldWells>;
export interface SankeyDiagramSortConfiguration {
  WeightSort?: FieldSortOptions[];
  SourceItemsLimit?: ItemsLimitConfiguration;
  DestinationItemsLimit?: ItemsLimitConfiguration;
}
export const SankeyDiagramSortConfiguration = S.suspend(() =>
  S.Struct({
    WeightSort: S.optional(FieldSortOptionsList),
    SourceItemsLimit: S.optional(ItemsLimitConfiguration),
    DestinationItemsLimit: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "SankeyDiagramSortConfiguration",
}) as any as S.Schema<SankeyDiagramSortConfiguration>;
export interface SankeyDiagramChartConfiguration {
  FieldWells?: SankeyDiagramFieldWells;
  SortConfiguration?: SankeyDiagramSortConfiguration;
  DataLabels?: DataLabelOptions;
  Interactions?: VisualInteractionOptions;
}
export const SankeyDiagramChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(SankeyDiagramFieldWells),
    SortConfiguration: S.optional(SankeyDiagramSortConfiguration),
    DataLabels: S.optional(DataLabelOptions),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "SankeyDiagramChartConfiguration",
}) as any as S.Schema<SankeyDiagramChartConfiguration>;
export interface SankeyDiagramVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: SankeyDiagramChartConfiguration;
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
}
export const SankeyDiagramVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(SankeyDiagramChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "SankeyDiagramVisual",
}) as any as S.Schema<SankeyDiagramVisual>;
export type CustomContentType = "IMAGE" | "OTHER_EMBEDDED_CONTENT";
export const CustomContentType = S.Literal("IMAGE", "OTHER_EMBEDDED_CONTENT");
export type CustomContentImageScalingConfiguration =
  | "FIT_TO_HEIGHT"
  | "FIT_TO_WIDTH"
  | "DO_NOT_SCALE"
  | "SCALE_TO_VISUAL";
export const CustomContentImageScalingConfiguration = S.Literal(
  "FIT_TO_HEIGHT",
  "FIT_TO_WIDTH",
  "DO_NOT_SCALE",
  "SCALE_TO_VISUAL",
);
export interface CustomContentConfiguration {
  ContentUrl?: string;
  ContentType?: CustomContentType;
  ImageScaling?: CustomContentImageScalingConfiguration;
  Interactions?: VisualInteractionOptions;
}
export const CustomContentConfiguration = S.suspend(() =>
  S.Struct({
    ContentUrl: S.optional(S.String),
    ContentType: S.optional(CustomContentType),
    ImageScaling: S.optional(CustomContentImageScalingConfiguration),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "CustomContentConfiguration",
}) as any as S.Schema<CustomContentConfiguration>;
export interface CustomContentVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: CustomContentConfiguration;
  Actions?: VisualCustomAction[];
  DataSetIdentifier: string;
  VisualContentAltText?: string;
}
export const CustomContentVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(CustomContentConfiguration),
    Actions: S.optional(VisualCustomActionList),
    DataSetIdentifier: S.String,
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "CustomContentVisual",
}) as any as S.Schema<CustomContentVisual>;
export interface EmptyVisual {
  VisualId: string;
  DataSetIdentifier: string;
  Actions?: VisualCustomAction[];
}
export const EmptyVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    DataSetIdentifier: S.String,
    Actions: S.optional(VisualCustomActionList),
  }),
).annotations({ identifier: "EmptyVisual" }) as any as S.Schema<EmptyVisual>;
export type RadarChartCategoryFieldList = DimensionField[];
export const RadarChartCategoryFieldList = S.Array(DimensionField);
export type RadarChartColorFieldList = DimensionField[];
export const RadarChartColorFieldList = S.Array(DimensionField);
export type RadarChartValuesFieldList = MeasureField[];
export const RadarChartValuesFieldList = S.Array(MeasureField);
export interface RadarChartAggregatedFieldWells {
  Category?: DimensionField[];
  Color?: DimensionField[];
  Values?: MeasureField[];
}
export const RadarChartAggregatedFieldWells = S.suspend(() =>
  S.Struct({
    Category: S.optional(RadarChartCategoryFieldList),
    Color: S.optional(RadarChartColorFieldList),
    Values: S.optional(RadarChartValuesFieldList),
  }),
).annotations({
  identifier: "RadarChartAggregatedFieldWells",
}) as any as S.Schema<RadarChartAggregatedFieldWells>;
export interface RadarChartFieldWells {
  RadarChartAggregatedFieldWells?: RadarChartAggregatedFieldWells;
}
export const RadarChartFieldWells = S.suspend(() =>
  S.Struct({
    RadarChartAggregatedFieldWells: S.optional(RadarChartAggregatedFieldWells),
  }),
).annotations({
  identifier: "RadarChartFieldWells",
}) as any as S.Schema<RadarChartFieldWells>;
export interface RadarChartSortConfiguration {
  CategorySort?: FieldSortOptions[];
  CategoryItemsLimit?: ItemsLimitConfiguration;
  ColorSort?: FieldSortOptions[];
  ColorItemsLimit?: ItemsLimitConfiguration;
}
export const RadarChartSortConfiguration = S.suspend(() =>
  S.Struct({
    CategorySort: S.optional(FieldSortOptionsList),
    CategoryItemsLimit: S.optional(ItemsLimitConfiguration),
    ColorSort: S.optional(FieldSortOptionsList),
    ColorItemsLimit: S.optional(ItemsLimitConfiguration),
  }),
).annotations({
  identifier: "RadarChartSortConfiguration",
}) as any as S.Schema<RadarChartSortConfiguration>;
export type RadarChartShape = "CIRCLE" | "POLYGON";
export const RadarChartShape = S.Literal("CIRCLE", "POLYGON");
export interface RadarChartAreaStyleSettings {
  Visibility?: Visibility;
}
export const RadarChartAreaStyleSettings = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "RadarChartAreaStyleSettings",
}) as any as S.Schema<RadarChartAreaStyleSettings>;
export interface RadarChartSeriesSettings {
  AreaStyleSettings?: RadarChartAreaStyleSettings;
}
export const RadarChartSeriesSettings = S.suspend(() =>
  S.Struct({ AreaStyleSettings: S.optional(RadarChartAreaStyleSettings) }),
).annotations({
  identifier: "RadarChartSeriesSettings",
}) as any as S.Schema<RadarChartSeriesSettings>;
export type RadarChartAxesRangeScale = "AUTO" | "INDEPENDENT" | "SHARED";
export const RadarChartAxesRangeScale = S.Literal(
  "AUTO",
  "INDEPENDENT",
  "SHARED",
);
export interface RadarChartConfiguration {
  FieldWells?: RadarChartFieldWells;
  SortConfiguration?: RadarChartSortConfiguration;
  Shape?: RadarChartShape;
  BaseSeriesSettings?: RadarChartSeriesSettings;
  StartAngle?: number;
  VisualPalette?: VisualPalette;
  AlternateBandColorsVisibility?: Visibility;
  AlternateBandEvenColor?: string;
  AlternateBandOddColor?: string;
  CategoryAxis?: AxisDisplayOptions;
  CategoryLabelOptions?: ChartAxisLabelOptions;
  ColorAxis?: AxisDisplayOptions;
  ColorLabelOptions?: ChartAxisLabelOptions;
  Legend?: LegendOptions;
  AxesRangeScale?: RadarChartAxesRangeScale;
  Interactions?: VisualInteractionOptions;
}
export const RadarChartConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(RadarChartFieldWells),
    SortConfiguration: S.optional(RadarChartSortConfiguration),
    Shape: S.optional(RadarChartShape),
    BaseSeriesSettings: S.optional(RadarChartSeriesSettings),
    StartAngle: S.optional(S.Number),
    VisualPalette: S.optional(VisualPalette),
    AlternateBandColorsVisibility: S.optional(Visibility),
    AlternateBandEvenColor: S.optional(S.String),
    AlternateBandOddColor: S.optional(S.String),
    CategoryAxis: S.optional(AxisDisplayOptions),
    CategoryLabelOptions: S.optional(ChartAxisLabelOptions),
    ColorAxis: S.optional(AxisDisplayOptions),
    ColorLabelOptions: S.optional(ChartAxisLabelOptions),
    Legend: S.optional(LegendOptions),
    AxesRangeScale: S.optional(RadarChartAxesRangeScale),
    Interactions: S.optional(VisualInteractionOptions),
  }),
).annotations({
  identifier: "RadarChartConfiguration",
}) as any as S.Schema<RadarChartConfiguration>;
export interface RadarChartVisual {
  VisualId: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: RadarChartConfiguration;
  Actions?: VisualCustomAction[];
  ColumnHierarchies?: ColumnHierarchy[];
  VisualContentAltText?: string;
}
export const RadarChartVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(RadarChartConfiguration),
    Actions: S.optional(VisualCustomActionList),
    ColumnHierarchies: S.optional(ColumnHierarchyList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({
  identifier: "RadarChartVisual",
}) as any as S.Schema<RadarChartVisual>;
export type PluginVisualAxisName = "GROUP_BY" | "VALUE";
export const PluginVisualAxisName = S.Literal("GROUP_BY", "VALUE");
export type UnaggregatedFieldList = UnaggregatedField[];
export const UnaggregatedFieldList = S.Array(UnaggregatedField);
export interface PluginVisualFieldWell {
  AxisName?: PluginVisualAxisName;
  Dimensions?: DimensionField[];
  Measures?: MeasureField[];
  Unaggregated?: UnaggregatedField[];
}
export const PluginVisualFieldWell = S.suspend(() =>
  S.Struct({
    AxisName: S.optional(PluginVisualAxisName),
    Dimensions: S.optional(DimensionFieldList),
    Measures: S.optional(MeasureFieldList),
    Unaggregated: S.optional(UnaggregatedFieldList),
  }),
).annotations({
  identifier: "PluginVisualFieldWell",
}) as any as S.Schema<PluginVisualFieldWell>;
export type PluginVisualFieldWells = PluginVisualFieldWell[];
export const PluginVisualFieldWells = S.Array(PluginVisualFieldWell);
export interface PluginVisualProperty {
  Name?: string;
  Value?: string;
}
export const PluginVisualProperty = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Value: S.optional(S.String) }),
).annotations({
  identifier: "PluginVisualProperty",
}) as any as S.Schema<PluginVisualProperty>;
export type PluginVisualPropertiesList = PluginVisualProperty[];
export const PluginVisualPropertiesList = S.Array(PluginVisualProperty);
export interface PluginVisualOptions {
  VisualProperties?: PluginVisualProperty[];
}
export const PluginVisualOptions = S.suspend(() =>
  S.Struct({ VisualProperties: S.optional(PluginVisualPropertiesList) }),
).annotations({
  identifier: "PluginVisualOptions",
}) as any as S.Schema<PluginVisualOptions>;
export interface PluginVisualItemsLimitConfiguration {
  ItemsLimit?: number;
}
export const PluginVisualItemsLimitConfiguration = S.suspend(() =>
  S.Struct({ ItemsLimit: S.optional(S.Number) }),
).annotations({
  identifier: "PluginVisualItemsLimitConfiguration",
}) as any as S.Schema<PluginVisualItemsLimitConfiguration>;
export interface PluginVisualTableQuerySort {
  RowSort?: FieldSortOptions[];
  ItemsLimitConfiguration?: PluginVisualItemsLimitConfiguration;
}
export const PluginVisualTableQuerySort = S.suspend(() =>
  S.Struct({
    RowSort: S.optional(RowSortList),
    ItemsLimitConfiguration: S.optional(PluginVisualItemsLimitConfiguration),
  }),
).annotations({
  identifier: "PluginVisualTableQuerySort",
}) as any as S.Schema<PluginVisualTableQuerySort>;
export interface PluginVisualSortConfiguration {
  PluginVisualTableQuerySort?: PluginVisualTableQuerySort;
}
export const PluginVisualSortConfiguration = S.suspend(() =>
  S.Struct({
    PluginVisualTableQuerySort: S.optional(PluginVisualTableQuerySort),
  }),
).annotations({
  identifier: "PluginVisualSortConfiguration",
}) as any as S.Schema<PluginVisualSortConfiguration>;
export interface PluginVisualConfiguration {
  FieldWells?: PluginVisualFieldWell[];
  VisualOptions?: PluginVisualOptions;
  SortConfiguration?: PluginVisualSortConfiguration;
}
export const PluginVisualConfiguration = S.suspend(() =>
  S.Struct({
    FieldWells: S.optional(PluginVisualFieldWells),
    VisualOptions: S.optional(PluginVisualOptions),
    SortConfiguration: S.optional(PluginVisualSortConfiguration),
  }),
).annotations({
  identifier: "PluginVisualConfiguration",
}) as any as S.Schema<PluginVisualConfiguration>;
export interface PluginVisual {
  VisualId: string;
  PluginArn: string;
  Title?: VisualTitleLabelOptions;
  Subtitle?: VisualSubtitleLabelOptions;
  ChartConfiguration?: PluginVisualConfiguration;
  Actions?: VisualCustomAction[];
  VisualContentAltText?: string;
}
export const PluginVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.String,
    PluginArn: S.String,
    Title: S.optional(VisualTitleLabelOptions),
    Subtitle: S.optional(VisualSubtitleLabelOptions),
    ChartConfiguration: S.optional(PluginVisualConfiguration),
    Actions: S.optional(VisualCustomActionList),
    VisualContentAltText: S.optional(S.String),
  }),
).annotations({ identifier: "PluginVisual" }) as any as S.Schema<PluginVisual>;
export interface Visual {
  TableVisual?: TableVisual;
  PivotTableVisual?: PivotTableVisual;
  BarChartVisual?: BarChartVisual;
  KPIVisual?: KPIVisual;
  PieChartVisual?: PieChartVisual;
  GaugeChartVisual?: GaugeChartVisual;
  LineChartVisual?: LineChartVisual;
  HeatMapVisual?: HeatMapVisual;
  TreeMapVisual?: TreeMapVisual;
  GeospatialMapVisual?: GeospatialMapVisual;
  FilledMapVisual?: FilledMapVisual;
  LayerMapVisual?: LayerMapVisual;
  FunnelChartVisual?: FunnelChartVisual;
  ScatterPlotVisual?: ScatterPlotVisual;
  ComboChartVisual?: ComboChartVisual;
  BoxPlotVisual?: BoxPlotVisual;
  WaterfallVisual?: WaterfallVisual;
  HistogramVisual?: HistogramVisual;
  WordCloudVisual?: WordCloudVisual;
  InsightVisual?: InsightVisual;
  SankeyDiagramVisual?: SankeyDiagramVisual;
  CustomContentVisual?: CustomContentVisual;
  EmptyVisual?: EmptyVisual;
  RadarChartVisual?: RadarChartVisual;
  PluginVisual?: PluginVisual;
}
export const Visual = S.suspend(() =>
  S.Struct({
    TableVisual: S.optional(TableVisual),
    PivotTableVisual: S.optional(PivotTableVisual),
    BarChartVisual: S.optional(BarChartVisual),
    KPIVisual: S.optional(KPIVisual),
    PieChartVisual: S.optional(PieChartVisual),
    GaugeChartVisual: S.optional(GaugeChartVisual),
    LineChartVisual: S.optional(LineChartVisual),
    HeatMapVisual: S.optional(HeatMapVisual),
    TreeMapVisual: S.optional(TreeMapVisual),
    GeospatialMapVisual: S.optional(GeospatialMapVisual),
    FilledMapVisual: S.optional(FilledMapVisual),
    LayerMapVisual: S.optional(LayerMapVisual),
    FunnelChartVisual: S.optional(FunnelChartVisual),
    ScatterPlotVisual: S.optional(ScatterPlotVisual),
    ComboChartVisual: S.optional(ComboChartVisual),
    BoxPlotVisual: S.optional(BoxPlotVisual),
    WaterfallVisual: S.optional(WaterfallVisual),
    HistogramVisual: S.optional(HistogramVisual),
    WordCloudVisual: S.optional(WordCloudVisual),
    InsightVisual: S.optional(InsightVisual),
    SankeyDiagramVisual: S.optional(SankeyDiagramVisual),
    CustomContentVisual: S.optional(CustomContentVisual),
    EmptyVisual: S.optional(EmptyVisual),
    RadarChartVisual: S.optional(RadarChartVisual),
    PluginVisual: S.optional(PluginVisual),
  }),
).annotations({ identifier: "Visual" }) as any as S.Schema<Visual>;
export type VisualList = Visual[];
export const VisualList = S.Array(Visual);
export interface TextBoxMenuOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const TextBoxMenuOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "TextBoxMenuOption",
}) as any as S.Schema<TextBoxMenuOption>;
export interface TextBoxInteractionOptions {
  TextBoxMenuOption?: TextBoxMenuOption;
}
export const TextBoxInteractionOptions = S.suspend(() =>
  S.Struct({ TextBoxMenuOption: S.optional(TextBoxMenuOption) }),
).annotations({
  identifier: "TextBoxInteractionOptions",
}) as any as S.Schema<TextBoxInteractionOptions>;
export interface SheetTextBox {
  SheetTextBoxId: string;
  Content?: string;
  Interactions?: TextBoxInteractionOptions;
}
export const SheetTextBox = S.suspend(() =>
  S.Struct({
    SheetTextBoxId: S.String,
    Content: S.optional(S.String),
    Interactions: S.optional(TextBoxInteractionOptions),
  }),
).annotations({ identifier: "SheetTextBox" }) as any as S.Schema<SheetTextBox>;
export type SheetTextBoxList = SheetTextBox[];
export const SheetTextBoxList = S.Array(SheetTextBox);
export interface SheetImageStaticFileSource {
  StaticFileId: string;
}
export const SheetImageStaticFileSource = S.suspend(() =>
  S.Struct({ StaticFileId: S.String }),
).annotations({
  identifier: "SheetImageStaticFileSource",
}) as any as S.Schema<SheetImageStaticFileSource>;
export interface SheetImageSource {
  SheetImageStaticFileSource?: SheetImageStaticFileSource;
}
export const SheetImageSource = S.suspend(() =>
  S.Struct({
    SheetImageStaticFileSource: S.optional(SheetImageStaticFileSource),
  }),
).annotations({
  identifier: "SheetImageSource",
}) as any as S.Schema<SheetImageSource>;
export type SheetImageScalingType =
  | "SCALE_TO_WIDTH"
  | "SCALE_TO_HEIGHT"
  | "SCALE_TO_CONTAINER"
  | "SCALE_NONE";
export const SheetImageScalingType = S.Literal(
  "SCALE_TO_WIDTH",
  "SCALE_TO_HEIGHT",
  "SCALE_TO_CONTAINER",
  "SCALE_NONE",
);
export interface SheetImageScalingConfiguration {
  ScalingType?: SheetImageScalingType;
}
export const SheetImageScalingConfiguration = S.suspend(() =>
  S.Struct({ ScalingType: S.optional(SheetImageScalingType) }),
).annotations({
  identifier: "SheetImageScalingConfiguration",
}) as any as S.Schema<SheetImageScalingConfiguration>;
export interface SheetImageTooltipText {
  PlainText?: string;
}
export const SheetImageTooltipText = S.suspend(() =>
  S.Struct({ PlainText: S.optional(S.String) }),
).annotations({
  identifier: "SheetImageTooltipText",
}) as any as S.Schema<SheetImageTooltipText>;
export interface SheetImageTooltipConfiguration {
  TooltipText?: SheetImageTooltipText;
  Visibility?: Visibility;
}
export const SheetImageTooltipConfiguration = S.suspend(() =>
  S.Struct({
    TooltipText: S.optional(SheetImageTooltipText),
    Visibility: S.optional(Visibility),
  }),
).annotations({
  identifier: "SheetImageTooltipConfiguration",
}) as any as S.Schema<SheetImageTooltipConfiguration>;
export interface ImageMenuOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const ImageMenuOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "ImageMenuOption",
}) as any as S.Schema<ImageMenuOption>;
export interface ImageInteractionOptions {
  ImageMenuOption?: ImageMenuOption;
}
export const ImageInteractionOptions = S.suspend(() =>
  S.Struct({ ImageMenuOption: S.optional(ImageMenuOption) }),
).annotations({
  identifier: "ImageInteractionOptions",
}) as any as S.Schema<ImageInteractionOptions>;
export type ImageCustomActionTrigger = "CLICK" | "MENU";
export const ImageCustomActionTrigger = S.Literal("CLICK", "MENU");
export interface ImageCustomActionOperation {
  NavigationOperation?: CustomActionNavigationOperation;
  URLOperation?: CustomActionURLOperation;
  SetParametersOperation?: CustomActionSetParametersOperation;
}
export const ImageCustomActionOperation = S.suspend(() =>
  S.Struct({
    NavigationOperation: S.optional(CustomActionNavigationOperation),
    URLOperation: S.optional(CustomActionURLOperation),
    SetParametersOperation: S.optional(CustomActionSetParametersOperation),
  }),
).annotations({
  identifier: "ImageCustomActionOperation",
}) as any as S.Schema<ImageCustomActionOperation>;
export type ImageCustomActionOperationList = ImageCustomActionOperation[];
export const ImageCustomActionOperationList = S.Array(
  ImageCustomActionOperation,
);
export interface ImageCustomAction {
  CustomActionId: string;
  Name: string;
  Status?: WidgetStatus;
  Trigger: ImageCustomActionTrigger;
  ActionOperations: ImageCustomActionOperation[];
}
export const ImageCustomAction = S.suspend(() =>
  S.Struct({
    CustomActionId: S.String,
    Name: S.String,
    Status: S.optional(WidgetStatus),
    Trigger: ImageCustomActionTrigger,
    ActionOperations: ImageCustomActionOperationList,
  }),
).annotations({
  identifier: "ImageCustomAction",
}) as any as S.Schema<ImageCustomAction>;
export type ImageCustomActionList = ImageCustomAction[];
export const ImageCustomActionList = S.Array(ImageCustomAction);
export interface SheetImage {
  SheetImageId: string;
  Source: SheetImageSource;
  Scaling?: SheetImageScalingConfiguration;
  Tooltip?: SheetImageTooltipConfiguration;
  ImageContentAltText?: string;
  Interactions?: ImageInteractionOptions;
  Actions?: ImageCustomAction[];
}
export const SheetImage = S.suspend(() =>
  S.Struct({
    SheetImageId: S.String,
    Source: SheetImageSource,
    Scaling: S.optional(SheetImageScalingConfiguration),
    Tooltip: S.optional(SheetImageTooltipConfiguration),
    ImageContentAltText: S.optional(S.String),
    Interactions: S.optional(ImageInteractionOptions),
    Actions: S.optional(ImageCustomActionList),
  }),
).annotations({ identifier: "SheetImage" }) as any as S.Schema<SheetImage>;
export type SheetImageList = SheetImage[];
export const SheetImageList = S.Array(SheetImage);
export type LayoutElementType =
  | "VISUAL"
  | "FILTER_CONTROL"
  | "PARAMETER_CONTROL"
  | "TEXT_BOX"
  | "IMAGE";
export const LayoutElementType = S.Literal(
  "VISUAL",
  "FILTER_CONTROL",
  "PARAMETER_CONTROL",
  "TEXT_BOX",
  "IMAGE",
);
export interface GridLayoutElementBorderStyle {
  Visibility?: Visibility;
  Color?: string;
  Width?: string;
}
export const GridLayoutElementBorderStyle = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    Color: S.optional(S.String),
    Width: S.optional(S.String),
  }),
).annotations({
  identifier: "GridLayoutElementBorderStyle",
}) as any as S.Schema<GridLayoutElementBorderStyle>;
export interface GridLayoutElementBackgroundStyle {
  Visibility?: Visibility;
  Color?: string;
}
export const GridLayoutElementBackgroundStyle = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility), Color: S.optional(S.String) }),
).annotations({
  identifier: "GridLayoutElementBackgroundStyle",
}) as any as S.Schema<GridLayoutElementBackgroundStyle>;
export interface LoadingAnimation {
  Visibility?: Visibility;
}
export const LoadingAnimation = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "LoadingAnimation",
}) as any as S.Schema<LoadingAnimation>;
export interface GridLayoutElement {
  ElementId: string;
  ElementType: LayoutElementType;
  ColumnIndex?: number;
  ColumnSpan: number;
  RowIndex?: number;
  RowSpan: number;
  BorderStyle?: GridLayoutElementBorderStyle;
  SelectedBorderStyle?: GridLayoutElementBorderStyle;
  BackgroundStyle?: GridLayoutElementBackgroundStyle;
  LoadingAnimation?: LoadingAnimation;
  BorderRadius?: string;
  Padding?: string;
}
export const GridLayoutElement = S.suspend(() =>
  S.Struct({
    ElementId: S.String,
    ElementType: LayoutElementType,
    ColumnIndex: S.optional(S.Number),
    ColumnSpan: S.Number,
    RowIndex: S.optional(S.Number),
    RowSpan: S.Number,
    BorderStyle: S.optional(GridLayoutElementBorderStyle),
    SelectedBorderStyle: S.optional(GridLayoutElementBorderStyle),
    BackgroundStyle: S.optional(GridLayoutElementBackgroundStyle),
    LoadingAnimation: S.optional(LoadingAnimation),
    BorderRadius: S.optional(S.String),
    Padding: S.optional(S.String),
  }),
).annotations({
  identifier: "GridLayoutElement",
}) as any as S.Schema<GridLayoutElement>;
export type GridLayoutElementList = GridLayoutElement[];
export const GridLayoutElementList = S.Array(GridLayoutElement);
export type ResizeOption = "FIXED" | "RESPONSIVE";
export const ResizeOption = S.Literal("FIXED", "RESPONSIVE");
export interface GridLayoutScreenCanvasSizeOptions {
  ResizeOption: ResizeOption;
  OptimizedViewPortWidth?: string;
}
export const GridLayoutScreenCanvasSizeOptions = S.suspend(() =>
  S.Struct({
    ResizeOption: ResizeOption,
    OptimizedViewPortWidth: S.optional(S.String),
  }),
).annotations({
  identifier: "GridLayoutScreenCanvasSizeOptions",
}) as any as S.Schema<GridLayoutScreenCanvasSizeOptions>;
export interface GridLayoutCanvasSizeOptions {
  ScreenCanvasSizeOptions?: GridLayoutScreenCanvasSizeOptions;
}
export const GridLayoutCanvasSizeOptions = S.suspend(() =>
  S.Struct({
    ScreenCanvasSizeOptions: S.optional(GridLayoutScreenCanvasSizeOptions),
  }),
).annotations({
  identifier: "GridLayoutCanvasSizeOptions",
}) as any as S.Schema<GridLayoutCanvasSizeOptions>;
export interface GridLayoutConfiguration {
  Elements: GridLayoutElement[];
  CanvasSizeOptions?: GridLayoutCanvasSizeOptions;
}
export const GridLayoutConfiguration = S.suspend(() =>
  S.Struct({
    Elements: GridLayoutElementList,
    CanvasSizeOptions: S.optional(GridLayoutCanvasSizeOptions),
  }),
).annotations({
  identifier: "GridLayoutConfiguration",
}) as any as S.Schema<GridLayoutConfiguration>;
export interface SheetElementConfigurationOverrides {
  Visibility?: Visibility;
}
export const SheetElementConfigurationOverrides = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility) }),
).annotations({
  identifier: "SheetElementConfigurationOverrides",
}) as any as S.Schema<SheetElementConfigurationOverrides>;
export interface SheetElementRenderingRule {
  Expression: string | redacted.Redacted<string>;
  ConfigurationOverrides: SheetElementConfigurationOverrides;
}
export const SheetElementRenderingRule = S.suspend(() =>
  S.Struct({
    Expression: SensitiveString,
    ConfigurationOverrides: SheetElementConfigurationOverrides,
  }),
).annotations({
  identifier: "SheetElementRenderingRule",
}) as any as S.Schema<SheetElementRenderingRule>;
export type SheetElementRenderingRuleList = SheetElementRenderingRule[];
export const SheetElementRenderingRuleList = S.Array(SheetElementRenderingRule);
export interface FreeFormLayoutElementBorderStyle {
  Visibility?: Visibility;
  Color?: string;
  Width?: string;
}
export const FreeFormLayoutElementBorderStyle = S.suspend(() =>
  S.Struct({
    Visibility: S.optional(Visibility),
    Color: S.optional(S.String),
    Width: S.optional(S.String),
  }),
).annotations({
  identifier: "FreeFormLayoutElementBorderStyle",
}) as any as S.Schema<FreeFormLayoutElementBorderStyle>;
export interface FreeFormLayoutElementBackgroundStyle {
  Visibility?: Visibility;
  Color?: string;
}
export const FreeFormLayoutElementBackgroundStyle = S.suspend(() =>
  S.Struct({ Visibility: S.optional(Visibility), Color: S.optional(S.String) }),
).annotations({
  identifier: "FreeFormLayoutElementBackgroundStyle",
}) as any as S.Schema<FreeFormLayoutElementBackgroundStyle>;
export interface FreeFormLayoutElement {
  ElementId: string;
  ElementType: LayoutElementType;
  XAxisLocation: string;
  YAxisLocation: string;
  Width: string;
  Height: string;
  Visibility?: Visibility;
  RenderingRules?: SheetElementRenderingRule[];
  BorderStyle?: FreeFormLayoutElementBorderStyle;
  SelectedBorderStyle?: FreeFormLayoutElementBorderStyle;
  BackgroundStyle?: FreeFormLayoutElementBackgroundStyle;
  LoadingAnimation?: LoadingAnimation;
  BorderRadius?: string;
  Padding?: string;
}
export const FreeFormLayoutElement = S.suspend(() =>
  S.Struct({
    ElementId: S.String,
    ElementType: LayoutElementType,
    XAxisLocation: S.String,
    YAxisLocation: S.String,
    Width: S.String,
    Height: S.String,
    Visibility: S.optional(Visibility),
    RenderingRules: S.optional(SheetElementRenderingRuleList),
    BorderStyle: S.optional(FreeFormLayoutElementBorderStyle),
    SelectedBorderStyle: S.optional(FreeFormLayoutElementBorderStyle),
    BackgroundStyle: S.optional(FreeFormLayoutElementBackgroundStyle),
    LoadingAnimation: S.optional(LoadingAnimation),
    BorderRadius: S.optional(S.String),
    Padding: S.optional(S.String),
  }),
).annotations({
  identifier: "FreeFormLayoutElement",
}) as any as S.Schema<FreeFormLayoutElement>;
export type FreeFromLayoutElementList = FreeFormLayoutElement[];
export const FreeFromLayoutElementList = S.Array(FreeFormLayoutElement);
export interface FreeFormLayoutScreenCanvasSizeOptions {
  OptimizedViewPortWidth: string;
}
export const FreeFormLayoutScreenCanvasSizeOptions = S.suspend(() =>
  S.Struct({ OptimizedViewPortWidth: S.String }),
).annotations({
  identifier: "FreeFormLayoutScreenCanvasSizeOptions",
}) as any as S.Schema<FreeFormLayoutScreenCanvasSizeOptions>;
export interface FreeFormLayoutCanvasSizeOptions {
  ScreenCanvasSizeOptions?: FreeFormLayoutScreenCanvasSizeOptions;
}
export const FreeFormLayoutCanvasSizeOptions = S.suspend(() =>
  S.Struct({
    ScreenCanvasSizeOptions: S.optional(FreeFormLayoutScreenCanvasSizeOptions),
  }),
).annotations({
  identifier: "FreeFormLayoutCanvasSizeOptions",
}) as any as S.Schema<FreeFormLayoutCanvasSizeOptions>;
export interface FreeFormLayoutConfiguration {
  Elements: FreeFormLayoutElement[];
  CanvasSizeOptions?: FreeFormLayoutCanvasSizeOptions;
}
export const FreeFormLayoutConfiguration = S.suspend(() =>
  S.Struct({
    Elements: FreeFromLayoutElementList,
    CanvasSizeOptions: S.optional(FreeFormLayoutCanvasSizeOptions),
  }),
).annotations({
  identifier: "FreeFormLayoutConfiguration",
}) as any as S.Schema<FreeFormLayoutConfiguration>;
export interface FreeFormSectionLayoutConfiguration {
  Elements: FreeFormLayoutElement[];
}
export const FreeFormSectionLayoutConfiguration = S.suspend(() =>
  S.Struct({ Elements: FreeFromLayoutElementList }),
).annotations({
  identifier: "FreeFormSectionLayoutConfiguration",
}) as any as S.Schema<FreeFormSectionLayoutConfiguration>;
export interface SectionLayoutConfiguration {
  FreeFormLayout: FreeFormSectionLayoutConfiguration;
}
export const SectionLayoutConfiguration = S.suspend(() =>
  S.Struct({ FreeFormLayout: FreeFormSectionLayoutConfiguration }),
).annotations({
  identifier: "SectionLayoutConfiguration",
}) as any as S.Schema<SectionLayoutConfiguration>;
export interface Spacing {
  Top?: string;
  Bottom?: string;
  Left?: string;
  Right?: string;
}
export const Spacing = S.suspend(() =>
  S.Struct({
    Top: S.optional(S.String),
    Bottom: S.optional(S.String),
    Left: S.optional(S.String),
    Right: S.optional(S.String),
  }),
).annotations({ identifier: "Spacing" }) as any as S.Schema<Spacing>;
export interface SectionStyle {
  Height?: string;
  Padding?: Spacing;
}
export const SectionStyle = S.suspend(() =>
  S.Struct({ Height: S.optional(S.String), Padding: S.optional(Spacing) }),
).annotations({ identifier: "SectionStyle" }) as any as S.Schema<SectionStyle>;
export interface HeaderFooterSectionConfiguration {
  SectionId: string;
  Layout: SectionLayoutConfiguration;
  Style?: SectionStyle;
}
export const HeaderFooterSectionConfiguration = S.suspend(() =>
  S.Struct({
    SectionId: S.String,
    Layout: SectionLayoutConfiguration,
    Style: S.optional(SectionStyle),
  }),
).annotations({
  identifier: "HeaderFooterSectionConfiguration",
}) as any as S.Schema<HeaderFooterSectionConfiguration>;
export type HeaderFooterSectionConfigurationList =
  HeaderFooterSectionConfiguration[];
export const HeaderFooterSectionConfigurationList = S.Array(
  HeaderFooterSectionConfiguration,
);
export interface BodySectionContent {
  Layout?: SectionLayoutConfiguration;
}
export const BodySectionContent = S.suspend(() =>
  S.Struct({ Layout: S.optional(SectionLayoutConfiguration) }),
).annotations({
  identifier: "BodySectionContent",
}) as any as S.Schema<BodySectionContent>;
export type SectionPageBreakStatus = "ENABLED" | "DISABLED";
export const SectionPageBreakStatus = S.Literal("ENABLED", "DISABLED");
export interface SectionAfterPageBreak {
  Status?: SectionPageBreakStatus;
}
export const SectionAfterPageBreak = S.suspend(() =>
  S.Struct({ Status: S.optional(SectionPageBreakStatus) }),
).annotations({
  identifier: "SectionAfterPageBreak",
}) as any as S.Schema<SectionAfterPageBreak>;
export interface SectionPageBreakConfiguration {
  After?: SectionAfterPageBreak;
}
export const SectionPageBreakConfiguration = S.suspend(() =>
  S.Struct({ After: S.optional(SectionAfterPageBreak) }),
).annotations({
  identifier: "SectionPageBreakConfiguration",
}) as any as S.Schema<SectionPageBreakConfiguration>;
export type BodySectionDynamicDimensionSortConfigurationList = ColumnSort[];
export const BodySectionDynamicDimensionSortConfigurationList =
  S.Array(ColumnSort);
export interface BodySectionDynamicCategoryDimensionConfiguration {
  Column: ColumnIdentifier;
  Limit?: number;
  SortByMetrics?: ColumnSort[];
}
export const BodySectionDynamicCategoryDimensionConfiguration = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    Limit: S.optional(S.Number),
    SortByMetrics: S.optional(BodySectionDynamicDimensionSortConfigurationList),
  }),
).annotations({
  identifier: "BodySectionDynamicCategoryDimensionConfiguration",
}) as any as S.Schema<BodySectionDynamicCategoryDimensionConfiguration>;
export interface BodySectionDynamicNumericDimensionConfiguration {
  Column: ColumnIdentifier;
  Limit?: number;
  SortByMetrics?: ColumnSort[];
}
export const BodySectionDynamicNumericDimensionConfiguration = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    Limit: S.optional(S.Number),
    SortByMetrics: S.optional(BodySectionDynamicDimensionSortConfigurationList),
  }),
).annotations({
  identifier: "BodySectionDynamicNumericDimensionConfiguration",
}) as any as S.Schema<BodySectionDynamicNumericDimensionConfiguration>;
export interface BodySectionRepeatDimensionConfiguration {
  DynamicCategoryDimensionConfiguration?: BodySectionDynamicCategoryDimensionConfiguration;
  DynamicNumericDimensionConfiguration?: BodySectionDynamicNumericDimensionConfiguration;
}
export const BodySectionRepeatDimensionConfiguration = S.suspend(() =>
  S.Struct({
    DynamicCategoryDimensionConfiguration: S.optional(
      BodySectionDynamicCategoryDimensionConfiguration,
    ),
    DynamicNumericDimensionConfiguration: S.optional(
      BodySectionDynamicNumericDimensionConfiguration,
    ),
  }),
).annotations({
  identifier: "BodySectionRepeatDimensionConfiguration",
}) as any as S.Schema<BodySectionRepeatDimensionConfiguration>;
export type BodySectionRepeatDimensionConfigurationList =
  BodySectionRepeatDimensionConfiguration[];
export const BodySectionRepeatDimensionConfigurationList = S.Array(
  BodySectionRepeatDimensionConfiguration,
);
export interface BodySectionRepeatPageBreakConfiguration {
  After?: SectionAfterPageBreak;
}
export const BodySectionRepeatPageBreakConfiguration = S.suspend(() =>
  S.Struct({ After: S.optional(SectionAfterPageBreak) }),
).annotations({
  identifier: "BodySectionRepeatPageBreakConfiguration",
}) as any as S.Schema<BodySectionRepeatPageBreakConfiguration>;
export type NonRepeatingVisualsList = string[];
export const NonRepeatingVisualsList = S.Array(S.String);
export interface BodySectionRepeatConfiguration {
  DimensionConfigurations?: BodySectionRepeatDimensionConfiguration[];
  PageBreakConfiguration?: BodySectionRepeatPageBreakConfiguration;
  NonRepeatingVisuals?: string[];
}
export const BodySectionRepeatConfiguration = S.suspend(() =>
  S.Struct({
    DimensionConfigurations: S.optional(
      BodySectionRepeatDimensionConfigurationList,
    ),
    PageBreakConfiguration: S.optional(BodySectionRepeatPageBreakConfiguration),
    NonRepeatingVisuals: S.optional(NonRepeatingVisualsList),
  }),
).annotations({
  identifier: "BodySectionRepeatConfiguration",
}) as any as S.Schema<BodySectionRepeatConfiguration>;
export interface BodySectionConfiguration {
  SectionId: string;
  Content: BodySectionContent;
  Style?: SectionStyle;
  PageBreakConfiguration?: SectionPageBreakConfiguration;
  RepeatConfiguration?: BodySectionRepeatConfiguration;
}
export const BodySectionConfiguration = S.suspend(() =>
  S.Struct({
    SectionId: S.String,
    Content: BodySectionContent,
    Style: S.optional(SectionStyle),
    PageBreakConfiguration: S.optional(SectionPageBreakConfiguration),
    RepeatConfiguration: S.optional(BodySectionRepeatConfiguration),
  }),
).annotations({
  identifier: "BodySectionConfiguration",
}) as any as S.Schema<BodySectionConfiguration>;
export type BodySectionConfigurationList = BodySectionConfiguration[];
export const BodySectionConfigurationList = S.Array(BodySectionConfiguration);
export type PaperSize =
  | "US_LETTER"
  | "US_LEGAL"
  | "US_TABLOID_LEDGER"
  | "A0"
  | "A1"
  | "A2"
  | "A3"
  | "A4"
  | "A5"
  | "JIS_B4"
  | "JIS_B5";
export const PaperSize = S.Literal(
  "US_LETTER",
  "US_LEGAL",
  "US_TABLOID_LEDGER",
  "A0",
  "A1",
  "A2",
  "A3",
  "A4",
  "A5",
  "JIS_B4",
  "JIS_B5",
);
export type PaperOrientation = "PORTRAIT" | "LANDSCAPE";
export const PaperOrientation = S.Literal("PORTRAIT", "LANDSCAPE");
export interface SectionBasedLayoutPaperCanvasSizeOptions {
  PaperSize?: PaperSize;
  PaperOrientation?: PaperOrientation;
  PaperMargin?: Spacing;
}
export const SectionBasedLayoutPaperCanvasSizeOptions = S.suspend(() =>
  S.Struct({
    PaperSize: S.optional(PaperSize),
    PaperOrientation: S.optional(PaperOrientation),
    PaperMargin: S.optional(Spacing),
  }),
).annotations({
  identifier: "SectionBasedLayoutPaperCanvasSizeOptions",
}) as any as S.Schema<SectionBasedLayoutPaperCanvasSizeOptions>;
export interface SectionBasedLayoutCanvasSizeOptions {
  PaperCanvasSizeOptions?: SectionBasedLayoutPaperCanvasSizeOptions;
}
export const SectionBasedLayoutCanvasSizeOptions = S.suspend(() =>
  S.Struct({
    PaperCanvasSizeOptions: S.optional(
      SectionBasedLayoutPaperCanvasSizeOptions,
    ),
  }),
).annotations({
  identifier: "SectionBasedLayoutCanvasSizeOptions",
}) as any as S.Schema<SectionBasedLayoutCanvasSizeOptions>;
export interface SectionBasedLayoutConfiguration {
  HeaderSections: HeaderFooterSectionConfiguration[];
  BodySections: BodySectionConfiguration[];
  FooterSections: HeaderFooterSectionConfiguration[];
  CanvasSizeOptions: SectionBasedLayoutCanvasSizeOptions;
}
export const SectionBasedLayoutConfiguration = S.suspend(() =>
  S.Struct({
    HeaderSections: HeaderFooterSectionConfigurationList,
    BodySections: BodySectionConfigurationList,
    FooterSections: HeaderFooterSectionConfigurationList,
    CanvasSizeOptions: SectionBasedLayoutCanvasSizeOptions,
  }),
).annotations({
  identifier: "SectionBasedLayoutConfiguration",
}) as any as S.Schema<SectionBasedLayoutConfiguration>;
export interface LayoutConfiguration {
  GridLayout?: GridLayoutConfiguration;
  FreeFormLayout?: FreeFormLayoutConfiguration;
  SectionBasedLayout?: SectionBasedLayoutConfiguration;
}
export const LayoutConfiguration = S.suspend(() =>
  S.Struct({
    GridLayout: S.optional(GridLayoutConfiguration),
    FreeFormLayout: S.optional(FreeFormLayoutConfiguration),
    SectionBasedLayout: S.optional(SectionBasedLayoutConfiguration),
  }),
).annotations({
  identifier: "LayoutConfiguration",
}) as any as S.Schema<LayoutConfiguration>;
export interface Layout {
  Configuration: LayoutConfiguration;
}
export const Layout = S.suspend(() =>
  S.Struct({ Configuration: LayoutConfiguration }),
).annotations({ identifier: "Layout" }) as any as S.Schema<Layout>;
export type LayoutList = Layout[];
export const LayoutList = S.Array(Layout);
export interface SheetControlLayoutConfiguration {
  GridLayout?: GridLayoutConfiguration;
}
export const SheetControlLayoutConfiguration = S.suspend(() =>
  S.Struct({ GridLayout: S.optional(GridLayoutConfiguration) }),
).annotations({
  identifier: "SheetControlLayoutConfiguration",
}) as any as S.Schema<SheetControlLayoutConfiguration>;
export interface SheetControlLayout {
  Configuration: SheetControlLayoutConfiguration;
}
export const SheetControlLayout = S.suspend(() =>
  S.Struct({ Configuration: SheetControlLayoutConfiguration }),
).annotations({
  identifier: "SheetControlLayout",
}) as any as S.Schema<SheetControlLayout>;
export type SheetControlLayoutList = SheetControlLayout[];
export const SheetControlLayoutList = S.Array(SheetControlLayout);
export type SheetContentType = "PAGINATED" | "INTERACTIVE";
export const SheetContentType = S.Literal("PAGINATED", "INTERACTIVE");
export type VisualHighlightTrigger =
  | "DATA_POINT_CLICK"
  | "DATA_POINT_HOVER"
  | "NONE";
export const VisualHighlightTrigger = S.Literal(
  "DATA_POINT_CLICK",
  "DATA_POINT_HOVER",
  "NONE",
);
export interface VisualHighlightOperation {
  Trigger: VisualHighlightTrigger;
}
export const VisualHighlightOperation = S.suspend(() =>
  S.Struct({ Trigger: VisualHighlightTrigger }),
).annotations({
  identifier: "VisualHighlightOperation",
}) as any as S.Schema<VisualHighlightOperation>;
export interface VisualCustomActionDefaults {
  highlightOperation?: VisualHighlightOperation;
}
export const VisualCustomActionDefaults = S.suspend(() =>
  S.Struct({ highlightOperation: S.optional(VisualHighlightOperation) }),
).annotations({
  identifier: "VisualCustomActionDefaults",
}) as any as S.Schema<VisualCustomActionDefaults>;
export interface SheetDefinition {
  SheetId: string;
  Title?: string;
  Description?: string;
  Name?: string;
  ParameterControls?: ParameterControl[];
  FilterControls?: FilterControl[];
  Visuals?: Visual[];
  TextBoxes?: SheetTextBox[];
  Images?: SheetImage[];
  Layouts?: Layout[];
  SheetControlLayouts?: SheetControlLayout[];
  ContentType?: SheetContentType;
  CustomActionDefaults?: VisualCustomActionDefaults;
}
export const SheetDefinition = S.suspend(() =>
  S.Struct({
    SheetId: S.String,
    Title: S.optional(S.String),
    Description: S.optional(S.String),
    Name: S.optional(S.String),
    ParameterControls: S.optional(ParameterControlList),
    FilterControls: S.optional(FilterControlList),
    Visuals: S.optional(VisualList),
    TextBoxes: S.optional(SheetTextBoxList),
    Images: S.optional(SheetImageList),
    Layouts: S.optional(LayoutList),
    SheetControlLayouts: S.optional(SheetControlLayoutList),
    ContentType: S.optional(SheetContentType),
    CustomActionDefaults: S.optional(VisualCustomActionDefaults),
  }),
).annotations({
  identifier: "SheetDefinition",
}) as any as S.Schema<SheetDefinition>;
export type SheetDefinitionList = SheetDefinition[];
export const SheetDefinitionList = S.Array(SheetDefinition);
export interface CalculatedField {
  DataSetIdentifier: string;
  Name: string;
  Expression: string | redacted.Redacted<string>;
}
export const CalculatedField = S.suspend(() =>
  S.Struct({
    DataSetIdentifier: S.String,
    Name: S.String,
    Expression: SensitiveString,
  }),
).annotations({
  identifier: "CalculatedField",
}) as any as S.Schema<CalculatedField>;
export type CalculatedFields = CalculatedField[];
export const CalculatedFields = S.Array(CalculatedField);
export type ParameterValueType = "MULTI_VALUED" | "SINGLE_VALUED";
export const ParameterValueType = S.Literal("MULTI_VALUED", "SINGLE_VALUED");
export interface DynamicDefaultValue {
  UserNameColumn?: ColumnIdentifier;
  GroupNameColumn?: ColumnIdentifier;
  DefaultValueColumn: ColumnIdentifier;
}
export const DynamicDefaultValue = S.suspend(() =>
  S.Struct({
    UserNameColumn: S.optional(ColumnIdentifier),
    GroupNameColumn: S.optional(ColumnIdentifier),
    DefaultValueColumn: ColumnIdentifier,
  }),
).annotations({
  identifier: "DynamicDefaultValue",
}) as any as S.Schema<DynamicDefaultValue>;
export interface StringDefaultValues {
  DynamicValue?: DynamicDefaultValue;
  StaticValues?: string | redacted.Redacted<string>[];
}
export const StringDefaultValues = S.suspend(() =>
  S.Struct({
    DynamicValue: S.optional(DynamicDefaultValue),
    StaticValues: S.optional(StringDefaultValueList),
  }),
).annotations({
  identifier: "StringDefaultValues",
}) as any as S.Schema<StringDefaultValues>;
export type ValueWhenUnsetOption = "RECOMMENDED_VALUE" | "NULL";
export const ValueWhenUnsetOption = S.Literal("RECOMMENDED_VALUE", "NULL");
export interface StringValueWhenUnsetConfiguration {
  ValueWhenUnsetOption?: ValueWhenUnsetOption;
  CustomValue?: string | redacted.Redacted<string>;
}
export const StringValueWhenUnsetConfiguration = S.suspend(() =>
  S.Struct({
    ValueWhenUnsetOption: S.optional(ValueWhenUnsetOption),
    CustomValue: S.optional(SensitiveString),
  }),
).annotations({
  identifier: "StringValueWhenUnsetConfiguration",
}) as any as S.Schema<StringValueWhenUnsetConfiguration>;
export interface MappedDataSetParameter {
  DataSetIdentifier: string;
  DataSetParameterName: string;
}
export const MappedDataSetParameter = S.suspend(() =>
  S.Struct({ DataSetIdentifier: S.String, DataSetParameterName: S.String }),
).annotations({
  identifier: "MappedDataSetParameter",
}) as any as S.Schema<MappedDataSetParameter>;
export type MappedDataSetParameters = MappedDataSetParameter[];
export const MappedDataSetParameters = S.Array(MappedDataSetParameter);
export interface StringParameterDeclaration {
  ParameterValueType: ParameterValueType;
  Name: string;
  DefaultValues?: StringDefaultValues;
  ValueWhenUnset?: StringValueWhenUnsetConfiguration;
  MappedDataSetParameters?: MappedDataSetParameter[];
}
export const StringParameterDeclaration = S.suspend(() =>
  S.Struct({
    ParameterValueType: ParameterValueType,
    Name: S.String,
    DefaultValues: S.optional(StringDefaultValues),
    ValueWhenUnset: S.optional(StringValueWhenUnsetConfiguration),
    MappedDataSetParameters: S.optional(MappedDataSetParameters),
  }),
).annotations({
  identifier: "StringParameterDeclaration",
}) as any as S.Schema<StringParameterDeclaration>;
export interface DecimalDefaultValues {
  DynamicValue?: DynamicDefaultValue;
  StaticValues?: number[];
}
export const DecimalDefaultValues = S.suspend(() =>
  S.Struct({
    DynamicValue: S.optional(DynamicDefaultValue),
    StaticValues: S.optional(DecimalDefaultValueList),
  }),
).annotations({
  identifier: "DecimalDefaultValues",
}) as any as S.Schema<DecimalDefaultValues>;
export interface DecimalValueWhenUnsetConfiguration {
  ValueWhenUnsetOption?: ValueWhenUnsetOption;
  CustomValue?: number;
}
export const DecimalValueWhenUnsetConfiguration = S.suspend(() =>
  S.Struct({
    ValueWhenUnsetOption: S.optional(ValueWhenUnsetOption),
    CustomValue: S.optional(S.Number),
  }),
).annotations({
  identifier: "DecimalValueWhenUnsetConfiguration",
}) as any as S.Schema<DecimalValueWhenUnsetConfiguration>;
export interface DecimalParameterDeclaration {
  ParameterValueType: ParameterValueType;
  Name: string;
  DefaultValues?: DecimalDefaultValues;
  ValueWhenUnset?: DecimalValueWhenUnsetConfiguration;
  MappedDataSetParameters?: MappedDataSetParameter[];
}
export const DecimalParameterDeclaration = S.suspend(() =>
  S.Struct({
    ParameterValueType: ParameterValueType,
    Name: S.String,
    DefaultValues: S.optional(DecimalDefaultValues),
    ValueWhenUnset: S.optional(DecimalValueWhenUnsetConfiguration),
    MappedDataSetParameters: S.optional(MappedDataSetParameters),
  }),
).annotations({
  identifier: "DecimalParameterDeclaration",
}) as any as S.Schema<DecimalParameterDeclaration>;
export interface IntegerDefaultValues {
  DynamicValue?: DynamicDefaultValue;
  StaticValues?: number[];
}
export const IntegerDefaultValues = S.suspend(() =>
  S.Struct({
    DynamicValue: S.optional(DynamicDefaultValue),
    StaticValues: S.optional(IntegerDefaultValueList),
  }),
).annotations({
  identifier: "IntegerDefaultValues",
}) as any as S.Schema<IntegerDefaultValues>;
export interface IntegerValueWhenUnsetConfiguration {
  ValueWhenUnsetOption?: ValueWhenUnsetOption;
  CustomValue?: number;
}
export const IntegerValueWhenUnsetConfiguration = S.suspend(() =>
  S.Struct({
    ValueWhenUnsetOption: S.optional(ValueWhenUnsetOption),
    CustomValue: S.optional(S.Number),
  }),
).annotations({
  identifier: "IntegerValueWhenUnsetConfiguration",
}) as any as S.Schema<IntegerValueWhenUnsetConfiguration>;
export interface IntegerParameterDeclaration {
  ParameterValueType: ParameterValueType;
  Name: string;
  DefaultValues?: IntegerDefaultValues;
  ValueWhenUnset?: IntegerValueWhenUnsetConfiguration;
  MappedDataSetParameters?: MappedDataSetParameter[];
}
export const IntegerParameterDeclaration = S.suspend(() =>
  S.Struct({
    ParameterValueType: ParameterValueType,
    Name: S.String,
    DefaultValues: S.optional(IntegerDefaultValues),
    ValueWhenUnset: S.optional(IntegerValueWhenUnsetConfiguration),
    MappedDataSetParameters: S.optional(MappedDataSetParameters),
  }),
).annotations({
  identifier: "IntegerParameterDeclaration",
}) as any as S.Schema<IntegerParameterDeclaration>;
export interface RollingDateConfiguration {
  DataSetIdentifier?: string;
  Expression: string | redacted.Redacted<string>;
}
export const RollingDateConfiguration = S.suspend(() =>
  S.Struct({
    DataSetIdentifier: S.optional(S.String),
    Expression: SensitiveString,
  }),
).annotations({
  identifier: "RollingDateConfiguration",
}) as any as S.Schema<RollingDateConfiguration>;
export interface DateTimeDefaultValues {
  DynamicValue?: DynamicDefaultValue;
  StaticValues?: Date[];
  RollingDate?: RollingDateConfiguration;
}
export const DateTimeDefaultValues = S.suspend(() =>
  S.Struct({
    DynamicValue: S.optional(DynamicDefaultValue),
    StaticValues: S.optional(DateTimeDefaultValueList),
    RollingDate: S.optional(RollingDateConfiguration),
  }),
).annotations({
  identifier: "DateTimeDefaultValues",
}) as any as S.Schema<DateTimeDefaultValues>;
export interface DateTimeValueWhenUnsetConfiguration {
  ValueWhenUnsetOption?: ValueWhenUnsetOption;
  CustomValue?: Date;
}
export const DateTimeValueWhenUnsetConfiguration = S.suspend(() =>
  S.Struct({
    ValueWhenUnsetOption: S.optional(ValueWhenUnsetOption),
    CustomValue: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotations({
  identifier: "DateTimeValueWhenUnsetConfiguration",
}) as any as S.Schema<DateTimeValueWhenUnsetConfiguration>;
export interface DateTimeParameterDeclaration {
  Name: string;
  DefaultValues?: DateTimeDefaultValues;
  TimeGranularity?: TimeGranularity;
  ValueWhenUnset?: DateTimeValueWhenUnsetConfiguration;
  MappedDataSetParameters?: MappedDataSetParameter[];
}
export const DateTimeParameterDeclaration = S.suspend(() =>
  S.Struct({
    Name: S.String,
    DefaultValues: S.optional(DateTimeDefaultValues),
    TimeGranularity: S.optional(TimeGranularity),
    ValueWhenUnset: S.optional(DateTimeValueWhenUnsetConfiguration),
    MappedDataSetParameters: S.optional(MappedDataSetParameters),
  }),
).annotations({
  identifier: "DateTimeParameterDeclaration",
}) as any as S.Schema<DateTimeParameterDeclaration>;
export interface ParameterDeclaration {
  StringParameterDeclaration?: StringParameterDeclaration;
  DecimalParameterDeclaration?: DecimalParameterDeclaration;
  IntegerParameterDeclaration?: IntegerParameterDeclaration;
  DateTimeParameterDeclaration?: DateTimeParameterDeclaration;
}
export const ParameterDeclaration = S.suspend(() =>
  S.Struct({
    StringParameterDeclaration: S.optional(StringParameterDeclaration),
    DecimalParameterDeclaration: S.optional(DecimalParameterDeclaration),
    IntegerParameterDeclaration: S.optional(IntegerParameterDeclaration),
    DateTimeParameterDeclaration: S.optional(DateTimeParameterDeclaration),
  }),
).annotations({
  identifier: "ParameterDeclaration",
}) as any as S.Schema<ParameterDeclaration>;
export type ParameterDeclarationList = ParameterDeclaration[];
export const ParameterDeclarationList = S.Array(ParameterDeclaration);
export type CategoryFilterMatchOperator =
  | "EQUALS"
  | "DOES_NOT_EQUAL"
  | "CONTAINS"
  | "DOES_NOT_CONTAIN"
  | "STARTS_WITH"
  | "ENDS_WITH";
export const CategoryFilterMatchOperator = S.Literal(
  "EQUALS",
  "DOES_NOT_EQUAL",
  "CONTAINS",
  "DOES_NOT_CONTAIN",
  "STARTS_WITH",
  "ENDS_WITH",
);
export type CategoryFilterSelectAllOptions = "FILTER_ALL_VALUES";
export const CategoryFilterSelectAllOptions = S.Literal("FILTER_ALL_VALUES");
export type FilterNullOption = "ALL_VALUES" | "NULLS_ONLY" | "NON_NULLS_ONLY";
export const FilterNullOption = S.Literal(
  "ALL_VALUES",
  "NULLS_ONLY",
  "NON_NULLS_ONLY",
);
export interface FilterListConfiguration {
  MatchOperator: CategoryFilterMatchOperator;
  CategoryValues?: string[];
  SelectAllOptions?: CategoryFilterSelectAllOptions;
  NullOption?: FilterNullOption;
}
export const FilterListConfiguration = S.suspend(() =>
  S.Struct({
    MatchOperator: CategoryFilterMatchOperator,
    CategoryValues: S.optional(CategoryValueList),
    SelectAllOptions: S.optional(CategoryFilterSelectAllOptions),
    NullOption: S.optional(FilterNullOption),
  }),
).annotations({
  identifier: "FilterListConfiguration",
}) as any as S.Schema<FilterListConfiguration>;
export interface CustomFilterListConfiguration {
  MatchOperator: CategoryFilterMatchOperator;
  CategoryValues?: string[];
  SelectAllOptions?: CategoryFilterSelectAllOptions;
  NullOption: FilterNullOption;
}
export const CustomFilterListConfiguration = S.suspend(() =>
  S.Struct({
    MatchOperator: CategoryFilterMatchOperator,
    CategoryValues: S.optional(CategoryValueList),
    SelectAllOptions: S.optional(CategoryFilterSelectAllOptions),
    NullOption: FilterNullOption,
  }),
).annotations({
  identifier: "CustomFilterListConfiguration",
}) as any as S.Schema<CustomFilterListConfiguration>;
export interface CustomFilterConfiguration {
  MatchOperator: CategoryFilterMatchOperator;
  CategoryValue?: string;
  SelectAllOptions?: CategoryFilterSelectAllOptions;
  ParameterName?: string;
  NullOption: FilterNullOption;
}
export const CustomFilterConfiguration = S.suspend(() =>
  S.Struct({
    MatchOperator: CategoryFilterMatchOperator,
    CategoryValue: S.optional(S.String),
    SelectAllOptions: S.optional(CategoryFilterSelectAllOptions),
    ParameterName: S.optional(S.String),
    NullOption: FilterNullOption,
  }),
).annotations({
  identifier: "CustomFilterConfiguration",
}) as any as S.Schema<CustomFilterConfiguration>;
export interface CategoryFilterConfiguration {
  FilterListConfiguration?: FilterListConfiguration;
  CustomFilterListConfiguration?: CustomFilterListConfiguration;
  CustomFilterConfiguration?: CustomFilterConfiguration;
}
export const CategoryFilterConfiguration = S.suspend(() =>
  S.Struct({
    FilterListConfiguration: S.optional(FilterListConfiguration),
    CustomFilterListConfiguration: S.optional(CustomFilterListConfiguration),
    CustomFilterConfiguration: S.optional(CustomFilterConfiguration),
  }),
).annotations({
  identifier: "CategoryFilterConfiguration",
}) as any as S.Schema<CategoryFilterConfiguration>;
export interface DefaultDateTimePickerControlOptions {
  Type?: SheetControlDateTimePickerType;
  DisplayOptions?: DateTimePickerControlDisplayOptions;
  CommitMode?: CommitMode;
}
export const DefaultDateTimePickerControlOptions = S.suspend(() =>
  S.Struct({
    Type: S.optional(SheetControlDateTimePickerType),
    DisplayOptions: S.optional(DateTimePickerControlDisplayOptions),
    CommitMode: S.optional(CommitMode),
  }),
).annotations({
  identifier: "DefaultDateTimePickerControlOptions",
}) as any as S.Schema<DefaultDateTimePickerControlOptions>;
export interface DefaultFilterListControlOptions {
  DisplayOptions?: ListControlDisplayOptions;
  Type?: SheetControlListType;
  SelectableValues?: FilterSelectableValues;
}
export const DefaultFilterListControlOptions = S.suspend(() =>
  S.Struct({
    DisplayOptions: S.optional(ListControlDisplayOptions),
    Type: S.optional(SheetControlListType),
    SelectableValues: S.optional(FilterSelectableValues),
  }),
).annotations({
  identifier: "DefaultFilterListControlOptions",
}) as any as S.Schema<DefaultFilterListControlOptions>;
export interface DefaultFilterDropDownControlOptions {
  DisplayOptions?: DropDownControlDisplayOptions;
  Type?: SheetControlListType;
  SelectableValues?: FilterSelectableValues;
  CommitMode?: CommitMode;
}
export const DefaultFilterDropDownControlOptions = S.suspend(() =>
  S.Struct({
    DisplayOptions: S.optional(DropDownControlDisplayOptions),
    Type: S.optional(SheetControlListType),
    SelectableValues: S.optional(FilterSelectableValues),
    CommitMode: S.optional(CommitMode),
  }),
).annotations({
  identifier: "DefaultFilterDropDownControlOptions",
}) as any as S.Schema<DefaultFilterDropDownControlOptions>;
export interface DefaultTextFieldControlOptions {
  DisplayOptions?: TextFieldControlDisplayOptions;
}
export const DefaultTextFieldControlOptions = S.suspend(() =>
  S.Struct({ DisplayOptions: S.optional(TextFieldControlDisplayOptions) }),
).annotations({
  identifier: "DefaultTextFieldControlOptions",
}) as any as S.Schema<DefaultTextFieldControlOptions>;
export interface DefaultTextAreaControlOptions {
  Delimiter?: string;
  DisplayOptions?: TextAreaControlDisplayOptions;
}
export const DefaultTextAreaControlOptions = S.suspend(() =>
  S.Struct({
    Delimiter: S.optional(S.String),
    DisplayOptions: S.optional(TextAreaControlDisplayOptions),
  }),
).annotations({
  identifier: "DefaultTextAreaControlOptions",
}) as any as S.Schema<DefaultTextAreaControlOptions>;
export interface DefaultSliderControlOptions {
  DisplayOptions?: SliderControlDisplayOptions;
  Type?: SheetControlSliderType;
  MaximumValue: number;
  MinimumValue: number;
  StepSize: number;
}
export const DefaultSliderControlOptions = S.suspend(() =>
  S.Struct({
    DisplayOptions: S.optional(SliderControlDisplayOptions),
    Type: S.optional(SheetControlSliderType),
    MaximumValue: S.Number,
    MinimumValue: S.Number,
    StepSize: S.Number,
  }),
).annotations({
  identifier: "DefaultSliderControlOptions",
}) as any as S.Schema<DefaultSliderControlOptions>;
export interface DefaultRelativeDateTimeControlOptions {
  DisplayOptions?: RelativeDateTimeControlDisplayOptions;
  CommitMode?: CommitMode;
}
export const DefaultRelativeDateTimeControlOptions = S.suspend(() =>
  S.Struct({
    DisplayOptions: S.optional(RelativeDateTimeControlDisplayOptions),
    CommitMode: S.optional(CommitMode),
  }),
).annotations({
  identifier: "DefaultRelativeDateTimeControlOptions",
}) as any as S.Schema<DefaultRelativeDateTimeControlOptions>;
export interface DefaultFilterControlOptions {
  DefaultDateTimePickerOptions?: DefaultDateTimePickerControlOptions;
  DefaultListOptions?: DefaultFilterListControlOptions;
  DefaultDropdownOptions?: DefaultFilterDropDownControlOptions;
  DefaultTextFieldOptions?: DefaultTextFieldControlOptions;
  DefaultTextAreaOptions?: DefaultTextAreaControlOptions;
  DefaultSliderOptions?: DefaultSliderControlOptions;
  DefaultRelativeDateTimeOptions?: DefaultRelativeDateTimeControlOptions;
}
export const DefaultFilterControlOptions = S.suspend(() =>
  S.Struct({
    DefaultDateTimePickerOptions: S.optional(
      DefaultDateTimePickerControlOptions,
    ),
    DefaultListOptions: S.optional(DefaultFilterListControlOptions),
    DefaultDropdownOptions: S.optional(DefaultFilterDropDownControlOptions),
    DefaultTextFieldOptions: S.optional(DefaultTextFieldControlOptions),
    DefaultTextAreaOptions: S.optional(DefaultTextAreaControlOptions),
    DefaultSliderOptions: S.optional(DefaultSliderControlOptions),
    DefaultRelativeDateTimeOptions: S.optional(
      DefaultRelativeDateTimeControlOptions,
    ),
  }),
).annotations({
  identifier: "DefaultFilterControlOptions",
}) as any as S.Schema<DefaultFilterControlOptions>;
export interface DefaultFilterControlConfiguration {
  Title: string;
  ControlOptions: DefaultFilterControlOptions;
}
export const DefaultFilterControlConfiguration = S.suspend(() =>
  S.Struct({ Title: S.String, ControlOptions: DefaultFilterControlOptions }),
).annotations({
  identifier: "DefaultFilterControlConfiguration",
}) as any as S.Schema<DefaultFilterControlConfiguration>;
export interface CategoryFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  Configuration: CategoryFilterConfiguration;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const CategoryFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    Configuration: CategoryFilterConfiguration,
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "CategoryFilter",
}) as any as S.Schema<CategoryFilter>;
export interface NumericRangeFilterValue {
  StaticValue?: number;
  Parameter?: string;
}
export const NumericRangeFilterValue = S.suspend(() =>
  S.Struct({
    StaticValue: S.optional(S.Number),
    Parameter: S.optional(S.String),
  }),
).annotations({
  identifier: "NumericRangeFilterValue",
}) as any as S.Schema<NumericRangeFilterValue>;
export type NumericFilterSelectAllOptions = "FILTER_ALL_VALUES";
export const NumericFilterSelectAllOptions = S.Literal("FILTER_ALL_VALUES");
export interface NumericRangeFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  IncludeMinimum?: boolean;
  IncludeMaximum?: boolean;
  RangeMinimum?: NumericRangeFilterValue;
  RangeMaximum?: NumericRangeFilterValue;
  SelectAllOptions?: NumericFilterSelectAllOptions;
  AggregationFunction?: AggregationFunction;
  NullOption: FilterNullOption;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const NumericRangeFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    IncludeMinimum: S.optional(S.Boolean),
    IncludeMaximum: S.optional(S.Boolean),
    RangeMinimum: S.optional(NumericRangeFilterValue),
    RangeMaximum: S.optional(NumericRangeFilterValue),
    SelectAllOptions: S.optional(NumericFilterSelectAllOptions),
    AggregationFunction: S.optional(AggregationFunction),
    NullOption: FilterNullOption,
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "NumericRangeFilter",
}) as any as S.Schema<NumericRangeFilter>;
export type NumericEqualityMatchOperator = "EQUALS" | "DOES_NOT_EQUAL";
export const NumericEqualityMatchOperator = S.Literal(
  "EQUALS",
  "DOES_NOT_EQUAL",
);
export interface NumericEqualityFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  Value?: number;
  SelectAllOptions?: NumericFilterSelectAllOptions;
  MatchOperator: NumericEqualityMatchOperator;
  AggregationFunction?: AggregationFunction;
  ParameterName?: string;
  NullOption: FilterNullOption;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const NumericEqualityFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    Value: S.optional(S.Number),
    SelectAllOptions: S.optional(NumericFilterSelectAllOptions),
    MatchOperator: NumericEqualityMatchOperator,
    AggregationFunction: S.optional(AggregationFunction),
    ParameterName: S.optional(S.String),
    NullOption: FilterNullOption,
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "NumericEqualityFilter",
}) as any as S.Schema<NumericEqualityFilter>;
export interface TimeEqualityFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  Value?: Date;
  ParameterName?: string;
  TimeGranularity?: TimeGranularity;
  RollingDate?: RollingDateConfiguration;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const TimeEqualityFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    Value: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    ParameterName: S.optional(S.String),
    TimeGranularity: S.optional(TimeGranularity),
    RollingDate: S.optional(RollingDateConfiguration),
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "TimeEqualityFilter",
}) as any as S.Schema<TimeEqualityFilter>;
export interface TimeRangeFilterValue {
  StaticValue?: Date;
  RollingDate?: RollingDateConfiguration;
  Parameter?: string;
}
export const TimeRangeFilterValue = S.suspend(() =>
  S.Struct({
    StaticValue: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    RollingDate: S.optional(RollingDateConfiguration),
    Parameter: S.optional(S.String),
  }),
).annotations({
  identifier: "TimeRangeFilterValue",
}) as any as S.Schema<TimeRangeFilterValue>;
export interface ExcludePeriodConfiguration {
  Amount: number;
  Granularity: TimeGranularity;
  Status?: WidgetStatus;
}
export const ExcludePeriodConfiguration = S.suspend(() =>
  S.Struct({
    Amount: S.Number,
    Granularity: TimeGranularity,
    Status: S.optional(WidgetStatus),
  }),
).annotations({
  identifier: "ExcludePeriodConfiguration",
}) as any as S.Schema<ExcludePeriodConfiguration>;
export interface TimeRangeFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  IncludeMinimum?: boolean;
  IncludeMaximum?: boolean;
  RangeMinimumValue?: TimeRangeFilterValue;
  RangeMaximumValue?: TimeRangeFilterValue;
  NullOption: FilterNullOption;
  ExcludePeriodConfiguration?: ExcludePeriodConfiguration;
  TimeGranularity?: TimeGranularity;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const TimeRangeFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    IncludeMinimum: S.optional(S.Boolean),
    IncludeMaximum: S.optional(S.Boolean),
    RangeMinimumValue: S.optional(TimeRangeFilterValue),
    RangeMaximumValue: S.optional(TimeRangeFilterValue),
    NullOption: FilterNullOption,
    ExcludePeriodConfiguration: S.optional(ExcludePeriodConfiguration),
    TimeGranularity: S.optional(TimeGranularity),
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "TimeRangeFilter",
}) as any as S.Schema<TimeRangeFilter>;
export type AnchorOption = "NOW";
export const AnchorOption = S.Literal("NOW");
export interface AnchorDateConfiguration {
  AnchorOption?: AnchorOption;
  ParameterName?: string;
}
export const AnchorDateConfiguration = S.suspend(() =>
  S.Struct({
    AnchorOption: S.optional(AnchorOption),
    ParameterName: S.optional(S.String),
  }),
).annotations({
  identifier: "AnchorDateConfiguration",
}) as any as S.Schema<AnchorDateConfiguration>;
export type RelativeDateType = "PREVIOUS" | "THIS" | "LAST" | "NOW" | "NEXT";
export const RelativeDateType = S.Literal(
  "PREVIOUS",
  "THIS",
  "LAST",
  "NOW",
  "NEXT",
);
export interface RelativeDatesFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  AnchorDateConfiguration: AnchorDateConfiguration;
  MinimumGranularity?: TimeGranularity;
  TimeGranularity: TimeGranularity;
  RelativeDateType: RelativeDateType;
  RelativeDateValue?: number;
  ParameterName?: string;
  NullOption: FilterNullOption;
  ExcludePeriodConfiguration?: ExcludePeriodConfiguration;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const RelativeDatesFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    AnchorDateConfiguration: AnchorDateConfiguration,
    MinimumGranularity: S.optional(TimeGranularity),
    TimeGranularity: TimeGranularity,
    RelativeDateType: RelativeDateType,
    RelativeDateValue: S.optional(S.Number),
    ParameterName: S.optional(S.String),
    NullOption: FilterNullOption,
    ExcludePeriodConfiguration: S.optional(ExcludePeriodConfiguration),
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "RelativeDatesFilter",
}) as any as S.Schema<RelativeDatesFilter>;
export interface AggregationSortConfiguration {
  Column: ColumnIdentifier;
  SortDirection: SortDirection;
  AggregationFunction?: AggregationFunction;
}
export const AggregationSortConfiguration = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    SortDirection: SortDirection,
    AggregationFunction: S.optional(AggregationFunction),
  }),
).annotations({
  identifier: "AggregationSortConfiguration",
}) as any as S.Schema<AggregationSortConfiguration>;
export type AggregationSortConfigurationList = AggregationSortConfiguration[];
export const AggregationSortConfigurationList = S.Array(
  AggregationSortConfiguration,
);
export interface TopBottomFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  Limit?: number;
  AggregationSortConfigurations: AggregationSortConfiguration[];
  TimeGranularity?: TimeGranularity;
  ParameterName?: string;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const TopBottomFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    Limit: S.optional(S.Number),
    AggregationSortConfigurations: AggregationSortConfigurationList,
    TimeGranularity: S.optional(TimeGranularity),
    ParameterName: S.optional(S.String),
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "TopBottomFilter",
}) as any as S.Schema<TopBottomFilter>;
export interface CategoryInnerFilter {
  Column: ColumnIdentifier;
  Configuration: CategoryFilterConfiguration;
  DefaultFilterControlConfiguration?: DefaultFilterControlConfiguration;
}
export const CategoryInnerFilter = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    Configuration: CategoryFilterConfiguration,
    DefaultFilterControlConfiguration: S.optional(
      DefaultFilterControlConfiguration,
    ),
  }),
).annotations({
  identifier: "CategoryInnerFilter",
}) as any as S.Schema<CategoryInnerFilter>;
export interface InnerFilter {
  CategoryInnerFilter?: CategoryInnerFilter;
}
export const InnerFilter = S.suspend(() =>
  S.Struct({ CategoryInnerFilter: S.optional(CategoryInnerFilter) }),
).annotations({ identifier: "InnerFilter" }) as any as S.Schema<InnerFilter>;
export interface NestedFilter {
  FilterId: string;
  Column: ColumnIdentifier;
  IncludeInnerSet: boolean;
  InnerFilter: InnerFilter;
}
export const NestedFilter = S.suspend(() =>
  S.Struct({
    FilterId: S.String,
    Column: ColumnIdentifier,
    IncludeInnerSet: S.Boolean,
    InnerFilter: InnerFilter,
  }),
).annotations({ identifier: "NestedFilter" }) as any as S.Schema<NestedFilter>;
export interface Filter {
  CategoryFilter?: CategoryFilter;
  NumericRangeFilter?: NumericRangeFilter;
  NumericEqualityFilter?: NumericEqualityFilter;
  TimeEqualityFilter?: TimeEqualityFilter;
  TimeRangeFilter?: TimeRangeFilter;
  RelativeDatesFilter?: RelativeDatesFilter;
  TopBottomFilter?: TopBottomFilter;
  NestedFilter?: NestedFilter;
}
export const Filter = S.suspend(() =>
  S.Struct({
    CategoryFilter: S.optional(CategoryFilter),
    NumericRangeFilter: S.optional(NumericRangeFilter),
    NumericEqualityFilter: S.optional(NumericEqualityFilter),
    TimeEqualityFilter: S.optional(TimeEqualityFilter),
    TimeRangeFilter: S.optional(TimeRangeFilter),
    RelativeDatesFilter: S.optional(RelativeDatesFilter),
    TopBottomFilter: S.optional(TopBottomFilter),
    NestedFilter: S.optional(NestedFilter),
  }),
).annotations({ identifier: "Filter" }) as any as S.Schema<Filter>;
export type FilterList = Filter[];
export const FilterList = S.Array(Filter);
export type FilterVisualScope = "ALL_VISUALS" | "SELECTED_VISUALS";
export const FilterVisualScope = S.Literal("ALL_VISUALS", "SELECTED_VISUALS");
export type FilteredVisualsList = string[];
export const FilteredVisualsList = S.Array(S.String);
export interface SheetVisualScopingConfiguration {
  SheetId: string;
  Scope: FilterVisualScope;
  VisualIds?: string[];
}
export const SheetVisualScopingConfiguration = S.suspend(() =>
  S.Struct({
    SheetId: S.String,
    Scope: FilterVisualScope,
    VisualIds: S.optional(FilteredVisualsList),
  }),
).annotations({
  identifier: "SheetVisualScopingConfiguration",
}) as any as S.Schema<SheetVisualScopingConfiguration>;
export type SheetVisualScopingConfigurations =
  SheetVisualScopingConfiguration[];
export const SheetVisualScopingConfigurations = S.Array(
  SheetVisualScopingConfiguration,
);
export interface SelectedSheetsFilterScopeConfiguration {
  SheetVisualScopingConfigurations?: SheetVisualScopingConfiguration[];
}
export const SelectedSheetsFilterScopeConfiguration = S.suspend(() =>
  S.Struct({
    SheetVisualScopingConfigurations: S.optional(
      SheetVisualScopingConfigurations,
    ),
  }),
).annotations({
  identifier: "SelectedSheetsFilterScopeConfiguration",
}) as any as S.Schema<SelectedSheetsFilterScopeConfiguration>;
export interface AllSheetsFilterScopeConfiguration {}
export const AllSheetsFilterScopeConfiguration = S.suspend(() =>
  S.Struct({}),
).annotations({
  identifier: "AllSheetsFilterScopeConfiguration",
}) as any as S.Schema<AllSheetsFilterScopeConfiguration>;
export interface FilterScopeConfiguration {
  SelectedSheets?: SelectedSheetsFilterScopeConfiguration;
  AllSheets?: AllSheetsFilterScopeConfiguration;
}
export const FilterScopeConfiguration = S.suspend(() =>
  S.Struct({
    SelectedSheets: S.optional(SelectedSheetsFilterScopeConfiguration),
    AllSheets: S.optional(AllSheetsFilterScopeConfiguration),
  }),
).annotations({
  identifier: "FilterScopeConfiguration",
}) as any as S.Schema<FilterScopeConfiguration>;
export type CrossDatasetTypes = "ALL_DATASETS" | "SINGLE_DATASET";
export const CrossDatasetTypes = S.Literal("ALL_DATASETS", "SINGLE_DATASET");
export interface FilterGroup {
  FilterGroupId: string;
  Filters: Filter[];
  ScopeConfiguration: FilterScopeConfiguration;
  Status?: WidgetStatus;
  CrossDataset: CrossDatasetTypes;
}
export const FilterGroup = S.suspend(() =>
  S.Struct({
    FilterGroupId: S.String,
    Filters: FilterList,
    ScopeConfiguration: FilterScopeConfiguration,
    Status: S.optional(WidgetStatus),
    CrossDataset: CrossDatasetTypes,
  }),
).annotations({ identifier: "FilterGroup" }) as any as S.Schema<FilterGroup>;
export type FilterGroupList = FilterGroup[];
export const FilterGroupList = S.Array(FilterGroup);
export type ColumnRole = "DIMENSION" | "MEASURE";
export const ColumnRole = S.Literal("DIMENSION", "MEASURE");
export type SpecialValue = "EMPTY" | "NULL" | "OTHER";
export const SpecialValue = S.Literal("EMPTY", "NULL", "OTHER");
export interface CustomColor {
  FieldValue?: string | redacted.Redacted<string>;
  Color: string;
  SpecialValue?: SpecialValue;
}
export const CustomColor = S.suspend(() =>
  S.Struct({
    FieldValue: S.optional(SensitiveString),
    Color: S.String,
    SpecialValue: S.optional(SpecialValue),
  }),
).annotations({ identifier: "CustomColor" }) as any as S.Schema<CustomColor>;
export type CustomColorsList = CustomColor[];
export const CustomColorsList = S.Array(CustomColor);
export interface ColorsConfiguration {
  CustomColors?: CustomColor[];
}
export const ColorsConfiguration = S.suspend(() =>
  S.Struct({ CustomColors: S.optional(CustomColorsList) }),
).annotations({
  identifier: "ColorsConfiguration",
}) as any as S.Schema<ColorsConfiguration>;
export type DecalSettingsList = DecalSettings[];
export const DecalSettingsList = S.Array(DecalSettings);
export interface DecalSettingsConfiguration {
  CustomDecalSettings?: DecalSettings[];
}
export const DecalSettingsConfiguration = S.suspend(() =>
  S.Struct({ CustomDecalSettings: S.optional(DecalSettingsList) }),
).annotations({
  identifier: "DecalSettingsConfiguration",
}) as any as S.Schema<DecalSettingsConfiguration>;
export interface ColumnConfiguration {
  Column: ColumnIdentifier;
  FormatConfiguration?: FormatConfiguration;
  Role?: ColumnRole;
  ColorsConfiguration?: ColorsConfiguration;
  DecalSettingsConfiguration?: DecalSettingsConfiguration;
}
export const ColumnConfiguration = S.suspend(() =>
  S.Struct({
    Column: ColumnIdentifier,
    FormatConfiguration: S.optional(FormatConfiguration),
    Role: S.optional(ColumnRole),
    ColorsConfiguration: S.optional(ColorsConfiguration),
    DecalSettingsConfiguration: S.optional(DecalSettingsConfiguration),
  }),
).annotations({
  identifier: "ColumnConfiguration",
}) as any as S.Schema<ColumnConfiguration>;
export type ColumnConfigurationList = ColumnConfiguration[];
export const ColumnConfigurationList = S.Array(ColumnConfiguration);
export interface DefaultGridLayoutConfiguration {
  CanvasSizeOptions: GridLayoutCanvasSizeOptions;
}
export const DefaultGridLayoutConfiguration = S.suspend(() =>
  S.Struct({ CanvasSizeOptions: GridLayoutCanvasSizeOptions }),
).annotations({
  identifier: "DefaultGridLayoutConfiguration",
}) as any as S.Schema<DefaultGridLayoutConfiguration>;
export interface DefaultFreeFormLayoutConfiguration {
  CanvasSizeOptions: FreeFormLayoutCanvasSizeOptions;
}
export const DefaultFreeFormLayoutConfiguration = S.suspend(() =>
  S.Struct({ CanvasSizeOptions: FreeFormLayoutCanvasSizeOptions }),
).annotations({
  identifier: "DefaultFreeFormLayoutConfiguration",
}) as any as S.Schema<DefaultFreeFormLayoutConfiguration>;
export interface DefaultInteractiveLayoutConfiguration {
  Grid?: DefaultGridLayoutConfiguration;
  FreeForm?: DefaultFreeFormLayoutConfiguration;
}
export const DefaultInteractiveLayoutConfiguration = S.suspend(() =>
  S.Struct({
    Grid: S.optional(DefaultGridLayoutConfiguration),
    FreeForm: S.optional(DefaultFreeFormLayoutConfiguration),
  }),
).annotations({
  identifier: "DefaultInteractiveLayoutConfiguration",
}) as any as S.Schema<DefaultInteractiveLayoutConfiguration>;
export interface DefaultSectionBasedLayoutConfiguration {
  CanvasSizeOptions: SectionBasedLayoutCanvasSizeOptions;
}
export const DefaultSectionBasedLayoutConfiguration = S.suspend(() =>
  S.Struct({ CanvasSizeOptions: SectionBasedLayoutCanvasSizeOptions }),
).annotations({
  identifier: "DefaultSectionBasedLayoutConfiguration",
}) as any as S.Schema<DefaultSectionBasedLayoutConfiguration>;
export interface DefaultPaginatedLayoutConfiguration {
  SectionBased?: DefaultSectionBasedLayoutConfiguration;
}
export const DefaultPaginatedLayoutConfiguration = S.suspend(() =>
  S.Struct({
    SectionBased: S.optional(DefaultSectionBasedLayoutConfiguration),
  }),
).annotations({
  identifier: "DefaultPaginatedLayoutConfiguration",
}) as any as S.Schema<DefaultPaginatedLayoutConfiguration>;
export interface DefaultNewSheetConfiguration {
  InteractiveLayoutConfiguration?: DefaultInteractiveLayoutConfiguration;
  PaginatedLayoutConfiguration?: DefaultPaginatedLayoutConfiguration;
  SheetContentType?: SheetContentType;
}
export const DefaultNewSheetConfiguration = S.suspend(() =>
  S.Struct({
    InteractiveLayoutConfiguration: S.optional(
      DefaultInteractiveLayoutConfiguration,
    ),
    PaginatedLayoutConfiguration: S.optional(
      DefaultPaginatedLayoutConfiguration,
    ),
    SheetContentType: S.optional(SheetContentType),
  }),
).annotations({
  identifier: "DefaultNewSheetConfiguration",
}) as any as S.Schema<DefaultNewSheetConfiguration>;
export interface AnalysisDefaults {
  DefaultNewSheetConfiguration: DefaultNewSheetConfiguration;
}
export const AnalysisDefaults = S.suspend(() =>
  S.Struct({ DefaultNewSheetConfiguration: DefaultNewSheetConfiguration }),
).annotations({
  identifier: "AnalysisDefaults",
}) as any as S.Schema<AnalysisDefaults>;
export type DayOfTheWeek =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY";
export const DayOfTheWeek = S.Literal(
  "SUNDAY",
  "MONDAY",
  "TUESDAY",
  "WEDNESDAY",
  "THURSDAY",
  "FRIDAY",
  "SATURDAY",
);
export type QBusinessInsightsStatus = "ENABLED" | "DISABLED";
export const QBusinessInsightsStatus = S.Literal("ENABLED", "DISABLED");
export type DataSetArnsList = string[];
export const DataSetArnsList = S.Array(S.String);
export interface AssetOptions {
  Timezone?: string;
  WeekStart?: DayOfTheWeek;
  QBusinessInsightsStatus?: QBusinessInsightsStatus;
  ExcludedDataSetArns?: string[];
  CustomActionDefaults?: VisualCustomActionDefaults;
}
export const AssetOptions = S.suspend(() =>
  S.Struct({
    Timezone: S.optional(S.String),
    WeekStart: S.optional(DayOfTheWeek),
    QBusinessInsightsStatus: S.optional(QBusinessInsightsStatus),
    ExcludedDataSetArns: S.optional(DataSetArnsList),
    CustomActionDefaults: S.optional(VisualCustomActionDefaults),
  }),
).annotations({ identifier: "AssetOptions" }) as any as S.Schema<AssetOptions>;
export type QueryExecutionMode = "AUTO" | "MANUAL";
export const QueryExecutionMode = S.Literal("AUTO", "MANUAL");
export interface QueryExecutionOptions {
  QueryExecutionMode?: QueryExecutionMode;
}
export const QueryExecutionOptions = S.suspend(() =>
  S.Struct({ QueryExecutionMode: S.optional(QueryExecutionMode) }),
).annotations({
  identifier: "QueryExecutionOptions",
}) as any as S.Schema<QueryExecutionOptions>;
export interface StaticFileUrlSourceOptions {
  Url: string;
}
export const StaticFileUrlSourceOptions = S.suspend(() =>
  S.Struct({ Url: S.String }),
).annotations({
  identifier: "StaticFileUrlSourceOptions",
}) as any as S.Schema<StaticFileUrlSourceOptions>;
export interface StaticFileS3SourceOptions {
  BucketName: string;
  ObjectKey: string;
  Region: string;
}
export const StaticFileS3SourceOptions = S.suspend(() =>
  S.Struct({ BucketName: S.String, ObjectKey: S.String, Region: S.String }),
).annotations({
  identifier: "StaticFileS3SourceOptions",
}) as any as S.Schema<StaticFileS3SourceOptions>;
export interface StaticFileSource {
  UrlOptions?: StaticFileUrlSourceOptions;
  S3Options?: StaticFileS3SourceOptions;
}
export const StaticFileSource = S.suspend(() =>
  S.Struct({
    UrlOptions: S.optional(StaticFileUrlSourceOptions),
    S3Options: S.optional(StaticFileS3SourceOptions),
  }),
).annotations({
  identifier: "StaticFileSource",
}) as any as S.Schema<StaticFileSource>;
export interface ImageStaticFile {
  StaticFileId: string;
  Source?: StaticFileSource;
}
export const ImageStaticFile = S.suspend(() =>
  S.Struct({ StaticFileId: S.String, Source: S.optional(StaticFileSource) }),
).annotations({
  identifier: "ImageStaticFile",
}) as any as S.Schema<ImageStaticFile>;
export interface SpatialStaticFile {
  StaticFileId: string;
  Source?: StaticFileSource;
}
export const SpatialStaticFile = S.suspend(() =>
  S.Struct({ StaticFileId: S.String, Source: S.optional(StaticFileSource) }),
).annotations({
  identifier: "SpatialStaticFile",
}) as any as S.Schema<SpatialStaticFile>;
export interface StaticFile {
  ImageStaticFile?: ImageStaticFile;
  SpatialStaticFile?: SpatialStaticFile;
}
export const StaticFile = S.suspend(() =>
  S.Struct({
    ImageStaticFile: S.optional(ImageStaticFile),
    SpatialStaticFile: S.optional(SpatialStaticFile),
  }),
).annotations({ identifier: "StaticFile" }) as any as S.Schema<StaticFile>;
export type StaticFileList = StaticFile[];
export const StaticFileList = S.Array(StaticFile);
export interface AnalysisDefinition {
  DataSetIdentifierDeclarations: DataSetIdentifierDeclaration[];
  Sheets?: SheetDefinition[];
  CalculatedFields?: CalculatedField[];
  ParameterDeclarations?: ParameterDeclaration[];
  FilterGroups?: FilterGroup[];
  ColumnConfigurations?: ColumnConfiguration[];
  AnalysisDefaults?: AnalysisDefaults;
  Options?: AssetOptions;
  QueryExecutionOptions?: QueryExecutionOptions;
  StaticFiles?: StaticFile[];
}
export const AnalysisDefinition = S.suspend(() =>
  S.Struct({
    DataSetIdentifierDeclarations: DataSetIdentifierDeclarationList,
    Sheets: S.optional(SheetDefinitionList),
    CalculatedFields: S.optional(CalculatedFields),
    ParameterDeclarations: S.optional(ParameterDeclarationList),
    FilterGroups: S.optional(FilterGroupList),
    ColumnConfigurations: S.optional(ColumnConfigurationList),
    AnalysisDefaults: S.optional(AnalysisDefaults),
    Options: S.optional(AssetOptions),
    QueryExecutionOptions: S.optional(QueryExecutionOptions),
    StaticFiles: S.optional(StaticFileList),
  }),
).annotations({
  identifier: "AnalysisDefinition",
}) as any as S.Schema<AnalysisDefinition>;
export type ValidationStrategyMode = "STRICT" | "LENIENT";
export const ValidationStrategyMode = S.Literal("STRICT", "LENIENT");
export interface ValidationStrategy {
  Mode: ValidationStrategyMode;
}
export const ValidationStrategy = S.suspend(() =>
  S.Struct({ Mode: ValidationStrategyMode }),
).annotations({
  identifier: "ValidationStrategy",
}) as any as S.Schema<ValidationStrategy>;
export interface UpdateAnalysisRequest {
  AwsAccountId: string;
  AnalysisId: string;
  Name: string;
  Parameters?: Parameters;
  SourceEntity?: AnalysisSourceEntity;
  ThemeArn?: string;
  Definition?: AnalysisDefinition;
  ValidationStrategy?: ValidationStrategy;
}
export const UpdateAnalysisRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
    Name: S.String,
    Parameters: S.optional(Parameters),
    SourceEntity: S.optional(AnalysisSourceEntity),
    ThemeArn: S.optional(S.String),
    Definition: S.optional(AnalysisDefinition),
    ValidationStrategy: S.optional(ValidationStrategy),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/analyses/{AnalysisId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateAnalysisRequest",
}) as any as S.Schema<UpdateAnalysisRequest>;
export interface UpdateAnalysisPermissionsRequest {
  AwsAccountId: string;
  AnalysisId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateAnalysisPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
    GrantPermissions: S.optional(UpdateResourcePermissionList),
    RevokePermissions: S.optional(UpdateResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/analyses/{AnalysisId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateAnalysisPermissionsRequest",
}) as any as S.Schema<UpdateAnalysisPermissionsRequest>;
export interface UpdateApplicationWithTokenExchangeGrantRequest {
  AwsAccountId: string;
  Namespace: string;
}
export const UpdateApplicationWithTokenExchangeGrantRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpQuery("namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/application-with-token-exchange-grant",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateApplicationWithTokenExchangeGrantRequest",
}) as any as S.Schema<UpdateApplicationWithTokenExchangeGrantRequest>;
export interface Palette {
  Foreground?: string;
  Background?: string;
}
export const Palette = S.suspend(() =>
  S.Struct({
    Foreground: S.optional(S.String),
    Background: S.optional(S.String),
  }),
).annotations({ identifier: "Palette" }) as any as S.Schema<Palette>;
export interface BrandColorPalette {
  Primary?: Palette;
  Secondary?: Palette;
  Accent?: Palette;
  Measure?: Palette;
  Dimension?: Palette;
  Success?: Palette;
  Info?: Palette;
  Warning?: Palette;
  Danger?: Palette;
}
export const BrandColorPalette = S.suspend(() =>
  S.Struct({
    Primary: S.optional(Palette),
    Secondary: S.optional(Palette),
    Accent: S.optional(Palette),
    Measure: S.optional(Palette),
    Dimension: S.optional(Palette),
    Success: S.optional(Palette),
    Info: S.optional(Palette),
    Warning: S.optional(Palette),
    Danger: S.optional(Palette),
  }),
).annotations({
  identifier: "BrandColorPalette",
}) as any as S.Schema<BrandColorPalette>;
export interface ContextualAccentPalette {
  Connection?: Palette;
  Visualization?: Palette;
  Insight?: Palette;
  Automation?: Palette;
}
export const ContextualAccentPalette = S.suspend(() =>
  S.Struct({
    Connection: S.optional(Palette),
    Visualization: S.optional(Palette),
    Insight: S.optional(Palette),
    Automation: S.optional(Palette),
  }),
).annotations({
  identifier: "ContextualAccentPalette",
}) as any as S.Schema<ContextualAccentPalette>;
export interface NavbarStyle {
  GlobalNavbar?: Palette;
  ContextualNavbar?: Palette;
}
export const NavbarStyle = S.suspend(() =>
  S.Struct({
    GlobalNavbar: S.optional(Palette),
    ContextualNavbar: S.optional(Palette),
  }),
).annotations({ identifier: "NavbarStyle" }) as any as S.Schema<NavbarStyle>;
export interface BrandElementStyle {
  NavbarStyle?: NavbarStyle;
}
export const BrandElementStyle = S.suspend(() =>
  S.Struct({ NavbarStyle: S.optional(NavbarStyle) }),
).annotations({
  identifier: "BrandElementStyle",
}) as any as S.Schema<BrandElementStyle>;
export interface ApplicationTheme {
  BrandColorPalette?: BrandColorPalette;
  ContextualAccentPalette?: ContextualAccentPalette;
  BrandElementStyle?: BrandElementStyle;
}
export const ApplicationTheme = S.suspend(() =>
  S.Struct({
    BrandColorPalette: S.optional(BrandColorPalette),
    ContextualAccentPalette: S.optional(ContextualAccentPalette),
    BrandElementStyle: S.optional(BrandElementStyle),
  }),
).annotations({
  identifier: "ApplicationTheme",
}) as any as S.Schema<ApplicationTheme>;
export type ImageSource = { PublicUrl: string } | { S3Uri: string };
export const ImageSource = S.Union(
  S.Struct({ PublicUrl: S.String }),
  S.Struct({ S3Uri: S.String }),
);
export interface ImageConfiguration {
  Source?: ImageSource;
}
export const ImageConfiguration = S.suspend(() =>
  S.Struct({ Source: S.optional(ImageSource) }),
).annotations({
  identifier: "ImageConfiguration",
}) as any as S.Schema<ImageConfiguration>;
export interface ImageSetConfiguration {
  Original: ImageConfiguration;
}
export const ImageSetConfiguration = S.suspend(() =>
  S.Struct({ Original: ImageConfiguration }),
).annotations({
  identifier: "ImageSetConfiguration",
}) as any as S.Schema<ImageSetConfiguration>;
export interface LogoSetConfiguration {
  Primary: ImageSetConfiguration;
  Favicon?: ImageSetConfiguration;
}
export const LogoSetConfiguration = S.suspend(() =>
  S.Struct({
    Primary: ImageSetConfiguration,
    Favicon: S.optional(ImageSetConfiguration),
  }),
).annotations({
  identifier: "LogoSetConfiguration",
}) as any as S.Schema<LogoSetConfiguration>;
export interface LogoConfiguration {
  AltText: string;
  LogoSet: LogoSetConfiguration;
}
export const LogoConfiguration = S.suspend(() =>
  S.Struct({ AltText: S.String, LogoSet: LogoSetConfiguration }),
).annotations({
  identifier: "LogoConfiguration",
}) as any as S.Schema<LogoConfiguration>;
export interface BrandDefinition {
  BrandName: string;
  Description?: string;
  ApplicationTheme?: ApplicationTheme;
  LogoConfiguration?: LogoConfiguration;
}
export const BrandDefinition = S.suspend(() =>
  S.Struct({
    BrandName: S.String,
    Description: S.optional(S.String),
    ApplicationTheme: S.optional(ApplicationTheme),
    LogoConfiguration: S.optional(LogoConfiguration),
  }),
).annotations({
  identifier: "BrandDefinition",
}) as any as S.Schema<BrandDefinition>;
export interface UpdateBrandRequest {
  AwsAccountId: string;
  BrandId: string;
  BrandDefinition?: BrandDefinition;
}
export const UpdateBrandRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    BrandId: S.String.pipe(T.HttpLabel("BrandId")),
    BrandDefinition: S.optional(BrandDefinition),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/brands/{BrandId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateBrandRequest",
}) as any as S.Schema<UpdateBrandRequest>;
export interface UpdateBrandAssignmentRequest {
  AwsAccountId: string;
  BrandArn: string;
}
export const UpdateBrandAssignmentRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    BrandArn: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/brandassignments",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateBrandAssignmentRequest",
}) as any as S.Schema<UpdateBrandAssignmentRequest>;
export interface UpdateBrandPublishedVersionRequest {
  AwsAccountId: string;
  BrandId: string;
  VersionId: string;
}
export const UpdateBrandPublishedVersionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    BrandId: S.String.pipe(T.HttpLabel("BrandId")),
    VersionId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/brands/{BrandId}/publishedversion",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateBrandPublishedVersionRequest",
}) as any as S.Schema<UpdateBrandPublishedVersionRequest>;
export type CapabilityState = "DENY";
export const CapabilityState = S.Literal("DENY");
export interface Capabilities {
  ExportToCsv?: CapabilityState;
  ExportToExcel?: CapabilityState;
  ExportToPdf?: CapabilityState;
  PrintReports?: CapabilityState;
  CreateAndUpdateThemes?: CapabilityState;
  AddOrRunAnomalyDetectionForAnalyses?: CapabilityState;
  ShareAnalyses?: CapabilityState;
  CreateAndUpdateDatasets?: CapabilityState;
  ShareDatasets?: CapabilityState;
  SubscribeDashboardEmailReports?: CapabilityState;
  CreateAndUpdateDashboardEmailReports?: CapabilityState;
  ShareDashboards?: CapabilityState;
  CreateAndUpdateThresholdAlerts?: CapabilityState;
  RenameSharedFolders?: CapabilityState;
  CreateSharedFolders?: CapabilityState;
  CreateAndUpdateDataSources?: CapabilityState;
  ShareDataSources?: CapabilityState;
  ViewAccountSPICECapacity?: CapabilityState;
  CreateSPICEDataset?: CapabilityState;
  ExportToPdfInScheduledReports?: CapabilityState;
  ExportToCsvInScheduledReports?: CapabilityState;
  ExportToExcelInScheduledReports?: CapabilityState;
  IncludeContentInScheduledReportsEmail?: CapabilityState;
  Dashboard?: CapabilityState;
  Analysis?: CapabilityState;
  Automate?: CapabilityState;
  Flow?: CapabilityState;
  PublishWithoutApproval?: CapabilityState;
  UseBedrockModels?: CapabilityState;
  PerformFlowUiTask?: CapabilityState;
  UseAgentWebSearch?: CapabilityState;
  KnowledgeBase?: CapabilityState;
  Action?: CapabilityState;
  Space?: CapabilityState;
  ChatAgent?: CapabilityState;
  CreateChatAgents?: CapabilityState;
  Research?: CapabilityState;
  SelfUpgradeUserRole?: CapabilityState;
}
export const Capabilities = S.suspend(() =>
  S.Struct({
    ExportToCsv: S.optional(CapabilityState),
    ExportToExcel: S.optional(CapabilityState),
    ExportToPdf: S.optional(CapabilityState),
    PrintReports: S.optional(CapabilityState),
    CreateAndUpdateThemes: S.optional(CapabilityState),
    AddOrRunAnomalyDetectionForAnalyses: S.optional(CapabilityState),
    ShareAnalyses: S.optional(CapabilityState),
    CreateAndUpdateDatasets: S.optional(CapabilityState),
    ShareDatasets: S.optional(CapabilityState),
    SubscribeDashboardEmailReports: S.optional(CapabilityState),
    CreateAndUpdateDashboardEmailReports: S.optional(CapabilityState),
    ShareDashboards: S.optional(CapabilityState),
    CreateAndUpdateThresholdAlerts: S.optional(CapabilityState),
    RenameSharedFolders: S.optional(CapabilityState),
    CreateSharedFolders: S.optional(CapabilityState),
    CreateAndUpdateDataSources: S.optional(CapabilityState),
    ShareDataSources: S.optional(CapabilityState),
    ViewAccountSPICECapacity: S.optional(CapabilityState),
    CreateSPICEDataset: S.optional(CapabilityState),
    ExportToPdfInScheduledReports: S.optional(CapabilityState),
    ExportToCsvInScheduledReports: S.optional(CapabilityState),
    ExportToExcelInScheduledReports: S.optional(CapabilityState),
    IncludeContentInScheduledReportsEmail: S.optional(CapabilityState),
    Dashboard: S.optional(CapabilityState),
    Analysis: S.optional(CapabilityState),
    Automate: S.optional(CapabilityState),
    Flow: S.optional(CapabilityState),
    PublishWithoutApproval: S.optional(CapabilityState),
    UseBedrockModels: S.optional(CapabilityState),
    PerformFlowUiTask: S.optional(CapabilityState),
    UseAgentWebSearch: S.optional(CapabilityState),
    KnowledgeBase: S.optional(CapabilityState),
    Action: S.optional(CapabilityState),
    Space: S.optional(CapabilityState),
    ChatAgent: S.optional(CapabilityState),
    CreateChatAgents: S.optional(CapabilityState),
    Research: S.optional(CapabilityState),
    SelfUpgradeUserRole: S.optional(CapabilityState),
  }),
).annotations({ identifier: "Capabilities" }) as any as S.Schema<Capabilities>;
export interface UpdateCustomPermissionsRequest {
  AwsAccountId: string;
  CustomPermissionsName: string;
  Capabilities?: Capabilities;
}
export const UpdateCustomPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    CustomPermissionsName: S.String.pipe(T.HttpLabel("CustomPermissionsName")),
    Capabilities: S.optional(Capabilities),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/custom-permissions/{CustomPermissionsName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateCustomPermissionsRequest",
}) as any as S.Schema<UpdateCustomPermissionsRequest>;
export interface DashboardSourceTemplate {
  DataSetReferences: DataSetReference[];
  Arn: string;
}
export const DashboardSourceTemplate = S.suspend(() =>
  S.Struct({ DataSetReferences: DataSetReferenceList, Arn: S.String }),
).annotations({
  identifier: "DashboardSourceTemplate",
}) as any as S.Schema<DashboardSourceTemplate>;
export interface DashboardSourceEntity {
  SourceTemplate?: DashboardSourceTemplate;
}
export const DashboardSourceEntity = S.suspend(() =>
  S.Struct({ SourceTemplate: S.optional(DashboardSourceTemplate) }),
).annotations({
  identifier: "DashboardSourceEntity",
}) as any as S.Schema<DashboardSourceEntity>;
export interface AdHocFilteringOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const AdHocFilteringOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "AdHocFilteringOption",
}) as any as S.Schema<AdHocFilteringOption>;
export interface ExportToCSVOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const ExportToCSVOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "ExportToCSVOption",
}) as any as S.Schema<ExportToCSVOption>;
export type DashboardUIState = "EXPANDED" | "COLLAPSED";
export const DashboardUIState = S.Literal("EXPANDED", "COLLAPSED");
export interface SheetControlsOption {
  VisibilityState?: DashboardUIState;
}
export const SheetControlsOption = S.suspend(() =>
  S.Struct({ VisibilityState: S.optional(DashboardUIState) }),
).annotations({
  identifier: "SheetControlsOption",
}) as any as S.Schema<SheetControlsOption>;
export interface ExportHiddenFieldsOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const ExportHiddenFieldsOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "ExportHiddenFieldsOption",
}) as any as S.Schema<ExportHiddenFieldsOption>;
export interface DashboardVisualPublishOptions {
  ExportHiddenFieldsOption?: ExportHiddenFieldsOption;
}
export const DashboardVisualPublishOptions = S.suspend(() =>
  S.Struct({ ExportHiddenFieldsOption: S.optional(ExportHiddenFieldsOption) }),
).annotations({
  identifier: "DashboardVisualPublishOptions",
}) as any as S.Schema<DashboardVisualPublishOptions>;
export interface SheetLayoutElementMaximizationOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const SheetLayoutElementMaximizationOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "SheetLayoutElementMaximizationOption",
}) as any as S.Schema<SheetLayoutElementMaximizationOption>;
export interface VisualAxisSortOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const VisualAxisSortOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "VisualAxisSortOption",
}) as any as S.Schema<VisualAxisSortOption>;
export interface ExportWithHiddenFieldsOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const ExportWithHiddenFieldsOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "ExportWithHiddenFieldsOption",
}) as any as S.Schema<ExportWithHiddenFieldsOption>;
export interface DataPointDrillUpDownOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const DataPointDrillUpDownOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "DataPointDrillUpDownOption",
}) as any as S.Schema<DataPointDrillUpDownOption>;
export interface DataPointMenuLabelOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const DataPointMenuLabelOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "DataPointMenuLabelOption",
}) as any as S.Schema<DataPointMenuLabelOption>;
export interface DataPointTooltipOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const DataPointTooltipOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "DataPointTooltipOption",
}) as any as S.Schema<DataPointTooltipOption>;
export interface DataQAEnabledOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const DataQAEnabledOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "DataQAEnabledOption",
}) as any as S.Schema<DataQAEnabledOption>;
export interface QuickSuiteActionsOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const QuickSuiteActionsOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "QuickSuiteActionsOption",
}) as any as S.Schema<QuickSuiteActionsOption>;
export interface ExecutiveSummaryOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const ExecutiveSummaryOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "ExecutiveSummaryOption",
}) as any as S.Schema<ExecutiveSummaryOption>;
export interface DataStoriesSharingOption {
  AvailabilityStatus?: DashboardBehavior;
}
export const DataStoriesSharingOption = S.suspend(() =>
  S.Struct({ AvailabilityStatus: S.optional(DashboardBehavior) }),
).annotations({
  identifier: "DataStoriesSharingOption",
}) as any as S.Schema<DataStoriesSharingOption>;
export interface DashboardPublishOptions {
  AdHocFilteringOption?: AdHocFilteringOption;
  ExportToCSVOption?: ExportToCSVOption;
  SheetControlsOption?: SheetControlsOption;
  VisualPublishOptions?: DashboardVisualPublishOptions;
  SheetLayoutElementMaximizationOption?: SheetLayoutElementMaximizationOption;
  VisualMenuOption?: VisualMenuOption;
  VisualAxisSortOption?: VisualAxisSortOption;
  ExportWithHiddenFieldsOption?: ExportWithHiddenFieldsOption;
  DataPointDrillUpDownOption?: DataPointDrillUpDownOption;
  DataPointMenuLabelOption?: DataPointMenuLabelOption;
  DataPointTooltipOption?: DataPointTooltipOption;
  DataQAEnabledOption?: DataQAEnabledOption;
  QuickSuiteActionsOption?: QuickSuiteActionsOption;
  ExecutiveSummaryOption?: ExecutiveSummaryOption;
  DataStoriesSharingOption?: DataStoriesSharingOption;
}
export const DashboardPublishOptions = S.suspend(() =>
  S.Struct({
    AdHocFilteringOption: S.optional(AdHocFilteringOption),
    ExportToCSVOption: S.optional(ExportToCSVOption),
    SheetControlsOption: S.optional(SheetControlsOption),
    VisualPublishOptions: S.optional(DashboardVisualPublishOptions),
    SheetLayoutElementMaximizationOption: S.optional(
      SheetLayoutElementMaximizationOption,
    ),
    VisualMenuOption: S.optional(VisualMenuOption),
    VisualAxisSortOption: S.optional(VisualAxisSortOption),
    ExportWithHiddenFieldsOption: S.optional(ExportWithHiddenFieldsOption),
    DataPointDrillUpDownOption: S.optional(DataPointDrillUpDownOption),
    DataPointMenuLabelOption: S.optional(DataPointMenuLabelOption),
    DataPointTooltipOption: S.optional(DataPointTooltipOption),
    DataQAEnabledOption: S.optional(DataQAEnabledOption),
    QuickSuiteActionsOption: S.optional(QuickSuiteActionsOption),
    ExecutiveSummaryOption: S.optional(ExecutiveSummaryOption),
    DataStoriesSharingOption: S.optional(DataStoriesSharingOption),
  }),
).annotations({
  identifier: "DashboardPublishOptions",
}) as any as S.Schema<DashboardPublishOptions>;
export interface DashboardVersionDefinition {
  DataSetIdentifierDeclarations: DataSetIdentifierDeclaration[];
  Sheets?: SheetDefinition[];
  CalculatedFields?: CalculatedField[];
  ParameterDeclarations?: ParameterDeclaration[];
  FilterGroups?: FilterGroup[];
  ColumnConfigurations?: ColumnConfiguration[];
  AnalysisDefaults?: AnalysisDefaults;
  Options?: AssetOptions;
  StaticFiles?: StaticFile[];
}
export const DashboardVersionDefinition = S.suspend(() =>
  S.Struct({
    DataSetIdentifierDeclarations: DataSetIdentifierDeclarationList,
    Sheets: S.optional(SheetDefinitionList),
    CalculatedFields: S.optional(CalculatedFields),
    ParameterDeclarations: S.optional(ParameterDeclarationList),
    FilterGroups: S.optional(FilterGroupList),
    ColumnConfigurations: S.optional(ColumnConfigurationList),
    AnalysisDefaults: S.optional(AnalysisDefaults),
    Options: S.optional(AssetOptions),
    StaticFiles: S.optional(StaticFileList),
  }),
).annotations({
  identifier: "DashboardVersionDefinition",
}) as any as S.Schema<DashboardVersionDefinition>;
export interface UpdateDashboardRequest {
  AwsAccountId: string;
  DashboardId: string;
  Name: string;
  SourceEntity?: DashboardSourceEntity;
  Parameters?: Parameters;
  VersionDescription?: string;
  DashboardPublishOptions?: DashboardPublishOptions;
  ThemeArn?: string;
  Definition?: DashboardVersionDefinition;
  ValidationStrategy?: ValidationStrategy;
}
export const UpdateDashboardRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    Name: S.String,
    SourceEntity: S.optional(DashboardSourceEntity),
    Parameters: S.optional(Parameters),
    VersionDescription: S.optional(S.String),
    DashboardPublishOptions: S.optional(DashboardPublishOptions),
    ThemeArn: S.optional(S.String),
    Definition: S.optional(DashboardVersionDefinition),
    ValidationStrategy: S.optional(ValidationStrategy),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDashboardRequest",
}) as any as S.Schema<UpdateDashboardRequest>;
export interface UpdateDashboardLinksRequest {
  AwsAccountId: string;
  DashboardId: string;
  LinkEntities: string[];
}
export const UpdateDashboardLinksRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    LinkEntities: LinkEntityArnList,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/linked-entities",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDashboardLinksRequest",
}) as any as S.Schema<UpdateDashboardLinksRequest>;
export interface UpdateDashboardPermissionsRequest {
  AwsAccountId: string;
  DashboardId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
  GrantLinkPermissions?: ResourcePermission[];
  RevokeLinkPermissions?: ResourcePermission[];
}
export const UpdateDashboardPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    GrantPermissions: S.optional(UpdateResourcePermissionList),
    RevokePermissions: S.optional(UpdateResourcePermissionList),
    GrantLinkPermissions: S.optional(UpdateLinkPermissionList),
    RevokeLinkPermissions: S.optional(UpdateLinkPermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDashboardPermissionsRequest",
}) as any as S.Schema<UpdateDashboardPermissionsRequest>;
export interface UpdateDashboardPublishedVersionRequest {
  AwsAccountId: string;
  DashboardId: string;
  VersionNumber: number;
}
export const UpdateDashboardPublishedVersionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    VersionNumber: S.Number.pipe(T.HttpLabel("VersionNumber")),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/versions/{VersionNumber}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDashboardPublishedVersionRequest",
}) as any as S.Schema<UpdateDashboardPublishedVersionRequest>;
export interface UpdateDashboardsQAConfigurationRequest {
  AwsAccountId: string;
  DashboardsQAStatus: DashboardsQAStatus;
}
export const UpdateDashboardsQAConfigurationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardsQAStatus: DashboardsQAStatus,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/dashboards-qa-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDashboardsQAConfigurationRequest",
}) as any as S.Schema<UpdateDashboardsQAConfigurationRequest>;
export type InputColumnDataType =
  | "STRING"
  | "INTEGER"
  | "DECIMAL"
  | "DATETIME"
  | "BIT"
  | "BOOLEAN"
  | "JSON";
export const InputColumnDataType = S.Literal(
  "STRING",
  "INTEGER",
  "DECIMAL",
  "DATETIME",
  "BIT",
  "BOOLEAN",
  "JSON",
);
export type ColumnDataSubType = "FLOAT" | "FIXED";
export const ColumnDataSubType = S.Literal("FLOAT", "FIXED");
export interface InputColumn {
  Name: string;
  Id?: string;
  Type: InputColumnDataType;
  SubType?: ColumnDataSubType;
}
export const InputColumn = S.suspend(() =>
  S.Struct({
    Name: S.String,
    Id: S.optional(S.String),
    Type: InputColumnDataType,
    SubType: S.optional(ColumnDataSubType),
  }),
).annotations({ identifier: "InputColumn" }) as any as S.Schema<InputColumn>;
export type InputColumnList = InputColumn[];
export const InputColumnList = S.Array(InputColumn);
export interface RelationalTable {
  DataSourceArn: string;
  Catalog?: string;
  Schema?: string;
  Name: string;
  InputColumns: InputColumn[];
}
export const RelationalTable = S.suspend(() =>
  S.Struct({
    DataSourceArn: S.String,
    Catalog: S.optional(S.String),
    Schema: S.optional(S.String),
    Name: S.String,
    InputColumns: InputColumnList,
  }),
).annotations({
  identifier: "RelationalTable",
}) as any as S.Schema<RelationalTable>;
export interface CustomSql {
  DataSourceArn: string;
  Name: string;
  SqlQuery: string | redacted.Redacted<string>;
  Columns?: InputColumn[];
}
export const CustomSql = S.suspend(() =>
  S.Struct({
    DataSourceArn: S.String,
    Name: S.String,
    SqlQuery: SensitiveString,
    Columns: S.optional(InputColumnList),
  }),
).annotations({ identifier: "CustomSql" }) as any as S.Schema<CustomSql>;
export type FileFormat = "CSV" | "TSV" | "CLF" | "ELF" | "XLSX" | "JSON";
export const FileFormat = S.Literal("CSV", "TSV", "CLF", "ELF", "XLSX", "JSON");
export type TextQualifier = "DOUBLE_QUOTE" | "SINGLE_QUOTE";
export const TextQualifier = S.Literal("DOUBLE_QUOTE", "SINGLE_QUOTE");
export interface UploadSettings {
  Format?: FileFormat;
  StartFromRow?: number;
  ContainsHeader?: boolean;
  TextQualifier?: TextQualifier;
  Delimiter?: string;
  CustomCellAddressRange?: string;
}
export const UploadSettings = S.suspend(() =>
  S.Struct({
    Format: S.optional(FileFormat),
    StartFromRow: S.optional(S.Number),
    ContainsHeader: S.optional(S.Boolean),
    TextQualifier: S.optional(TextQualifier),
    Delimiter: S.optional(S.String),
    CustomCellAddressRange: S.optional(S.String),
  }),
).annotations({
  identifier: "UploadSettings",
}) as any as S.Schema<UploadSettings>;
export interface S3Source {
  DataSourceArn: string;
  UploadSettings?: UploadSettings;
  InputColumns: InputColumn[];
}
export const S3Source = S.suspend(() =>
  S.Struct({
    DataSourceArn: S.String,
    UploadSettings: S.optional(UploadSettings),
    InputColumns: InputColumnList,
  }),
).annotations({ identifier: "S3Source" }) as any as S.Schema<S3Source>;
export interface TablePathElement {
  Name?: string;
  Id?: string;
}
export const TablePathElement = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String), Id: S.optional(S.String) }),
).annotations({
  identifier: "TablePathElement",
}) as any as S.Schema<TablePathElement>;
export type TablePathElementList = TablePathElement[];
export const TablePathElementList = S.Array(TablePathElement);
export interface SaaSTable {
  DataSourceArn: string;
  TablePath: TablePathElement[];
  InputColumns: InputColumn[];
}
export const SaaSTable = S.suspend(() =>
  S.Struct({
    DataSourceArn: S.String,
    TablePath: TablePathElementList,
    InputColumns: InputColumnList,
  }),
).annotations({ identifier: "SaaSTable" }) as any as S.Schema<SaaSTable>;
export type PhysicalTable =
  | { RelationalTable: RelationalTable }
  | { CustomSql: CustomSql }
  | { S3Source: S3Source }
  | { SaaSTable: SaaSTable };
export const PhysicalTable = S.Union(
  S.Struct({ RelationalTable: RelationalTable }),
  S.Struct({ CustomSql: CustomSql }),
  S.Struct({ S3Source: S3Source }),
  S.Struct({ SaaSTable: SaaSTable }),
);
export type PhysicalTableMap = { [key: string]: PhysicalTable };
export const PhysicalTableMap = S.Record({
  key: S.String,
  value: PhysicalTable,
});
export interface DataSetColumnIdMapping {
  SourceColumnId: string;
  TargetColumnId: string;
}
export const DataSetColumnIdMapping = S.suspend(() =>
  S.Struct({ SourceColumnId: S.String, TargetColumnId: S.String }),
).annotations({
  identifier: "DataSetColumnIdMapping",
}) as any as S.Schema<DataSetColumnIdMapping>;
export type DataSetColumnIdMappingList = DataSetColumnIdMapping[];
export const DataSetColumnIdMappingList = S.Array(DataSetColumnIdMapping);
export interface TransformOperationSource {
  TransformOperationId: string;
  ColumnIdMappings?: DataSetColumnIdMapping[];
}
export const TransformOperationSource = S.suspend(() =>
  S.Struct({
    TransformOperationId: S.String,
    ColumnIdMappings: S.optional(DataSetColumnIdMappingList),
  }),
).annotations({
  identifier: "TransformOperationSource",
}) as any as S.Schema<TransformOperationSource>;
export type ProjectedColumnNameList = string[];
export const ProjectedColumnNameList = S.Array(S.String);
export interface ProjectOperation {
  Alias?: string;
  Source?: TransformOperationSource;
  ProjectedColumns: string[];
}
export const ProjectOperation = S.suspend(() =>
  S.Struct({
    Alias: S.optional(S.String),
    Source: S.optional(TransformOperationSource),
    ProjectedColumns: ProjectedColumnNameList,
  }),
).annotations({
  identifier: "ProjectOperation",
}) as any as S.Schema<ProjectOperation>;
export type DataSetStringComparisonFilterOperator =
  | "EQUALS"
  | "DOES_NOT_EQUAL"
  | "CONTAINS"
  | "DOES_NOT_CONTAIN"
  | "STARTS_WITH"
  | "ENDS_WITH";
export const DataSetStringComparisonFilterOperator = S.Literal(
  "EQUALS",
  "DOES_NOT_EQUAL",
  "CONTAINS",
  "DOES_NOT_CONTAIN",
  "STARTS_WITH",
  "ENDS_WITH",
);
export interface DataSetStringFilterValue {
  StaticValue?: string | redacted.Redacted<string>;
}
export const DataSetStringFilterValue = S.suspend(() =>
  S.Struct({ StaticValue: S.optional(SensitiveString) }),
).annotations({
  identifier: "DataSetStringFilterValue",
}) as any as S.Schema<DataSetStringFilterValue>;
export interface DataSetStringComparisonFilterCondition {
  Operator: DataSetStringComparisonFilterOperator;
  Value?: DataSetStringFilterValue;
}
export const DataSetStringComparisonFilterCondition = S.suspend(() =>
  S.Struct({
    Operator: DataSetStringComparisonFilterOperator,
    Value: S.optional(DataSetStringFilterValue),
  }),
).annotations({
  identifier: "DataSetStringComparisonFilterCondition",
}) as any as S.Schema<DataSetStringComparisonFilterCondition>;
export type DataSetStringListFilterOperator = "INCLUDE" | "EXCLUDE";
export const DataSetStringListFilterOperator = S.Literal("INCLUDE", "EXCLUDE");
export type DataSetStringFilterStaticValueList =
  | string
  | redacted.Redacted<string>[];
export const DataSetStringFilterStaticValueList = S.Array(SensitiveString);
export interface DataSetStringListFilterValue {
  StaticValues?: string | redacted.Redacted<string>[];
}
export const DataSetStringListFilterValue = S.suspend(() =>
  S.Struct({ StaticValues: S.optional(DataSetStringFilterStaticValueList) }),
).annotations({
  identifier: "DataSetStringListFilterValue",
}) as any as S.Schema<DataSetStringListFilterValue>;
export interface DataSetStringListFilterCondition {
  Operator: DataSetStringListFilterOperator;
  Values?: DataSetStringListFilterValue;
}
export const DataSetStringListFilterCondition = S.suspend(() =>
  S.Struct({
    Operator: DataSetStringListFilterOperator,
    Values: S.optional(DataSetStringListFilterValue),
  }),
).annotations({
  identifier: "DataSetStringListFilterCondition",
}) as any as S.Schema<DataSetStringListFilterCondition>;
export interface DataSetStringFilterCondition {
  ColumnName?: string;
  ComparisonFilterCondition?: DataSetStringComparisonFilterCondition;
  ListFilterCondition?: DataSetStringListFilterCondition;
}
export const DataSetStringFilterCondition = S.suspend(() =>
  S.Struct({
    ColumnName: S.optional(S.String),
    ComparisonFilterCondition: S.optional(
      DataSetStringComparisonFilterCondition,
    ),
    ListFilterCondition: S.optional(DataSetStringListFilterCondition),
  }),
).annotations({
  identifier: "DataSetStringFilterCondition",
}) as any as S.Schema<DataSetStringFilterCondition>;
export type DataSetNumericComparisonFilterOperator =
  | "EQUALS"
  | "DOES_NOT_EQUAL"
  | "GREATER_THAN"
  | "GREATER_THAN_OR_EQUALS_TO"
  | "LESS_THAN"
  | "LESS_THAN_OR_EQUALS_TO";
export const DataSetNumericComparisonFilterOperator = S.Literal(
  "EQUALS",
  "DOES_NOT_EQUAL",
  "GREATER_THAN",
  "GREATER_THAN_OR_EQUALS_TO",
  "LESS_THAN",
  "LESS_THAN_OR_EQUALS_TO",
);
export interface DataSetNumericFilterValue {
  StaticValue?: number;
}
export const DataSetNumericFilterValue = S.suspend(() =>
  S.Struct({ StaticValue: S.optional(S.Number) }),
).annotations({
  identifier: "DataSetNumericFilterValue",
}) as any as S.Schema<DataSetNumericFilterValue>;
export interface DataSetNumericComparisonFilterCondition {
  Operator: DataSetNumericComparisonFilterOperator;
  Value?: DataSetNumericFilterValue;
}
export const DataSetNumericComparisonFilterCondition = S.suspend(() =>
  S.Struct({
    Operator: DataSetNumericComparisonFilterOperator,
    Value: S.optional(DataSetNumericFilterValue),
  }),
).annotations({
  identifier: "DataSetNumericComparisonFilterCondition",
}) as any as S.Schema<DataSetNumericComparisonFilterCondition>;
export interface DataSetNumericRangeFilterCondition {
  RangeMinimum?: DataSetNumericFilterValue;
  RangeMaximum?: DataSetNumericFilterValue;
  IncludeMinimum?: boolean;
  IncludeMaximum?: boolean;
}
export const DataSetNumericRangeFilterCondition = S.suspend(() =>
  S.Struct({
    RangeMinimum: S.optional(DataSetNumericFilterValue),
    RangeMaximum: S.optional(DataSetNumericFilterValue),
    IncludeMinimum: S.optional(S.Boolean),
    IncludeMaximum: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "DataSetNumericRangeFilterCondition",
}) as any as S.Schema<DataSetNumericRangeFilterCondition>;
export interface DataSetNumericFilterCondition {
  ColumnName?: string;
  ComparisonFilterCondition?: DataSetNumericComparisonFilterCondition;
  RangeFilterCondition?: DataSetNumericRangeFilterCondition;
}
export const DataSetNumericFilterCondition = S.suspend(() =>
  S.Struct({
    ColumnName: S.optional(S.String),
    ComparisonFilterCondition: S.optional(
      DataSetNumericComparisonFilterCondition,
    ),
    RangeFilterCondition: S.optional(DataSetNumericRangeFilterCondition),
  }),
).annotations({
  identifier: "DataSetNumericFilterCondition",
}) as any as S.Schema<DataSetNumericFilterCondition>;
export type DataSetDateComparisonFilterOperator =
  | "BEFORE"
  | "BEFORE_OR_EQUALS_TO"
  | "AFTER"
  | "AFTER_OR_EQUALS_TO";
export const DataSetDateComparisonFilterOperator = S.Literal(
  "BEFORE",
  "BEFORE_OR_EQUALS_TO",
  "AFTER",
  "AFTER_OR_EQUALS_TO",
);
export interface DataSetDateFilterValue {
  StaticValue?: Date;
}
export const DataSetDateFilterValue = S.suspend(() =>
  S.Struct({
    StaticValue: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotations({
  identifier: "DataSetDateFilterValue",
}) as any as S.Schema<DataSetDateFilterValue>;
export interface DataSetDateComparisonFilterCondition {
  Operator: DataSetDateComparisonFilterOperator;
  Value?: DataSetDateFilterValue;
}
export const DataSetDateComparisonFilterCondition = S.suspend(() =>
  S.Struct({
    Operator: DataSetDateComparisonFilterOperator,
    Value: S.optional(DataSetDateFilterValue),
  }),
).annotations({
  identifier: "DataSetDateComparisonFilterCondition",
}) as any as S.Schema<DataSetDateComparisonFilterCondition>;
export interface DataSetDateRangeFilterCondition {
  RangeMinimum?: DataSetDateFilterValue;
  RangeMaximum?: DataSetDateFilterValue;
  IncludeMinimum?: boolean;
  IncludeMaximum?: boolean;
}
export const DataSetDateRangeFilterCondition = S.suspend(() =>
  S.Struct({
    RangeMinimum: S.optional(DataSetDateFilterValue),
    RangeMaximum: S.optional(DataSetDateFilterValue),
    IncludeMinimum: S.optional(S.Boolean),
    IncludeMaximum: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "DataSetDateRangeFilterCondition",
}) as any as S.Schema<DataSetDateRangeFilterCondition>;
export interface DataSetDateFilterCondition {
  ColumnName?: string;
  ComparisonFilterCondition?: DataSetDateComparisonFilterCondition;
  RangeFilterCondition?: DataSetDateRangeFilterCondition;
}
export const DataSetDateFilterCondition = S.suspend(() =>
  S.Struct({
    ColumnName: S.optional(S.String),
    ComparisonFilterCondition: S.optional(DataSetDateComparisonFilterCondition),
    RangeFilterCondition: S.optional(DataSetDateRangeFilterCondition),
  }),
).annotations({
  identifier: "DataSetDateFilterCondition",
}) as any as S.Schema<DataSetDateFilterCondition>;
export interface FilterOperation {
  ConditionExpression?: string | redacted.Redacted<string>;
  StringFilterCondition?: DataSetStringFilterCondition;
  NumericFilterCondition?: DataSetNumericFilterCondition;
  DateFilterCondition?: DataSetDateFilterCondition;
}
export const FilterOperation = S.suspend(() =>
  S.Struct({
    ConditionExpression: S.optional(SensitiveString),
    StringFilterCondition: S.optional(DataSetStringFilterCondition),
    NumericFilterCondition: S.optional(DataSetNumericFilterCondition),
    DateFilterCondition: S.optional(DataSetDateFilterCondition),
  }),
).annotations({
  identifier: "FilterOperation",
}) as any as S.Schema<FilterOperation>;
export interface CalculatedColumn {
  ColumnName: string;
  ColumnId: string;
  Expression: string | redacted.Redacted<string>;
}
export const CalculatedColumn = S.suspend(() =>
  S.Struct({
    ColumnName: S.String,
    ColumnId: S.String,
    Expression: SensitiveString,
  }),
).annotations({
  identifier: "CalculatedColumn",
}) as any as S.Schema<CalculatedColumn>;
export type CalculatedColumnList = CalculatedColumn[];
export const CalculatedColumnList = S.Array(CalculatedColumn);
export interface CreateColumnsOperation {
  Alias?: string;
  Source?: TransformOperationSource;
  Columns: CalculatedColumn[];
}
export const CreateColumnsOperation = S.suspend(() =>
  S.Struct({
    Alias: S.optional(S.String),
    Source: S.optional(TransformOperationSource),
    Columns: CalculatedColumnList,
  }),
).annotations({
  identifier: "CreateColumnsOperation",
}) as any as S.Schema<CreateColumnsOperation>;
export interface RenameColumnOperation {
  ColumnName: string;
  NewColumnName: string;
}
export const RenameColumnOperation = S.suspend(() =>
  S.Struct({ ColumnName: S.String, NewColumnName: S.String }),
).annotations({
  identifier: "RenameColumnOperation",
}) as any as S.Schema<RenameColumnOperation>;
export type ColumnDataType = "STRING" | "INTEGER" | "DECIMAL" | "DATETIME";
export const ColumnDataType = S.Literal(
  "STRING",
  "INTEGER",
  "DECIMAL",
  "DATETIME",
);
export interface CastColumnTypeOperation {
  ColumnName: string;
  NewColumnType: ColumnDataType;
  SubType?: ColumnDataSubType;
  Format?: string;
}
export const CastColumnTypeOperation = S.suspend(() =>
  S.Struct({
    ColumnName: S.String,
    NewColumnType: ColumnDataType,
    SubType: S.optional(ColumnDataSubType),
    Format: S.optional(S.String),
  }),
).annotations({
  identifier: "CastColumnTypeOperation",
}) as any as S.Schema<CastColumnTypeOperation>;
export type GeoSpatialDataRole =
  | "COUNTRY"
  | "STATE"
  | "COUNTY"
  | "CITY"
  | "POSTCODE"
  | "LONGITUDE"
  | "LATITUDE";
export const GeoSpatialDataRole = S.Literal(
  "COUNTRY",
  "STATE",
  "COUNTY",
  "CITY",
  "POSTCODE",
  "LONGITUDE",
  "LATITUDE",
);
export interface ColumnDescription {
  Text?: string | redacted.Redacted<string>;
}
export const ColumnDescription = S.suspend(() =>
  S.Struct({ Text: S.optional(SensitiveString) }),
).annotations({
  identifier: "ColumnDescription",
}) as any as S.Schema<ColumnDescription>;
export interface ColumnTag {
  ColumnGeographicRole?: GeoSpatialDataRole;
  ColumnDescription?: ColumnDescription;
}
export const ColumnTag = S.suspend(() =>
  S.Struct({
    ColumnGeographicRole: S.optional(GeoSpatialDataRole),
    ColumnDescription: S.optional(ColumnDescription),
  }),
).annotations({ identifier: "ColumnTag" }) as any as S.Schema<ColumnTag>;
export type ColumnTagList = ColumnTag[];
export const ColumnTagList = S.Array(ColumnTag);
export interface TagColumnOperation {
  ColumnName: string;
  Tags: ColumnTag[];
}
export const TagColumnOperation = S.suspend(() =>
  S.Struct({ ColumnName: S.String, Tags: ColumnTagList }),
).annotations({
  identifier: "TagColumnOperation",
}) as any as S.Schema<TagColumnOperation>;
export type ColumnTagName = "COLUMN_GEOGRAPHIC_ROLE" | "COLUMN_DESCRIPTION";
export const ColumnTagName = S.Literal(
  "COLUMN_GEOGRAPHIC_ROLE",
  "COLUMN_DESCRIPTION",
);
export type ColumnTagNames = ColumnTagName[];
export const ColumnTagNames = S.Array(ColumnTagName);
export interface UntagColumnOperation {
  ColumnName: string;
  TagNames: ColumnTagName[];
}
export const UntagColumnOperation = S.suspend(() =>
  S.Struct({ ColumnName: S.String, TagNames: ColumnTagNames }),
).annotations({
  identifier: "UntagColumnOperation",
}) as any as S.Schema<UntagColumnOperation>;
export type StringDatasetParameterValueList = string[];
export const StringDatasetParameterValueList = S.Array(S.String);
export type DecimalDatasetParameterValueList = number[];
export const DecimalDatasetParameterValueList = S.Array(S.Number);
export type DateTimeDatasetParameterValueList = Date[];
export const DateTimeDatasetParameterValueList = S.Array(
  S.Date.pipe(T.TimestampFormat("epoch-seconds")),
);
export type IntegerDatasetParameterValueList = number[];
export const IntegerDatasetParameterValueList = S.Array(S.Number);
export interface NewDefaultValues {
  StringStaticValues?: string[];
  DecimalStaticValues?: number[];
  DateTimeStaticValues?: Date[];
  IntegerStaticValues?: number[];
}
export const NewDefaultValues = S.suspend(() =>
  S.Struct({
    StringStaticValues: S.optional(StringDatasetParameterValueList),
    DecimalStaticValues: S.optional(DecimalDatasetParameterValueList),
    DateTimeStaticValues: S.optional(DateTimeDatasetParameterValueList),
    IntegerStaticValues: S.optional(IntegerDatasetParameterValueList),
  }),
).annotations({
  identifier: "NewDefaultValues",
}) as any as S.Schema<NewDefaultValues>;
export interface OverrideDatasetParameterOperation {
  ParameterName: string;
  NewParameterName?: string;
  NewDefaultValues?: NewDefaultValues;
}
export const OverrideDatasetParameterOperation = S.suspend(() =>
  S.Struct({
    ParameterName: S.String,
    NewParameterName: S.optional(S.String),
    NewDefaultValues: S.optional(NewDefaultValues),
  }),
).annotations({
  identifier: "OverrideDatasetParameterOperation",
}) as any as S.Schema<OverrideDatasetParameterOperation>;
export type TransformOperation =
  | { ProjectOperation: ProjectOperation }
  | { FilterOperation: FilterOperation }
  | { CreateColumnsOperation: CreateColumnsOperation }
  | { RenameColumnOperation: RenameColumnOperation }
  | { CastColumnTypeOperation: CastColumnTypeOperation }
  | { TagColumnOperation: TagColumnOperation }
  | { UntagColumnOperation: UntagColumnOperation }
  | { OverrideDatasetParameterOperation: OverrideDatasetParameterOperation };
export const TransformOperation = S.Union(
  S.Struct({ ProjectOperation: ProjectOperation }),
  S.Struct({ FilterOperation: FilterOperation }),
  S.Struct({ CreateColumnsOperation: CreateColumnsOperation }),
  S.Struct({ RenameColumnOperation: RenameColumnOperation }),
  S.Struct({ CastColumnTypeOperation: CastColumnTypeOperation }),
  S.Struct({ TagColumnOperation: TagColumnOperation }),
  S.Struct({ UntagColumnOperation: UntagColumnOperation }),
  S.Struct({
    OverrideDatasetParameterOperation: OverrideDatasetParameterOperation,
  }),
);
export type TransformOperationList = TransformOperation[];
export const TransformOperationList = S.Array(TransformOperation);
export interface JoinKeyProperties {
  UniqueKey?: boolean;
}
export const JoinKeyProperties = S.suspend(() =>
  S.Struct({ UniqueKey: S.optional(S.Boolean) }),
).annotations({
  identifier: "JoinKeyProperties",
}) as any as S.Schema<JoinKeyProperties>;
export type JoinType = "INNER" | "OUTER" | "LEFT" | "RIGHT";
export const JoinType = S.Literal("INNER", "OUTER", "LEFT", "RIGHT");
export interface JoinInstruction {
  LeftOperand: string;
  RightOperand: string;
  LeftJoinKeyProperties?: JoinKeyProperties;
  RightJoinKeyProperties?: JoinKeyProperties;
  Type: JoinType;
  OnClause: string;
}
export const JoinInstruction = S.suspend(() =>
  S.Struct({
    LeftOperand: S.String,
    RightOperand: S.String,
    LeftJoinKeyProperties: S.optional(JoinKeyProperties),
    RightJoinKeyProperties: S.optional(JoinKeyProperties),
    Type: JoinType,
    OnClause: S.String,
  }),
).annotations({
  identifier: "JoinInstruction",
}) as any as S.Schema<JoinInstruction>;
export interface LogicalTableSource {
  JoinInstruction?: JoinInstruction;
  PhysicalTableId?: string;
  DataSetArn?: string;
}
export const LogicalTableSource = S.suspend(() =>
  S.Struct({
    JoinInstruction: S.optional(JoinInstruction),
    PhysicalTableId: S.optional(S.String),
    DataSetArn: S.optional(S.String),
  }),
).annotations({
  identifier: "LogicalTableSource",
}) as any as S.Schema<LogicalTableSource>;
export interface LogicalTable {
  Alias: string;
  DataTransforms?: TransformOperation[];
  Source: LogicalTableSource;
}
export const LogicalTable = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    DataTransforms: S.optional(TransformOperationList),
    Source: LogicalTableSource,
  }),
).annotations({ identifier: "LogicalTable" }) as any as S.Schema<LogicalTable>;
export type LogicalTableMap = { [key: string]: LogicalTable };
export const LogicalTableMap = S.Record({ key: S.String, value: LogicalTable });
export type GeoSpatialCountryCode = "US";
export const GeoSpatialCountryCode = S.Literal("US");
export type ColumnList = string[];
export const ColumnList = S.Array(S.String);
export interface GeoSpatialColumnGroup {
  Name: string;
  CountryCode?: GeoSpatialCountryCode;
  Columns: string[];
}
export const GeoSpatialColumnGroup = S.suspend(() =>
  S.Struct({
    Name: S.String,
    CountryCode: S.optional(GeoSpatialCountryCode),
    Columns: ColumnList,
  }),
).annotations({
  identifier: "GeoSpatialColumnGroup",
}) as any as S.Schema<GeoSpatialColumnGroup>;
export interface ColumnGroup {
  GeoSpatialColumnGroup?: GeoSpatialColumnGroup;
}
export const ColumnGroup = S.suspend(() =>
  S.Struct({ GeoSpatialColumnGroup: S.optional(GeoSpatialColumnGroup) }),
).annotations({ identifier: "ColumnGroup" }) as any as S.Schema<ColumnGroup>;
export type ColumnGroupList = ColumnGroup[];
export const ColumnGroupList = S.Array(ColumnGroup);
export type FolderColumnList = string[];
export const FolderColumnList = S.Array(S.String);
export interface FieldFolder {
  description?: string;
  columns?: string[];
}
export const FieldFolder = S.suspend(() =>
  S.Struct({
    description: S.optional(S.String),
    columns: S.optional(FolderColumnList),
  }),
).annotations({ identifier: "FieldFolder" }) as any as S.Schema<FieldFolder>;
export type FieldFolderMap = { [key: string]: FieldFolder };
export const FieldFolderMap = S.Record({ key: S.String, value: FieldFolder });
export type RowLevelPermissionPolicy = "GRANT_ACCESS" | "DENY_ACCESS";
export const RowLevelPermissionPolicy = S.Literal(
  "GRANT_ACCESS",
  "DENY_ACCESS",
);
export type RowLevelPermissionFormatVersion = "VERSION_1" | "VERSION_2";
export const RowLevelPermissionFormatVersion = S.Literal(
  "VERSION_1",
  "VERSION_2",
);
export type Status = "ENABLED" | "DISABLED";
export const Status = S.Literal("ENABLED", "DISABLED");
export interface RowLevelPermissionDataSet {
  Namespace?: string;
  Arn: string;
  PermissionPolicy: RowLevelPermissionPolicy;
  FormatVersion?: RowLevelPermissionFormatVersion;
  Status?: Status;
}
export const RowLevelPermissionDataSet = S.suspend(() =>
  S.Struct({
    Namespace: S.optional(S.String),
    Arn: S.String,
    PermissionPolicy: RowLevelPermissionPolicy,
    FormatVersion: S.optional(RowLevelPermissionFormatVersion),
    Status: S.optional(Status),
  }),
).annotations({
  identifier: "RowLevelPermissionDataSet",
}) as any as S.Schema<RowLevelPermissionDataSet>;
export interface RowLevelPermissionTagRule {
  TagKey: string;
  ColumnName: string;
  TagMultiValueDelimiter?: string;
  MatchAllValue?: string | redacted.Redacted<string>;
}
export const RowLevelPermissionTagRule = S.suspend(() =>
  S.Struct({
    TagKey: S.String,
    ColumnName: S.String,
    TagMultiValueDelimiter: S.optional(S.String),
    MatchAllValue: S.optional(SensitiveString),
  }),
).annotations({
  identifier: "RowLevelPermissionTagRule",
}) as any as S.Schema<RowLevelPermissionTagRule>;
export type RowLevelPermissionTagRuleList = RowLevelPermissionTagRule[];
export const RowLevelPermissionTagRuleList = S.Array(RowLevelPermissionTagRule);
export type RowLevelPermissionTagRuleConfiguration = string[];
export const RowLevelPermissionTagRuleConfiguration = S.Array(S.String);
export type RowLevelPermissionTagRuleConfigurationList = string[][];
export const RowLevelPermissionTagRuleConfigurationList = S.Array(
  RowLevelPermissionTagRuleConfiguration,
);
export interface RowLevelPermissionTagConfiguration {
  Status?: Status;
  TagRules: RowLevelPermissionTagRule[];
  TagRuleConfigurations?: string[][];
}
export const RowLevelPermissionTagConfiguration = S.suspend(() =>
  S.Struct({
    Status: S.optional(Status),
    TagRules: RowLevelPermissionTagRuleList,
    TagRuleConfigurations: S.optional(
      RowLevelPermissionTagRuleConfigurationList,
    ),
  }),
).annotations({
  identifier: "RowLevelPermissionTagConfiguration",
}) as any as S.Schema<RowLevelPermissionTagConfiguration>;
export type PrincipalList = string[];
export const PrincipalList = S.Array(S.String);
export type ColumnLevelPermissionRuleColumnNameList = string[];
export const ColumnLevelPermissionRuleColumnNameList = S.Array(S.String);
export interface ColumnLevelPermissionRule {
  Principals?: string[];
  ColumnNames?: string[];
}
export const ColumnLevelPermissionRule = S.suspend(() =>
  S.Struct({
    Principals: S.optional(PrincipalList),
    ColumnNames: S.optional(ColumnLevelPermissionRuleColumnNameList),
  }),
).annotations({
  identifier: "ColumnLevelPermissionRule",
}) as any as S.Schema<ColumnLevelPermissionRule>;
export type ColumnLevelPermissionRuleList = ColumnLevelPermissionRule[];
export const ColumnLevelPermissionRuleList = S.Array(ColumnLevelPermissionRule);
export interface DataSetUsageConfiguration {
  DisableUseAsDirectQuerySource?: boolean;
  DisableUseAsImportedSource?: boolean;
}
export const DataSetUsageConfiguration = S.suspend(() =>
  S.Struct({
    DisableUseAsDirectQuerySource: S.optional(S.Boolean),
    DisableUseAsImportedSource: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "DataSetUsageConfiguration",
}) as any as S.Schema<DataSetUsageConfiguration>;
export type DatasetParameterValueType = "MULTI_VALUED" | "SINGLE_VALUED";
export const DatasetParameterValueType = S.Literal(
  "MULTI_VALUED",
  "SINGLE_VALUED",
);
export interface StringDatasetParameterDefaultValues {
  StaticValues?: string[];
}
export const StringDatasetParameterDefaultValues = S.suspend(() =>
  S.Struct({ StaticValues: S.optional(StringDatasetParameterValueList) }),
).annotations({
  identifier: "StringDatasetParameterDefaultValues",
}) as any as S.Schema<StringDatasetParameterDefaultValues>;
export interface StringDatasetParameter {
  Id: string;
  Name: string;
  ValueType: DatasetParameterValueType;
  DefaultValues?: StringDatasetParameterDefaultValues;
}
export const StringDatasetParameter = S.suspend(() =>
  S.Struct({
    Id: S.String,
    Name: S.String,
    ValueType: DatasetParameterValueType,
    DefaultValues: S.optional(StringDatasetParameterDefaultValues),
  }),
).annotations({
  identifier: "StringDatasetParameter",
}) as any as S.Schema<StringDatasetParameter>;
export interface DecimalDatasetParameterDefaultValues {
  StaticValues?: number[];
}
export const DecimalDatasetParameterDefaultValues = S.suspend(() =>
  S.Struct({ StaticValues: S.optional(DecimalDatasetParameterValueList) }),
).annotations({
  identifier: "DecimalDatasetParameterDefaultValues",
}) as any as S.Schema<DecimalDatasetParameterDefaultValues>;
export interface DecimalDatasetParameter {
  Id: string;
  Name: string;
  ValueType: DatasetParameterValueType;
  DefaultValues?: DecimalDatasetParameterDefaultValues;
}
export const DecimalDatasetParameter = S.suspend(() =>
  S.Struct({
    Id: S.String,
    Name: S.String,
    ValueType: DatasetParameterValueType,
    DefaultValues: S.optional(DecimalDatasetParameterDefaultValues),
  }),
).annotations({
  identifier: "DecimalDatasetParameter",
}) as any as S.Schema<DecimalDatasetParameter>;
export interface IntegerDatasetParameterDefaultValues {
  StaticValues?: number[];
}
export const IntegerDatasetParameterDefaultValues = S.suspend(() =>
  S.Struct({ StaticValues: S.optional(IntegerDatasetParameterValueList) }),
).annotations({
  identifier: "IntegerDatasetParameterDefaultValues",
}) as any as S.Schema<IntegerDatasetParameterDefaultValues>;
export interface IntegerDatasetParameter {
  Id: string;
  Name: string;
  ValueType: DatasetParameterValueType;
  DefaultValues?: IntegerDatasetParameterDefaultValues;
}
export const IntegerDatasetParameter = S.suspend(() =>
  S.Struct({
    Id: S.String,
    Name: S.String,
    ValueType: DatasetParameterValueType,
    DefaultValues: S.optional(IntegerDatasetParameterDefaultValues),
  }),
).annotations({
  identifier: "IntegerDatasetParameter",
}) as any as S.Schema<IntegerDatasetParameter>;
export interface DateTimeDatasetParameterDefaultValues {
  StaticValues?: Date[];
}
export const DateTimeDatasetParameterDefaultValues = S.suspend(() =>
  S.Struct({ StaticValues: S.optional(DateTimeDatasetParameterValueList) }),
).annotations({
  identifier: "DateTimeDatasetParameterDefaultValues",
}) as any as S.Schema<DateTimeDatasetParameterDefaultValues>;
export interface DateTimeDatasetParameter {
  Id: string;
  Name: string;
  ValueType: DatasetParameterValueType;
  TimeGranularity?: TimeGranularity;
  DefaultValues?: DateTimeDatasetParameterDefaultValues;
}
export const DateTimeDatasetParameter = S.suspend(() =>
  S.Struct({
    Id: S.String,
    Name: S.String,
    ValueType: DatasetParameterValueType,
    TimeGranularity: S.optional(TimeGranularity),
    DefaultValues: S.optional(DateTimeDatasetParameterDefaultValues),
  }),
).annotations({
  identifier: "DateTimeDatasetParameter",
}) as any as S.Schema<DateTimeDatasetParameter>;
export interface DatasetParameter {
  StringDatasetParameter?: StringDatasetParameter;
  DecimalDatasetParameter?: DecimalDatasetParameter;
  IntegerDatasetParameter?: IntegerDatasetParameter;
  DateTimeDatasetParameter?: DateTimeDatasetParameter;
}
export const DatasetParameter = S.suspend(() =>
  S.Struct({
    StringDatasetParameter: S.optional(StringDatasetParameter),
    DecimalDatasetParameter: S.optional(DecimalDatasetParameter),
    IntegerDatasetParameter: S.optional(IntegerDatasetParameter),
    DateTimeDatasetParameter: S.optional(DateTimeDatasetParameter),
  }),
).annotations({
  identifier: "DatasetParameter",
}) as any as S.Schema<DatasetParameter>;
export type DatasetParameterList = DatasetParameter[];
export const DatasetParameterList = S.Array(DatasetParameter);
export type UniqueKeyColumnNameList = string[];
export const UniqueKeyColumnNameList = S.Array(S.String);
export interface UniqueKey {
  ColumnNames: string[];
}
export const UniqueKey = S.suspend(() =>
  S.Struct({ ColumnNames: UniqueKeyColumnNameList }),
).annotations({ identifier: "UniqueKey" }) as any as S.Schema<UniqueKey>;
export type UniqueKeyList = UniqueKey[];
export const UniqueKeyList = S.Array(UniqueKey);
export interface PerformanceConfiguration {
  UniqueKeys?: UniqueKey[];
}
export const PerformanceConfiguration = S.suspend(() =>
  S.Struct({ UniqueKeys: S.optional(UniqueKeyList) }),
).annotations({
  identifier: "PerformanceConfiguration",
}) as any as S.Schema<PerformanceConfiguration>;
export interface ParentDataSet {
  DataSetArn: string;
  InputColumns: InputColumn[];
}
export const ParentDataSet = S.suspend(() =>
  S.Struct({ DataSetArn: S.String, InputColumns: InputColumnList }),
).annotations({
  identifier: "ParentDataSet",
}) as any as S.Schema<ParentDataSet>;
export interface SourceTable {
  PhysicalTableId?: string;
  DataSet?: ParentDataSet;
}
export const SourceTable = S.suspend(() =>
  S.Struct({
    PhysicalTableId: S.optional(S.String),
    DataSet: S.optional(ParentDataSet),
  }),
).annotations({ identifier: "SourceTable" }) as any as S.Schema<SourceTable>;
export type SourceTableMap = { [key: string]: SourceTable };
export const SourceTableMap = S.Record({ key: S.String, value: SourceTable });
export interface ImportTableOperationSource {
  SourceTableId: string;
  ColumnIdMappings?: DataSetColumnIdMapping[];
}
export const ImportTableOperationSource = S.suspend(() =>
  S.Struct({
    SourceTableId: S.String,
    ColumnIdMappings: S.optional(DataSetColumnIdMappingList),
  }),
).annotations({
  identifier: "ImportTableOperationSource",
}) as any as S.Schema<ImportTableOperationSource>;
export interface ImportTableOperation {
  Alias: string;
  Source: ImportTableOperationSource;
}
export const ImportTableOperation = S.suspend(() =>
  S.Struct({ Alias: S.String, Source: ImportTableOperationSource }),
).annotations({
  identifier: "ImportTableOperation",
}) as any as S.Schema<ImportTableOperation>;
export type FilterOperationList = FilterOperation[];
export const FilterOperationList = S.Array(FilterOperation);
export interface FiltersOperation {
  Alias: string;
  Source: TransformOperationSource;
  FilterOperations: FilterOperation[];
}
export const FiltersOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    Source: TransformOperationSource,
    FilterOperations: FilterOperationList,
  }),
).annotations({
  identifier: "FiltersOperation",
}) as any as S.Schema<FiltersOperation>;
export type RenameColumnOperationList = RenameColumnOperation[];
export const RenameColumnOperationList = S.Array(RenameColumnOperation);
export interface RenameColumnsOperation {
  Alias: string;
  Source: TransformOperationSource;
  RenameColumnOperations: RenameColumnOperation[];
}
export const RenameColumnsOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    Source: TransformOperationSource,
    RenameColumnOperations: RenameColumnOperationList,
  }),
).annotations({
  identifier: "RenameColumnsOperation",
}) as any as S.Schema<RenameColumnsOperation>;
export type CastColumnTypeOperationList = CastColumnTypeOperation[];
export const CastColumnTypeOperationList = S.Array(CastColumnTypeOperation);
export interface CastColumnTypesOperation {
  Alias: string;
  Source: TransformOperationSource;
  CastColumnTypeOperations: CastColumnTypeOperation[];
}
export const CastColumnTypesOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    Source: TransformOperationSource,
    CastColumnTypeOperations: CastColumnTypeOperationList,
  }),
).annotations({
  identifier: "CastColumnTypesOperation",
}) as any as S.Schema<CastColumnTypesOperation>;
export type JoinOperationType = "INNER" | "OUTER" | "LEFT" | "RIGHT";
export const JoinOperationType = S.Literal("INNER", "OUTER", "LEFT", "RIGHT");
export interface OutputColumnNameOverride {
  SourceColumnName?: string;
  OutputColumnName: string;
}
export const OutputColumnNameOverride = S.suspend(() =>
  S.Struct({
    SourceColumnName: S.optional(S.String),
    OutputColumnName: S.String,
  }),
).annotations({
  identifier: "OutputColumnNameOverride",
}) as any as S.Schema<OutputColumnNameOverride>;
export type OutputColumnNameOverrideList = OutputColumnNameOverride[];
export const OutputColumnNameOverrideList = S.Array(OutputColumnNameOverride);
export interface JoinOperandProperties {
  OutputColumnNameOverrides: OutputColumnNameOverride[];
}
export const JoinOperandProperties = S.suspend(() =>
  S.Struct({ OutputColumnNameOverrides: OutputColumnNameOverrideList }),
).annotations({
  identifier: "JoinOperandProperties",
}) as any as S.Schema<JoinOperandProperties>;
export interface JoinOperation {
  Alias: string;
  LeftOperand: TransformOperationSource;
  RightOperand: TransformOperationSource;
  Type: JoinOperationType;
  OnClause: string | redacted.Redacted<string>;
  LeftOperandProperties?: JoinOperandProperties;
  RightOperandProperties?: JoinOperandProperties;
}
export const JoinOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    LeftOperand: TransformOperationSource,
    RightOperand: TransformOperationSource,
    Type: JoinOperationType,
    OnClause: SensitiveString,
    LeftOperandProperties: S.optional(JoinOperandProperties),
    RightOperandProperties: S.optional(JoinOperandProperties),
  }),
).annotations({
  identifier: "JoinOperation",
}) as any as S.Schema<JoinOperation>;
export type GroupByColumnNameList = string[];
export const GroupByColumnNameList = S.Array(S.String);
export type DataPrepSimpleAggregationFunctionType =
  | "COUNT"
  | "DISTINCT_COUNT"
  | "SUM"
  | "AVERAGE"
  | "MAX"
  | "MIN";
export const DataPrepSimpleAggregationFunctionType = S.Literal(
  "COUNT",
  "DISTINCT_COUNT",
  "SUM",
  "AVERAGE",
  "MAX",
  "MIN",
);
export interface DataPrepSimpleAggregationFunction {
  InputColumnName?: string;
  FunctionType: DataPrepSimpleAggregationFunctionType;
}
export const DataPrepSimpleAggregationFunction = S.suspend(() =>
  S.Struct({
    InputColumnName: S.optional(S.String),
    FunctionType: DataPrepSimpleAggregationFunctionType,
  }),
).annotations({
  identifier: "DataPrepSimpleAggregationFunction",
}) as any as S.Schema<DataPrepSimpleAggregationFunction>;
export interface DataPrepListAggregationFunction {
  InputColumnName?: string;
  Separator: string;
  Distinct: boolean;
}
export const DataPrepListAggregationFunction = S.suspend(() =>
  S.Struct({
    InputColumnName: S.optional(S.String),
    Separator: S.String,
    Distinct: S.Boolean,
  }),
).annotations({
  identifier: "DataPrepListAggregationFunction",
}) as any as S.Schema<DataPrepListAggregationFunction>;
export interface DataPrepAggregationFunction {
  SimpleAggregation?: DataPrepSimpleAggregationFunction;
  ListAggregation?: DataPrepListAggregationFunction;
}
export const DataPrepAggregationFunction = S.suspend(() =>
  S.Struct({
    SimpleAggregation: S.optional(DataPrepSimpleAggregationFunction),
    ListAggregation: S.optional(DataPrepListAggregationFunction),
  }),
).annotations({
  identifier: "DataPrepAggregationFunction",
}) as any as S.Schema<DataPrepAggregationFunction>;
export interface Aggregation {
  AggregationFunction: DataPrepAggregationFunction;
  NewColumnName: string;
  NewColumnId: string;
}
export const Aggregation = S.suspend(() =>
  S.Struct({
    AggregationFunction: DataPrepAggregationFunction,
    NewColumnName: S.String,
    NewColumnId: S.String,
  }),
).annotations({ identifier: "Aggregation" }) as any as S.Schema<Aggregation>;
export type AggregationList = Aggregation[];
export const AggregationList = S.Array(Aggregation);
export interface AggregateOperation {
  Alias: string;
  Source: TransformOperationSource;
  GroupByColumnNames?: string[];
  Aggregations: Aggregation[];
}
export const AggregateOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    Source: TransformOperationSource,
    GroupByColumnNames: S.optional(GroupByColumnNameList),
    Aggregations: AggregationList,
  }),
).annotations({
  identifier: "AggregateOperation",
}) as any as S.Schema<AggregateOperation>;
export type PivotGroupByColumnNameList = string[];
export const PivotGroupByColumnNameList = S.Array(S.String);
export interface ValueColumnConfiguration {
  AggregationFunction?: DataPrepAggregationFunction;
}
export const ValueColumnConfiguration = S.suspend(() =>
  S.Struct({ AggregationFunction: S.optional(DataPrepAggregationFunction) }),
).annotations({
  identifier: "ValueColumnConfiguration",
}) as any as S.Schema<ValueColumnConfiguration>;
export interface PivotedLabel {
  LabelName: string;
  NewColumnName: string;
  NewColumnId: string;
}
export const PivotedLabel = S.suspend(() =>
  S.Struct({
    LabelName: S.String,
    NewColumnName: S.String,
    NewColumnId: S.String,
  }),
).annotations({ identifier: "PivotedLabel" }) as any as S.Schema<PivotedLabel>;
export type PivotedLabelList = PivotedLabel[];
export const PivotedLabelList = S.Array(PivotedLabel);
export interface PivotConfiguration {
  LabelColumnName?: string;
  PivotedLabels: PivotedLabel[];
}
export const PivotConfiguration = S.suspend(() =>
  S.Struct({
    LabelColumnName: S.optional(S.String),
    PivotedLabels: PivotedLabelList,
  }),
).annotations({
  identifier: "PivotConfiguration",
}) as any as S.Schema<PivotConfiguration>;
export interface PivotOperation {
  Alias: string;
  Source: TransformOperationSource;
  GroupByColumnNames?: string[];
  ValueColumnConfiguration: ValueColumnConfiguration;
  PivotConfiguration: PivotConfiguration;
}
export const PivotOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    Source: TransformOperationSource,
    GroupByColumnNames: S.optional(PivotGroupByColumnNameList),
    ValueColumnConfiguration: ValueColumnConfiguration,
    PivotConfiguration: PivotConfiguration,
  }),
).annotations({
  identifier: "PivotOperation",
}) as any as S.Schema<PivotOperation>;
export interface ColumnToUnpivot {
  ColumnName?: string;
  NewValue?: string;
}
export const ColumnToUnpivot = S.suspend(() =>
  S.Struct({
    ColumnName: S.optional(S.String),
    NewValue: S.optional(S.String),
  }),
).annotations({
  identifier: "ColumnToUnpivot",
}) as any as S.Schema<ColumnToUnpivot>;
export type ColumnToUnpivotList = ColumnToUnpivot[];
export const ColumnToUnpivotList = S.Array(ColumnToUnpivot);
export interface UnpivotOperation {
  Alias: string;
  Source: TransformOperationSource;
  ColumnsToUnpivot: ColumnToUnpivot[];
  UnpivotedLabelColumnName: string;
  UnpivotedLabelColumnId: string;
  UnpivotedValueColumnName: string;
  UnpivotedValueColumnId: string;
}
export const UnpivotOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    Source: TransformOperationSource,
    ColumnsToUnpivot: ColumnToUnpivotList,
    UnpivotedLabelColumnName: S.String,
    UnpivotedLabelColumnId: S.String,
    UnpivotedValueColumnName: S.String,
    UnpivotedValueColumnId: S.String,
  }),
).annotations({
  identifier: "UnpivotOperation",
}) as any as S.Schema<UnpivotOperation>;
export interface AppendedColumn {
  ColumnName: string;
  NewColumnId: string;
}
export const AppendedColumn = S.suspend(() =>
  S.Struct({ ColumnName: S.String, NewColumnId: S.String }),
).annotations({
  identifier: "AppendedColumn",
}) as any as S.Schema<AppendedColumn>;
export type AppendedColumnList = AppendedColumn[];
export const AppendedColumnList = S.Array(AppendedColumn);
export interface AppendOperation {
  Alias: string;
  FirstSource?: TransformOperationSource;
  SecondSource?: TransformOperationSource;
  AppendedColumns: AppendedColumn[];
}
export const AppendOperation = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    FirstSource: S.optional(TransformOperationSource),
    SecondSource: S.optional(TransformOperationSource),
    AppendedColumns: AppendedColumnList,
  }),
).annotations({
  identifier: "AppendOperation",
}) as any as S.Schema<AppendOperation>;
export interface TransformStep {
  ImportTableStep?: ImportTableOperation;
  ProjectStep?: ProjectOperation;
  FiltersStep?: FiltersOperation;
  CreateColumnsStep?: CreateColumnsOperation;
  RenameColumnsStep?: RenameColumnsOperation;
  CastColumnTypesStep?: CastColumnTypesOperation;
  JoinStep?: JoinOperation;
  AggregateStep?: AggregateOperation;
  PivotStep?: PivotOperation;
  UnpivotStep?: UnpivotOperation;
  AppendStep?: AppendOperation;
}
export const TransformStep = S.suspend(() =>
  S.Struct({
    ImportTableStep: S.optional(ImportTableOperation),
    ProjectStep: S.optional(ProjectOperation),
    FiltersStep: S.optional(FiltersOperation),
    CreateColumnsStep: S.optional(CreateColumnsOperation),
    RenameColumnsStep: S.optional(RenameColumnsOperation),
    CastColumnTypesStep: S.optional(CastColumnTypesOperation),
    JoinStep: S.optional(JoinOperation),
    AggregateStep: S.optional(AggregateOperation),
    PivotStep: S.optional(PivotOperation),
    UnpivotStep: S.optional(UnpivotOperation),
    AppendStep: S.optional(AppendOperation),
  }),
).annotations({
  identifier: "TransformStep",
}) as any as S.Schema<TransformStep>;
export type TransformStepMap = { [key: string]: TransformStep };
export const TransformStepMap = S.Record({
  key: S.String,
  value: TransformStep,
});
export interface DestinationTableSource {
  TransformOperationId: string;
}
export const DestinationTableSource = S.suspend(() =>
  S.Struct({ TransformOperationId: S.String }),
).annotations({
  identifier: "DestinationTableSource",
}) as any as S.Schema<DestinationTableSource>;
export interface DestinationTable {
  Alias: string;
  Source: DestinationTableSource;
}
export const DestinationTable = S.suspend(() =>
  S.Struct({ Alias: S.String, Source: DestinationTableSource }),
).annotations({
  identifier: "DestinationTable",
}) as any as S.Schema<DestinationTable>;
export type DestinationTableMap = { [key: string]: DestinationTable };
export const DestinationTableMap = S.Record({
  key: S.String,
  value: DestinationTable,
});
export interface DataPrepConfiguration {
  SourceTableMap: { [key: string]: SourceTable };
  TransformStepMap: { [key: string]: TransformStep };
  DestinationTableMap: { [key: string]: DestinationTable };
}
export const DataPrepConfiguration = S.suspend(() =>
  S.Struct({
    SourceTableMap: SourceTableMap,
    TransformStepMap: TransformStepMap,
    DestinationTableMap: DestinationTableMap,
  }),
).annotations({
  identifier: "DataPrepConfiguration",
}) as any as S.Schema<DataPrepConfiguration>;
export interface RowLevelPermissionConfiguration {
  TagConfiguration?: RowLevelPermissionTagConfiguration;
  RowLevelPermissionDataSet?: RowLevelPermissionDataSet;
}
export const RowLevelPermissionConfiguration = S.suspend(() =>
  S.Struct({
    TagConfiguration: S.optional(RowLevelPermissionTagConfiguration),
    RowLevelPermissionDataSet: S.optional(RowLevelPermissionDataSet),
  }),
).annotations({
  identifier: "RowLevelPermissionConfiguration",
}) as any as S.Schema<RowLevelPermissionConfiguration>;
export interface SemanticTable {
  Alias: string;
  DestinationTableId: string;
  RowLevelPermissionConfiguration?: RowLevelPermissionConfiguration;
}
export const SemanticTable = S.suspend(() =>
  S.Struct({
    Alias: S.String,
    DestinationTableId: S.String,
    RowLevelPermissionConfiguration: S.optional(
      RowLevelPermissionConfiguration,
    ),
  }),
).annotations({
  identifier: "SemanticTable",
}) as any as S.Schema<SemanticTable>;
export type SemanticTableMap = { [key: string]: SemanticTable };
export const SemanticTableMap = S.Record({
  key: S.String,
  value: SemanticTable,
});
export interface SemanticModelConfiguration {
  TableMap?: { [key: string]: SemanticTable };
}
export const SemanticModelConfiguration = S.suspend(() =>
  S.Struct({ TableMap: S.optional(SemanticTableMap) }),
).annotations({
  identifier: "SemanticModelConfiguration",
}) as any as S.Schema<SemanticModelConfiguration>;
export interface UpdateDataSetRequest {
  AwsAccountId: string;
  DataSetId: string;
  Name: string;
  PhysicalTableMap: { [key: string]: PhysicalTable };
  LogicalTableMap?: { [key: string]: LogicalTable };
  ImportMode: DataSetImportMode;
  ColumnGroups?: ColumnGroup[];
  FieldFolders?: { [key: string]: FieldFolder };
  RowLevelPermissionDataSet?: RowLevelPermissionDataSet;
  RowLevelPermissionTagConfiguration?: RowLevelPermissionTagConfiguration;
  ColumnLevelPermissionRules?: ColumnLevelPermissionRule[];
  DataSetUsageConfiguration?: DataSetUsageConfiguration;
  DatasetParameters?: DatasetParameter[];
  PerformanceConfiguration?: PerformanceConfiguration;
  DataPrepConfiguration?: DataPrepConfiguration;
  SemanticModelConfiguration?: SemanticModelConfiguration;
}
export const UpdateDataSetRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    Name: S.String,
    PhysicalTableMap: PhysicalTableMap,
    LogicalTableMap: S.optional(LogicalTableMap),
    ImportMode: DataSetImportMode,
    ColumnGroups: S.optional(ColumnGroupList),
    FieldFolders: S.optional(FieldFolderMap),
    RowLevelPermissionDataSet: S.optional(RowLevelPermissionDataSet),
    RowLevelPermissionTagConfiguration: S.optional(
      RowLevelPermissionTagConfiguration,
    ),
    ColumnLevelPermissionRules: S.optional(ColumnLevelPermissionRuleList),
    DataSetUsageConfiguration: S.optional(DataSetUsageConfiguration),
    DatasetParameters: S.optional(DatasetParameterList),
    PerformanceConfiguration: S.optional(PerformanceConfiguration),
    DataPrepConfiguration: S.optional(DataPrepConfiguration),
    SemanticModelConfiguration: S.optional(SemanticModelConfiguration),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDataSetRequest",
}) as any as S.Schema<UpdateDataSetRequest>;
export interface UpdateDataSetPermissionsRequest {
  AwsAccountId: string;
  DataSetId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateDataSetPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    GrantPermissions: S.optional(ResourcePermissionList),
    RevokePermissions: S.optional(ResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDataSetPermissionsRequest",
}) as any as S.Schema<UpdateDataSetPermissionsRequest>;
export interface AmazonElasticsearchParameters {
  Domain: string;
}
export const AmazonElasticsearchParameters = S.suspend(() =>
  S.Struct({ Domain: S.String }),
).annotations({
  identifier: "AmazonElasticsearchParameters",
}) as any as S.Schema<AmazonElasticsearchParameters>;
export interface IdentityCenterConfiguration {
  EnableIdentityPropagation?: boolean;
}
export const IdentityCenterConfiguration = S.suspend(() =>
  S.Struct({ EnableIdentityPropagation: S.optional(S.Boolean) }),
).annotations({
  identifier: "IdentityCenterConfiguration",
}) as any as S.Schema<IdentityCenterConfiguration>;
export interface AthenaParameters {
  WorkGroup?: string;
  RoleArn?: string;
  IdentityCenterConfiguration?: IdentityCenterConfiguration;
}
export const AthenaParameters = S.suspend(() =>
  S.Struct({
    WorkGroup: S.optional(S.String),
    RoleArn: S.optional(S.String),
    IdentityCenterConfiguration: S.optional(IdentityCenterConfiguration),
  }),
).annotations({
  identifier: "AthenaParameters",
}) as any as S.Schema<AthenaParameters>;
export interface AuroraParameters {
  Host: string;
  Port: number;
  Database: string;
}
export const AuroraParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Database: S.String }),
).annotations({
  identifier: "AuroraParameters",
}) as any as S.Schema<AuroraParameters>;
export interface AuroraPostgreSqlParameters {
  Host: string;
  Port: number;
  Database: string;
}
export const AuroraPostgreSqlParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Database: S.String }),
).annotations({
  identifier: "AuroraPostgreSqlParameters",
}) as any as S.Schema<AuroraPostgreSqlParameters>;
export interface AwsIotAnalyticsParameters {
  DataSetName: string;
}
export const AwsIotAnalyticsParameters = S.suspend(() =>
  S.Struct({ DataSetName: S.String }),
).annotations({
  identifier: "AwsIotAnalyticsParameters",
}) as any as S.Schema<AwsIotAnalyticsParameters>;
export interface JiraParameters {
  SiteBaseUrl: string;
}
export const JiraParameters = S.suspend(() =>
  S.Struct({ SiteBaseUrl: S.String }),
).annotations({
  identifier: "JiraParameters",
}) as any as S.Schema<JiraParameters>;
export interface MariaDbParameters {
  Host: string;
  Port: number;
  Database: string;
}
export const MariaDbParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Database: S.String }),
).annotations({
  identifier: "MariaDbParameters",
}) as any as S.Schema<MariaDbParameters>;
export interface MySqlParameters {
  Host: string;
  Port: number;
  Database: string;
}
export const MySqlParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Database: S.String }),
).annotations({
  identifier: "MySqlParameters",
}) as any as S.Schema<MySqlParameters>;
export interface OracleParameters {
  Host: string;
  Port: number;
  Database: string;
  UseServiceName?: boolean;
}
export const OracleParameters = S.suspend(() =>
  S.Struct({
    Host: S.String,
    Port: S.Number,
    Database: S.String,
    UseServiceName: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "OracleParameters",
}) as any as S.Schema<OracleParameters>;
export interface PostgreSqlParameters {
  Host: string;
  Port: number;
  Database: string;
}
export const PostgreSqlParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Database: S.String }),
).annotations({
  identifier: "PostgreSqlParameters",
}) as any as S.Schema<PostgreSqlParameters>;
export interface PrestoParameters {
  Host: string;
  Port: number;
  Catalog: string;
}
export const PrestoParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Catalog: S.String }),
).annotations({
  identifier: "PrestoParameters",
}) as any as S.Schema<PrestoParameters>;
export interface RdsParameters {
  InstanceId: string;
  Database: string;
}
export const RdsParameters = S.suspend(() =>
  S.Struct({ InstanceId: S.String, Database: S.String }),
).annotations({
  identifier: "RdsParameters",
}) as any as S.Schema<RdsParameters>;
export type DatabaseGroupList = string[];
export const DatabaseGroupList = S.Array(S.String);
export interface RedshiftIAMParameters {
  RoleArn: string;
  DatabaseUser?: string;
  DatabaseGroups?: string[];
  AutoCreateDatabaseUser?: boolean;
}
export const RedshiftIAMParameters = S.suspend(() =>
  S.Struct({
    RoleArn: S.String,
    DatabaseUser: S.optional(S.String),
    DatabaseGroups: S.optional(DatabaseGroupList),
    AutoCreateDatabaseUser: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "RedshiftIAMParameters",
}) as any as S.Schema<RedshiftIAMParameters>;
export interface RedshiftParameters {
  Host?: string;
  Port?: number;
  Database: string;
  ClusterId?: string;
  IAMParameters?: RedshiftIAMParameters;
  IdentityCenterConfiguration?: IdentityCenterConfiguration;
}
export const RedshiftParameters = S.suspend(() =>
  S.Struct({
    Host: S.optional(S.String),
    Port: S.optional(S.Number),
    Database: S.String,
    ClusterId: S.optional(S.String),
    IAMParameters: S.optional(RedshiftIAMParameters),
    IdentityCenterConfiguration: S.optional(IdentityCenterConfiguration),
  }),
).annotations({
  identifier: "RedshiftParameters",
}) as any as S.Schema<RedshiftParameters>;
export interface ManifestFileLocation {
  Bucket: string;
  Key: string;
}
export const ManifestFileLocation = S.suspend(() =>
  S.Struct({ Bucket: S.String, Key: S.String }),
).annotations({
  identifier: "ManifestFileLocation",
}) as any as S.Schema<ManifestFileLocation>;
export interface S3Parameters {
  ManifestFileLocation: ManifestFileLocation;
  RoleArn?: string;
}
export const S3Parameters = S.suspend(() =>
  S.Struct({
    ManifestFileLocation: ManifestFileLocation,
    RoleArn: S.optional(S.String),
  }),
).annotations({ identifier: "S3Parameters" }) as any as S.Schema<S3Parameters>;
export interface S3KnowledgeBaseParameters {
  RoleArn?: string;
  BucketUrl: string;
  MetadataFilesLocation?: string;
}
export const S3KnowledgeBaseParameters = S.suspend(() =>
  S.Struct({
    RoleArn: S.optional(S.String),
    BucketUrl: S.String,
    MetadataFilesLocation: S.optional(S.String),
  }),
).annotations({
  identifier: "S3KnowledgeBaseParameters",
}) as any as S.Schema<S3KnowledgeBaseParameters>;
export interface ServiceNowParameters {
  SiteBaseUrl: string;
}
export const ServiceNowParameters = S.suspend(() =>
  S.Struct({ SiteBaseUrl: S.String }),
).annotations({
  identifier: "ServiceNowParameters",
}) as any as S.Schema<ServiceNowParameters>;
export type AuthenticationType = "PASSWORD" | "TOKEN" | "X509";
export const AuthenticationType = S.Literal("PASSWORD", "TOKEN", "X509");
export interface VpcConnectionProperties {
  VpcConnectionArn: string;
}
export const VpcConnectionProperties = S.suspend(() =>
  S.Struct({ VpcConnectionArn: S.String }),
).annotations({
  identifier: "VpcConnectionProperties",
}) as any as S.Schema<VpcConnectionProperties>;
export interface OAuthParameters {
  TokenProviderUrl: string;
  OAuthScope?: string;
  IdentityProviderVpcConnectionProperties?: VpcConnectionProperties;
  IdentityProviderResourceUri?: string;
}
export const OAuthParameters = S.suspend(() =>
  S.Struct({
    TokenProviderUrl: S.String,
    OAuthScope: S.optional(S.String),
    IdentityProviderVpcConnectionProperties: S.optional(
      VpcConnectionProperties,
    ),
    IdentityProviderResourceUri: S.optional(S.String),
  }),
).annotations({
  identifier: "OAuthParameters",
}) as any as S.Schema<OAuthParameters>;
export interface SnowflakeParameters {
  Host: string;
  Database: string;
  Warehouse: string;
  AuthenticationType?: AuthenticationType;
  DatabaseAccessControlRole?: string;
  OAuthParameters?: OAuthParameters;
}
export const SnowflakeParameters = S.suspend(() =>
  S.Struct({
    Host: S.String,
    Database: S.String,
    Warehouse: S.String,
    AuthenticationType: S.optional(AuthenticationType),
    DatabaseAccessControlRole: S.optional(S.String),
    OAuthParameters: S.optional(OAuthParameters),
  }),
).annotations({
  identifier: "SnowflakeParameters",
}) as any as S.Schema<SnowflakeParameters>;
export interface SparkParameters {
  Host: string;
  Port: number;
}
export const SparkParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number }),
).annotations({
  identifier: "SparkParameters",
}) as any as S.Schema<SparkParameters>;
export interface SqlServerParameters {
  Host: string;
  Port: number;
  Database: string;
}
export const SqlServerParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Database: S.String }),
).annotations({
  identifier: "SqlServerParameters",
}) as any as S.Schema<SqlServerParameters>;
export interface TeradataParameters {
  Host: string;
  Port: number;
  Database: string;
}
export const TeradataParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Database: S.String }),
).annotations({
  identifier: "TeradataParameters",
}) as any as S.Schema<TeradataParameters>;
export interface TwitterParameters {
  Query: string;
  MaxRows: number;
}
export const TwitterParameters = S.suspend(() =>
  S.Struct({ Query: S.String, MaxRows: S.Number }),
).annotations({
  identifier: "TwitterParameters",
}) as any as S.Schema<TwitterParameters>;
export interface AmazonOpenSearchParameters {
  Domain: string;
}
export const AmazonOpenSearchParameters = S.suspend(() =>
  S.Struct({ Domain: S.String }),
).annotations({
  identifier: "AmazonOpenSearchParameters",
}) as any as S.Schema<AmazonOpenSearchParameters>;
export interface ExasolParameters {
  Host: string;
  Port: number;
}
export const ExasolParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number }),
).annotations({
  identifier: "ExasolParameters",
}) as any as S.Schema<ExasolParameters>;
export interface DatabricksParameters {
  Host: string;
  Port: number;
  SqlEndpointPath: string;
}
export const DatabricksParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, SqlEndpointPath: S.String }),
).annotations({
  identifier: "DatabricksParameters",
}) as any as S.Schema<DatabricksParameters>;
export type StarburstProductType = "GALAXY" | "ENTERPRISE";
export const StarburstProductType = S.Literal("GALAXY", "ENTERPRISE");
export interface StarburstParameters {
  Host: string;
  Port: number;
  Catalog: string;
  ProductType?: StarburstProductType;
  DatabaseAccessControlRole?: string;
  AuthenticationType?: AuthenticationType;
  OAuthParameters?: OAuthParameters;
}
export const StarburstParameters = S.suspend(() =>
  S.Struct({
    Host: S.String,
    Port: S.Number,
    Catalog: S.String,
    ProductType: S.optional(StarburstProductType),
    DatabaseAccessControlRole: S.optional(S.String),
    AuthenticationType: S.optional(AuthenticationType),
    OAuthParameters: S.optional(OAuthParameters),
  }),
).annotations({
  identifier: "StarburstParameters",
}) as any as S.Schema<StarburstParameters>;
export interface TrinoParameters {
  Host: string;
  Port: number;
  Catalog: string;
}
export const TrinoParameters = S.suspend(() =>
  S.Struct({ Host: S.String, Port: S.Number, Catalog: S.String }),
).annotations({
  identifier: "TrinoParameters",
}) as any as S.Schema<TrinoParameters>;
export interface BigQueryParameters {
  ProjectId: string;
  DataSetRegion?: string;
}
export const BigQueryParameters = S.suspend(() =>
  S.Struct({ ProjectId: S.String, DataSetRegion: S.optional(S.String) }),
).annotations({
  identifier: "BigQueryParameters",
}) as any as S.Schema<BigQueryParameters>;
export interface ImpalaParameters {
  Host: string;
  Port: number;
  Database?: string;
  SqlEndpointPath: string;
}
export const ImpalaParameters = S.suspend(() =>
  S.Struct({
    Host: S.String,
    Port: S.Number,
    Database: S.optional(S.String),
    SqlEndpointPath: S.String,
  }),
).annotations({
  identifier: "ImpalaParameters",
}) as any as S.Schema<ImpalaParameters>;
export interface CustomConnectionParameters {
  ConnectionType?: string;
}
export const CustomConnectionParameters = S.suspend(() =>
  S.Struct({ ConnectionType: S.optional(S.String) }),
).annotations({
  identifier: "CustomConnectionParameters",
}) as any as S.Schema<CustomConnectionParameters>;
export type WebCrawlerAuthType = "NO_AUTH" | "BASIC_AUTH" | "FORM" | "SAML";
export const WebCrawlerAuthType = S.Literal(
  "NO_AUTH",
  "BASIC_AUTH",
  "FORM",
  "SAML",
);
export interface WebCrawlerParameters {
  WebCrawlerAuthType: WebCrawlerAuthType;
  UsernameFieldXpath?: string;
  PasswordFieldXpath?: string;
  UsernameButtonXpath?: string;
  PasswordButtonXpath?: string;
  LoginPageUrl?: string;
  WebProxyHostName?: string;
  WebProxyPortNumber?: number;
}
export const WebCrawlerParameters = S.suspend(() =>
  S.Struct({
    WebCrawlerAuthType: WebCrawlerAuthType,
    UsernameFieldXpath: S.optional(S.String),
    PasswordFieldXpath: S.optional(S.String),
    UsernameButtonXpath: S.optional(S.String),
    PasswordButtonXpath: S.optional(S.String),
    LoginPageUrl: S.optional(S.String),
    WebProxyHostName: S.optional(S.String),
    WebProxyPortNumber: S.optional(S.Number),
  }),
).annotations({
  identifier: "WebCrawlerParameters",
}) as any as S.Schema<WebCrawlerParameters>;
export interface ConfluenceParameters {
  ConfluenceUrl: string;
}
export const ConfluenceParameters = S.suspend(() =>
  S.Struct({ ConfluenceUrl: S.String }),
).annotations({
  identifier: "ConfluenceParameters",
}) as any as S.Schema<ConfluenceParameters>;
export interface QBusinessParameters {
  ApplicationArn: string;
}
export const QBusinessParameters = S.suspend(() =>
  S.Struct({ ApplicationArn: S.String }),
).annotations({
  identifier: "QBusinessParameters",
}) as any as S.Schema<QBusinessParameters>;
export type DataSourceParameters =
  | { AmazonElasticsearchParameters: AmazonElasticsearchParameters }
  | { AthenaParameters: AthenaParameters }
  | { AuroraParameters: AuroraParameters }
  | { AuroraPostgreSqlParameters: AuroraPostgreSqlParameters }
  | { AwsIotAnalyticsParameters: AwsIotAnalyticsParameters }
  | { JiraParameters: JiraParameters }
  | { MariaDbParameters: MariaDbParameters }
  | { MySqlParameters: MySqlParameters }
  | { OracleParameters: OracleParameters }
  | { PostgreSqlParameters: PostgreSqlParameters }
  | { PrestoParameters: PrestoParameters }
  | { RdsParameters: RdsParameters }
  | { RedshiftParameters: RedshiftParameters }
  | { S3Parameters: S3Parameters }
  | { S3KnowledgeBaseParameters: S3KnowledgeBaseParameters }
  | { ServiceNowParameters: ServiceNowParameters }
  | { SnowflakeParameters: SnowflakeParameters }
  | { SparkParameters: SparkParameters }
  | { SqlServerParameters: SqlServerParameters }
  | { TeradataParameters: TeradataParameters }
  | { TwitterParameters: TwitterParameters }
  | { AmazonOpenSearchParameters: AmazonOpenSearchParameters }
  | { ExasolParameters: ExasolParameters }
  | { DatabricksParameters: DatabricksParameters }
  | { StarburstParameters: StarburstParameters }
  | { TrinoParameters: TrinoParameters }
  | { BigQueryParameters: BigQueryParameters }
  | { ImpalaParameters: ImpalaParameters }
  | { CustomConnectionParameters: CustomConnectionParameters }
  | { WebCrawlerParameters: WebCrawlerParameters }
  | { ConfluenceParameters: ConfluenceParameters }
  | { QBusinessParameters: QBusinessParameters };
export const DataSourceParameters = S.Union(
  S.Struct({ AmazonElasticsearchParameters: AmazonElasticsearchParameters }),
  S.Struct({ AthenaParameters: AthenaParameters }),
  S.Struct({ AuroraParameters: AuroraParameters }),
  S.Struct({ AuroraPostgreSqlParameters: AuroraPostgreSqlParameters }),
  S.Struct({ AwsIotAnalyticsParameters: AwsIotAnalyticsParameters }),
  S.Struct({ JiraParameters: JiraParameters }),
  S.Struct({ MariaDbParameters: MariaDbParameters }),
  S.Struct({ MySqlParameters: MySqlParameters }),
  S.Struct({ OracleParameters: OracleParameters }),
  S.Struct({ PostgreSqlParameters: PostgreSqlParameters }),
  S.Struct({ PrestoParameters: PrestoParameters }),
  S.Struct({ RdsParameters: RdsParameters }),
  S.Struct({ RedshiftParameters: RedshiftParameters }),
  S.Struct({ S3Parameters: S3Parameters }),
  S.Struct({ S3KnowledgeBaseParameters: S3KnowledgeBaseParameters }),
  S.Struct({ ServiceNowParameters: ServiceNowParameters }),
  S.Struct({ SnowflakeParameters: SnowflakeParameters }),
  S.Struct({ SparkParameters: SparkParameters }),
  S.Struct({ SqlServerParameters: SqlServerParameters }),
  S.Struct({ TeradataParameters: TeradataParameters }),
  S.Struct({ TwitterParameters: TwitterParameters }),
  S.Struct({ AmazonOpenSearchParameters: AmazonOpenSearchParameters }),
  S.Struct({ ExasolParameters: ExasolParameters }),
  S.Struct({ DatabricksParameters: DatabricksParameters }),
  S.Struct({ StarburstParameters: StarburstParameters }),
  S.Struct({ TrinoParameters: TrinoParameters }),
  S.Struct({ BigQueryParameters: BigQueryParameters }),
  S.Struct({ ImpalaParameters: ImpalaParameters }),
  S.Struct({ CustomConnectionParameters: CustomConnectionParameters }),
  S.Struct({ WebCrawlerParameters: WebCrawlerParameters }),
  S.Struct({ ConfluenceParameters: ConfluenceParameters }),
  S.Struct({ QBusinessParameters: QBusinessParameters }),
);
export type DataSourceParametersList = DataSourceParameters[];
export const DataSourceParametersList = S.Array(DataSourceParameters);
export interface CredentialPair {
  Username: string;
  Password: string;
  AlternateDataSourceParameters?: DataSourceParameters[];
}
export const CredentialPair = S.suspend(() =>
  S.Struct({
    Username: S.String,
    Password: S.String,
    AlternateDataSourceParameters: S.optional(DataSourceParametersList),
  }),
).annotations({
  identifier: "CredentialPair",
}) as any as S.Schema<CredentialPair>;
export interface KeyPairCredentials {
  KeyPairUsername: string;
  PrivateKey: string | redacted.Redacted<string>;
  PrivateKeyPassphrase?: string | redacted.Redacted<string>;
}
export const KeyPairCredentials = S.suspend(() =>
  S.Struct({
    KeyPairUsername: S.String,
    PrivateKey: SensitiveString,
    PrivateKeyPassphrase: S.optional(SensitiveString),
  }),
).annotations({
  identifier: "KeyPairCredentials",
}) as any as S.Schema<KeyPairCredentials>;
export interface WebProxyCredentials {
  WebProxyUsername: string;
  WebProxyPassword: string;
}
export const WebProxyCredentials = S.suspend(() =>
  S.Struct({ WebProxyUsername: S.String, WebProxyPassword: S.String }),
).annotations({
  identifier: "WebProxyCredentials",
}) as any as S.Schema<WebProxyCredentials>;
export interface DataSourceCredentials {
  CredentialPair?: CredentialPair;
  CopySourceArn?: string;
  SecretArn?: string;
  KeyPairCredentials?: KeyPairCredentials;
  WebProxyCredentials?: WebProxyCredentials;
}
export const DataSourceCredentials = S.suspend(() =>
  S.Struct({
    CredentialPair: S.optional(CredentialPair),
    CopySourceArn: S.optional(S.String),
    SecretArn: S.optional(S.String),
    KeyPairCredentials: S.optional(KeyPairCredentials),
    WebProxyCredentials: S.optional(WebProxyCredentials),
  }),
).annotations({
  identifier: "DataSourceCredentials",
}) as any as S.Schema<DataSourceCredentials>;
export interface SslProperties {
  DisableSsl?: boolean;
}
export const SslProperties = S.suspend(() =>
  S.Struct({ DisableSsl: S.optional(S.Boolean) }),
).annotations({
  identifier: "SslProperties",
}) as any as S.Schema<SslProperties>;
export interface UpdateDataSourceRequest {
  AwsAccountId: string;
  DataSourceId: string;
  Name: string;
  DataSourceParameters?: DataSourceParameters;
  Credentials?: DataSourceCredentials;
  VpcConnectionProperties?: VpcConnectionProperties;
  SslProperties?: SslProperties;
}
export const UpdateDataSourceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSourceId: S.String.pipe(T.HttpLabel("DataSourceId")),
    Name: S.String,
    DataSourceParameters: S.optional(DataSourceParameters),
    Credentials: S.optional(DataSourceCredentials),
    VpcConnectionProperties: S.optional(VpcConnectionProperties),
    SslProperties: S.optional(SslProperties),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/data-sources/{DataSourceId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDataSourceRequest",
}) as any as S.Schema<UpdateDataSourceRequest>;
export interface UpdateDataSourcePermissionsRequest {
  AwsAccountId: string;
  DataSourceId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateDataSourcePermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSourceId: S.String.pipe(T.HttpLabel("DataSourceId")),
    GrantPermissions: S.optional(ResourcePermissionList),
    RevokePermissions: S.optional(ResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/data-sources/{DataSourceId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDataSourcePermissionsRequest",
}) as any as S.Schema<UpdateDataSourcePermissionsRequest>;
export interface UpdateDefaultQBusinessApplicationRequest {
  AwsAccountId: string;
  Namespace?: string;
  ApplicationId: string;
}
export const UpdateDefaultQBusinessApplicationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
    ApplicationId: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/default-qbusiness-application",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateDefaultQBusinessApplicationRequest",
}) as any as S.Schema<UpdateDefaultQBusinessApplicationRequest>;
export interface UpdateFolderRequest {
  AwsAccountId: string;
  FolderId: string;
  Name: string;
}
export const UpdateFolderRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    Name: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateFolderRequest",
}) as any as S.Schema<UpdateFolderRequest>;
export interface UpdateFolderPermissionsRequest {
  AwsAccountId: string;
  FolderId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateFolderPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FolderId: S.String.pipe(T.HttpLabel("FolderId")),
    GrantPermissions: S.optional(ResourcePermissionList),
    RevokePermissions: S.optional(ResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/folders/{FolderId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateFolderPermissionsRequest",
}) as any as S.Schema<UpdateFolderPermissionsRequest>;
export interface UpdateGroupRequest {
  GroupName: string;
  Description?: string;
  AwsAccountId: string;
  Namespace: string;
}
export const UpdateGroupRequest = S.suspend(() =>
  S.Struct({
    GroupName: S.String.pipe(T.HttpLabel("GroupName")),
    Description: S.optional(S.String),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateGroupRequest",
}) as any as S.Schema<UpdateGroupRequest>;
export type IdentityNameList = string[];
export const IdentityNameList = S.Array(S.String);
export type IdentityMap = { [key: string]: string[] };
export const IdentityMap = S.Record({ key: S.String, value: IdentityNameList });
export interface UpdateIAMPolicyAssignmentRequest {
  AwsAccountId: string;
  AssignmentName: string;
  Namespace: string;
  AssignmentStatus?: AssignmentStatus;
  PolicyArn?: string;
  Identities?: { [key: string]: string[] };
}
export const UpdateIAMPolicyAssignmentRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssignmentName: S.String.pipe(T.HttpLabel("AssignmentName")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    AssignmentStatus: S.optional(AssignmentStatus),
    PolicyArn: S.optional(S.String),
    Identities: S.optional(IdentityMap),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/iam-policy-assignments/{AssignmentName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateIAMPolicyAssignmentRequest",
}) as any as S.Schema<UpdateIAMPolicyAssignmentRequest>;
export interface UpdateIdentityPropagationConfigRequest {
  AwsAccountId: string;
  Service: ServiceType;
  AuthorizedTargets?: string[];
}
export const UpdateIdentityPropagationConfigRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Service: ServiceType.pipe(T.HttpLabel("Service")),
    AuthorizedTargets: S.optional(AuthorizedTargetsList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/identity-propagation-config/{Service}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateIdentityPropagationConfigRequest",
}) as any as S.Schema<UpdateIdentityPropagationConfigRequest>;
export interface UpdatePublicSharingSettingsRequest {
  AwsAccountId: string;
  PublicSharingEnabled?: boolean;
}
export const UpdatePublicSharingSettingsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    PublicSharingEnabled: S.optional(S.Boolean),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/public-sharing-settings",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdatePublicSharingSettingsRequest",
}) as any as S.Schema<UpdatePublicSharingSettingsRequest>;
export interface UpdateQPersonalizationConfigurationRequest {
  AwsAccountId: string;
  PersonalizationMode: PersonalizationMode;
}
export const UpdateQPersonalizationConfigurationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    PersonalizationMode: PersonalizationMode,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/q-personalization-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQPersonalizationConfigurationRequest",
}) as any as S.Schema<UpdateQPersonalizationConfigurationRequest>;
export interface UpdateQuickSightQSearchConfigurationRequest {
  AwsAccountId: string;
  QSearchStatus: QSearchStatus;
}
export const UpdateQuickSightQSearchConfigurationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    QSearchStatus: QSearchStatus,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/quicksight-q-search-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateQuickSightQSearchConfigurationRequest",
}) as any as S.Schema<UpdateQuickSightQSearchConfigurationRequest>;
export type RefreshInterval =
  | "MINUTE15"
  | "MINUTE30"
  | "HOURLY"
  | "DAILY"
  | "WEEKLY"
  | "MONTHLY";
export const RefreshInterval = S.Literal(
  "MINUTE15",
  "MINUTE30",
  "HOURLY",
  "DAILY",
  "WEEKLY",
  "MONTHLY",
);
export type DayOfWeek =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY";
export const DayOfWeek = S.Literal(
  "SUNDAY",
  "MONDAY",
  "TUESDAY",
  "WEDNESDAY",
  "THURSDAY",
  "FRIDAY",
  "SATURDAY",
);
export interface ScheduleRefreshOnEntity {
  DayOfWeek?: DayOfWeek;
  DayOfMonth?: string;
}
export const ScheduleRefreshOnEntity = S.suspend(() =>
  S.Struct({
    DayOfWeek: S.optional(DayOfWeek),
    DayOfMonth: S.optional(S.String),
  }),
).annotations({
  identifier: "ScheduleRefreshOnEntity",
}) as any as S.Schema<ScheduleRefreshOnEntity>;
export interface RefreshFrequency {
  Interval: RefreshInterval;
  RefreshOnDay?: ScheduleRefreshOnEntity;
  Timezone?: string;
  TimeOfTheDay?: string;
}
export const RefreshFrequency = S.suspend(() =>
  S.Struct({
    Interval: RefreshInterval,
    RefreshOnDay: S.optional(ScheduleRefreshOnEntity),
    Timezone: S.optional(S.String),
    TimeOfTheDay: S.optional(S.String),
  }),
).annotations({
  identifier: "RefreshFrequency",
}) as any as S.Schema<RefreshFrequency>;
export interface RefreshSchedule {
  ScheduleId: string;
  ScheduleFrequency: RefreshFrequency;
  StartAfterDateTime?: Date;
  RefreshType: IngestionType;
  Arn?: string;
}
export const RefreshSchedule = S.suspend(() =>
  S.Struct({
    ScheduleId: S.String,
    ScheduleFrequency: RefreshFrequency,
    StartAfterDateTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RefreshType: IngestionType,
    Arn: S.optional(S.String),
  }),
).annotations({
  identifier: "RefreshSchedule",
}) as any as S.Schema<RefreshSchedule>;
export interface UpdateRefreshScheduleRequest {
  DataSetId: string;
  AwsAccountId: string;
  Schedule: RefreshSchedule;
}
export const UpdateRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Schedule: RefreshSchedule,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-schedules",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRefreshScheduleRequest",
}) as any as S.Schema<UpdateRefreshScheduleRequest>;
export interface UpdateRoleCustomPermissionRequest {
  CustomPermissionsName: string;
  Role: Role;
  AwsAccountId: string;
  Namespace: string;
}
export const UpdateRoleCustomPermissionRequest = S.suspend(() =>
  S.Struct({
    CustomPermissionsName: S.String,
    Role: Role.pipe(T.HttpLabel("Role")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/roles/{Role}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateRoleCustomPermissionRequest",
}) as any as S.Schema<UpdateRoleCustomPermissionRequest>;
export interface UpdateSelfUpgradeRequest {
  AwsAccountId: string;
  Namespace: string;
  UpgradeRequestId: string;
  Action: SelfUpgradeAdminAction;
}
export const UpdateSelfUpgradeRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    UpgradeRequestId: S.String,
    Action: SelfUpgradeAdminAction,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/update-self-upgrade-request",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateSelfUpgradeRequest",
}) as any as S.Schema<UpdateSelfUpgradeRequest>;
export interface UpdateSelfUpgradeConfigurationRequest {
  AwsAccountId: string;
  Namespace: string;
  SelfUpgradeStatus: SelfUpgradeStatus;
}
export const UpdateSelfUpgradeConfigurationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    SelfUpgradeStatus: SelfUpgradeStatus,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/self-upgrade-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateSelfUpgradeConfigurationRequest",
}) as any as S.Schema<UpdateSelfUpgradeConfigurationRequest>;
export interface UpdateSPICECapacityConfigurationRequest {
  AwsAccountId: string;
  PurchaseMode: PurchaseMode;
}
export const UpdateSPICECapacityConfigurationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    PurchaseMode: PurchaseMode,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/spice-capacity-configuration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateSPICECapacityConfigurationRequest",
}) as any as S.Schema<UpdateSPICECapacityConfigurationRequest>;
export interface TemplateSourceAnalysis {
  Arn: string;
  DataSetReferences: DataSetReference[];
}
export const TemplateSourceAnalysis = S.suspend(() =>
  S.Struct({ Arn: S.String, DataSetReferences: DataSetReferenceList }),
).annotations({
  identifier: "TemplateSourceAnalysis",
}) as any as S.Schema<TemplateSourceAnalysis>;
export interface TemplateSourceTemplate {
  Arn: string;
}
export const TemplateSourceTemplate = S.suspend(() =>
  S.Struct({ Arn: S.String }),
).annotations({
  identifier: "TemplateSourceTemplate",
}) as any as S.Schema<TemplateSourceTemplate>;
export interface TemplateSourceEntity {
  SourceAnalysis?: TemplateSourceAnalysis;
  SourceTemplate?: TemplateSourceTemplate;
}
export const TemplateSourceEntity = S.suspend(() =>
  S.Struct({
    SourceAnalysis: S.optional(TemplateSourceAnalysis),
    SourceTemplate: S.optional(TemplateSourceTemplate),
  }),
).annotations({
  identifier: "TemplateSourceEntity",
}) as any as S.Schema<TemplateSourceEntity>;
export interface ColumnSchema {
  Name?: string;
  DataType?: string;
  GeographicRole?: string;
}
export const ColumnSchema = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    DataType: S.optional(S.String),
    GeographicRole: S.optional(S.String),
  }),
).annotations({ identifier: "ColumnSchema" }) as any as S.Schema<ColumnSchema>;
export type ColumnSchemaList = ColumnSchema[];
export const ColumnSchemaList = S.Array(ColumnSchema);
export interface DataSetSchema {
  ColumnSchemaList?: ColumnSchema[];
}
export const DataSetSchema = S.suspend(() =>
  S.Struct({ ColumnSchemaList: S.optional(ColumnSchemaList) }),
).annotations({
  identifier: "DataSetSchema",
}) as any as S.Schema<DataSetSchema>;
export interface ColumnGroupColumnSchema {
  Name?: string;
}
export const ColumnGroupColumnSchema = S.suspend(() =>
  S.Struct({ Name: S.optional(S.String) }),
).annotations({
  identifier: "ColumnGroupColumnSchema",
}) as any as S.Schema<ColumnGroupColumnSchema>;
export type ColumnGroupColumnSchemaList = ColumnGroupColumnSchema[];
export const ColumnGroupColumnSchemaList = S.Array(ColumnGroupColumnSchema);
export interface ColumnGroupSchema {
  Name?: string;
  ColumnGroupColumnSchemaList?: ColumnGroupColumnSchema[];
}
export const ColumnGroupSchema = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    ColumnGroupColumnSchemaList: S.optional(ColumnGroupColumnSchemaList),
  }),
).annotations({
  identifier: "ColumnGroupSchema",
}) as any as S.Schema<ColumnGroupSchema>;
export type ColumnGroupSchemaList = ColumnGroupSchema[];
export const ColumnGroupSchemaList = S.Array(ColumnGroupSchema);
export interface DataSetConfiguration {
  Placeholder?: string;
  DataSetSchema?: DataSetSchema;
  ColumnGroupSchemaList?: ColumnGroupSchema[];
}
export const DataSetConfiguration = S.suspend(() =>
  S.Struct({
    Placeholder: S.optional(S.String),
    DataSetSchema: S.optional(DataSetSchema),
    ColumnGroupSchemaList: S.optional(ColumnGroupSchemaList),
  }),
).annotations({
  identifier: "DataSetConfiguration",
}) as any as S.Schema<DataSetConfiguration>;
export type DataSetConfigurationList = DataSetConfiguration[];
export const DataSetConfigurationList = S.Array(DataSetConfiguration);
export interface TemplateVersionDefinition {
  DataSetConfigurations: DataSetConfiguration[];
  Sheets?: SheetDefinition[];
  CalculatedFields?: CalculatedField[];
  ParameterDeclarations?: ParameterDeclaration[];
  FilterGroups?: FilterGroup[];
  ColumnConfigurations?: ColumnConfiguration[];
  AnalysisDefaults?: AnalysisDefaults;
  Options?: AssetOptions;
  QueryExecutionOptions?: QueryExecutionOptions;
  StaticFiles?: StaticFile[];
}
export const TemplateVersionDefinition = S.suspend(() =>
  S.Struct({
    DataSetConfigurations: DataSetConfigurationList,
    Sheets: S.optional(SheetDefinitionList),
    CalculatedFields: S.optional(CalculatedFields),
    ParameterDeclarations: S.optional(ParameterDeclarationList),
    FilterGroups: S.optional(FilterGroupList),
    ColumnConfigurations: S.optional(ColumnConfigurationList),
    AnalysisDefaults: S.optional(AnalysisDefaults),
    Options: S.optional(AssetOptions),
    QueryExecutionOptions: S.optional(QueryExecutionOptions),
    StaticFiles: S.optional(StaticFileList),
  }),
).annotations({
  identifier: "TemplateVersionDefinition",
}) as any as S.Schema<TemplateVersionDefinition>;
export interface UpdateTemplateRequest {
  AwsAccountId: string;
  TemplateId: string;
  SourceEntity?: TemplateSourceEntity;
  VersionDescription?: string;
  Name?: string;
  Definition?: TemplateVersionDefinition;
  ValidationStrategy?: ValidationStrategy;
}
export const UpdateTemplateRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    SourceEntity: S.optional(TemplateSourceEntity),
    VersionDescription: S.optional(S.String),
    Name: S.optional(S.String),
    Definition: S.optional(TemplateVersionDefinition),
    ValidationStrategy: S.optional(ValidationStrategy),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTemplateRequest",
}) as any as S.Schema<UpdateTemplateRequest>;
export interface UpdateTemplateAliasRequest {
  AwsAccountId: string;
  TemplateId: string;
  AliasName: string;
  TemplateVersionNumber: number;
}
export const UpdateTemplateAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
    TemplateVersionNumber: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTemplateAliasRequest",
}) as any as S.Schema<UpdateTemplateAliasRequest>;
export interface UpdateTemplatePermissionsRequest {
  AwsAccountId: string;
  TemplateId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateTemplatePermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    GrantPermissions: S.optional(UpdateResourcePermissionList),
    RevokePermissions: S.optional(UpdateResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTemplatePermissionsRequest",
}) as any as S.Schema<UpdateTemplatePermissionsRequest>;
export type ColorList = string[];
export const ColorList = S.Array(S.String);
export interface DataColorPalette {
  Colors?: string[];
  MinMaxGradient?: string[];
  EmptyFillColor?: string;
}
export const DataColorPalette = S.suspend(() =>
  S.Struct({
    Colors: S.optional(ColorList),
    MinMaxGradient: S.optional(ColorList),
    EmptyFillColor: S.optional(S.String),
  }),
).annotations({
  identifier: "DataColorPalette",
}) as any as S.Schema<DataColorPalette>;
export interface UIColorPalette {
  PrimaryForeground?: string;
  PrimaryBackground?: string;
  SecondaryForeground?: string;
  SecondaryBackground?: string;
  Accent?: string;
  AccentForeground?: string;
  Danger?: string;
  DangerForeground?: string;
  Warning?: string;
  WarningForeground?: string;
  Success?: string;
  SuccessForeground?: string;
  Dimension?: string;
  DimensionForeground?: string;
  Measure?: string;
  MeasureForeground?: string;
}
export const UIColorPalette = S.suspend(() =>
  S.Struct({
    PrimaryForeground: S.optional(S.String),
    PrimaryBackground: S.optional(S.String),
    SecondaryForeground: S.optional(S.String),
    SecondaryBackground: S.optional(S.String),
    Accent: S.optional(S.String),
    AccentForeground: S.optional(S.String),
    Danger: S.optional(S.String),
    DangerForeground: S.optional(S.String),
    Warning: S.optional(S.String),
    WarningForeground: S.optional(S.String),
    Success: S.optional(S.String),
    SuccessForeground: S.optional(S.String),
    Dimension: S.optional(S.String),
    DimensionForeground: S.optional(S.String),
    Measure: S.optional(S.String),
    MeasureForeground: S.optional(S.String),
  }),
).annotations({
  identifier: "UIColorPalette",
}) as any as S.Schema<UIColorPalette>;
export interface BorderStyle {
  Color?: string;
  Show?: boolean;
  Width?: string;
}
export const BorderStyle = S.suspend(() =>
  S.Struct({
    Color: S.optional(S.String),
    Show: S.optional(S.Boolean),
    Width: S.optional(S.String),
  }),
).annotations({ identifier: "BorderStyle" }) as any as S.Schema<BorderStyle>;
export interface TileStyle {
  BackgroundColor?: string;
  Border?: BorderStyle;
  BorderRadius?: string;
  Padding?: string;
}
export const TileStyle = S.suspend(() =>
  S.Struct({
    BackgroundColor: S.optional(S.String),
    Border: S.optional(BorderStyle),
    BorderRadius: S.optional(S.String),
    Padding: S.optional(S.String),
  }),
).annotations({ identifier: "TileStyle" }) as any as S.Schema<TileStyle>;
export interface GutterStyle {
  Show?: boolean;
}
export const GutterStyle = S.suspend(() =>
  S.Struct({ Show: S.optional(S.Boolean) }),
).annotations({ identifier: "GutterStyle" }) as any as S.Schema<GutterStyle>;
export interface MarginStyle {
  Show?: boolean;
}
export const MarginStyle = S.suspend(() =>
  S.Struct({ Show: S.optional(S.Boolean) }),
).annotations({ identifier: "MarginStyle" }) as any as S.Schema<MarginStyle>;
export interface TileLayoutStyle {
  Gutter?: GutterStyle;
  Margin?: MarginStyle;
}
export const TileLayoutStyle = S.suspend(() =>
  S.Struct({
    Gutter: S.optional(GutterStyle),
    Margin: S.optional(MarginStyle),
  }),
).annotations({
  identifier: "TileLayoutStyle",
}) as any as S.Schema<TileLayoutStyle>;
export interface SheetBackgroundStyle {
  Color?: string;
  Gradient?: string;
}
export const SheetBackgroundStyle = S.suspend(() =>
  S.Struct({ Color: S.optional(S.String), Gradient: S.optional(S.String) }),
).annotations({
  identifier: "SheetBackgroundStyle",
}) as any as S.Schema<SheetBackgroundStyle>;
export interface SheetStyle {
  Tile?: TileStyle;
  TileLayout?: TileLayoutStyle;
  Background?: SheetBackgroundStyle;
}
export const SheetStyle = S.suspend(() =>
  S.Struct({
    Tile: S.optional(TileStyle),
    TileLayout: S.optional(TileLayoutStyle),
    Background: S.optional(SheetBackgroundStyle),
  }),
).annotations({ identifier: "SheetStyle" }) as any as S.Schema<SheetStyle>;
export interface Font {
  FontFamily?: string;
}
export const Font = S.suspend(() =>
  S.Struct({ FontFamily: S.optional(S.String) }),
).annotations({ identifier: "Font" }) as any as S.Schema<Font>;
export type FontList = Font[];
export const FontList = S.Array(Font);
export type TextTransform = "CAPITALIZE";
export const TextTransform = S.Literal("CAPITALIZE");
export interface VisualTitleFontConfiguration {
  FontConfiguration?: FontConfiguration;
  TextAlignment?: HorizontalTextAlignment;
  TextTransform?: TextTransform;
}
export const VisualTitleFontConfiguration = S.suspend(() =>
  S.Struct({
    FontConfiguration: S.optional(FontConfiguration),
    TextAlignment: S.optional(HorizontalTextAlignment),
    TextTransform: S.optional(TextTransform),
  }),
).annotations({
  identifier: "VisualTitleFontConfiguration",
}) as any as S.Schema<VisualTitleFontConfiguration>;
export interface VisualSubtitleFontConfiguration {
  FontConfiguration?: FontConfiguration;
  TextAlignment?: HorizontalTextAlignment;
  TextTransform?: TextTransform;
}
export const VisualSubtitleFontConfiguration = S.suspend(() =>
  S.Struct({
    FontConfiguration: S.optional(FontConfiguration),
    TextAlignment: S.optional(HorizontalTextAlignment),
    TextTransform: S.optional(TextTransform),
  }),
).annotations({
  identifier: "VisualSubtitleFontConfiguration",
}) as any as S.Schema<VisualSubtitleFontConfiguration>;
export interface Typography {
  FontFamilies?: Font[];
  AxisTitleFontConfiguration?: FontConfiguration;
  AxisLabelFontConfiguration?: FontConfiguration;
  LegendTitleFontConfiguration?: FontConfiguration;
  LegendValueFontConfiguration?: FontConfiguration;
  DataLabelFontConfiguration?: FontConfiguration;
  VisualTitleFontConfiguration?: VisualTitleFontConfiguration;
  VisualSubtitleFontConfiguration?: VisualSubtitleFontConfiguration;
}
export const Typography = S.suspend(() =>
  S.Struct({
    FontFamilies: S.optional(FontList),
    AxisTitleFontConfiguration: S.optional(FontConfiguration),
    AxisLabelFontConfiguration: S.optional(FontConfiguration),
    LegendTitleFontConfiguration: S.optional(FontConfiguration),
    LegendValueFontConfiguration: S.optional(FontConfiguration),
    DataLabelFontConfiguration: S.optional(FontConfiguration),
    VisualTitleFontConfiguration: S.optional(VisualTitleFontConfiguration),
    VisualSubtitleFontConfiguration: S.optional(
      VisualSubtitleFontConfiguration,
    ),
  }),
).annotations({ identifier: "Typography" }) as any as S.Schema<Typography>;
export interface ThemeConfiguration {
  DataColorPalette?: DataColorPalette;
  UIColorPalette?: UIColorPalette;
  Sheet?: SheetStyle;
  Typography?: Typography;
}
export const ThemeConfiguration = S.suspend(() =>
  S.Struct({
    DataColorPalette: S.optional(DataColorPalette),
    UIColorPalette: S.optional(UIColorPalette),
    Sheet: S.optional(SheetStyle),
    Typography: S.optional(Typography),
  }),
).annotations({
  identifier: "ThemeConfiguration",
}) as any as S.Schema<ThemeConfiguration>;
export interface UpdateThemeRequest {
  AwsAccountId: string;
  ThemeId: string;
  Name?: string;
  BaseThemeId: string;
  VersionDescription?: string;
  Configuration?: ThemeConfiguration;
}
export const UpdateThemeRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    Name: S.optional(S.String),
    BaseThemeId: S.String,
    VersionDescription: S.optional(S.String),
    Configuration: S.optional(ThemeConfiguration),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateThemeRequest",
}) as any as S.Schema<UpdateThemeRequest>;
export interface UpdateThemeAliasRequest {
  AwsAccountId: string;
  ThemeId: string;
  AliasName: string;
  ThemeVersionNumber: number;
}
export const UpdateThemeAliasRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    AliasName: S.String.pipe(T.HttpLabel("AliasName")),
    ThemeVersionNumber: S.Number,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/aliases/{AliasName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateThemeAliasRequest",
}) as any as S.Schema<UpdateThemeAliasRequest>;
export interface UpdateThemePermissionsRequest {
  AwsAccountId: string;
  ThemeId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateThemePermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    GrantPermissions: S.optional(UpdateResourcePermissionList),
    RevokePermissions: S.optional(UpdateResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateThemePermissionsRequest",
}) as any as S.Schema<UpdateThemePermissionsRequest>;
export type TopicUserExperienceVersion = "LEGACY" | "NEW_READER_EXPERIENCE";
export const TopicUserExperienceVersion = S.Literal(
  "LEGACY",
  "NEW_READER_EXPERIENCE",
);
export type TopicTimeGranularity =
  | "SECOND"
  | "MINUTE"
  | "HOUR"
  | "DAY"
  | "WEEK"
  | "MONTH"
  | "QUARTER"
  | "YEAR";
export const TopicTimeGranularity = S.Literal(
  "SECOND",
  "MINUTE",
  "HOUR",
  "DAY",
  "WEEK",
  "MONTH",
  "QUARTER",
  "YEAR",
);
export interface DataAggregation {
  DatasetRowDateGranularity?: TopicTimeGranularity;
  DefaultDateColumnName?: string;
}
export const DataAggregation = S.suspend(() =>
  S.Struct({
    DatasetRowDateGranularity: S.optional(TopicTimeGranularity),
    DefaultDateColumnName: S.optional(S.String),
  }),
).annotations({
  identifier: "DataAggregation",
}) as any as S.Schema<DataAggregation>;
export type FilterClass =
  | "ENFORCED_VALUE_FILTER"
  | "CONDITIONAL_VALUE_FILTER"
  | "NAMED_VALUE_FILTER";
export const FilterClass = S.Literal(
  "ENFORCED_VALUE_FILTER",
  "CONDITIONAL_VALUE_FILTER",
  "NAMED_VALUE_FILTER",
);
export type Synonyms = string[];
export const Synonyms = S.Array(S.String);
export type NamedFilterType =
  | "CATEGORY_FILTER"
  | "NUMERIC_EQUALITY_FILTER"
  | "NUMERIC_RANGE_FILTER"
  | "DATE_RANGE_FILTER"
  | "RELATIVE_DATE_FILTER"
  | "NULL_FILTER";
export const NamedFilterType = S.Literal(
  "CATEGORY_FILTER",
  "NUMERIC_EQUALITY_FILTER",
  "NUMERIC_RANGE_FILTER",
  "DATE_RANGE_FILTER",
  "RELATIVE_DATE_FILTER",
  "NULL_FILTER",
);
export type CategoryFilterFunction = "EXACT" | "CONTAINS";
export const CategoryFilterFunction = S.Literal("EXACT", "CONTAINS");
export type CategoryFilterType =
  | "CUSTOM_FILTER"
  | "CUSTOM_FILTER_LIST"
  | "FILTER_LIST";
export const CategoryFilterType = S.Literal(
  "CUSTOM_FILTER",
  "CUSTOM_FILTER_LIST",
  "FILTER_LIST",
);
export type ConstantType = "SINGULAR" | "RANGE" | "COLLECTIVE";
export const ConstantType = S.Literal("SINGULAR", "RANGE", "COLLECTIVE");
export interface CollectiveConstant {
  ValueList?: string[];
}
export const CollectiveConstant = S.suspend(() =>
  S.Struct({ ValueList: S.optional(StringList) }),
).annotations({
  identifier: "CollectiveConstant",
}) as any as S.Schema<CollectiveConstant>;
export interface TopicCategoryFilterConstant {
  ConstantType?: ConstantType;
  SingularConstant?: string;
  CollectiveConstant?: CollectiveConstant;
}
export const TopicCategoryFilterConstant = S.suspend(() =>
  S.Struct({
    ConstantType: S.optional(ConstantType),
    SingularConstant: S.optional(S.String),
    CollectiveConstant: S.optional(CollectiveConstant),
  }),
).annotations({
  identifier: "TopicCategoryFilterConstant",
}) as any as S.Schema<TopicCategoryFilterConstant>;
export interface TopicCategoryFilter {
  CategoryFilterFunction?: CategoryFilterFunction;
  CategoryFilterType?: CategoryFilterType;
  Constant?: TopicCategoryFilterConstant;
  Inverse?: boolean;
}
export const TopicCategoryFilter = S.suspend(() =>
  S.Struct({
    CategoryFilterFunction: S.optional(CategoryFilterFunction),
    CategoryFilterType: S.optional(CategoryFilterType),
    Constant: S.optional(TopicCategoryFilterConstant),
    Inverse: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "TopicCategoryFilter",
}) as any as S.Schema<TopicCategoryFilter>;
export interface TopicSingularFilterConstant {
  ConstantType?: ConstantType;
  SingularConstant?: string;
}
export const TopicSingularFilterConstant = S.suspend(() =>
  S.Struct({
    ConstantType: S.optional(ConstantType),
    SingularConstant: S.optional(S.String),
  }),
).annotations({
  identifier: "TopicSingularFilterConstant",
}) as any as S.Schema<TopicSingularFilterConstant>;
export type NamedFilterAggType =
  | "NO_AGGREGATION"
  | "SUM"
  | "AVERAGE"
  | "COUNT"
  | "DISTINCT_COUNT"
  | "MAX"
  | "MEDIAN"
  | "MIN"
  | "STDEV"
  | "STDEVP"
  | "VAR"
  | "VARP";
export const NamedFilterAggType = S.Literal(
  "NO_AGGREGATION",
  "SUM",
  "AVERAGE",
  "COUNT",
  "DISTINCT_COUNT",
  "MAX",
  "MEDIAN",
  "MIN",
  "STDEV",
  "STDEVP",
  "VAR",
  "VARP",
);
export interface TopicNumericEqualityFilter {
  Constant?: TopicSingularFilterConstant;
  Aggregation?: NamedFilterAggType;
}
export const TopicNumericEqualityFilter = S.suspend(() =>
  S.Struct({
    Constant: S.optional(TopicSingularFilterConstant),
    Aggregation: S.optional(NamedFilterAggType),
  }),
).annotations({
  identifier: "TopicNumericEqualityFilter",
}) as any as S.Schema<TopicNumericEqualityFilter>;
export interface RangeConstant {
  Minimum?: string;
  Maximum?: string;
}
export const RangeConstant = S.suspend(() =>
  S.Struct({ Minimum: S.optional(S.String), Maximum: S.optional(S.String) }),
).annotations({
  identifier: "RangeConstant",
}) as any as S.Schema<RangeConstant>;
export interface TopicRangeFilterConstant {
  ConstantType?: ConstantType;
  RangeConstant?: RangeConstant;
}
export const TopicRangeFilterConstant = S.suspend(() =>
  S.Struct({
    ConstantType: S.optional(ConstantType),
    RangeConstant: S.optional(RangeConstant),
  }),
).annotations({
  identifier: "TopicRangeFilterConstant",
}) as any as S.Schema<TopicRangeFilterConstant>;
export interface TopicNumericRangeFilter {
  Inclusive?: boolean;
  Constant?: TopicRangeFilterConstant;
  Aggregation?: NamedFilterAggType;
}
export const TopicNumericRangeFilter = S.suspend(() =>
  S.Struct({
    Inclusive: S.optional(S.Boolean),
    Constant: S.optional(TopicRangeFilterConstant),
    Aggregation: S.optional(NamedFilterAggType),
  }),
).annotations({
  identifier: "TopicNumericRangeFilter",
}) as any as S.Schema<TopicNumericRangeFilter>;
export interface TopicDateRangeFilter {
  Inclusive?: boolean;
  Constant?: TopicRangeFilterConstant;
}
export const TopicDateRangeFilter = S.suspend(() =>
  S.Struct({
    Inclusive: S.optional(S.Boolean),
    Constant: S.optional(TopicRangeFilterConstant),
  }),
).annotations({
  identifier: "TopicDateRangeFilter",
}) as any as S.Schema<TopicDateRangeFilter>;
export type TopicRelativeDateFilterFunction =
  | "PREVIOUS"
  | "THIS"
  | "LAST"
  | "NEXT"
  | "NOW";
export const TopicRelativeDateFilterFunction = S.Literal(
  "PREVIOUS",
  "THIS",
  "LAST",
  "NEXT",
  "NOW",
);
export interface TopicRelativeDateFilter {
  TimeGranularity?: TopicTimeGranularity;
  RelativeDateFilterFunction?: TopicRelativeDateFilterFunction;
  Constant?: TopicSingularFilterConstant;
}
export const TopicRelativeDateFilter = S.suspend(() =>
  S.Struct({
    TimeGranularity: S.optional(TopicTimeGranularity),
    RelativeDateFilterFunction: S.optional(TopicRelativeDateFilterFunction),
    Constant: S.optional(TopicSingularFilterConstant),
  }),
).annotations({
  identifier: "TopicRelativeDateFilter",
}) as any as S.Schema<TopicRelativeDateFilter>;
export type NullFilterType = "ALL_VALUES" | "NON_NULLS_ONLY" | "NULLS_ONLY";
export const NullFilterType = S.Literal(
  "ALL_VALUES",
  "NON_NULLS_ONLY",
  "NULLS_ONLY",
);
export interface TopicNullFilter {
  NullFilterType?: NullFilterType;
  Constant?: TopicSingularFilterConstant;
  Inverse?: boolean;
}
export const TopicNullFilter = S.suspend(() =>
  S.Struct({
    NullFilterType: S.optional(NullFilterType),
    Constant: S.optional(TopicSingularFilterConstant),
    Inverse: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "TopicNullFilter",
}) as any as S.Schema<TopicNullFilter>;
export interface TopicFilter {
  FilterDescription?: string;
  FilterClass?: FilterClass;
  FilterName: string;
  FilterSynonyms?: string[];
  OperandFieldName: string;
  FilterType?: NamedFilterType;
  CategoryFilter?: TopicCategoryFilter;
  NumericEqualityFilter?: TopicNumericEqualityFilter;
  NumericRangeFilter?: TopicNumericRangeFilter;
  DateRangeFilter?: TopicDateRangeFilter;
  RelativeDateFilter?: TopicRelativeDateFilter;
  NullFilter?: TopicNullFilter;
}
export const TopicFilter = S.suspend(() =>
  S.Struct({
    FilterDescription: S.optional(S.String),
    FilterClass: S.optional(FilterClass),
    FilterName: S.String,
    FilterSynonyms: S.optional(Synonyms),
    OperandFieldName: S.String,
    FilterType: S.optional(NamedFilterType),
    CategoryFilter: S.optional(TopicCategoryFilter),
    NumericEqualityFilter: S.optional(TopicNumericEqualityFilter),
    NumericRangeFilter: S.optional(TopicNumericRangeFilter),
    DateRangeFilter: S.optional(TopicDateRangeFilter),
    RelativeDateFilter: S.optional(TopicRelativeDateFilter),
    NullFilter: S.optional(TopicNullFilter),
  }),
).annotations({ identifier: "TopicFilter" }) as any as S.Schema<TopicFilter>;
export type TopicFilters = TopicFilter[];
export const TopicFilters = S.Array(TopicFilter);
export type ColumnDataRole = "DIMENSION" | "MEASURE";
export const ColumnDataRole = S.Literal("DIMENSION", "MEASURE");
export type DefaultAggregation =
  | "SUM"
  | "MAX"
  | "MIN"
  | "COUNT"
  | "DISTINCT_COUNT"
  | "AVERAGE"
  | "MEDIAN"
  | "STDEV"
  | "STDEVP"
  | "VAR"
  | "VARP";
export const DefaultAggregation = S.Literal(
  "SUM",
  "MAX",
  "MIN",
  "COUNT",
  "DISTINCT_COUNT",
  "AVERAGE",
  "MEDIAN",
  "STDEV",
  "STDEVP",
  "VAR",
  "VARP",
);
export type ColumnOrderingType =
  | "GREATER_IS_BETTER"
  | "LESSER_IS_BETTER"
  | "SPECIFIED";
export const ColumnOrderingType = S.Literal(
  "GREATER_IS_BETTER",
  "LESSER_IS_BETTER",
  "SPECIFIED",
);
export type UndefinedSpecifiedValueType = "LEAST" | "MOST";
export const UndefinedSpecifiedValueType = S.Literal("LEAST", "MOST");
export interface ComparativeOrder {
  UseOrdering?: ColumnOrderingType;
  SpecifedOrder?: string[];
  TreatUndefinedSpecifiedValues?: UndefinedSpecifiedValueType;
}
export const ComparativeOrder = S.suspend(() =>
  S.Struct({
    UseOrdering: S.optional(ColumnOrderingType),
    SpecifedOrder: S.optional(StringList),
    TreatUndefinedSpecifiedValues: S.optional(UndefinedSpecifiedValueType),
  }),
).annotations({
  identifier: "ComparativeOrder",
}) as any as S.Schema<ComparativeOrder>;
export type TypeParameters = { [key: string]: string };
export const TypeParameters = S.Record({ key: S.String, value: S.String });
export interface SemanticType {
  TypeName?: string;
  SubTypeName?: string;
  TypeParameters?: { [key: string]: string };
  TruthyCellValue?: string | redacted.Redacted<string>;
  TruthyCellValueSynonyms?: string | redacted.Redacted<string>[];
  FalseyCellValue?: string | redacted.Redacted<string>;
  FalseyCellValueSynonyms?: string | redacted.Redacted<string>[];
}
export const SemanticType = S.suspend(() =>
  S.Struct({
    TypeName: S.optional(S.String),
    SubTypeName: S.optional(S.String),
    TypeParameters: S.optional(TypeParameters),
    TruthyCellValue: S.optional(SensitiveString),
    TruthyCellValueSynonyms: S.optional(SensitiveStringList),
    FalseyCellValue: S.optional(SensitiveString),
    FalseyCellValueSynonyms: S.optional(SensitiveStringList),
  }),
).annotations({ identifier: "SemanticType" }) as any as S.Schema<SemanticType>;
export type AuthorSpecifiedAggregation =
  | "COUNT"
  | "DISTINCT_COUNT"
  | "MIN"
  | "MAX"
  | "MEDIAN"
  | "SUM"
  | "AVERAGE"
  | "STDEV"
  | "STDEVP"
  | "VAR"
  | "VARP"
  | "PERCENTILE";
export const AuthorSpecifiedAggregation = S.Literal(
  "COUNT",
  "DISTINCT_COUNT",
  "MIN",
  "MAX",
  "MEDIAN",
  "SUM",
  "AVERAGE",
  "STDEV",
  "STDEVP",
  "VAR",
  "VARP",
  "PERCENTILE",
);
export type AuthorSpecifiedAggregations = AuthorSpecifiedAggregation[];
export const AuthorSpecifiedAggregations = S.Array(AuthorSpecifiedAggregation);
export type DisplayFormat =
  | "AUTO"
  | "PERCENT"
  | "CURRENCY"
  | "NUMBER"
  | "DATE"
  | "STRING";
export const DisplayFormat = S.Literal(
  "AUTO",
  "PERCENT",
  "CURRENCY",
  "NUMBER",
  "DATE",
  "STRING",
);
export type TopicNumericSeparatorSymbol = "COMMA" | "DOT";
export const TopicNumericSeparatorSymbol = S.Literal("COMMA", "DOT");
export interface NegativeFormat {
  Prefix?: string;
  Suffix?: string;
}
export const NegativeFormat = S.suspend(() =>
  S.Struct({ Prefix: S.optional(S.String), Suffix: S.optional(S.String) }),
).annotations({
  identifier: "NegativeFormat",
}) as any as S.Schema<NegativeFormat>;
export interface DisplayFormatOptions {
  UseBlankCellFormat?: boolean;
  BlankCellFormat?: string;
  DateFormat?: string;
  DecimalSeparator?: TopicNumericSeparatorSymbol;
  GroupingSeparator?: string;
  UseGrouping?: boolean;
  FractionDigits?: number;
  Prefix?: string;
  Suffix?: string;
  UnitScaler?: NumberScale;
  NegativeFormat?: NegativeFormat;
  CurrencySymbol?: string;
}
export const DisplayFormatOptions = S.suspend(() =>
  S.Struct({
    UseBlankCellFormat: S.optional(S.Boolean),
    BlankCellFormat: S.optional(S.String),
    DateFormat: S.optional(S.String),
    DecimalSeparator: S.optional(TopicNumericSeparatorSymbol),
    GroupingSeparator: S.optional(S.String),
    UseGrouping: S.optional(S.Boolean),
    FractionDigits: S.optional(S.Number),
    Prefix: S.optional(S.String),
    Suffix: S.optional(S.String),
    UnitScaler: S.optional(NumberScale),
    NegativeFormat: S.optional(NegativeFormat),
    CurrencySymbol: S.optional(S.String),
  }),
).annotations({
  identifier: "DisplayFormatOptions",
}) as any as S.Schema<DisplayFormatOptions>;
export interface DefaultFormatting {
  DisplayFormat?: DisplayFormat;
  DisplayFormatOptions?: DisplayFormatOptions;
}
export const DefaultFormatting = S.suspend(() =>
  S.Struct({
    DisplayFormat: S.optional(DisplayFormat),
    DisplayFormatOptions: S.optional(DisplayFormatOptions),
  }),
).annotations({
  identifier: "DefaultFormatting",
}) as any as S.Schema<DefaultFormatting>;
export interface CellValueSynonym {
  CellValue?: string;
  Synonyms?: string[];
}
export const CellValueSynonym = S.suspend(() =>
  S.Struct({
    CellValue: S.optional(S.String),
    Synonyms: S.optional(StringList),
  }),
).annotations({
  identifier: "CellValueSynonym",
}) as any as S.Schema<CellValueSynonym>;
export type CellValueSynonyms = CellValueSynonym[];
export const CellValueSynonyms = S.Array(CellValueSynonym);
export interface TopicColumn {
  ColumnName: string;
  ColumnFriendlyName?: string;
  ColumnDescription?: string;
  ColumnSynonyms?: string[];
  ColumnDataRole?: ColumnDataRole;
  Aggregation?: DefaultAggregation;
  IsIncludedInTopic?: boolean;
  DisableIndexing?: boolean;
  ComparativeOrder?: ComparativeOrder;
  SemanticType?: SemanticType;
  TimeGranularity?: TopicTimeGranularity;
  AllowedAggregations?: AuthorSpecifiedAggregation[];
  NotAllowedAggregations?: AuthorSpecifiedAggregation[];
  DefaultFormatting?: DefaultFormatting;
  NeverAggregateInFilter?: boolean;
  CellValueSynonyms?: CellValueSynonym[];
  NonAdditive?: boolean;
}
export const TopicColumn = S.suspend(() =>
  S.Struct({
    ColumnName: S.String,
    ColumnFriendlyName: S.optional(S.String),
    ColumnDescription: S.optional(S.String),
    ColumnSynonyms: S.optional(Synonyms),
    ColumnDataRole: S.optional(ColumnDataRole),
    Aggregation: S.optional(DefaultAggregation),
    IsIncludedInTopic: S.optional(S.Boolean),
    DisableIndexing: S.optional(S.Boolean),
    ComparativeOrder: S.optional(ComparativeOrder),
    SemanticType: S.optional(SemanticType),
    TimeGranularity: S.optional(TopicTimeGranularity),
    AllowedAggregations: S.optional(AuthorSpecifiedAggregations),
    NotAllowedAggregations: S.optional(AuthorSpecifiedAggregations),
    DefaultFormatting: S.optional(DefaultFormatting),
    NeverAggregateInFilter: S.optional(S.Boolean),
    CellValueSynonyms: S.optional(CellValueSynonyms),
    NonAdditive: S.optional(S.Boolean),
  }),
).annotations({ identifier: "TopicColumn" }) as any as S.Schema<TopicColumn>;
export type TopicColumns = TopicColumn[];
export const TopicColumns = S.Array(TopicColumn);
export interface TopicCalculatedField {
  CalculatedFieldName: string;
  CalculatedFieldDescription?: string;
  Expression: string | redacted.Redacted<string>;
  CalculatedFieldSynonyms?: string[];
  IsIncludedInTopic?: boolean;
  DisableIndexing?: boolean;
  ColumnDataRole?: ColumnDataRole;
  TimeGranularity?: TopicTimeGranularity;
  DefaultFormatting?: DefaultFormatting;
  Aggregation?: DefaultAggregation;
  ComparativeOrder?: ComparativeOrder;
  SemanticType?: SemanticType;
  AllowedAggregations?: AuthorSpecifiedAggregation[];
  NotAllowedAggregations?: AuthorSpecifiedAggregation[];
  NeverAggregateInFilter?: boolean;
  CellValueSynonyms?: CellValueSynonym[];
  NonAdditive?: boolean;
}
export const TopicCalculatedField = S.suspend(() =>
  S.Struct({
    CalculatedFieldName: S.String,
    CalculatedFieldDescription: S.optional(S.String),
    Expression: SensitiveString,
    CalculatedFieldSynonyms: S.optional(Synonyms),
    IsIncludedInTopic: S.optional(S.Boolean),
    DisableIndexing: S.optional(S.Boolean),
    ColumnDataRole: S.optional(ColumnDataRole),
    TimeGranularity: S.optional(TopicTimeGranularity),
    DefaultFormatting: S.optional(DefaultFormatting),
    Aggregation: S.optional(DefaultAggregation),
    ComparativeOrder: S.optional(ComparativeOrder),
    SemanticType: S.optional(SemanticType),
    AllowedAggregations: S.optional(AuthorSpecifiedAggregations),
    NotAllowedAggregations: S.optional(AuthorSpecifiedAggregations),
    NeverAggregateInFilter: S.optional(S.Boolean),
    CellValueSynonyms: S.optional(CellValueSynonyms),
    NonAdditive: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "TopicCalculatedField",
}) as any as S.Schema<TopicCalculatedField>;
export type TopicCalculatedFields = TopicCalculatedField[];
export const TopicCalculatedFields = S.Array(TopicCalculatedField);
export interface SemanticEntityType {
  TypeName?: string;
  SubTypeName?: string;
  TypeParameters?: { [key: string]: string };
}
export const SemanticEntityType = S.suspend(() =>
  S.Struct({
    TypeName: S.optional(S.String),
    SubTypeName: S.optional(S.String),
    TypeParameters: S.optional(TypeParameters),
  }),
).annotations({
  identifier: "SemanticEntityType",
}) as any as S.Schema<SemanticEntityType>;
export type PropertyRole = "PRIMARY" | "ID";
export const PropertyRole = S.Literal("PRIMARY", "ID");
export type PropertyUsage = "INHERIT" | "DIMENSION" | "MEASURE";
export const PropertyUsage = S.Literal("INHERIT", "DIMENSION", "MEASURE");
export type NamedEntityAggType =
  | "SUM"
  | "MIN"
  | "MAX"
  | "COUNT"
  | "AVERAGE"
  | "DISTINCT_COUNT"
  | "STDEV"
  | "STDEVP"
  | "VAR"
  | "VARP"
  | "PERCENTILE"
  | "MEDIAN"
  | "CUSTOM";
export const NamedEntityAggType = S.Literal(
  "SUM",
  "MIN",
  "MAX",
  "COUNT",
  "AVERAGE",
  "DISTINCT_COUNT",
  "STDEV",
  "STDEVP",
  "VAR",
  "VARP",
  "PERCENTILE",
  "MEDIAN",
  "CUSTOM",
);
export type AggregationFunctionParameters = { [key: string]: string };
export const AggregationFunctionParameters = S.Record({
  key: S.String,
  value: S.String,
});
export interface NamedEntityDefinitionMetric {
  Aggregation?: NamedEntityAggType;
  AggregationFunctionParameters?: { [key: string]: string };
}
export const NamedEntityDefinitionMetric = S.suspend(() =>
  S.Struct({
    Aggregation: S.optional(NamedEntityAggType),
    AggregationFunctionParameters: S.optional(AggregationFunctionParameters),
  }),
).annotations({
  identifier: "NamedEntityDefinitionMetric",
}) as any as S.Schema<NamedEntityDefinitionMetric>;
export interface NamedEntityDefinition {
  FieldName?: string;
  PropertyName?: string;
  PropertyRole?: PropertyRole;
  PropertyUsage?: PropertyUsage;
  Metric?: NamedEntityDefinitionMetric;
}
export const NamedEntityDefinition = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    PropertyName: S.optional(S.String),
    PropertyRole: S.optional(PropertyRole),
    PropertyUsage: S.optional(PropertyUsage),
    Metric: S.optional(NamedEntityDefinitionMetric),
  }),
).annotations({
  identifier: "NamedEntityDefinition",
}) as any as S.Schema<NamedEntityDefinition>;
export type NamedEntityDefinitions = NamedEntityDefinition[];
export const NamedEntityDefinitions = S.Array(NamedEntityDefinition);
export interface TopicNamedEntity {
  EntityName: string;
  EntityDescription?: string;
  EntitySynonyms?: string[];
  SemanticEntityType?: SemanticEntityType;
  Definition?: NamedEntityDefinition[];
}
export const TopicNamedEntity = S.suspend(() =>
  S.Struct({
    EntityName: S.String,
    EntityDescription: S.optional(S.String),
    EntitySynonyms: S.optional(Synonyms),
    SemanticEntityType: S.optional(SemanticEntityType),
    Definition: S.optional(NamedEntityDefinitions),
  }),
).annotations({
  identifier: "TopicNamedEntity",
}) as any as S.Schema<TopicNamedEntity>;
export type TopicNamedEntities = TopicNamedEntity[];
export const TopicNamedEntities = S.Array(TopicNamedEntity);
export interface DatasetMetadata {
  DatasetArn: string;
  DatasetName?: string;
  DatasetDescription?: string;
  DataAggregation?: DataAggregation;
  Filters?: TopicFilter[];
  Columns?: TopicColumn[];
  CalculatedFields?: TopicCalculatedField[];
  NamedEntities?: TopicNamedEntity[];
}
export const DatasetMetadata = S.suspend(() =>
  S.Struct({
    DatasetArn: S.String,
    DatasetName: S.optional(S.String),
    DatasetDescription: S.optional(S.String),
    DataAggregation: S.optional(DataAggregation),
    Filters: S.optional(TopicFilters),
    Columns: S.optional(TopicColumns),
    CalculatedFields: S.optional(TopicCalculatedFields),
    NamedEntities: S.optional(TopicNamedEntities),
  }),
).annotations({
  identifier: "DatasetMetadata",
}) as any as S.Schema<DatasetMetadata>;
export type Datasets = DatasetMetadata[];
export const Datasets = S.Array(DatasetMetadata);
export interface TopicConfigOptions {
  QBusinessInsightsEnabled?: boolean;
}
export const TopicConfigOptions = S.suspend(() =>
  S.Struct({ QBusinessInsightsEnabled: S.optional(S.Boolean) }),
).annotations({
  identifier: "TopicConfigOptions",
}) as any as S.Schema<TopicConfigOptions>;
export interface TopicDetails {
  Name?: string;
  Description?: string;
  UserExperienceVersion?: TopicUserExperienceVersion;
  DataSets?: DatasetMetadata[];
  ConfigOptions?: TopicConfigOptions;
}
export const TopicDetails = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Description: S.optional(S.String),
    UserExperienceVersion: S.optional(TopicUserExperienceVersion),
    DataSets: S.optional(Datasets),
    ConfigOptions: S.optional(TopicConfigOptions),
  }),
).annotations({ identifier: "TopicDetails" }) as any as S.Schema<TopicDetails>;
export interface CustomInstructions {
  CustomInstructionsString: string | redacted.Redacted<string>;
}
export const CustomInstructions = S.suspend(() =>
  S.Struct({ CustomInstructionsString: SensitiveString }),
).annotations({
  identifier: "CustomInstructions",
}) as any as S.Schema<CustomInstructions>;
export interface UpdateTopicRequest {
  AwsAccountId: string;
  TopicId: string;
  Topic: TopicDetails;
  CustomInstructions?: CustomInstructions;
}
export const UpdateTopicRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    Topic: TopicDetails,
    CustomInstructions: S.optional(CustomInstructions),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTopicRequest",
}) as any as S.Schema<UpdateTopicRequest>;
export interface UpdateTopicPermissionsRequest {
  AwsAccountId: string;
  TopicId: string;
  GrantPermissions?: ResourcePermission[];
  RevokePermissions?: ResourcePermission[];
}
export const UpdateTopicPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    GrantPermissions: S.optional(UpdateResourcePermissionList),
    RevokePermissions: S.optional(UpdateResourcePermissionList),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTopicPermissionsRequest",
}) as any as S.Schema<UpdateTopicPermissionsRequest>;
export type TopicScheduleType = "HOURLY" | "DAILY" | "WEEKLY" | "MONTHLY";
export const TopicScheduleType = S.Literal(
  "HOURLY",
  "DAILY",
  "WEEKLY",
  "MONTHLY",
);
export interface TopicRefreshSchedule {
  IsEnabled: boolean;
  BasedOnSpiceSchedule: boolean;
  StartingAt?: Date;
  Timezone?: string;
  RepeatAt?: string;
  TopicScheduleType?: TopicScheduleType;
}
export const TopicRefreshSchedule = S.suspend(() =>
  S.Struct({
    IsEnabled: S.Boolean,
    BasedOnSpiceSchedule: S.Boolean,
    StartingAt: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Timezone: S.optional(S.String),
    RepeatAt: S.optional(S.String),
    TopicScheduleType: S.optional(TopicScheduleType),
  }),
).annotations({
  identifier: "TopicRefreshSchedule",
}) as any as S.Schema<TopicRefreshSchedule>;
export interface UpdateTopicRefreshScheduleRequest {
  AwsAccountId: string;
  TopicId: string;
  DatasetId: string;
  RefreshSchedule: TopicRefreshSchedule;
}
export const UpdateTopicRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    DatasetId: S.String.pipe(T.HttpLabel("DatasetId")),
    RefreshSchedule: TopicRefreshSchedule,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/schedules/{DatasetId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateTopicRefreshScheduleRequest",
}) as any as S.Schema<UpdateTopicRefreshScheduleRequest>;
export interface UpdateUserRequest {
  UserName: string;
  AwsAccountId: string;
  Namespace: string;
  Email: string;
  Role: UserRole;
  CustomPermissionsName?: string;
  UnapplyCustomPermissions?: boolean;
  ExternalLoginFederationProviderType?: string;
  CustomFederationProviderUrl?: string;
  ExternalLoginId?: string;
}
export const UpdateUserRequest = S.suspend(() =>
  S.Struct({
    UserName: S.String.pipe(T.HttpLabel("UserName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    Email: S.String,
    Role: UserRole,
    CustomPermissionsName: S.optional(S.String),
    UnapplyCustomPermissions: S.optional(S.Boolean),
    ExternalLoginFederationProviderType: S.optional(S.String),
    CustomFederationProviderUrl: S.optional(S.String),
    ExternalLoginId: S.optional(S.String),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserRequest",
}) as any as S.Schema<UpdateUserRequest>;
export interface UpdateUserCustomPermissionRequest {
  UserName: string;
  AwsAccountId: string;
  Namespace: string;
  CustomPermissionsName: string;
}
export const UpdateUserCustomPermissionRequest = S.suspend(() =>
  S.Struct({
    UserName: S.String.pipe(T.HttpLabel("UserName")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    CustomPermissionsName: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}/custom-permission",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateUserCustomPermissionRequest",
}) as any as S.Schema<UpdateUserCustomPermissionRequest>;
export interface UpdateVPCConnectionRequest {
  AwsAccountId: string;
  VPCConnectionId: string;
  Name: string;
  SubnetIds: string[];
  SecurityGroupIds: string[];
  DnsResolvers?: string[];
  RoleArn: string;
}
export const UpdateVPCConnectionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    VPCConnectionId: S.String.pipe(T.HttpLabel("VPCConnectionId")),
    Name: S.String,
    SubnetIds: SubnetIdList,
    SecurityGroupIds: SecurityGroupIdList,
    DnsResolvers: S.optional(DnsResolverList),
    RoleArn: S.String,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/vpc-connections/{VPCConnectionId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateVPCConnectionRequest",
}) as any as S.Schema<UpdateVPCConnectionRequest>;
export type ActionConnectorSearchFilterNameEnum =
  | "ACTION_CONNECTOR_NAME"
  | "ACTION_CONNECTOR_TYPE"
  | "QUICKSIGHT_OWNER"
  | "QUICKSIGHT_VIEWER_OR_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER";
export const ActionConnectorSearchFilterNameEnum = S.Literal(
  "ACTION_CONNECTOR_NAME",
  "ACTION_CONNECTOR_TYPE",
  "QUICKSIGHT_OWNER",
  "QUICKSIGHT_VIEWER_OR_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
);
export type FilterOperator = "StringEquals" | "StringLike";
export const FilterOperator = S.Literal("StringEquals", "StringLike");
export type AnalysisFilterAttribute =
  | "QUICKSIGHT_USER"
  | "QUICKSIGHT_VIEWER_OR_OWNER"
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
  | "QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER"
  | "ANALYSIS_NAME";
export const AnalysisFilterAttribute = S.Literal(
  "QUICKSIGHT_USER",
  "QUICKSIGHT_VIEWER_OR_OWNER",
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
  "QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
  "ANALYSIS_NAME",
);
export type DashboardFilterAttribute =
  | "QUICKSIGHT_USER"
  | "QUICKSIGHT_VIEWER_OR_OWNER"
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
  | "QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER"
  | "DASHBOARD_NAME";
export const DashboardFilterAttribute = S.Literal(
  "QUICKSIGHT_USER",
  "QUICKSIGHT_VIEWER_OR_OWNER",
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
  "QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
  "DASHBOARD_NAME",
);
export type DataSetFilterAttribute =
  | "QUICKSIGHT_VIEWER_OR_OWNER"
  | "QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER"
  | "DATASET_NAME";
export const DataSetFilterAttribute = S.Literal(
  "QUICKSIGHT_VIEWER_OR_OWNER",
  "QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
  "DATASET_NAME",
);
export type DataSourceFilterAttribute =
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER"
  | "DATASOURCE_NAME";
export const DataSourceFilterAttribute = S.Literal(
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
  "DATASOURCE_NAME",
);
export type FieldName =
  | "assetName"
  | "assetDescription"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER";
export const FieldName = S.Literal(
  "assetName",
  "assetDescription",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
);
export type SearchFilterOperator = "StringEquals" | "StringLike";
export const SearchFilterOperator = S.Literal("StringEquals", "StringLike");
export type FolderFilterAttribute =
  | "PARENT_FOLDER_ARN"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER"
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
  | "QUICKSIGHT_OWNER"
  | "QUICKSIGHT_VIEWER_OR_OWNER"
  | "FOLDER_NAME";
export const FolderFilterAttribute = S.Literal(
  "PARENT_FOLDER_ARN",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
  "QUICKSIGHT_OWNER",
  "QUICKSIGHT_VIEWER_OR_OWNER",
  "FOLDER_NAME",
);
export type GroupFilterOperator = "StartsWith";
export const GroupFilterOperator = S.Literal("StartsWith");
export type GroupFilterAttribute = "GROUP_NAME";
export const GroupFilterAttribute = S.Literal("GROUP_NAME");
export type TopicFilterOperator = "StringEquals" | "StringLike";
export const TopicFilterOperator = S.Literal("StringEquals", "StringLike");
export type TopicFilterAttribute =
  | "QUICKSIGHT_USER"
  | "QUICKSIGHT_VIEWER_OR_OWNER"
  | "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
  | "QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_OWNER"
  | "DIRECT_QUICKSIGHT_SOLE_OWNER"
  | "TOPIC_NAME";
export const TopicFilterAttribute = S.Literal(
  "QUICKSIGHT_USER",
  "QUICKSIGHT_VIEWER_OR_OWNER",
  "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
  "QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_OWNER",
  "DIRECT_QUICKSIGHT_SOLE_OWNER",
  "TOPIC_NAME",
);
export interface LinkSharingConfiguration {
  Permissions?: ResourcePermission[];
}
export const LinkSharingConfiguration = S.suspend(() =>
  S.Struct({ Permissions: S.optional(ResourcePermissionList) }),
).annotations({
  identifier: "LinkSharingConfiguration",
}) as any as S.Schema<LinkSharingConfiguration>;
export type IngestionStatus =
  | "INITIALIZED"
  | "QUEUED"
  | "RUNNING"
  | "FAILED"
  | "COMPLETED"
  | "CANCELLED";
export const IngestionStatus = S.Literal(
  "INITIALIZED",
  "QUEUED",
  "RUNNING",
  "FAILED",
  "COMPLETED",
  "CANCELLED",
);
export type NamespaceStatus =
  | "CREATED"
  | "CREATING"
  | "DELETING"
  | "RETRYABLE_FAILURE"
  | "NON_RETRYABLE_FAILURE";
export const NamespaceStatus = S.Literal(
  "CREATED",
  "CREATING",
  "DELETING",
  "RETRYABLE_FAILURE",
  "NON_RETRYABLE_FAILURE",
);
export type VPCConnectionResourceStatus =
  | "CREATION_IN_PROGRESS"
  | "CREATION_SUCCESSFUL"
  | "CREATION_FAILED"
  | "UPDATE_IN_PROGRESS"
  | "UPDATE_SUCCESSFUL"
  | "UPDATE_FAILED"
  | "DELETION_IN_PROGRESS"
  | "DELETION_FAILED"
  | "DELETED";
export const VPCConnectionResourceStatus = S.Literal(
  "CREATION_IN_PROGRESS",
  "CREATION_SUCCESSFUL",
  "CREATION_FAILED",
  "UPDATE_IN_PROGRESS",
  "UPDATE_SUCCESSFUL",
  "UPDATE_FAILED",
  "DELETION_IN_PROGRESS",
  "DELETION_FAILED",
  "DELETED",
);
export type VPCConnectionAvailabilityStatus =
  | "AVAILABLE"
  | "UNAVAILABLE"
  | "PARTIALLY_AVAILABLE";
export const VPCConnectionAvailabilityStatus = S.Literal(
  "AVAILABLE",
  "UNAVAILABLE",
  "PARTIALLY_AVAILABLE",
);
export type ResourceStatus =
  | "CREATION_IN_PROGRESS"
  | "CREATION_SUCCESSFUL"
  | "CREATION_FAILED"
  | "UPDATE_IN_PROGRESS"
  | "UPDATE_SUCCESSFUL"
  | "UPDATE_FAILED"
  | "DELETED";
export const ResourceStatus = S.Literal(
  "CREATION_IN_PROGRESS",
  "CREATION_SUCCESSFUL",
  "CREATION_FAILED",
  "UPDATE_IN_PROGRESS",
  "UPDATE_SUCCESSFUL",
  "UPDATE_FAILED",
  "DELETED",
);
export type AssetBundleExportJobStatus =
  | "QUEUED_FOR_IMMEDIATE_EXECUTION"
  | "IN_PROGRESS"
  | "SUCCESSFUL"
  | "FAILED";
export const AssetBundleExportJobStatus = S.Literal(
  "QUEUED_FOR_IMMEDIATE_EXECUTION",
  "IN_PROGRESS",
  "SUCCESSFUL",
  "FAILED",
);
export type AssetBundleImportJobStatus =
  | "QUEUED_FOR_IMMEDIATE_EXECUTION"
  | "IN_PROGRESS"
  | "SUCCESSFUL"
  | "FAILED"
  | "FAILED_ROLLBACK_IN_PROGRESS"
  | "FAILED_ROLLBACK_COMPLETED"
  | "FAILED_ROLLBACK_ERROR";
export const AssetBundleImportJobStatus = S.Literal(
  "QUEUED_FOR_IMMEDIATE_EXECUTION",
  "IN_PROGRESS",
  "SUCCESSFUL",
  "FAILED",
  "FAILED_ROLLBACK_IN_PROGRESS",
  "FAILED_ROLLBACK_COMPLETED",
  "FAILED_ROLLBACK_ERROR",
);
export type SnapshotJobStatus = "QUEUED" | "RUNNING" | "COMPLETED" | "FAILED";
export const SnapshotJobStatus = S.Literal(
  "QUEUED",
  "RUNNING",
  "COMPLETED",
  "FAILED",
);
export interface SessionTag {
  Key: string;
  Value: string | redacted.Redacted<string>;
}
export const SessionTag = S.suspend(() =>
  S.Struct({ Key: S.String, Value: SensitiveString }),
).annotations({ identifier: "SessionTag" }) as any as S.Schema<SessionTag>;
export type SessionTagList = SessionTag[];
export const SessionTagList = S.Array(SessionTag);
export type FlowPublishState = "PUBLISHED" | "DRAFT" | "PENDING_APPROVAL";
export const FlowPublishState = S.Literal(
  "PUBLISHED",
  "DRAFT",
  "PENDING_APPROVAL",
);
export type PermissionsList = Permission[];
export const PermissionsList = S.Array(Permission);
export type UserIdentifier =
  | { UserName: string | redacted.Redacted<string> }
  | { Email: string | redacted.Redacted<string> }
  | { UserArn: string };
export const UserIdentifier = S.Union(
  S.Struct({ UserName: SensitiveString }),
  S.Struct({ Email: SensitiveString }),
  S.Struct({ UserArn: S.String }),
);
export interface CustomPermissions {
  Arn?: string;
  CustomPermissionsName?: string;
  Capabilities?: Capabilities;
}
export const CustomPermissions = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    CustomPermissionsName: S.optional(S.String),
    Capabilities: S.optional(Capabilities),
  }),
).annotations({
  identifier: "CustomPermissions",
}) as any as S.Schema<CustomPermissions>;
export type CustomPermissionsList = CustomPermissions[];
export const CustomPermissionsList = S.Array(CustomPermissions);
export type DataSourceErrorInfoType =
  | "ACCESS_DENIED"
  | "COPY_SOURCE_NOT_FOUND"
  | "TIMEOUT"
  | "ENGINE_VERSION_NOT_SUPPORTED"
  | "UNKNOWN_HOST"
  | "GENERIC_SQL_FAILURE"
  | "CONFLICT"
  | "UNKNOWN";
export const DataSourceErrorInfoType = S.Literal(
  "ACCESS_DENIED",
  "COPY_SOURCE_NOT_FOUND",
  "TIMEOUT",
  "ENGINE_VERSION_NOT_SUPPORTED",
  "UNKNOWN_HOST",
  "GENERIC_SQL_FAILURE",
  "CONFLICT",
  "UNKNOWN",
);
export interface DataSourceErrorInfo {
  Type?: DataSourceErrorInfoType;
  Message?: string;
}
export const DataSourceErrorInfo = S.suspend(() =>
  S.Struct({
    Type: S.optional(DataSourceErrorInfoType),
    Message: S.optional(S.String),
  }),
).annotations({
  identifier: "DataSourceErrorInfo",
}) as any as S.Schema<DataSourceErrorInfo>;
export interface DataSource {
  Arn?: string;
  DataSourceId?: string;
  Name?: string;
  Type?: DataSourceType;
  Status?: ResourceStatus;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  DataSourceParameters?: DataSourceParameters;
  AlternateDataSourceParameters?: DataSourceParameters[];
  VpcConnectionProperties?: VpcConnectionProperties;
  SslProperties?: SslProperties;
  ErrorInfo?: DataSourceErrorInfo;
  SecretArn?: string;
}
export const DataSource = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSourceId: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(DataSourceType),
    Status: S.optional(ResourceStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    DataSourceParameters: S.optional(DataSourceParameters),
    AlternateDataSourceParameters: S.optional(DataSourceParametersList),
    VpcConnectionProperties: S.optional(VpcConnectionProperties),
    SslProperties: S.optional(SslProperties),
    ErrorInfo: S.optional(DataSourceErrorInfo),
    SecretArn: S.optional(S.String),
  }),
).annotations({ identifier: "DataSource" }) as any as S.Schema<DataSource>;
export type DataSourceList = DataSource[];
export const DataSourceList = S.Array(DataSource);
export type FoldersForResourceArnList = string[];
export const FoldersForResourceArnList = S.Array(S.String);
export interface GroupMember {
  Arn?: string;
  MemberName?: string;
}
export const GroupMember = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), MemberName: S.optional(S.String) }),
).annotations({ identifier: "GroupMember" }) as any as S.Schema<GroupMember>;
export type GroupMemberList = GroupMember[];
export const GroupMemberList = S.Array(GroupMember);
export interface Group {
  Arn?: string;
  GroupName?: string;
  Description?: string;
  PrincipalId?: string;
}
export const Group = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    GroupName: S.optional(S.String),
    Description: S.optional(S.String),
    PrincipalId: S.optional(S.String),
  }),
).annotations({ identifier: "Group" }) as any as S.Schema<Group>;
export type GroupList = Group[];
export const GroupList = S.Array(Group);
export type IngestionErrorType =
  | "FAILURE_TO_ASSUME_ROLE"
  | "INGESTION_SUPERSEDED"
  | "INGESTION_CANCELED"
  | "DATA_SET_DELETED"
  | "DATA_SET_NOT_SPICE"
  | "S3_UPLOADED_FILE_DELETED"
  | "S3_MANIFEST_ERROR"
  | "DATA_TOLERANCE_EXCEPTION"
  | "SPICE_TABLE_NOT_FOUND"
  | "DATA_SET_SIZE_LIMIT_EXCEEDED"
  | "ROW_SIZE_LIMIT_EXCEEDED"
  | "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
  | "CUSTOMER_ERROR"
  | "DATA_SOURCE_NOT_FOUND"
  | "IAM_ROLE_NOT_AVAILABLE"
  | "CONNECTION_FAILURE"
  | "SQL_TABLE_NOT_FOUND"
  | "PERMISSION_DENIED"
  | "SSL_CERTIFICATE_VALIDATION_FAILURE"
  | "OAUTH_TOKEN_FAILURE"
  | "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
  | "PASSWORD_AUTHENTICATION_FAILURE"
  | "SQL_SCHEMA_MISMATCH_ERROR"
  | "INVALID_DATE_FORMAT"
  | "INVALID_DATAPREP_SYNTAX"
  | "SOURCE_RESOURCE_LIMIT_EXCEEDED"
  | "SQL_INVALID_PARAMETER_VALUE"
  | "QUERY_TIMEOUT"
  | "SQL_NUMERIC_OVERFLOW"
  | "UNRESOLVABLE_HOST"
  | "UNROUTABLE_HOST"
  | "SQL_EXCEPTION"
  | "S3_FILE_INACCESSIBLE"
  | "IOT_FILE_NOT_FOUND"
  | "IOT_DATA_SET_FILE_EMPTY"
  | "INVALID_DATA_SOURCE_CONFIG"
  | "DATA_SOURCE_AUTH_FAILED"
  | "DATA_SOURCE_CONNECTION_FAILED"
  | "FAILURE_TO_PROCESS_JSON_FILE"
  | "INTERNAL_SERVICE_ERROR"
  | "REFRESH_SUPPRESSED_BY_EDIT"
  | "PERMISSION_NOT_FOUND"
  | "ELASTICSEARCH_CURSOR_NOT_ENABLED"
  | "CURSOR_NOT_ENABLED"
  | "DUPLICATE_COLUMN_NAMES_FOUND";
export const IngestionErrorType = S.Literal(
  "FAILURE_TO_ASSUME_ROLE",
  "INGESTION_SUPERSEDED",
  "INGESTION_CANCELED",
  "DATA_SET_DELETED",
  "DATA_SET_NOT_SPICE",
  "S3_UPLOADED_FILE_DELETED",
  "S3_MANIFEST_ERROR",
  "DATA_TOLERANCE_EXCEPTION",
  "SPICE_TABLE_NOT_FOUND",
  "DATA_SET_SIZE_LIMIT_EXCEEDED",
  "ROW_SIZE_LIMIT_EXCEEDED",
  "ACCOUNT_CAPACITY_LIMIT_EXCEEDED",
  "CUSTOMER_ERROR",
  "DATA_SOURCE_NOT_FOUND",
  "IAM_ROLE_NOT_AVAILABLE",
  "CONNECTION_FAILURE",
  "SQL_TABLE_NOT_FOUND",
  "PERMISSION_DENIED",
  "SSL_CERTIFICATE_VALIDATION_FAILURE",
  "OAUTH_TOKEN_FAILURE",
  "SOURCE_API_LIMIT_EXCEEDED_FAILURE",
  "PASSWORD_AUTHENTICATION_FAILURE",
  "SQL_SCHEMA_MISMATCH_ERROR",
  "INVALID_DATE_FORMAT",
  "INVALID_DATAPREP_SYNTAX",
  "SOURCE_RESOURCE_LIMIT_EXCEEDED",
  "SQL_INVALID_PARAMETER_VALUE",
  "QUERY_TIMEOUT",
  "SQL_NUMERIC_OVERFLOW",
  "UNRESOLVABLE_HOST",
  "UNROUTABLE_HOST",
  "SQL_EXCEPTION",
  "S3_FILE_INACCESSIBLE",
  "IOT_FILE_NOT_FOUND",
  "IOT_DATA_SET_FILE_EMPTY",
  "INVALID_DATA_SOURCE_CONFIG",
  "DATA_SOURCE_AUTH_FAILED",
  "DATA_SOURCE_CONNECTION_FAILED",
  "FAILURE_TO_PROCESS_JSON_FILE",
  "INTERNAL_SERVICE_ERROR",
  "REFRESH_SUPPRESSED_BY_EDIT",
  "PERMISSION_NOT_FOUND",
  "ELASTICSEARCH_CURSOR_NOT_ENABLED",
  "CURSOR_NOT_ENABLED",
  "DUPLICATE_COLUMN_NAMES_FOUND",
);
export interface ErrorInfo {
  Type?: IngestionErrorType;
  Message?: string;
}
export const ErrorInfo = S.suspend(() =>
  S.Struct({
    Type: S.optional(IngestionErrorType),
    Message: S.optional(S.String),
  }),
).annotations({ identifier: "ErrorInfo" }) as any as S.Schema<ErrorInfo>;
export interface RowInfo {
  RowsIngested?: number;
  RowsDropped?: number;
  TotalRowsInDataset?: number;
}
export const RowInfo = S.suspend(() =>
  S.Struct({
    RowsIngested: S.optional(S.Number),
    RowsDropped: S.optional(S.Number),
    TotalRowsInDataset: S.optional(S.Number),
  }),
).annotations({ identifier: "RowInfo" }) as any as S.Schema<RowInfo>;
export interface QueueInfo {
  WaitingOnIngestion: string;
  QueuedIngestion: string;
}
export const QueueInfo = S.suspend(() =>
  S.Struct({ WaitingOnIngestion: S.String, QueuedIngestion: S.String }),
).annotations({ identifier: "QueueInfo" }) as any as S.Schema<QueueInfo>;
export type IngestionRequestSource = "MANUAL" | "SCHEDULED";
export const IngestionRequestSource = S.Literal("MANUAL", "SCHEDULED");
export type IngestionRequestType =
  | "INITIAL_INGESTION"
  | "EDIT"
  | "INCREMENTAL_REFRESH"
  | "FULL_REFRESH";
export const IngestionRequestType = S.Literal(
  "INITIAL_INGESTION",
  "EDIT",
  "INCREMENTAL_REFRESH",
  "FULL_REFRESH",
);
export interface Ingestion {
  Arn: string;
  IngestionId?: string;
  IngestionStatus: IngestionStatus;
  ErrorInfo?: ErrorInfo;
  RowInfo?: RowInfo;
  QueueInfo?: QueueInfo;
  CreatedTime: Date;
  IngestionTimeInSeconds?: number;
  IngestionSizeInBytes?: number;
  RequestSource?: IngestionRequestSource;
  RequestType?: IngestionRequestType;
}
export const Ingestion = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    IngestionId: S.optional(S.String),
    IngestionStatus: IngestionStatus,
    ErrorInfo: S.optional(ErrorInfo),
    RowInfo: S.optional(RowInfo),
    QueueInfo: S.optional(QueueInfo),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    IngestionTimeInSeconds: S.optional(S.Number),
    IngestionSizeInBytes: S.optional(S.Number),
    RequestSource: S.optional(IngestionRequestSource),
    RequestType: S.optional(IngestionRequestType),
  }),
).annotations({ identifier: "Ingestion" }) as any as S.Schema<Ingestion>;
export type Ingestions = Ingestion[];
export const Ingestions = S.Array(Ingestion);
export type NamespaceErrorType = "PERMISSION_DENIED" | "INTERNAL_SERVICE_ERROR";
export const NamespaceErrorType = S.Literal(
  "PERMISSION_DENIED",
  "INTERNAL_SERVICE_ERROR",
);
export interface NamespaceError {
  Type?: NamespaceErrorType;
  Message?: string;
}
export const NamespaceError = S.suspend(() =>
  S.Struct({
    Type: S.optional(NamespaceErrorType),
    Message: S.optional(S.String),
  }),
).annotations({
  identifier: "NamespaceError",
}) as any as S.Schema<NamespaceError>;
export interface NamespaceInfoV2 {
  Name?: string;
  Arn?: string;
  CapacityRegion?: string;
  CreationStatus?: NamespaceStatus;
  IdentityStore?: IdentityStore;
  NamespaceError?: NamespaceError;
  IamIdentityCenterApplicationArn?: string;
  IamIdentityCenterInstanceArn?: string;
}
export const NamespaceInfoV2 = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Arn: S.optional(S.String),
    CapacityRegion: S.optional(S.String),
    CreationStatus: S.optional(NamespaceStatus),
    IdentityStore: S.optional(IdentityStore),
    NamespaceError: S.optional(NamespaceError),
    IamIdentityCenterApplicationArn: S.optional(S.String),
    IamIdentityCenterInstanceArn: S.optional(S.String),
  }),
).annotations({
  identifier: "NamespaceInfoV2",
}) as any as S.Schema<NamespaceInfoV2>;
export type Namespaces = NamespaceInfoV2[];
export const Namespaces = S.Array(NamespaceInfoV2);
export type RefreshSchedules = RefreshSchedule[];
export const RefreshSchedules = S.Array(RefreshSchedule);
export interface TemplateAlias {
  AliasName?: string;
  Arn?: string;
  TemplateVersionNumber?: number;
}
export const TemplateAlias = S.suspend(() =>
  S.Struct({
    AliasName: S.optional(S.String),
    Arn: S.optional(S.String),
    TemplateVersionNumber: S.optional(S.Number),
  }),
).annotations({
  identifier: "TemplateAlias",
}) as any as S.Schema<TemplateAlias>;
export type TemplateAliasList = TemplateAlias[];
export const TemplateAliasList = S.Array(TemplateAlias);
export interface ThemeAlias {
  Arn?: string;
  AliasName?: string;
  ThemeVersionNumber?: number;
}
export const ThemeAlias = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AliasName: S.optional(S.String),
    ThemeVersionNumber: S.optional(S.Number),
  }),
).annotations({ identifier: "ThemeAlias" }) as any as S.Schema<ThemeAlias>;
export type ThemeAliasList = ThemeAlias[];
export const ThemeAliasList = S.Array(ThemeAlias);
export interface User {
  Arn?: string;
  UserName?: string;
  Email?: string;
  Role?: UserRole;
  IdentityType?: IdentityType;
  Active?: boolean;
  PrincipalId?: string;
  CustomPermissionsName?: string;
  ExternalLoginFederationProviderType?: string;
  ExternalLoginFederationProviderUrl?: string;
  ExternalLoginId?: string;
}
export const User = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    UserName: S.optional(S.String),
    Email: S.optional(S.String),
    Role: S.optional(UserRole),
    IdentityType: S.optional(IdentityType),
    Active: S.optional(S.Boolean),
    PrincipalId: S.optional(S.String),
    CustomPermissionsName: S.optional(S.String),
    ExternalLoginFederationProviderType: S.optional(S.String),
    ExternalLoginFederationProviderUrl: S.optional(S.String),
    ExternalLoginId: S.optional(S.String),
  }),
).annotations({ identifier: "User" }) as any as S.Schema<User>;
export type UserList = User[];
export const UserList = S.Array(User);
export type QAResultType =
  | "DASHBOARD_VISUAL"
  | "GENERATED_ANSWER"
  | "NO_ANSWER";
export const QAResultType = S.Literal(
  "DASHBOARD_VISUAL",
  "GENERATED_ANSWER",
  "NO_ANSWER",
);
export interface DashboardVisualResult {
  DashboardId?: string;
  DashboardName?: string;
  SheetId?: string;
  SheetName?: string;
  VisualId?: string;
  VisualTitle?: string;
  VisualSubtitle?: string;
  DashboardUrl?: string;
}
export const DashboardVisualResult = S.suspend(() =>
  S.Struct({
    DashboardId: S.optional(S.String),
    DashboardName: S.optional(S.String),
    SheetId: S.optional(S.String),
    SheetName: S.optional(S.String),
    VisualId: S.optional(S.String),
    VisualTitle: S.optional(S.String),
    VisualSubtitle: S.optional(S.String),
    DashboardUrl: S.optional(S.String),
  }),
).annotations({
  identifier: "DashboardVisualResult",
}) as any as S.Schema<DashboardVisualResult>;
export type GeneratedAnswerStatus =
  | "ANSWER_GENERATED"
  | "ANSWER_RETRIEVED"
  | "ANSWER_DOWNGRADE";
export const GeneratedAnswerStatus = S.Literal(
  "ANSWER_GENERATED",
  "ANSWER_RETRIEVED",
  "ANSWER_DOWNGRADE",
);
export interface GeneratedAnswerResult {
  QuestionText?: string | redacted.Redacted<string>;
  AnswerStatus?: GeneratedAnswerStatus;
  TopicId?: string;
  TopicName?: string;
  Restatement?: string | redacted.Redacted<string>;
  QuestionId?: string;
  AnswerId?: string;
  QuestionUrl?: string;
}
export const GeneratedAnswerResult = S.suspend(() =>
  S.Struct({
    QuestionText: S.optional(SensitiveString),
    AnswerStatus: S.optional(GeneratedAnswerStatus),
    TopicId: S.optional(S.String),
    TopicName: S.optional(S.String),
    Restatement: S.optional(SensitiveString),
    QuestionId: S.optional(S.String),
    AnswerId: S.optional(S.String),
    QuestionUrl: S.optional(S.String),
  }),
).annotations({
  identifier: "GeneratedAnswerResult",
}) as any as S.Schema<GeneratedAnswerResult>;
export interface QAResult {
  ResultType?: QAResultType;
  DashboardVisual?: DashboardVisualResult;
  GeneratedAnswer?: GeneratedAnswerResult;
}
export const QAResult = S.suspend(() =>
  S.Struct({
    ResultType: S.optional(QAResultType),
    DashboardVisual: S.optional(DashboardVisualResult),
    GeneratedAnswer: S.optional(GeneratedAnswerResult),
  }),
).annotations({ identifier: "QAResult" }) as any as S.Schema<QAResult>;
export type QAResults = QAResult[];
export const QAResults = S.Array(QAResult);
export interface ActionConnectorSearchFilter {
  Name: ActionConnectorSearchFilterNameEnum;
  Operator: FilterOperator;
  Value: string;
}
export const ActionConnectorSearchFilter = S.suspend(() =>
  S.Struct({
    Name: ActionConnectorSearchFilterNameEnum,
    Operator: FilterOperator,
    Value: S.String,
  }),
).annotations({
  identifier: "ActionConnectorSearchFilter",
}) as any as S.Schema<ActionConnectorSearchFilter>;
export type ActionConnectorSearchFilterList = ActionConnectorSearchFilter[];
export const ActionConnectorSearchFilterList = S.Array(
  ActionConnectorSearchFilter,
);
export interface AnalysisSearchFilter {
  Operator?: FilterOperator;
  Name?: AnalysisFilterAttribute;
  Value?: string;
}
export const AnalysisSearchFilter = S.suspend(() =>
  S.Struct({
    Operator: S.optional(FilterOperator),
    Name: S.optional(AnalysisFilterAttribute),
    Value: S.optional(S.String),
  }),
).annotations({
  identifier: "AnalysisSearchFilter",
}) as any as S.Schema<AnalysisSearchFilter>;
export type AnalysisSearchFilterList = AnalysisSearchFilter[];
export const AnalysisSearchFilterList = S.Array(AnalysisSearchFilter);
export interface DashboardSearchFilter {
  Operator: FilterOperator;
  Name?: DashboardFilterAttribute;
  Value?: string;
}
export const DashboardSearchFilter = S.suspend(() =>
  S.Struct({
    Operator: FilterOperator,
    Name: S.optional(DashboardFilterAttribute),
    Value: S.optional(S.String),
  }),
).annotations({
  identifier: "DashboardSearchFilter",
}) as any as S.Schema<DashboardSearchFilter>;
export type DashboardSearchFilterList = DashboardSearchFilter[];
export const DashboardSearchFilterList = S.Array(DashboardSearchFilter);
export interface DataSetSearchFilter {
  Operator: FilterOperator;
  Name: DataSetFilterAttribute;
  Value: string;
}
export const DataSetSearchFilter = S.suspend(() =>
  S.Struct({
    Operator: FilterOperator,
    Name: DataSetFilterAttribute,
    Value: S.String,
  }),
).annotations({
  identifier: "DataSetSearchFilter",
}) as any as S.Schema<DataSetSearchFilter>;
export type DataSetSearchFilterList = DataSetSearchFilter[];
export const DataSetSearchFilterList = S.Array(DataSetSearchFilter);
export interface DataSourceSearchFilter {
  Operator: FilterOperator;
  Name: DataSourceFilterAttribute;
  Value: string;
}
export const DataSourceSearchFilter = S.suspend(() =>
  S.Struct({
    Operator: FilterOperator,
    Name: DataSourceFilterAttribute,
    Value: S.String,
  }),
).annotations({
  identifier: "DataSourceSearchFilter",
}) as any as S.Schema<DataSourceSearchFilter>;
export type DataSourceSearchFilterList = DataSourceSearchFilter[];
export const DataSourceSearchFilterList = S.Array(DataSourceSearchFilter);
export interface SearchFlowsFilter {
  Name: FieldName;
  Operator: SearchFilterOperator;
  Value: string;
}
export const SearchFlowsFilter = S.suspend(() =>
  S.Struct({
    Name: FieldName,
    Operator: SearchFilterOperator,
    Value: S.String,
  }),
).annotations({
  identifier: "SearchFlowsFilter",
}) as any as S.Schema<SearchFlowsFilter>;
export type SearchFlowsFilterList = SearchFlowsFilter[];
export const SearchFlowsFilterList = S.Array(SearchFlowsFilter);
export interface FolderSearchFilter {
  Operator?: FilterOperator;
  Name?: FolderFilterAttribute;
  Value?: string;
}
export const FolderSearchFilter = S.suspend(() =>
  S.Struct({
    Operator: S.optional(FilterOperator),
    Name: S.optional(FolderFilterAttribute),
    Value: S.optional(S.String),
  }),
).annotations({
  identifier: "FolderSearchFilter",
}) as any as S.Schema<FolderSearchFilter>;
export type FolderSearchFilterList = FolderSearchFilter[];
export const FolderSearchFilterList = S.Array(FolderSearchFilter);
export interface GroupSearchFilter {
  Operator: GroupFilterOperator;
  Name: GroupFilterAttribute;
  Value: string;
}
export const GroupSearchFilter = S.suspend(() =>
  S.Struct({
    Operator: GroupFilterOperator,
    Name: GroupFilterAttribute,
    Value: S.String,
  }),
).annotations({
  identifier: "GroupSearchFilter",
}) as any as S.Schema<GroupSearchFilter>;
export type GroupSearchFilterList = GroupSearchFilter[];
export const GroupSearchFilterList = S.Array(GroupSearchFilter);
export interface TopicSearchFilter {
  Operator: TopicFilterOperator;
  Name: TopicFilterAttribute;
  Value: string;
}
export const TopicSearchFilter = S.suspend(() =>
  S.Struct({
    Operator: TopicFilterOperator,
    Name: TopicFilterAttribute,
    Value: S.String,
  }),
).annotations({
  identifier: "TopicSearchFilter",
}) as any as S.Schema<TopicSearchFilter>;
export type TopicSearchFilterList = TopicSearchFilter[];
export const TopicSearchFilterList = S.Array(TopicSearchFilter);
export interface AssetBundleExportJobValidationStrategy {
  StrictModeForAllResources?: boolean;
}
export const AssetBundleExportJobValidationStrategy = S.suspend(() =>
  S.Struct({ StrictModeForAllResources: S.optional(S.Boolean) }),
).annotations({
  identifier: "AssetBundleExportJobValidationStrategy",
}) as any as S.Schema<AssetBundleExportJobValidationStrategy>;
export interface AssetBundleImportSource {
  Body?: Uint8Array | redacted.Redacted<Uint8Array>;
  S3Uri?: string;
}
export const AssetBundleImportSource = S.suspend(() =>
  S.Struct({ Body: S.optional(SensitiveBlob), S3Uri: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleImportSource",
}) as any as S.Schema<AssetBundleImportSource>;
export interface AssetBundleImportJobOverrideValidationStrategy {
  StrictModeForAllResources?: boolean;
}
export const AssetBundleImportJobOverrideValidationStrategy = S.suspend(() =>
  S.Struct({ StrictModeForAllResources: S.optional(S.Boolean) }),
).annotations({
  identifier: "AssetBundleImportJobOverrideValidationStrategy",
}) as any as S.Schema<AssetBundleImportJobOverrideValidationStrategy>;
export type UpdateFlowPermissionsInputGrantPermissionsList = Permission[];
export const UpdateFlowPermissionsInputGrantPermissionsList =
  S.Array(Permission);
export type IpRestrictionRuleMap = { [key: string]: string };
export const IpRestrictionRuleMap = S.Record({
  key: S.String,
  value: S.String,
});
export type VpcIdRestrictionRuleMap = { [key: string]: string };
export const VpcIdRestrictionRuleMap = S.Record({
  key: S.String,
  value: S.String,
});
export type VpcEndpointIdRestrictionRuleMap = { [key: string]: string };
export const VpcEndpointIdRestrictionRuleMap = S.Record({
  key: S.String,
  value: S.String,
});
export interface RegisteredCustomerManagedKey {
  KeyArn?: string;
  DefaultKey?: boolean;
}
export const RegisteredCustomerManagedKey = S.suspend(() =>
  S.Struct({ KeyArn: S.optional(S.String), DefaultKey: S.optional(S.Boolean) }),
).annotations({
  identifier: "RegisteredCustomerManagedKey",
}) as any as S.Schema<RegisteredCustomerManagedKey>;
export type KeyRegistration = RegisteredCustomerManagedKey[];
export const KeyRegistration = S.Array(RegisteredCustomerManagedKey);
export type VisualRole =
  | "PRIMARY"
  | "COMPLIMENTARY"
  | "MULTI_INTENT"
  | "FALLBACK"
  | "FRAGMENT";
export const VisualRole = S.Literal(
  "PRIMARY",
  "COMPLIMENTARY",
  "MULTI_INTENT",
  "FALLBACK",
  "FRAGMENT",
);
export type TopicVisuals = TopicVisual[];
export const TopicVisuals = S.Array(
  S.suspend((): S.Schema<TopicVisual, any> => TopicVisual).annotations({
    identifier: "TopicVisual",
  }),
) as any as S.Schema<TopicVisuals>;
export type AnonymousUserDashboardEmbeddingConfigurationEnabledFeature =
  "SHARED_VIEW";
export const AnonymousUserDashboardEmbeddingConfigurationEnabledFeature =
  S.Literal("SHARED_VIEW");
export type AnonymousUserDashboardEmbeddingConfigurationEnabledFeatures =
  AnonymousUserDashboardEmbeddingConfigurationEnabledFeature[];
export const AnonymousUserDashboardEmbeddingConfigurationEnabledFeatures =
  S.Array(AnonymousUserDashboardEmbeddingConfigurationEnabledFeature);
export type AnonymousUserDashboardEmbeddingConfigurationDisabledFeature =
  "SHARED_VIEW";
export const AnonymousUserDashboardEmbeddingConfigurationDisabledFeature =
  S.Literal("SHARED_VIEW");
export type AnonymousUserDashboardEmbeddingConfigurationDisabledFeatures =
  AnonymousUserDashboardEmbeddingConfigurationDisabledFeature[];
export const AnonymousUserDashboardEmbeddingConfigurationDisabledFeatures =
  S.Array(AnonymousUserDashboardEmbeddingConfigurationDisabledFeature);
export type AssetBundleExportJobVPCConnectionPropertyToOverride =
  | "Name"
  | "DnsResolvers"
  | "RoleArn";
export const AssetBundleExportJobVPCConnectionPropertyToOverride = S.Literal(
  "Name",
  "DnsResolvers",
  "RoleArn",
);
export type AssetBundleExportJobVPCConnectionPropertyToOverrideList =
  AssetBundleExportJobVPCConnectionPropertyToOverride[];
export const AssetBundleExportJobVPCConnectionPropertyToOverrideList = S.Array(
  AssetBundleExportJobVPCConnectionPropertyToOverride,
);
export type AssetBundleExportJobRefreshSchedulePropertyToOverride =
  "StartAfterDateTime";
export const AssetBundleExportJobRefreshSchedulePropertyToOverride =
  S.Literal("StartAfterDateTime");
export type AssetBundleExportJobRefreshSchedulePropertyToOverrideList =
  AssetBundleExportJobRefreshSchedulePropertyToOverride[];
export const AssetBundleExportJobRefreshSchedulePropertyToOverrideList =
  S.Array(AssetBundleExportJobRefreshSchedulePropertyToOverride);
export type AssetBundleExportJobDataSourcePropertyToOverride =
  | "Name"
  | "DisableSsl"
  | "SecretArn"
  | "Username"
  | "Password"
  | "Domain"
  | "WorkGroup"
  | "Host"
  | "Port"
  | "Database"
  | "DataSetName"
  | "Catalog"
  | "InstanceId"
  | "ClusterId"
  | "ManifestFileLocation"
  | "Warehouse"
  | "RoleArn"
  | "ProductType";
export const AssetBundleExportJobDataSourcePropertyToOverride = S.Literal(
  "Name",
  "DisableSsl",
  "SecretArn",
  "Username",
  "Password",
  "Domain",
  "WorkGroup",
  "Host",
  "Port",
  "Database",
  "DataSetName",
  "Catalog",
  "InstanceId",
  "ClusterId",
  "ManifestFileLocation",
  "Warehouse",
  "RoleArn",
  "ProductType",
);
export type AssetBundleExportJobDataSourcePropertyToOverrideList =
  AssetBundleExportJobDataSourcePropertyToOverride[];
export const AssetBundleExportJobDataSourcePropertyToOverrideList = S.Array(
  AssetBundleExportJobDataSourcePropertyToOverride,
);
export type AssetBundleExportJobDataSetPropertyToOverride =
  | "Name"
  | "RefreshFailureEmailAlertStatus";
export const AssetBundleExportJobDataSetPropertyToOverride = S.Literal(
  "Name",
  "RefreshFailureEmailAlertStatus",
);
export type AssetBundleExportJobDataSetPropertyToOverrideList =
  AssetBundleExportJobDataSetPropertyToOverride[];
export const AssetBundleExportJobDataSetPropertyToOverrideList = S.Array(
  AssetBundleExportJobDataSetPropertyToOverride,
);
export type AssetBundleExportJobThemePropertyToOverride = "Name";
export const AssetBundleExportJobThemePropertyToOverride = S.Literal("Name");
export type AssetBundleExportJobThemePropertyToOverrideList =
  AssetBundleExportJobThemePropertyToOverride[];
export const AssetBundleExportJobThemePropertyToOverrideList = S.Array(
  AssetBundleExportJobThemePropertyToOverride,
);
export type AssetBundleExportJobAnalysisPropertyToOverride = "Name";
export const AssetBundleExportJobAnalysisPropertyToOverride = S.Literal("Name");
export type AssetBundleExportJobAnalysisPropertyToOverrideList =
  AssetBundleExportJobAnalysisPropertyToOverride[];
export const AssetBundleExportJobAnalysisPropertyToOverrideList = S.Array(
  AssetBundleExportJobAnalysisPropertyToOverride,
);
export type AssetBundleExportJobDashboardPropertyToOverride = "Name";
export const AssetBundleExportJobDashboardPropertyToOverride =
  S.Literal("Name");
export type AssetBundleExportJobDashboardPropertyToOverrideList =
  AssetBundleExportJobDashboardPropertyToOverride[];
export const AssetBundleExportJobDashboardPropertyToOverrideList = S.Array(
  AssetBundleExportJobDashboardPropertyToOverride,
);
export type AssetBundleExportJobFolderPropertyToOverride =
  | "Name"
  | "ParentFolderArn";
export const AssetBundleExportJobFolderPropertyToOverride = S.Literal(
  "Name",
  "ParentFolderArn",
);
export type AssetBundleExportJobFolderPropertyToOverrideList =
  AssetBundleExportJobFolderPropertyToOverride[];
export const AssetBundleExportJobFolderPropertyToOverrideList = S.Array(
  AssetBundleExportJobFolderPropertyToOverride,
);
export type AssetBundleRestrictiveResourceIdList = string[];
export const AssetBundleRestrictiveResourceIdList = S.Array(S.String);
export interface CancelIngestionResponse {
  Arn?: string;
  IngestionId?: string;
  RequestId?: string;
  Status?: number;
}
export const CancelIngestionResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    IngestionId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CancelIngestionResponse",
}) as any as S.Schema<CancelIngestionResponse>;
export interface CreateAccountCustomizationRequest {
  AwsAccountId: string;
  Namespace?: string;
  AccountCustomization: AccountCustomization;
  Tags?: Tag[];
}
export const CreateAccountCustomizationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Namespace: S.optional(S.String).pipe(T.HttpQuery("namespace")),
    AccountCustomization: AccountCustomization,
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/customizations",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateAccountCustomizationRequest",
}) as any as S.Schema<CreateAccountCustomizationRequest>;
export interface CreateCustomPermissionsRequest {
  AwsAccountId: string;
  CustomPermissionsName: string;
  Capabilities?: Capabilities;
  Tags?: Tag[];
}
export const CreateCustomPermissionsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    CustomPermissionsName: S.String,
    Capabilities: S.optional(Capabilities),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/custom-permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateCustomPermissionsRequest",
}) as any as S.Schema<CreateCustomPermissionsRequest>;
export interface CreateFolderResponse {
  Status?: number;
  Arn?: string;
  FolderId?: string;
  RequestId?: string;
}
export const CreateFolderResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Arn: S.optional(S.String),
    FolderId: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateFolderResponse",
}) as any as S.Schema<CreateFolderResponse>;
export interface CreateIAMPolicyAssignmentRequest {
  AwsAccountId: string;
  AssignmentName: string;
  AssignmentStatus: AssignmentStatus;
  PolicyArn?: string;
  Identities?: { [key: string]: string[] };
  Namespace: string;
}
export const CreateIAMPolicyAssignmentRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssignmentName: S.String,
    AssignmentStatus: AssignmentStatus,
    PolicyArn: S.optional(S.String),
    Identities: S.optional(IdentityMap),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/iam-policy-assignments",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateIAMPolicyAssignmentRequest",
}) as any as S.Schema<CreateIAMPolicyAssignmentRequest>;
export interface CreateIngestionResponse {
  Arn?: string;
  IngestionId?: string;
  IngestionStatus?: IngestionStatus;
  RequestId?: string;
  Status?: number;
}
export const CreateIngestionResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    IngestionId: S.optional(S.String),
    IngestionStatus: S.optional(IngestionStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateIngestionResponse",
}) as any as S.Schema<CreateIngestionResponse>;
export interface CreateNamespaceResponse {
  Arn?: string;
  Name?: string;
  CapacityRegion?: string;
  CreationStatus?: NamespaceStatus;
  IdentityStore?: IdentityStore;
  RequestId?: string;
  Status?: number;
}
export const CreateNamespaceResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    CapacityRegion: S.optional(S.String),
    CreationStatus: S.optional(NamespaceStatus),
    IdentityStore: S.optional(IdentityStore),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateNamespaceResponse",
}) as any as S.Schema<CreateNamespaceResponse>;
export interface CreateRoleMembershipResponse {
  RequestId?: string;
  Status?: number;
}
export const CreateRoleMembershipResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateRoleMembershipResponse",
}) as any as S.Schema<CreateRoleMembershipResponse>;
export interface CreateTopicRefreshScheduleRequest {
  AwsAccountId: string;
  TopicId: string;
  DatasetArn: string;
  DatasetName?: string;
  RefreshSchedule: TopicRefreshSchedule;
}
export const CreateTopicRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    DatasetArn: S.String,
    DatasetName: S.optional(S.String),
    RefreshSchedule: TopicRefreshSchedule,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/schedules",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateTopicRefreshScheduleRequest",
}) as any as S.Schema<CreateTopicRefreshScheduleRequest>;
export interface CreateVPCConnectionResponse {
  Arn?: string;
  VPCConnectionId?: string;
  CreationStatus?: VPCConnectionResourceStatus;
  AvailabilityStatus?: VPCConnectionAvailabilityStatus;
  RequestId?: string;
  Status?: number;
}
export const CreateVPCConnectionResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VPCConnectionId: S.optional(S.String),
    CreationStatus: S.optional(VPCConnectionResourceStatus),
    AvailabilityStatus: S.optional(VPCConnectionAvailabilityStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateVPCConnectionResponse",
}) as any as S.Schema<CreateVPCConnectionResponse>;
export interface DeleteAccountCustomizationResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteAccountCustomizationResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteAccountCustomizationResponse",
}) as any as S.Schema<DeleteAccountCustomizationResponse>;
export interface DeleteAccountCustomPermissionResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteAccountCustomPermissionResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String), Status: S.optional(S.Number) }),
).annotations({
  identifier: "DeleteAccountCustomPermissionResponse",
}) as any as S.Schema<DeleteAccountCustomPermissionResponse>;
export interface DeleteAccountSubscriptionResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteAccountSubscriptionResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteAccountSubscriptionResponse",
}) as any as S.Schema<DeleteAccountSubscriptionResponse>;
export interface DeleteActionConnectorResponse {
  Arn?: string;
  ActionConnectorId?: string;
  RequestId?: string;
  Status?: number;
}
export const DeleteActionConnectorResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    ActionConnectorId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteActionConnectorResponse",
}) as any as S.Schema<DeleteActionConnectorResponse>;
export interface DeleteAnalysisResponse {
  Status?: number;
  Arn?: string;
  AnalysisId?: string;
  DeletionTime?: Date;
  RequestId?: string;
}
export const DeleteAnalysisResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Arn: S.optional(S.String),
    AnalysisId: S.optional(S.String),
    DeletionTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteAnalysisResponse",
}) as any as S.Schema<DeleteAnalysisResponse>;
export interface DeleteBrandResponse {
  RequestId?: string;
}
export const DeleteBrandResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String) }),
).annotations({
  identifier: "DeleteBrandResponse",
}) as any as S.Schema<DeleteBrandResponse>;
export interface DeleteBrandAssignmentResponse {
  RequestId?: string;
}
export const DeleteBrandAssignmentResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String) }),
).annotations({
  identifier: "DeleteBrandAssignmentResponse",
}) as any as S.Schema<DeleteBrandAssignmentResponse>;
export interface DeleteCustomPermissionsResponse {
  Status?: number;
  Arn?: string;
  RequestId?: string;
}
export const DeleteCustomPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number),
    Arn: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteCustomPermissionsResponse",
}) as any as S.Schema<DeleteCustomPermissionsResponse>;
export interface DeleteDashboardResponse {
  Status?: number;
  Arn?: string;
  DashboardId?: string;
  RequestId?: string;
}
export const DeleteDashboardResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Arn: S.optional(S.String),
    DashboardId: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteDashboardResponse",
}) as any as S.Schema<DeleteDashboardResponse>;
export interface DeleteDataSetResponse {
  Arn?: string;
  DataSetId?: string;
  RequestId?: string;
  Status?: number;
}
export const DeleteDataSetResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSetId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteDataSetResponse",
}) as any as S.Schema<DeleteDataSetResponse>;
export interface DeleteDataSetRefreshPropertiesResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteDataSetRefreshPropertiesResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteDataSetRefreshPropertiesResponse",
}) as any as S.Schema<DeleteDataSetRefreshPropertiesResponse>;
export interface DeleteDataSourceResponse {
  Arn?: string;
  DataSourceId?: string;
  RequestId?: string;
  Status?: number;
}
export const DeleteDataSourceResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSourceId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteDataSourceResponse",
}) as any as S.Schema<DeleteDataSourceResponse>;
export interface DeleteDefaultQBusinessApplicationResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteDefaultQBusinessApplicationResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteDefaultQBusinessApplicationResponse",
}) as any as S.Schema<DeleteDefaultQBusinessApplicationResponse>;
export interface DeleteFolderResponse {
  Status?: number;
  Arn?: string;
  FolderId?: string;
  RequestId?: string;
}
export const DeleteFolderResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Arn: S.optional(S.String),
    FolderId: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteFolderResponse",
}) as any as S.Schema<DeleteFolderResponse>;
export interface DeleteFolderMembershipResponse {
  Status?: number;
  RequestId?: string;
}
export const DeleteFolderMembershipResponse = S.suspend(() =>
  S.Struct({ Status: S.optional(S.Number), RequestId: S.optional(S.String) }),
).annotations({
  identifier: "DeleteFolderMembershipResponse",
}) as any as S.Schema<DeleteFolderMembershipResponse>;
export interface DeleteGroupResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteGroupResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteGroupResponse",
}) as any as S.Schema<DeleteGroupResponse>;
export interface DeleteGroupMembershipResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteGroupMembershipResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteGroupMembershipResponse",
}) as any as S.Schema<DeleteGroupMembershipResponse>;
export interface DeleteIAMPolicyAssignmentResponse {
  AssignmentName?: string;
  RequestId?: string;
  Status?: number;
}
export const DeleteIAMPolicyAssignmentResponse = S.suspend(() =>
  S.Struct({
    AssignmentName: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteIAMPolicyAssignmentResponse",
}) as any as S.Schema<DeleteIAMPolicyAssignmentResponse>;
export interface DeleteIdentityPropagationConfigResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteIdentityPropagationConfigResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteIdentityPropagationConfigResponse",
}) as any as S.Schema<DeleteIdentityPropagationConfigResponse>;
export interface DeleteNamespaceResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteNamespaceResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteNamespaceResponse",
}) as any as S.Schema<DeleteNamespaceResponse>;
export interface DeleteRefreshScheduleResponse {
  Status?: number;
  RequestId?: string;
  ScheduleId?: string;
  Arn?: string;
}
export const DeleteRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    ScheduleId: S.optional(S.String),
    Arn: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteRefreshScheduleResponse",
}) as any as S.Schema<DeleteRefreshScheduleResponse>;
export interface DeleteRoleCustomPermissionResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteRoleCustomPermissionResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String), Status: S.optional(S.Number) }),
).annotations({
  identifier: "DeleteRoleCustomPermissionResponse",
}) as any as S.Schema<DeleteRoleCustomPermissionResponse>;
export interface DeleteRoleMembershipResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteRoleMembershipResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteRoleMembershipResponse",
}) as any as S.Schema<DeleteRoleMembershipResponse>;
export interface DeleteTemplateResponse {
  RequestId?: string;
  Arn?: string;
  TemplateId?: string;
  Status?: number;
}
export const DeleteTemplateResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Arn: S.optional(S.String),
    TemplateId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteTemplateResponse",
}) as any as S.Schema<DeleteTemplateResponse>;
export interface DeleteTemplateAliasResponse {
  Status?: number;
  TemplateId?: string;
  AliasName?: string;
  Arn?: string;
  RequestId?: string;
}
export const DeleteTemplateAliasResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    TemplateId: S.optional(S.String),
    AliasName: S.optional(S.String),
    Arn: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteTemplateAliasResponse",
}) as any as S.Schema<DeleteTemplateAliasResponse>;
export interface DeleteThemeResponse {
  Arn?: string;
  RequestId?: string;
  Status?: number;
  ThemeId?: string;
}
export const DeleteThemeResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    ThemeId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteThemeResponse",
}) as any as S.Schema<DeleteThemeResponse>;
export interface DeleteThemeAliasResponse {
  AliasName?: string;
  Arn?: string;
  RequestId?: string;
  Status?: number;
  ThemeId?: string;
}
export const DeleteThemeAliasResponse = S.suspend(() =>
  S.Struct({
    AliasName: S.optional(S.String),
    Arn: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    ThemeId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteThemeAliasResponse",
}) as any as S.Schema<DeleteThemeAliasResponse>;
export interface DeleteTopicResponse {
  Arn?: string;
  TopicId?: string;
  RequestId?: string;
  Status?: number;
}
export const DeleteTopicResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    TopicId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteTopicResponse",
}) as any as S.Schema<DeleteTopicResponse>;
export interface DeleteTopicRefreshScheduleResponse {
  TopicId?: string;
  TopicArn?: string;
  DatasetArn?: string;
  Status?: number;
  RequestId?: string;
}
export const DeleteTopicRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    DatasetArn: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DeleteTopicRefreshScheduleResponse",
}) as any as S.Schema<DeleteTopicRefreshScheduleResponse>;
export interface DeleteUserResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteUserResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteUserResponse",
}) as any as S.Schema<DeleteUserResponse>;
export interface DeleteUserByPrincipalIdResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteUserByPrincipalIdResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteUserByPrincipalIdResponse",
}) as any as S.Schema<DeleteUserByPrincipalIdResponse>;
export interface DeleteUserCustomPermissionResponse {
  RequestId?: string;
  Status?: number;
}
export const DeleteUserCustomPermissionResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteUserCustomPermissionResponse",
}) as any as S.Schema<DeleteUserCustomPermissionResponse>;
export interface DeleteVPCConnectionResponse {
  Arn?: string;
  VPCConnectionId?: string;
  DeletionStatus?: VPCConnectionResourceStatus;
  AvailabilityStatus?: VPCConnectionAvailabilityStatus;
  RequestId?: string;
  Status?: number;
}
export const DeleteVPCConnectionResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VPCConnectionId: S.optional(S.String),
    DeletionStatus: S.optional(VPCConnectionResourceStatus),
    AvailabilityStatus: S.optional(VPCConnectionAvailabilityStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DeleteVPCConnectionResponse",
}) as any as S.Schema<DeleteVPCConnectionResponse>;
export interface DescribeAccountCustomizationResponse {
  Arn?: string;
  AwsAccountId?: string;
  Namespace?: string;
  AccountCustomization?: AccountCustomization;
  RequestId?: string;
  Status?: number;
}
export const DescribeAccountCustomizationResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AwsAccountId: S.optional(S.String),
    Namespace: S.optional(S.String),
    AccountCustomization: S.optional(AccountCustomization),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeAccountCustomizationResponse",
}) as any as S.Schema<DescribeAccountCustomizationResponse>;
export interface DescribeAccountCustomPermissionResponse {
  CustomPermissionsName?: string;
  RequestId?: string;
  Status?: number;
}
export const DescribeAccountCustomPermissionResponse = S.suspend(() =>
  S.Struct({
    CustomPermissionsName: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number),
  }),
).annotations({
  identifier: "DescribeAccountCustomPermissionResponse",
}) as any as S.Schema<DescribeAccountCustomPermissionResponse>;
export interface DescribeActionConnectorPermissionsResponse {
  Arn?: string;
  ActionConnectorId?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const DescribeActionConnectorPermissionsResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    ActionConnectorId: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeActionConnectorPermissionsResponse",
}) as any as S.Schema<DescribeActionConnectorPermissionsResponse>;
export interface DescribeAnalysisPermissionsResponse {
  AnalysisId?: string;
  AnalysisArn?: string;
  Permissions?: ResourcePermission[];
  Status?: number;
  RequestId?: string;
}
export const DescribeAnalysisPermissionsResponse = S.suspend(() =>
  S.Struct({
    AnalysisId: S.optional(S.String),
    AnalysisArn: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeAnalysisPermissionsResponse",
}) as any as S.Schema<DescribeAnalysisPermissionsResponse>;
export interface DescribeBrandAssignmentResponse {
  RequestId?: string;
  BrandArn?: string;
}
export const DescribeBrandAssignmentResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String), BrandArn: S.optional(S.String) }),
).annotations({
  identifier: "DescribeBrandAssignmentResponse",
}) as any as S.Schema<DescribeBrandAssignmentResponse>;
export type BrandStatus =
  | "CREATE_IN_PROGRESS"
  | "CREATE_SUCCEEDED"
  | "CREATE_FAILED"
  | "DELETE_IN_PROGRESS"
  | "DELETE_FAILED";
export const BrandStatus = S.Literal(
  "CREATE_IN_PROGRESS",
  "CREATE_SUCCEEDED",
  "CREATE_FAILED",
  "DELETE_IN_PROGRESS",
  "DELETE_FAILED",
);
export type BrandVersionStatus =
  | "CREATE_IN_PROGRESS"
  | "CREATE_SUCCEEDED"
  | "CREATE_FAILED";
export const BrandVersionStatus = S.Literal(
  "CREATE_IN_PROGRESS",
  "CREATE_SUCCEEDED",
  "CREATE_FAILED",
);
export type ErrorList = string[];
export const ErrorList = S.Array(S.String);
export interface Image {
  Source?: ImageSource;
  GeneratedImageUrl?: string;
}
export const Image = S.suspend(() =>
  S.Struct({
    Source: S.optional(ImageSource),
    GeneratedImageUrl: S.optional(S.String),
  }),
).annotations({ identifier: "Image" }) as any as S.Schema<Image>;
export interface ImageSet {
  Original: Image;
  Height64?: Image;
  Height32?: Image;
}
export const ImageSet = S.suspend(() =>
  S.Struct({
    Original: Image,
    Height64: S.optional(Image),
    Height32: S.optional(Image),
  }),
).annotations({ identifier: "ImageSet" }) as any as S.Schema<ImageSet>;
export interface LogoSet {
  Primary: ImageSet;
  Favicon?: ImageSet;
}
export const LogoSet = S.suspend(() =>
  S.Struct({ Primary: ImageSet, Favicon: S.optional(ImageSet) }),
).annotations({ identifier: "LogoSet" }) as any as S.Schema<LogoSet>;
export interface Logo {
  AltText: string;
  LogoSet: LogoSet;
}
export const Logo = S.suspend(() =>
  S.Struct({ AltText: S.String, LogoSet: LogoSet }),
).annotations({ identifier: "Logo" }) as any as S.Schema<Logo>;
export interface BrandDetail {
  BrandId: string;
  Arn?: string;
  BrandStatus?: BrandStatus;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  VersionId?: string;
  VersionStatus?: BrandVersionStatus;
  Errors?: string[];
  Logo?: Logo;
}
export const BrandDetail = S.suspend(() =>
  S.Struct({
    BrandId: S.String,
    Arn: S.optional(S.String),
    BrandStatus: S.optional(BrandStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    VersionId: S.optional(S.String),
    VersionStatus: S.optional(BrandVersionStatus),
    Errors: S.optional(ErrorList),
    Logo: S.optional(Logo),
  }),
).annotations({ identifier: "BrandDetail" }) as any as S.Schema<BrandDetail>;
export interface DescribeBrandPublishedVersionResponse {
  RequestId?: string;
  BrandDetail?: BrandDetail;
  BrandDefinition?: BrandDefinition;
}
export const DescribeBrandPublishedVersionResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    BrandDetail: S.optional(BrandDetail),
    BrandDefinition: S.optional(BrandDefinition),
  }),
).annotations({
  identifier: "DescribeBrandPublishedVersionResponse",
}) as any as S.Schema<DescribeBrandPublishedVersionResponse>;
export interface DescribeDashboardPermissionsResponse {
  DashboardId?: string;
  DashboardArn?: string;
  Permissions?: ResourcePermission[];
  Status?: number;
  RequestId?: string;
  LinkSharingConfiguration?: LinkSharingConfiguration;
}
export const DescribeDashboardPermissionsResponse = S.suspend(() =>
  S.Struct({
    DashboardId: S.optional(S.String),
    DashboardArn: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    LinkSharingConfiguration: S.optional(LinkSharingConfiguration),
  }),
).annotations({
  identifier: "DescribeDashboardPermissionsResponse",
}) as any as S.Schema<DescribeDashboardPermissionsResponse>;
export interface DescribeDashboardsQAConfigurationResponse {
  DashboardsQAStatus?: DashboardsQAStatus;
  RequestId?: string;
  Status?: number;
}
export const DescribeDashboardsQAConfigurationResponse = S.suspend(() =>
  S.Struct({
    DashboardsQAStatus: S.optional(DashboardsQAStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeDashboardsQAConfigurationResponse",
}) as any as S.Schema<DescribeDashboardsQAConfigurationResponse>;
export interface DescribeDataSetPermissionsResponse {
  DataSetArn?: string;
  DataSetId?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const DescribeDataSetPermissionsResponse = S.suspend(() =>
  S.Struct({
    DataSetArn: S.optional(S.String),
    DataSetId: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeDataSetPermissionsResponse",
}) as any as S.Schema<DescribeDataSetPermissionsResponse>;
export type LookbackWindowSizeUnit = "HOUR" | "DAY" | "WEEK";
export const LookbackWindowSizeUnit = S.Literal("HOUR", "DAY", "WEEK");
export interface LookbackWindow {
  ColumnName: string;
  Size: number;
  SizeUnit: LookbackWindowSizeUnit;
}
export const LookbackWindow = S.suspend(() =>
  S.Struct({
    ColumnName: S.String,
    Size: S.Number,
    SizeUnit: LookbackWindowSizeUnit,
  }),
).annotations({
  identifier: "LookbackWindow",
}) as any as S.Schema<LookbackWindow>;
export interface IncrementalRefresh {
  LookbackWindow: LookbackWindow;
}
export const IncrementalRefresh = S.suspend(() =>
  S.Struct({ LookbackWindow: LookbackWindow }),
).annotations({
  identifier: "IncrementalRefresh",
}) as any as S.Schema<IncrementalRefresh>;
export interface RefreshConfiguration {
  IncrementalRefresh: IncrementalRefresh;
}
export const RefreshConfiguration = S.suspend(() =>
  S.Struct({ IncrementalRefresh: IncrementalRefresh }),
).annotations({
  identifier: "RefreshConfiguration",
}) as any as S.Schema<RefreshConfiguration>;
export type RefreshFailureAlertStatus = "ENABLED" | "DISABLED";
export const RefreshFailureAlertStatus = S.Literal("ENABLED", "DISABLED");
export interface RefreshFailureEmailAlert {
  AlertStatus?: RefreshFailureAlertStatus;
}
export const RefreshFailureEmailAlert = S.suspend(() =>
  S.Struct({ AlertStatus: S.optional(RefreshFailureAlertStatus) }),
).annotations({
  identifier: "RefreshFailureEmailAlert",
}) as any as S.Schema<RefreshFailureEmailAlert>;
export interface RefreshFailureConfiguration {
  EmailAlert?: RefreshFailureEmailAlert;
}
export const RefreshFailureConfiguration = S.suspend(() =>
  S.Struct({ EmailAlert: S.optional(RefreshFailureEmailAlert) }),
).annotations({
  identifier: "RefreshFailureConfiguration",
}) as any as S.Schema<RefreshFailureConfiguration>;
export interface DataSetRefreshProperties {
  RefreshConfiguration?: RefreshConfiguration;
  FailureConfiguration?: RefreshFailureConfiguration;
}
export const DataSetRefreshProperties = S.suspend(() =>
  S.Struct({
    RefreshConfiguration: S.optional(RefreshConfiguration),
    FailureConfiguration: S.optional(RefreshFailureConfiguration),
  }),
).annotations({
  identifier: "DataSetRefreshProperties",
}) as any as S.Schema<DataSetRefreshProperties>;
export interface DescribeDataSetRefreshPropertiesResponse {
  RequestId?: string;
  Status?: number;
  DataSetRefreshProperties?: DataSetRefreshProperties;
}
export const DescribeDataSetRefreshPropertiesResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    DataSetRefreshProperties: S.optional(DataSetRefreshProperties),
  }),
).annotations({
  identifier: "DescribeDataSetRefreshPropertiesResponse",
}) as any as S.Schema<DescribeDataSetRefreshPropertiesResponse>;
export interface DescribeDataSourcePermissionsResponse {
  DataSourceArn?: string;
  DataSourceId?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const DescribeDataSourcePermissionsResponse = S.suspend(() =>
  S.Struct({
    DataSourceArn: S.optional(S.String),
    DataSourceId: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeDataSourcePermissionsResponse",
}) as any as S.Schema<DescribeDataSourcePermissionsResponse>;
export interface DescribeDefaultQBusinessApplicationResponse {
  RequestId?: string;
  Status?: number;
  ApplicationId?: string;
}
export const DescribeDefaultQBusinessApplicationResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    ApplicationId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeDefaultQBusinessApplicationResponse",
}) as any as S.Schema<DescribeDefaultQBusinessApplicationResponse>;
export interface DescribeFolderPermissionsResponse {
  Status?: number;
  FolderId?: string;
  Arn?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  NextToken?: string;
}
export const DescribeFolderPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    FolderId: S.optional(S.String),
    Arn: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    RequestId: S.optional(S.String),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeFolderPermissionsResponse",
}) as any as S.Schema<DescribeFolderPermissionsResponse>;
export interface DescribeFolderResolvedPermissionsResponse {
  Status?: number;
  FolderId?: string;
  Arn?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  NextToken?: string;
}
export const DescribeFolderResolvedPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    FolderId: S.optional(S.String),
    Arn: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    RequestId: S.optional(S.String),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeFolderResolvedPermissionsResponse",
}) as any as S.Schema<DescribeFolderResolvedPermissionsResponse>;
export interface DescribeGroupResponse {
  Group?: Group;
  RequestId?: string;
  Status?: number;
}
export const DescribeGroupResponse = S.suspend(() =>
  S.Struct({
    Group: S.optional(Group),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeGroupResponse",
}) as any as S.Schema<DescribeGroupResponse>;
export interface DescribeGroupMembershipResponse {
  GroupMember?: GroupMember;
  RequestId?: string;
  Status?: number;
}
export const DescribeGroupMembershipResponse = S.suspend(() =>
  S.Struct({
    GroupMember: S.optional(GroupMember),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeGroupMembershipResponse",
}) as any as S.Schema<DescribeGroupMembershipResponse>;
export interface DescribeIpRestrictionResponse {
  AwsAccountId?: string;
  IpRestrictionRuleMap?: { [key: string]: string };
  VpcIdRestrictionRuleMap?: { [key: string]: string };
  VpcEndpointIdRestrictionRuleMap?: { [key: string]: string };
  Enabled?: boolean;
  RequestId?: string;
  Status?: number;
}
export const DescribeIpRestrictionResponse = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.optional(S.String),
    IpRestrictionRuleMap: S.optional(IpRestrictionRuleMap),
    VpcIdRestrictionRuleMap: S.optional(VpcIdRestrictionRuleMap),
    VpcEndpointIdRestrictionRuleMap: S.optional(
      VpcEndpointIdRestrictionRuleMap,
    ),
    Enabled: S.optional(S.Boolean),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeIpRestrictionResponse",
}) as any as S.Schema<DescribeIpRestrictionResponse>;
export interface DescribeQPersonalizationConfigurationResponse {
  PersonalizationMode?: PersonalizationMode;
  RequestId?: string;
  Status?: number;
}
export const DescribeQPersonalizationConfigurationResponse = S.suspend(() =>
  S.Struct({
    PersonalizationMode: S.optional(PersonalizationMode),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeQPersonalizationConfigurationResponse",
}) as any as S.Schema<DescribeQPersonalizationConfigurationResponse>;
export interface DescribeQuickSightQSearchConfigurationResponse {
  QSearchStatus?: QSearchStatus;
  RequestId?: string;
  Status?: number;
}
export const DescribeQuickSightQSearchConfigurationResponse = S.suspend(() =>
  S.Struct({
    QSearchStatus: S.optional(QSearchStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeQuickSightQSearchConfigurationResponse",
}) as any as S.Schema<DescribeQuickSightQSearchConfigurationResponse>;
export interface DescribeRefreshScheduleResponse {
  RefreshSchedule?: RefreshSchedule;
  Status?: number;
  RequestId?: string;
  Arn?: string;
}
export const DescribeRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    RefreshSchedule: S.optional(RefreshSchedule),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    Arn: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeRefreshScheduleResponse",
}) as any as S.Schema<DescribeRefreshScheduleResponse>;
export interface DescribeRoleCustomPermissionResponse {
  CustomPermissionsName?: string;
  RequestId?: string;
  Status?: number;
}
export const DescribeRoleCustomPermissionResponse = S.suspend(() =>
  S.Struct({
    CustomPermissionsName: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number),
  }),
).annotations({
  identifier: "DescribeRoleCustomPermissionResponse",
}) as any as S.Schema<DescribeRoleCustomPermissionResponse>;
export interface DescribeTemplateAliasResponse {
  TemplateAlias?: TemplateAlias;
  Status?: number;
  RequestId?: string;
}
export const DescribeTemplateAliasResponse = S.suspend(() =>
  S.Struct({
    TemplateAlias: S.optional(TemplateAlias),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeTemplateAliasResponse",
}) as any as S.Schema<DescribeTemplateAliasResponse>;
export interface DescribeTemplatePermissionsResponse {
  TemplateId?: string;
  TemplateArn?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const DescribeTemplatePermissionsResponse = S.suspend(() =>
  S.Struct({
    TemplateId: S.optional(S.String),
    TemplateArn: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeTemplatePermissionsResponse",
}) as any as S.Schema<DescribeTemplatePermissionsResponse>;
export interface DescribeThemeAliasResponse {
  ThemeAlias?: ThemeAlias;
  Status?: number;
  RequestId?: string;
}
export const DescribeThemeAliasResponse = S.suspend(() =>
  S.Struct({
    ThemeAlias: S.optional(ThemeAlias),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeThemeAliasResponse",
}) as any as S.Schema<DescribeThemeAliasResponse>;
export interface DescribeThemePermissionsResponse {
  ThemeId?: string;
  ThemeArn?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const DescribeThemePermissionsResponse = S.suspend(() =>
  S.Struct({
    ThemeId: S.optional(S.String),
    ThemeArn: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeThemePermissionsResponse",
}) as any as S.Schema<DescribeThemePermissionsResponse>;
export interface DescribeTopicResponse {
  Arn?: string;
  TopicId?: string;
  Topic?: TopicDetails;
  RequestId?: string;
  Status?: number;
  CustomInstructions?: CustomInstructions;
}
export const DescribeTopicResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    TopicId: S.optional(S.String),
    Topic: S.optional(TopicDetails),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    CustomInstructions: S.optional(CustomInstructions),
  }),
).annotations({
  identifier: "DescribeTopicResponse",
}) as any as S.Schema<DescribeTopicResponse>;
export interface DescribeTopicPermissionsResponse {
  TopicId?: string;
  TopicArn?: string;
  Permissions?: ResourcePermission[];
  Status?: number;
  RequestId?: string;
}
export const DescribeTopicPermissionsResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeTopicPermissionsResponse",
}) as any as S.Schema<DescribeTopicPermissionsResponse>;
export interface DescribeTopicRefreshScheduleResponse {
  TopicId?: string;
  TopicArn?: string;
  DatasetArn?: string;
  RefreshSchedule?: TopicRefreshSchedule;
  Status?: number;
  RequestId?: string;
}
export const DescribeTopicRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    DatasetArn: S.optional(S.String),
    RefreshSchedule: S.optional(TopicRefreshSchedule),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeTopicRefreshScheduleResponse",
}) as any as S.Schema<DescribeTopicRefreshScheduleResponse>;
export interface GenerateEmbedUrlForRegisteredUserWithIdentityResponse {
  EmbedUrl: string | redacted.Redacted<string>;
  Status: number;
  RequestId: string;
}
export const GenerateEmbedUrlForRegisteredUserWithIdentityResponse = S.suspend(
  () =>
    S.Struct({
      EmbedUrl: SensitiveString,
      Status: S.Number.pipe(T.HttpResponseCode()),
      RequestId: S.String,
    }),
).annotations({
  identifier: "GenerateEmbedUrlForRegisteredUserWithIdentityResponse",
}) as any as S.Schema<GenerateEmbedUrlForRegisteredUserWithIdentityResponse>;
export interface GetDashboardEmbedUrlResponse {
  EmbedUrl?: string | redacted.Redacted<string>;
  Status?: number;
  RequestId?: string;
}
export const GetDashboardEmbedUrlResponse = S.suspend(() =>
  S.Struct({
    EmbedUrl: S.optional(SensitiveString),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "GetDashboardEmbedUrlResponse",
}) as any as S.Schema<GetDashboardEmbedUrlResponse>;
export interface GetFlowMetadataOutput {
  Arn: string;
  FlowId: string;
  Name: string;
  Description?: string;
  PublishState?: FlowPublishState;
  UserCount?: number;
  RunCount?: number;
  CreatedTime: Date;
  LastUpdatedTime?: Date;
  RequestId?: string;
  Status?: number;
}
export const GetFlowMetadataOutput = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    FlowId: S.String,
    Name: S.String,
    Description: S.optional(S.String),
    PublishState: S.optional(FlowPublishState),
    UserCount: S.optional(S.Number),
    RunCount: S.optional(S.Number),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "GetFlowMetadataOutput",
}) as any as S.Schema<GetFlowMetadataOutput>;
export interface GetFlowPermissionsOutput {
  Arn: string;
  FlowId: string;
  Permissions: Permission[];
  RequestId?: string;
  Status?: number;
}
export const GetFlowPermissionsOutput = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    FlowId: S.String,
    Permissions: PermissionsList,
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "GetFlowPermissionsOutput",
}) as any as S.Schema<GetFlowPermissionsOutput>;
export interface GetIdentityContextRequest {
  AwsAccountId: string;
  UserIdentifier: UserIdentifier;
  Namespace?: string;
  SessionExpiresAt?: Date;
}
export const GetIdentityContextRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    UserIdentifier: UserIdentifier,
    Namespace: S.optional(S.String),
    SessionExpiresAt: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/identity-context",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GetIdentityContextRequest",
}) as any as S.Schema<GetIdentityContextRequest>;
export interface GetSessionEmbedUrlResponse {
  EmbedUrl?: string | redacted.Redacted<string>;
  Status?: number;
  RequestId?: string;
}
export const GetSessionEmbedUrlResponse = S.suspend(() =>
  S.Struct({
    EmbedUrl: S.optional(SensitiveString),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "GetSessionEmbedUrlResponse",
}) as any as S.Schema<GetSessionEmbedUrlResponse>;
export interface ListCustomPermissionsResponse {
  Status?: number;
  CustomPermissionsList?: CustomPermissions[];
  NextToken?: string;
  RequestId?: string;
}
export const ListCustomPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    CustomPermissionsList: S.optional(CustomPermissionsList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListCustomPermissionsResponse",
}) as any as S.Schema<ListCustomPermissionsResponse>;
export interface ListDataSourcesResponse {
  DataSources?: DataSource[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListDataSourcesResponse = S.suspend(() =>
  S.Struct({
    DataSources: S.optional(DataSourceList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListDataSourcesResponse",
}) as any as S.Schema<ListDataSourcesResponse>;
export interface ListFoldersForResourceResponse {
  Status?: number;
  Folders?: string[];
  NextToken?: string;
  RequestId?: string;
}
export const ListFoldersForResourceResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Folders: S.optional(FoldersForResourceArnList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListFoldersForResourceResponse",
}) as any as S.Schema<ListFoldersForResourceResponse>;
export interface ListGroupMembershipsResponse {
  GroupMemberList?: GroupMember[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListGroupMembershipsResponse = S.suspend(() =>
  S.Struct({
    GroupMemberList: S.optional(GroupMemberList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListGroupMembershipsResponse",
}) as any as S.Schema<ListGroupMembershipsResponse>;
export interface ListGroupsResponse {
  GroupList?: Group[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListGroupsResponse = S.suspend(() =>
  S.Struct({
    GroupList: S.optional(GroupList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListGroupsResponse",
}) as any as S.Schema<ListGroupsResponse>;
export interface ListIngestionsResponse {
  Ingestions?: Ingestion[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListIngestionsResponse = S.suspend(() =>
  S.Struct({
    Ingestions: S.optional(Ingestions),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListIngestionsResponse",
}) as any as S.Schema<ListIngestionsResponse>;
export interface ListNamespacesResponse {
  Namespaces?: NamespaceInfoV2[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListNamespacesResponse = S.suspend(() =>
  S.Struct({
    Namespaces: S.optional(Namespaces),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListNamespacesResponse",
}) as any as S.Schema<ListNamespacesResponse>;
export interface ListRefreshSchedulesResponse {
  RefreshSchedules?: RefreshSchedule[];
  Status?: number;
  RequestId?: string;
}
export const ListRefreshSchedulesResponse = S.suspend(() =>
  S.Struct({
    RefreshSchedules: S.optional(RefreshSchedules),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListRefreshSchedulesResponse",
}) as any as S.Schema<ListRefreshSchedulesResponse>;
export interface ListRoleMembershipsResponse {
  MembersList?: string[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListRoleMembershipsResponse = S.suspend(() =>
  S.Struct({
    MembersList: S.optional(GroupsList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListRoleMembershipsResponse",
}) as any as S.Schema<ListRoleMembershipsResponse>;
export interface ListTagsForResourceResponse {
  Tags?: Tag[];
  RequestId?: string;
  Status?: number;
}
export const ListTagsForResourceResponse = S.suspend(() =>
  S.Struct({
    Tags: S.optional(TagList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListTagsForResourceResponse",
}) as any as S.Schema<ListTagsForResourceResponse>;
export interface ListTemplateAliasesResponse {
  TemplateAliasList?: TemplateAlias[];
  Status?: number;
  RequestId?: string;
  NextToken?: string;
}
export const ListTemplateAliasesResponse = S.suspend(() =>
  S.Struct({
    TemplateAliasList: S.optional(TemplateAliasList),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListTemplateAliasesResponse",
}) as any as S.Schema<ListTemplateAliasesResponse>;
export interface ListThemeAliasesResponse {
  ThemeAliasList?: ThemeAlias[];
  Status?: number;
  RequestId?: string;
  NextToken?: string;
}
export const ListThemeAliasesResponse = S.suspend(() =>
  S.Struct({
    ThemeAliasList: S.optional(ThemeAliasList),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    NextToken: S.optional(S.String),
  }),
).annotations({
  identifier: "ListThemeAliasesResponse",
}) as any as S.Schema<ListThemeAliasesResponse>;
export interface ListUserGroupsResponse {
  GroupList?: Group[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListUserGroupsResponse = S.suspend(() =>
  S.Struct({
    GroupList: S.optional(GroupList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListUserGroupsResponse",
}) as any as S.Schema<ListUserGroupsResponse>;
export interface ListUsersResponse {
  UserList?: User[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListUsersResponse = S.suspend(() =>
  S.Struct({
    UserList: S.optional(UserList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListUsersResponse",
}) as any as S.Schema<ListUsersResponse>;
export interface RegisterUserResponse {
  User?: User;
  UserInvitationUrl?: string;
  RequestId?: string;
  Status?: number;
}
export const RegisterUserResponse = S.suspend(() =>
  S.Struct({
    User: S.optional(User),
    UserInvitationUrl: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "RegisterUserResponse",
}) as any as S.Schema<RegisterUserResponse>;
export interface RestoreAnalysisResponse {
  Status?: number;
  Arn?: string;
  AnalysisId?: string;
  RequestId?: string;
  RestorationFailedFolderArns?: string[];
}
export const RestoreAnalysisResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Arn: S.optional(S.String),
    AnalysisId: S.optional(S.String),
    RequestId: S.optional(S.String),
    RestorationFailedFolderArns: S.optional(FolderArnList),
  }),
).annotations({
  identifier: "RestoreAnalysisResponse",
}) as any as S.Schema<RestoreAnalysisResponse>;
export interface SearchActionConnectorsRequest {
  AwsAccountId: string;
  MaxResults?: number;
  NextToken?: string;
  Filters: ActionConnectorSearchFilter[];
}
export const SearchActionConnectorsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    Filters: ActionConnectorSearchFilterList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/search/action-connectors",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchActionConnectorsRequest",
}) as any as S.Schema<SearchActionConnectorsRequest>;
export interface SearchAnalysesRequest {
  AwsAccountId: string;
  Filters: AnalysisSearchFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const SearchAnalysesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Filters: AnalysisSearchFilterList,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/search/analyses",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchAnalysesRequest",
}) as any as S.Schema<SearchAnalysesRequest>;
export interface SearchDashboardsRequest {
  AwsAccountId: string;
  Filters: DashboardSearchFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const SearchDashboardsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Filters: DashboardSearchFilterList,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/search/dashboards",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchDashboardsRequest",
}) as any as S.Schema<SearchDashboardsRequest>;
export interface SearchDataSetsRequest {
  AwsAccountId: string;
  Filters: DataSetSearchFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const SearchDataSetsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Filters: DataSetSearchFilterList,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/search/data-sets",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchDataSetsRequest",
}) as any as S.Schema<SearchDataSetsRequest>;
export interface SearchDataSourcesRequest {
  AwsAccountId: string;
  Filters: DataSourceSearchFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const SearchDataSourcesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Filters: DataSourceSearchFilterList,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/search/data-sources",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchDataSourcesRequest",
}) as any as S.Schema<SearchDataSourcesRequest>;
export interface SearchFlowsInput {
  AwsAccountId: string;
  Filters: SearchFlowsFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const SearchFlowsInput = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Filters: SearchFlowsFilterList,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/flows/searchFlows",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchFlowsInput",
}) as any as S.Schema<SearchFlowsInput>;
export interface SearchFoldersRequest {
  AwsAccountId: string;
  Filters: FolderSearchFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const SearchFoldersRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Filters: FolderSearchFilterList,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/search/folders",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchFoldersRequest",
}) as any as S.Schema<SearchFoldersRequest>;
export interface SearchGroupsRequest {
  AwsAccountId: string;
  NextToken?: string;
  MaxResults?: number;
  Namespace: string;
  Filters: GroupSearchFilter[];
}
export const SearchGroupsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    NextToken: S.optional(S.String).pipe(T.HttpQuery("next-token")),
    MaxResults: S.optional(S.Number).pipe(T.HttpQuery("max-results")),
    Namespace: S.String.pipe(T.HttpLabel("Namespace")),
    Filters: GroupSearchFilterList,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups-search",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchGroupsRequest",
}) as any as S.Schema<SearchGroupsRequest>;
export interface SearchTopicsRequest {
  AwsAccountId: string;
  Filters: TopicSearchFilter[];
  NextToken?: string;
  MaxResults?: number;
}
export const SearchTopicsRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Filters: TopicSearchFilterList,
    NextToken: S.optional(S.String),
    MaxResults: S.optional(S.Number),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/accounts/{AwsAccountId}/search/topics" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "SearchTopicsRequest",
}) as any as S.Schema<SearchTopicsRequest>;
export interface StartDashboardSnapshotJobScheduleResponse {
  RequestId?: string;
  Status?: number;
}
export const StartDashboardSnapshotJobScheduleResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "StartDashboardSnapshotJobScheduleResponse",
}) as any as S.Schema<StartDashboardSnapshotJobScheduleResponse>;
export interface TagResourceResponse {
  RequestId?: string;
  Status?: number;
}
export const TagResourceResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "TagResourceResponse",
}) as any as S.Schema<TagResourceResponse>;
export interface UntagResourceResponse {
  RequestId?: string;
  Status?: number;
}
export const UntagResourceResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UntagResourceResponse",
}) as any as S.Schema<UntagResourceResponse>;
export interface UpdateAccountCustomizationResponse {
  Arn?: string;
  AwsAccountId?: string;
  Namespace?: string;
  AccountCustomization?: AccountCustomization;
  RequestId?: string;
  Status?: number;
}
export const UpdateAccountCustomizationResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AwsAccountId: S.optional(S.String),
    Namespace: S.optional(S.String),
    AccountCustomization: S.optional(AccountCustomization),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateAccountCustomizationResponse",
}) as any as S.Schema<UpdateAccountCustomizationResponse>;
export interface UpdateAccountCustomPermissionResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateAccountCustomPermissionResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String), Status: S.optional(S.Number) }),
).annotations({
  identifier: "UpdateAccountCustomPermissionResponse",
}) as any as S.Schema<UpdateAccountCustomPermissionResponse>;
export interface UpdateAccountSettingsResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateAccountSettingsResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateAccountSettingsResponse",
}) as any as S.Schema<UpdateAccountSettingsResponse>;
export interface UpdateActionConnectorResponse {
  Arn?: string;
  ActionConnectorId?: string;
  RequestId?: string;
  UpdateStatus?: ResourceStatus;
  Status?: number;
}
export const UpdateActionConnectorResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    ActionConnectorId: S.optional(S.String),
    RequestId: S.optional(S.String),
    UpdateStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateActionConnectorResponse",
}) as any as S.Schema<UpdateActionConnectorResponse>;
export interface UpdateActionConnectorPermissionsResponse {
  Arn?: string;
  ActionConnectorId?: string;
  RequestId?: string;
  Status?: number;
  Permissions?: ResourcePermission[];
}
export const UpdateActionConnectorPermissionsResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    ActionConnectorId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Permissions: S.optional(ResourcePermissionList),
  }),
).annotations({
  identifier: "UpdateActionConnectorPermissionsResponse",
}) as any as S.Schema<UpdateActionConnectorPermissionsResponse>;
export interface UpdateAnalysisResponse {
  Arn?: string;
  AnalysisId?: string;
  UpdateStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const UpdateAnalysisResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AnalysisId: S.optional(S.String),
    UpdateStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateAnalysisResponse",
}) as any as S.Schema<UpdateAnalysisResponse>;
export interface UpdateAnalysisPermissionsResponse {
  AnalysisArn?: string;
  AnalysisId?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const UpdateAnalysisPermissionsResponse = S.suspend(() =>
  S.Struct({
    AnalysisArn: S.optional(S.String),
    AnalysisId: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateAnalysisPermissionsResponse",
}) as any as S.Schema<UpdateAnalysisPermissionsResponse>;
export interface UpdateApplicationWithTokenExchangeGrantResponse {
  Status?: number;
  RequestId?: string;
}
export const UpdateApplicationWithTokenExchangeGrantResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateApplicationWithTokenExchangeGrantResponse",
}) as any as S.Schema<UpdateApplicationWithTokenExchangeGrantResponse>;
export interface UpdateBrandResponse {
  RequestId?: string;
  BrandDetail?: BrandDetail;
  BrandDefinition?: BrandDefinition;
}
export const UpdateBrandResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    BrandDetail: S.optional(BrandDetail),
    BrandDefinition: S.optional(BrandDefinition),
  }),
).annotations({
  identifier: "UpdateBrandResponse",
}) as any as S.Schema<UpdateBrandResponse>;
export interface UpdateBrandAssignmentResponse {
  RequestId?: string;
  BrandArn?: string;
}
export const UpdateBrandAssignmentResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String), BrandArn: S.optional(S.String) }),
).annotations({
  identifier: "UpdateBrandAssignmentResponse",
}) as any as S.Schema<UpdateBrandAssignmentResponse>;
export interface UpdateBrandPublishedVersionResponse {
  RequestId?: string;
  VersionId?: string;
}
export const UpdateBrandPublishedVersionResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    VersionId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateBrandPublishedVersionResponse",
}) as any as S.Schema<UpdateBrandPublishedVersionResponse>;
export interface UpdateCustomPermissionsResponse {
  Status?: number;
  Arn?: string;
  RequestId?: string;
}
export const UpdateCustomPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number),
    Arn: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateCustomPermissionsResponse",
}) as any as S.Schema<UpdateCustomPermissionsResponse>;
export interface UpdateDashboardResponse {
  Arn?: string;
  VersionArn?: string;
  DashboardId?: string;
  CreationStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const UpdateDashboardResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionArn: S.optional(S.String),
    DashboardId: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateDashboardResponse",
}) as any as S.Schema<UpdateDashboardResponse>;
export interface UpdateDashboardLinksResponse {
  RequestId?: string;
  Status?: number;
  DashboardArn?: string;
  LinkEntities?: string[];
}
export const UpdateDashboardLinksResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    DashboardArn: S.optional(S.String),
    LinkEntities: S.optional(LinkEntityArnList),
  }),
).annotations({
  identifier: "UpdateDashboardLinksResponse",
}) as any as S.Schema<UpdateDashboardLinksResponse>;
export interface UpdateDashboardPermissionsResponse {
  DashboardArn?: string;
  DashboardId?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
  LinkSharingConfiguration?: LinkSharingConfiguration;
}
export const UpdateDashboardPermissionsResponse = S.suspend(() =>
  S.Struct({
    DashboardArn: S.optional(S.String),
    DashboardId: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    LinkSharingConfiguration: S.optional(LinkSharingConfiguration),
  }),
).annotations({
  identifier: "UpdateDashboardPermissionsResponse",
}) as any as S.Schema<UpdateDashboardPermissionsResponse>;
export interface UpdateDashboardPublishedVersionResponse {
  DashboardId?: string;
  DashboardArn?: string;
  Status?: number;
  RequestId?: string;
}
export const UpdateDashboardPublishedVersionResponse = S.suspend(() =>
  S.Struct({
    DashboardId: S.optional(S.String),
    DashboardArn: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateDashboardPublishedVersionResponse",
}) as any as S.Schema<UpdateDashboardPublishedVersionResponse>;
export interface UpdateDashboardsQAConfigurationResponse {
  DashboardsQAStatus?: DashboardsQAStatus;
  RequestId?: string;
  Status?: number;
}
export const UpdateDashboardsQAConfigurationResponse = S.suspend(() =>
  S.Struct({
    DashboardsQAStatus: S.optional(DashboardsQAStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateDashboardsQAConfigurationResponse",
}) as any as S.Schema<UpdateDashboardsQAConfigurationResponse>;
export interface UpdateDataSetResponse {
  Arn?: string;
  DataSetId?: string;
  IngestionArn?: string;
  IngestionId?: string;
  RequestId?: string;
  Status?: number;
}
export const UpdateDataSetResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSetId: S.optional(S.String),
    IngestionArn: S.optional(S.String),
    IngestionId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateDataSetResponse",
}) as any as S.Schema<UpdateDataSetResponse>;
export interface UpdateDataSetPermissionsResponse {
  DataSetArn?: string;
  DataSetId?: string;
  RequestId?: string;
  Status?: number;
}
export const UpdateDataSetPermissionsResponse = S.suspend(() =>
  S.Struct({
    DataSetArn: S.optional(S.String),
    DataSetId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateDataSetPermissionsResponse",
}) as any as S.Schema<UpdateDataSetPermissionsResponse>;
export interface UpdateDataSourceResponse {
  Arn?: string;
  DataSourceId?: string;
  UpdateStatus?: ResourceStatus;
  RequestId?: string;
  Status?: number;
}
export const UpdateDataSourceResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSourceId: S.optional(S.String),
    UpdateStatus: S.optional(ResourceStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateDataSourceResponse",
}) as any as S.Schema<UpdateDataSourceResponse>;
export interface UpdateDataSourcePermissionsResponse {
  DataSourceArn?: string;
  DataSourceId?: string;
  RequestId?: string;
  Status?: number;
}
export const UpdateDataSourcePermissionsResponse = S.suspend(() =>
  S.Struct({
    DataSourceArn: S.optional(S.String),
    DataSourceId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateDataSourcePermissionsResponse",
}) as any as S.Schema<UpdateDataSourcePermissionsResponse>;
export interface UpdateDefaultQBusinessApplicationResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateDefaultQBusinessApplicationResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateDefaultQBusinessApplicationResponse",
}) as any as S.Schema<UpdateDefaultQBusinessApplicationResponse>;
export interface UpdateFlowPermissionsInput {
  AwsAccountId: string;
  FlowId: string;
  GrantPermissions?: Permission[];
  RevokePermissions?: Permission[];
}
export const UpdateFlowPermissionsInput = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    FlowId: S.String.pipe(T.HttpLabel("FlowId")),
    GrantPermissions: S.optional(
      UpdateFlowPermissionsInputGrantPermissionsList,
    ),
    RevokePermissions: S.optional(
      UpdateFlowPermissionsInputRevokePermissionsList,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/flows/{FlowId}/permissions",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateFlowPermissionsInput",
}) as any as S.Schema<UpdateFlowPermissionsInput>;
export interface UpdateFolderResponse {
  Status?: number;
  Arn?: string;
  FolderId?: string;
  RequestId?: string;
}
export const UpdateFolderResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Arn: S.optional(S.String),
    FolderId: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateFolderResponse",
}) as any as S.Schema<UpdateFolderResponse>;
export interface UpdateFolderPermissionsResponse {
  Status?: number;
  Arn?: string;
  FolderId?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
}
export const UpdateFolderPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number),
    Arn: S.optional(S.String),
    FolderId: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateFolderPermissionsResponse",
}) as any as S.Schema<UpdateFolderPermissionsResponse>;
export interface UpdateGroupResponse {
  Group?: Group;
  RequestId?: string;
  Status?: number;
}
export const UpdateGroupResponse = S.suspend(() =>
  S.Struct({
    Group: S.optional(Group),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateGroupResponse",
}) as any as S.Schema<UpdateGroupResponse>;
export interface UpdateIAMPolicyAssignmentResponse {
  AssignmentName?: string;
  AssignmentId?: string;
  PolicyArn?: string;
  Identities?: { [key: string]: string[] };
  AssignmentStatus?: AssignmentStatus;
  RequestId?: string;
  Status?: number;
}
export const UpdateIAMPolicyAssignmentResponse = S.suspend(() =>
  S.Struct({
    AssignmentName: S.optional(S.String),
    AssignmentId: S.optional(S.String),
    PolicyArn: S.optional(S.String),
    Identities: S.optional(IdentityMap),
    AssignmentStatus: S.optional(AssignmentStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateIAMPolicyAssignmentResponse",
}) as any as S.Schema<UpdateIAMPolicyAssignmentResponse>;
export interface UpdateIdentityPropagationConfigResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateIdentityPropagationConfigResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateIdentityPropagationConfigResponse",
}) as any as S.Schema<UpdateIdentityPropagationConfigResponse>;
export interface UpdateIpRestrictionRequest {
  AwsAccountId: string;
  IpRestrictionRuleMap?: { [key: string]: string };
  VpcIdRestrictionRuleMap?: { [key: string]: string };
  VpcEndpointIdRestrictionRuleMap?: { [key: string]: string };
  Enabled?: boolean;
}
export const UpdateIpRestrictionRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    IpRestrictionRuleMap: S.optional(IpRestrictionRuleMap),
    VpcIdRestrictionRuleMap: S.optional(VpcIdRestrictionRuleMap),
    VpcEndpointIdRestrictionRuleMap: S.optional(
      VpcEndpointIdRestrictionRuleMap,
    ),
    Enabled: S.optional(S.Boolean),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/ip-restriction",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateIpRestrictionRequest",
}) as any as S.Schema<UpdateIpRestrictionRequest>;
export interface UpdateKeyRegistrationRequest {
  AwsAccountId: string;
  KeyRegistration: RegisteredCustomerManagedKey[];
}
export const UpdateKeyRegistrationRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    KeyRegistration: KeyRegistration,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/key-registration",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "UpdateKeyRegistrationRequest",
}) as any as S.Schema<UpdateKeyRegistrationRequest>;
export interface UpdatePublicSharingSettingsResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdatePublicSharingSettingsResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdatePublicSharingSettingsResponse",
}) as any as S.Schema<UpdatePublicSharingSettingsResponse>;
export interface UpdateQPersonalizationConfigurationResponse {
  PersonalizationMode?: PersonalizationMode;
  RequestId?: string;
  Status?: number;
}
export const UpdateQPersonalizationConfigurationResponse = S.suspend(() =>
  S.Struct({
    PersonalizationMode: S.optional(PersonalizationMode),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateQPersonalizationConfigurationResponse",
}) as any as S.Schema<UpdateQPersonalizationConfigurationResponse>;
export interface UpdateQuickSightQSearchConfigurationResponse {
  QSearchStatus?: QSearchStatus;
  RequestId?: string;
  Status?: number;
}
export const UpdateQuickSightQSearchConfigurationResponse = S.suspend(() =>
  S.Struct({
    QSearchStatus: S.optional(QSearchStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateQuickSightQSearchConfigurationResponse",
}) as any as S.Schema<UpdateQuickSightQSearchConfigurationResponse>;
export interface UpdateRefreshScheduleResponse {
  Status?: number;
  RequestId?: string;
  ScheduleId?: string;
  Arn?: string;
}
export const UpdateRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    ScheduleId: S.optional(S.String),
    Arn: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateRefreshScheduleResponse",
}) as any as S.Schema<UpdateRefreshScheduleResponse>;
export interface UpdateRoleCustomPermissionResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateRoleCustomPermissionResponse = S.suspend(() =>
  S.Struct({ RequestId: S.optional(S.String), Status: S.optional(S.Number) }),
).annotations({
  identifier: "UpdateRoleCustomPermissionResponse",
}) as any as S.Schema<UpdateRoleCustomPermissionResponse>;
export type SelfUpgradeRequestStatus =
  | "PENDING"
  | "APPROVED"
  | "DENIED"
  | "UPDATE_FAILED"
  | "VERIFY_FAILED";
export const SelfUpgradeRequestStatus = S.Literal(
  "PENDING",
  "APPROVED",
  "DENIED",
  "UPDATE_FAILED",
  "VERIFY_FAILED",
);
export interface SelfUpgradeRequestDetail {
  UpgradeRequestId?: string;
  UserName?: string;
  OriginalRole?: UserRole;
  RequestedRole?: UserRole;
  RequestNote?: string;
  CreationTime?: number;
  RequestStatus?: SelfUpgradeRequestStatus;
  lastUpdateAttemptTime?: number;
  lastUpdateFailureReason?: string;
}
export const SelfUpgradeRequestDetail = S.suspend(() =>
  S.Struct({
    UpgradeRequestId: S.optional(S.String),
    UserName: S.optional(S.String),
    OriginalRole: S.optional(UserRole),
    RequestedRole: S.optional(UserRole),
    RequestNote: S.optional(S.String),
    CreationTime: S.optional(S.Number),
    RequestStatus: S.optional(SelfUpgradeRequestStatus),
    lastUpdateAttemptTime: S.optional(S.Number),
    lastUpdateFailureReason: S.optional(S.String),
  }),
).annotations({
  identifier: "SelfUpgradeRequestDetail",
}) as any as S.Schema<SelfUpgradeRequestDetail>;
export interface UpdateSelfUpgradeResponse {
  SelfUpgradeRequestDetail?: SelfUpgradeRequestDetail;
  RequestId?: string;
  Status?: number;
}
export const UpdateSelfUpgradeResponse = S.suspend(() =>
  S.Struct({
    SelfUpgradeRequestDetail: S.optional(SelfUpgradeRequestDetail),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateSelfUpgradeResponse",
}) as any as S.Schema<UpdateSelfUpgradeResponse>;
export interface UpdateSelfUpgradeConfigurationResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateSelfUpgradeConfigurationResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateSelfUpgradeConfigurationResponse",
}) as any as S.Schema<UpdateSelfUpgradeConfigurationResponse>;
export interface UpdateSPICECapacityConfigurationResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateSPICECapacityConfigurationResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateSPICECapacityConfigurationResponse",
}) as any as S.Schema<UpdateSPICECapacityConfigurationResponse>;
export interface UpdateTemplateResponse {
  TemplateId?: string;
  Arn?: string;
  VersionArn?: string;
  CreationStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const UpdateTemplateResponse = S.suspend(() =>
  S.Struct({
    TemplateId: S.optional(S.String),
    Arn: S.optional(S.String),
    VersionArn: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateTemplateResponse",
}) as any as S.Schema<UpdateTemplateResponse>;
export interface UpdateTemplateAliasResponse {
  TemplateAlias?: TemplateAlias;
  Status?: number;
  RequestId?: string;
}
export const UpdateTemplateAliasResponse = S.suspend(() =>
  S.Struct({
    TemplateAlias: S.optional(TemplateAlias),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateTemplateAliasResponse",
}) as any as S.Schema<UpdateTemplateAliasResponse>;
export interface UpdateTemplatePermissionsResponse {
  TemplateId?: string;
  TemplateArn?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const UpdateTemplatePermissionsResponse = S.suspend(() =>
  S.Struct({
    TemplateId: S.optional(S.String),
    TemplateArn: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateTemplatePermissionsResponse",
}) as any as S.Schema<UpdateTemplatePermissionsResponse>;
export interface UpdateThemeResponse {
  ThemeId?: string;
  Arn?: string;
  VersionArn?: string;
  CreationStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const UpdateThemeResponse = S.suspend(() =>
  S.Struct({
    ThemeId: S.optional(S.String),
    Arn: S.optional(S.String),
    VersionArn: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateThemeResponse",
}) as any as S.Schema<UpdateThemeResponse>;
export interface UpdateThemeAliasResponse {
  ThemeAlias?: ThemeAlias;
  Status?: number;
  RequestId?: string;
}
export const UpdateThemeAliasResponse = S.suspend(() =>
  S.Struct({
    ThemeAlias: S.optional(ThemeAlias),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateThemeAliasResponse",
}) as any as S.Schema<UpdateThemeAliasResponse>;
export interface UpdateThemePermissionsResponse {
  ThemeId?: string;
  ThemeArn?: string;
  Permissions?: ResourcePermission[];
  RequestId?: string;
  Status?: number;
}
export const UpdateThemePermissionsResponse = S.suspend(() =>
  S.Struct({
    ThemeId: S.optional(S.String),
    ThemeArn: S.optional(S.String),
    Permissions: S.optional(UpdateResourcePermissionList),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateThemePermissionsResponse",
}) as any as S.Schema<UpdateThemePermissionsResponse>;
export interface UpdateTopicResponse {
  TopicId?: string;
  Arn?: string;
  RefreshArn?: string;
  RequestId?: string;
  Status?: number;
}
export const UpdateTopicResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    Arn: S.optional(S.String),
    RefreshArn: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateTopicResponse",
}) as any as S.Schema<UpdateTopicResponse>;
export interface UpdateTopicPermissionsResponse {
  TopicId?: string;
  TopicArn?: string;
  Permissions?: ResourcePermission[];
  Status?: number;
  RequestId?: string;
}
export const UpdateTopicPermissionsResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateTopicPermissionsResponse",
}) as any as S.Schema<UpdateTopicPermissionsResponse>;
export interface UpdateTopicRefreshScheduleResponse {
  TopicId?: string;
  TopicArn?: string;
  DatasetArn?: string;
  Status?: number;
  RequestId?: string;
}
export const UpdateTopicRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    DatasetArn: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateTopicRefreshScheduleResponse",
}) as any as S.Schema<UpdateTopicRefreshScheduleResponse>;
export interface UpdateUserResponse {
  User?: User;
  RequestId?: string;
  Status?: number;
}
export const UpdateUserResponse = S.suspend(() =>
  S.Struct({
    User: S.optional(User),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateUserResponse",
}) as any as S.Schema<UpdateUserResponse>;
export interface UpdateUserCustomPermissionResponse {
  RequestId?: string;
  Status?: number;
}
export const UpdateUserCustomPermissionResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateUserCustomPermissionResponse",
}) as any as S.Schema<UpdateUserCustomPermissionResponse>;
export interface UpdateVPCConnectionResponse {
  Arn?: string;
  VPCConnectionId?: string;
  UpdateStatus?: VPCConnectionResourceStatus;
  AvailabilityStatus?: VPCConnectionAvailabilityStatus;
  RequestId?: string;
  Status?: number;
}
export const UpdateVPCConnectionResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VPCConnectionId: S.optional(S.String),
    UpdateStatus: S.optional(VPCConnectionResourceStatus),
    AvailabilityStatus: S.optional(VPCConnectionAvailabilityStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateVPCConnectionResponse",
}) as any as S.Schema<UpdateVPCConnectionResponse>;
export interface Identifier {
  Identity: string;
}
export const Identifier = S.suspend(() =>
  S.Struct({ Identity: S.String }),
).annotations({ identifier: "Identifier" }) as any as S.Schema<Identifier>;
export type AggType =
  | "SUM"
  | "MIN"
  | "MAX"
  | "COUNT"
  | "AVERAGE"
  | "DISTINCT_COUNT"
  | "STDEV"
  | "STDEVP"
  | "VAR"
  | "VARP"
  | "PERCENTILE"
  | "MEDIAN"
  | "PTD_SUM"
  | "PTD_MIN"
  | "PTD_MAX"
  | "PTD_COUNT"
  | "PTD_DISTINCT_COUNT"
  | "PTD_AVERAGE"
  | "COLUMN"
  | "CUSTOM";
export const AggType = S.Literal(
  "SUM",
  "MIN",
  "MAX",
  "COUNT",
  "AVERAGE",
  "DISTINCT_COUNT",
  "STDEV",
  "STDEVP",
  "VAR",
  "VARP",
  "PERCENTILE",
  "MEDIAN",
  "PTD_SUM",
  "PTD_MIN",
  "PTD_MAX",
  "PTD_COUNT",
  "PTD_DISTINCT_COUNT",
  "PTD_AVERAGE",
  "COLUMN",
  "CUSTOM",
);
export type AggFunctionParamMap = { [key: string]: string };
export const AggFunctionParamMap = S.Record({ key: S.String, value: S.String });
export interface AggFunction {
  Aggregation?: AggType;
  AggregationFunctionParameters?: { [key: string]: string };
  Period?: TopicTimeGranularity;
  PeriodField?: string;
}
export const AggFunction = S.suspend(() =>
  S.Struct({
    Aggregation: S.optional(AggType),
    AggregationFunctionParameters: S.optional(AggFunctionParamMap),
    Period: S.optional(TopicTimeGranularity),
    PeriodField: S.optional(S.String),
  }),
).annotations({ identifier: "AggFunction" }) as any as S.Schema<AggFunction>;
export type OperandList = Identifier[];
export const OperandList = S.Array(Identifier);
export type ComparisonMethodType =
  | "DIFF"
  | "PERC_DIFF"
  | "DIFF_AS_PERC"
  | "POP_CURRENT_DIFF_AS_PERC"
  | "POP_CURRENT_DIFF"
  | "POP_OVERTIME_DIFF_AS_PERC"
  | "POP_OVERTIME_DIFF"
  | "PERCENT_OF_TOTAL"
  | "RUNNING_SUM"
  | "MOVING_AVERAGE";
export const ComparisonMethodType = S.Literal(
  "DIFF",
  "PERC_DIFF",
  "DIFF_AS_PERC",
  "POP_CURRENT_DIFF_AS_PERC",
  "POP_CURRENT_DIFF",
  "POP_OVERTIME_DIFF_AS_PERC",
  "POP_OVERTIME_DIFF",
  "PERCENT_OF_TOTAL",
  "RUNNING_SUM",
  "MOVING_AVERAGE",
);
export interface TopicIRComparisonMethod {
  Type?: ComparisonMethodType;
  Period?: TopicTimeGranularity;
  WindowSize?: number;
}
export const TopicIRComparisonMethod = S.suspend(() =>
  S.Struct({
    Type: S.optional(ComparisonMethodType),
    Period: S.optional(TopicTimeGranularity),
    WindowSize: S.optional(S.Number),
  }),
).annotations({
  identifier: "TopicIRComparisonMethod",
}) as any as S.Schema<TopicIRComparisonMethod>;
export type CalculatedFieldReferenceList = Identifier[];
export const CalculatedFieldReferenceList = S.Array(Identifier);
export interface NamedEntityRef {
  NamedEntityName?: string;
}
export const NamedEntityRef = S.suspend(() =>
  S.Struct({ NamedEntityName: S.optional(S.String) }),
).annotations({
  identifier: "NamedEntityRef",
}) as any as S.Schema<NamedEntityRef>;
export interface TopicIRMetric {
  MetricId?: Identifier;
  Function?: AggFunction;
  Operands?: Identifier[];
  ComparisonMethod?: TopicIRComparisonMethod;
  Expression?: string | redacted.Redacted<string>;
  CalculatedFieldReferences?: Identifier[];
  DisplayFormat?: DisplayFormat;
  DisplayFormatOptions?: DisplayFormatOptions;
  NamedEntity?: NamedEntityRef;
}
export const TopicIRMetric = S.suspend(() =>
  S.Struct({
    MetricId: S.optional(Identifier),
    Function: S.optional(AggFunction),
    Operands: S.optional(OperandList),
    ComparisonMethod: S.optional(TopicIRComparisonMethod),
    Expression: S.optional(SensitiveString),
    CalculatedFieldReferences: S.optional(CalculatedFieldReferenceList),
    DisplayFormat: S.optional(DisplayFormat),
    DisplayFormatOptions: S.optional(DisplayFormatOptions),
    NamedEntity: S.optional(NamedEntityRef),
  }),
).annotations({
  identifier: "TopicIRMetric",
}) as any as S.Schema<TopicIRMetric>;
export type TopicIRMetricList = TopicIRMetric[];
export const TopicIRMetricList = S.Array(TopicIRMetric);
export type TopicSortDirection = "ASCENDING" | "DESCENDING";
export const TopicSortDirection = S.Literal("ASCENDING", "DESCENDING");
export interface TopicSortClause {
  Operand?: Identifier;
  SortDirection?: TopicSortDirection;
}
export const TopicSortClause = S.suspend(() =>
  S.Struct({
    Operand: S.optional(Identifier),
    SortDirection: S.optional(TopicSortDirection),
  }),
).annotations({
  identifier: "TopicSortClause",
}) as any as S.Schema<TopicSortClause>;
export interface TopicIRGroupBy {
  FieldName?: Identifier;
  TimeGranularity?: TopicTimeGranularity;
  Sort?: TopicSortClause;
  DisplayFormat?: DisplayFormat;
  DisplayFormatOptions?: DisplayFormatOptions;
  NamedEntity?: NamedEntityRef;
}
export const TopicIRGroupBy = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(Identifier),
    TimeGranularity: S.optional(TopicTimeGranularity),
    Sort: S.optional(TopicSortClause),
    DisplayFormat: S.optional(DisplayFormat),
    DisplayFormatOptions: S.optional(DisplayFormatOptions),
    NamedEntity: S.optional(NamedEntityRef),
  }),
).annotations({
  identifier: "TopicIRGroupBy",
}) as any as S.Schema<TopicIRGroupBy>;
export type TopicIRGroupByList = TopicIRGroupBy[];
export const TopicIRGroupByList = S.Array(TopicIRGroupBy);
export type TopicIRFilterType =
  | "CATEGORY_FILTER"
  | "NUMERIC_EQUALITY_FILTER"
  | "NUMERIC_RANGE_FILTER"
  | "DATE_RANGE_FILTER"
  | "RELATIVE_DATE_FILTER"
  | "TOP_BOTTOM_FILTER"
  | "EQUALS"
  | "RANK_LIMIT_FILTER"
  | "ACCEPT_ALL_FILTER";
export const TopicIRFilterType = S.Literal(
  "CATEGORY_FILTER",
  "NUMERIC_EQUALITY_FILTER",
  "NUMERIC_RANGE_FILTER",
  "DATE_RANGE_FILTER",
  "RELATIVE_DATE_FILTER",
  "TOP_BOTTOM_FILTER",
  "EQUALS",
  "RANK_LIMIT_FILTER",
  "ACCEPT_ALL_FILTER",
);
export type TopicIRFilterFunction =
  | "CONTAINS"
  | "EXACT"
  | "STARTS_WITH"
  | "ENDS_WITH"
  | "CONTAINS_STRING"
  | "PREVIOUS"
  | "THIS"
  | "LAST"
  | "NEXT"
  | "NOW";
export const TopicIRFilterFunction = S.Literal(
  "CONTAINS",
  "EXACT",
  "STARTS_WITH",
  "ENDS_WITH",
  "CONTAINS_STRING",
  "PREVIOUS",
  "THIS",
  "LAST",
  "NEXT",
  "NOW",
);
export interface CollectiveConstantEntry {
  ConstantType?: ConstantType;
  Value?: string;
}
export const CollectiveConstantEntry = S.suspend(() =>
  S.Struct({
    ConstantType: S.optional(ConstantType),
    Value: S.optional(S.String),
  }),
).annotations({
  identifier: "CollectiveConstantEntry",
}) as any as S.Schema<CollectiveConstantEntry>;
export type CollectiveConstantEntryList = CollectiveConstantEntry[];
export const CollectiveConstantEntryList = S.Array(CollectiveConstantEntry);
export interface TopicConstantValue {
  ConstantType?: ConstantType;
  Value?: string;
  Minimum?: string;
  Maximum?: string;
  ValueList?: CollectiveConstantEntry[];
}
export const TopicConstantValue = S.suspend(() =>
  S.Struct({
    ConstantType: S.optional(ConstantType),
    Value: S.optional(S.String),
    Minimum: S.optional(S.String),
    Maximum: S.optional(S.String),
    ValueList: S.optional(CollectiveConstantEntryList),
  }),
).annotations({
  identifier: "TopicConstantValue",
}) as any as S.Schema<TopicConstantValue>;
export type NullFilterOption = "ALL_VALUES" | "NON_NULLS_ONLY" | "NULLS_ONLY";
export const NullFilterOption = S.Literal(
  "ALL_VALUES",
  "NON_NULLS_ONLY",
  "NULLS_ONLY",
);
export interface AggregationPartitionBy {
  FieldName?: string;
  TimeGranularity?: TimeGranularity;
}
export const AggregationPartitionBy = S.suspend(() =>
  S.Struct({
    FieldName: S.optional(S.String),
    TimeGranularity: S.optional(TimeGranularity),
  }),
).annotations({
  identifier: "AggregationPartitionBy",
}) as any as S.Schema<AggregationPartitionBy>;
export type AggregationPartitionByList = AggregationPartitionBy[];
export const AggregationPartitionByList = S.Array(AggregationPartitionBy);
export interface FilterAggMetrics {
  MetricOperand?: Identifier;
  Function?: AggType;
  SortDirection?: TopicSortDirection;
}
export const FilterAggMetrics = S.suspend(() =>
  S.Struct({
    MetricOperand: S.optional(Identifier),
    Function: S.optional(AggType),
    SortDirection: S.optional(TopicSortDirection),
  }),
).annotations({
  identifier: "FilterAggMetrics",
}) as any as S.Schema<FilterAggMetrics>;
export type FilterAggMetricsList = FilterAggMetrics[];
export const FilterAggMetricsList = S.Array(FilterAggMetrics);
export type AnchorType = "TODAY";
export const AnchorType = S.Literal("TODAY");
export interface Anchor {
  AnchorType?: AnchorType;
  TimeGranularity?: TimeGranularity;
  Offset?: number;
}
export const Anchor = S.suspend(() =>
  S.Struct({
    AnchorType: S.optional(AnchorType),
    TimeGranularity: S.optional(TimeGranularity),
    Offset: S.optional(S.Number),
  }),
).annotations({ identifier: "Anchor" }) as any as S.Schema<Anchor>;
export interface TopicIRFilterOption {
  FilterType?: TopicIRFilterType;
  FilterClass?: FilterClass;
  OperandField?: Identifier;
  Function?: TopicIRFilterFunction;
  Constant?: TopicConstantValue;
  Inverse?: boolean;
  NullFilter?: NullFilterOption;
  Aggregation?: AggType;
  AggregationFunctionParameters?: { [key: string]: string };
  AggregationPartitionBy?: AggregationPartitionBy[];
  Range?: TopicConstantValue;
  Inclusive?: boolean;
  TimeGranularity?: TimeGranularity;
  LastNextOffset?: TopicConstantValue;
  AggMetrics?: FilterAggMetrics[];
  TopBottomLimit?: TopicConstantValue;
  SortDirection?: TopicSortDirection;
  Anchor?: Anchor;
}
export const TopicIRFilterOption = S.suspend(() =>
  S.Struct({
    FilterType: S.optional(TopicIRFilterType),
    FilterClass: S.optional(FilterClass),
    OperandField: S.optional(Identifier),
    Function: S.optional(TopicIRFilterFunction),
    Constant: S.optional(TopicConstantValue),
    Inverse: S.optional(S.Boolean),
    NullFilter: S.optional(NullFilterOption),
    Aggregation: S.optional(AggType),
    AggregationFunctionParameters: S.optional(AggFunctionParamMap),
    AggregationPartitionBy: S.optional(AggregationPartitionByList),
    Range: S.optional(TopicConstantValue),
    Inclusive: S.optional(S.Boolean),
    TimeGranularity: S.optional(TimeGranularity),
    LastNextOffset: S.optional(TopicConstantValue),
    AggMetrics: S.optional(FilterAggMetricsList),
    TopBottomLimit: S.optional(TopicConstantValue),
    SortDirection: S.optional(TopicSortDirection),
    Anchor: S.optional(Anchor),
  }),
).annotations({
  identifier: "TopicIRFilterOption",
}) as any as S.Schema<TopicIRFilterOption>;
export type TopicIRFilterEntry = TopicIRFilterOption[];
export const TopicIRFilterEntry = S.Array(TopicIRFilterOption);
export type TopicIRFilterList = TopicIRFilterOption[][];
export const TopicIRFilterList = S.Array(TopicIRFilterEntry);
export interface ContributionAnalysisFactor {
  FieldName?: string;
}
export const ContributionAnalysisFactor = S.suspend(() =>
  S.Struct({ FieldName: S.optional(S.String) }),
).annotations({
  identifier: "ContributionAnalysisFactor",
}) as any as S.Schema<ContributionAnalysisFactor>;
export type ContributionAnalysisFactorsList = ContributionAnalysisFactor[];
export const ContributionAnalysisFactorsList = S.Array(
  ContributionAnalysisFactor,
);
export interface ContributionAnalysisTimeRanges {
  StartRange?: TopicIRFilterOption;
  EndRange?: TopicIRFilterOption;
}
export const ContributionAnalysisTimeRanges = S.suspend(() =>
  S.Struct({
    StartRange: S.optional(TopicIRFilterOption),
    EndRange: S.optional(TopicIRFilterOption),
  }),
).annotations({
  identifier: "ContributionAnalysisTimeRanges",
}) as any as S.Schema<ContributionAnalysisTimeRanges>;
export type ContributionAnalysisDirection = "INCREASE" | "DECREASE" | "NEUTRAL";
export const ContributionAnalysisDirection = S.Literal(
  "INCREASE",
  "DECREASE",
  "NEUTRAL",
);
export type ContributionAnalysisSortType =
  | "ABSOLUTE_DIFFERENCE"
  | "CONTRIBUTION_PERCENTAGE"
  | "DEVIATION_FROM_EXPECTED"
  | "PERCENTAGE_DIFFERENCE";
export const ContributionAnalysisSortType = S.Literal(
  "ABSOLUTE_DIFFERENCE",
  "CONTRIBUTION_PERCENTAGE",
  "DEVIATION_FROM_EXPECTED",
  "PERCENTAGE_DIFFERENCE",
);
export interface TopicIRContributionAnalysis {
  Factors?: ContributionAnalysisFactor[];
  TimeRanges?: ContributionAnalysisTimeRanges;
  Direction?: ContributionAnalysisDirection;
  SortType?: ContributionAnalysisSortType;
}
export const TopicIRContributionAnalysis = S.suspend(() =>
  S.Struct({
    Factors: S.optional(ContributionAnalysisFactorsList),
    TimeRanges: S.optional(ContributionAnalysisTimeRanges),
    Direction: S.optional(ContributionAnalysisDirection),
    SortType: S.optional(ContributionAnalysisSortType),
  }),
).annotations({
  identifier: "TopicIRContributionAnalysis",
}) as any as S.Schema<TopicIRContributionAnalysis>;
export interface VisualOptions {
  type?: string;
}
export const VisualOptions = S.suspend(() =>
  S.Struct({ type: S.optional(S.String) }),
).annotations({
  identifier: "VisualOptions",
}) as any as S.Schema<VisualOptions>;
export interface TopicIR {
  Metrics?: TopicIRMetric[];
  GroupByList?: TopicIRGroupBy[];
  Filters?: TopicIRFilterOption[][];
  Sort?: TopicSortClause;
  ContributionAnalysis?: TopicIRContributionAnalysis;
  Visual?: VisualOptions;
}
export const TopicIR = S.suspend(() =>
  S.Struct({
    Metrics: S.optional(TopicIRMetricList),
    GroupByList: S.optional(TopicIRGroupByList),
    Filters: S.optional(TopicIRFilterList),
    Sort: S.optional(TopicSortClause),
    ContributionAnalysis: S.optional(TopicIRContributionAnalysis),
    Visual: S.optional(VisualOptions),
  }),
).annotations({ identifier: "TopicIR" }) as any as S.Schema<TopicIR>;
export interface TopicVisual {
  VisualId?: string;
  Role?: VisualRole;
  Ir?: TopicIR;
  SupportingVisuals?: TopicVisual[];
}
export const TopicVisual = S.suspend(() =>
  S.Struct({
    VisualId: S.optional(S.String),
    Role: S.optional(VisualRole),
    Ir: S.optional(TopicIR),
    SupportingVisuals: S.optional(
      S.suspend(() => TopicVisuals).annotations({ identifier: "TopicVisuals" }),
    ),
  }),
).annotations({ identifier: "TopicVisual" }) as any as S.Schema<TopicVisual>;
export type ReviewedAnswerErrorCode =
  | "INTERNAL_ERROR"
  | "MISSING_ANSWER"
  | "DATASET_DOES_NOT_EXIST"
  | "INVALID_DATASET_ARN"
  | "DUPLICATED_ANSWER"
  | "INVALID_DATA"
  | "MISSING_REQUIRED_FIELDS";
export const ReviewedAnswerErrorCode = S.Literal(
  "INTERNAL_ERROR",
  "MISSING_ANSWER",
  "DATASET_DOES_NOT_EXIST",
  "INVALID_DATASET_ARN",
  "DUPLICATED_ANSWER",
  "INVALID_DATA",
  "MISSING_REQUIRED_FIELDS",
);
export type ActionIdList = string[];
export const ActionIdList = S.Array(S.String);
export type AnalysisErrorType =
  | "ACCESS_DENIED"
  | "SOURCE_NOT_FOUND"
  | "DATA_SET_NOT_FOUND"
  | "INTERNAL_FAILURE"
  | "PARAMETER_VALUE_INCOMPATIBLE"
  | "PARAMETER_TYPE_INVALID"
  | "PARAMETER_NOT_FOUND"
  | "COLUMN_TYPE_MISMATCH"
  | "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
  | "COLUMN_REPLACEMENT_MISSING";
export const AnalysisErrorType = S.Literal(
  "ACCESS_DENIED",
  "SOURCE_NOT_FOUND",
  "DATA_SET_NOT_FOUND",
  "INTERNAL_FAILURE",
  "PARAMETER_VALUE_INCOMPATIBLE",
  "PARAMETER_TYPE_INVALID",
  "PARAMETER_NOT_FOUND",
  "COLUMN_TYPE_MISMATCH",
  "COLUMN_GEOGRAPHIC_ROLE_MISMATCH",
  "COLUMN_REPLACEMENT_MISSING",
);
export type DashboardErrorType =
  | "ACCESS_DENIED"
  | "SOURCE_NOT_FOUND"
  | "DATA_SET_NOT_FOUND"
  | "INTERNAL_FAILURE"
  | "PARAMETER_VALUE_INCOMPATIBLE"
  | "PARAMETER_TYPE_INVALID"
  | "PARAMETER_NOT_FOUND"
  | "COLUMN_TYPE_MISMATCH"
  | "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
  | "COLUMN_REPLACEMENT_MISSING";
export const DashboardErrorType = S.Literal(
  "ACCESS_DENIED",
  "SOURCE_NOT_FOUND",
  "DATA_SET_NOT_FOUND",
  "INTERNAL_FAILURE",
  "PARAMETER_VALUE_INCOMPATIBLE",
  "PARAMETER_TYPE_INVALID",
  "PARAMETER_NOT_FOUND",
  "COLUMN_TYPE_MISMATCH",
  "COLUMN_GEOGRAPHIC_ROLE_MISMATCH",
  "COLUMN_REPLACEMENT_MISSING",
);
export type Path = string[];
export const Path = S.Array(S.String);
export type QDataKeyType = "AWS_OWNED" | "CMK";
export const QDataKeyType = S.Literal("AWS_OWNED", "CMK");
export type TemplateErrorType =
  | "SOURCE_NOT_FOUND"
  | "DATA_SET_NOT_FOUND"
  | "INTERNAL_FAILURE"
  | "ACCESS_DENIED";
export const TemplateErrorType = S.Literal(
  "SOURCE_NOT_FOUND",
  "DATA_SET_NOT_FOUND",
  "INTERNAL_FAILURE",
  "ACCESS_DENIED",
);
export type TopicRefreshStatus =
  | "INITIALIZED"
  | "RUNNING"
  | "FAILED"
  | "COMPLETED"
  | "CANCELLED";
export const TopicRefreshStatus = S.Literal(
  "INITIALIZED",
  "RUNNING",
  "FAILED",
  "COMPLETED",
  "CANCELLED",
);
export interface AnonymousUserQSearchBarEmbeddingConfiguration {
  InitialTopicId: string;
}
export const AnonymousUserQSearchBarEmbeddingConfiguration = S.suspend(() =>
  S.Struct({ InitialTopicId: S.String }),
).annotations({
  identifier: "AnonymousUserQSearchBarEmbeddingConfiguration",
}) as any as S.Schema<AnonymousUserQSearchBarEmbeddingConfiguration>;
export interface AnonymousUserGenerativeQnAEmbeddingConfiguration {
  InitialTopicId: string;
}
export const AnonymousUserGenerativeQnAEmbeddingConfiguration = S.suspend(() =>
  S.Struct({ InitialTopicId: S.String }),
).annotations({
  identifier: "AnonymousUserGenerativeQnAEmbeddingConfiguration",
}) as any as S.Schema<AnonymousUserGenerativeQnAEmbeddingConfiguration>;
export interface AssetBundleExportJobResourceIdOverrideConfiguration {
  PrefixForAllResources?: boolean;
}
export const AssetBundleExportJobResourceIdOverrideConfiguration = S.suspend(
  () => S.Struct({ PrefixForAllResources: S.optional(S.Boolean) }),
).annotations({
  identifier: "AssetBundleExportJobResourceIdOverrideConfiguration",
}) as any as S.Schema<AssetBundleExportJobResourceIdOverrideConfiguration>;
export interface AssetBundleExportJobVPCConnectionOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobVPCConnectionPropertyToOverride[];
}
export const AssetBundleExportJobVPCConnectionOverrideProperties = S.suspend(
  () =>
    S.Struct({
      Arn: S.String,
      Properties: AssetBundleExportJobVPCConnectionPropertyToOverrideList,
    }),
).annotations({
  identifier: "AssetBundleExportJobVPCConnectionOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobVPCConnectionOverrideProperties>;
export type AssetBundleExportJobVPCConnectionOverridePropertiesList =
  AssetBundleExportJobVPCConnectionOverrideProperties[];
export const AssetBundleExportJobVPCConnectionOverridePropertiesList = S.Array(
  AssetBundleExportJobVPCConnectionOverrideProperties,
);
export interface AssetBundleExportJobRefreshScheduleOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobRefreshSchedulePropertyToOverride[];
}
export const AssetBundleExportJobRefreshScheduleOverrideProperties = S.suspend(
  () =>
    S.Struct({
      Arn: S.String,
      Properties: AssetBundleExportJobRefreshSchedulePropertyToOverrideList,
    }),
).annotations({
  identifier: "AssetBundleExportJobRefreshScheduleOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobRefreshScheduleOverrideProperties>;
export type AssetBundleExportJobRefreshScheduleOverridePropertiesList =
  AssetBundleExportJobRefreshScheduleOverrideProperties[];
export const AssetBundleExportJobRefreshScheduleOverridePropertiesList =
  S.Array(AssetBundleExportJobRefreshScheduleOverrideProperties);
export interface AssetBundleExportJobDataSourceOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobDataSourcePropertyToOverride[];
}
export const AssetBundleExportJobDataSourceOverrideProperties = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    Properties: AssetBundleExportJobDataSourcePropertyToOverrideList,
  }),
).annotations({
  identifier: "AssetBundleExportJobDataSourceOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobDataSourceOverrideProperties>;
export type AssetBundleExportJobDataSourceOverridePropertiesList =
  AssetBundleExportJobDataSourceOverrideProperties[];
export const AssetBundleExportJobDataSourceOverridePropertiesList = S.Array(
  AssetBundleExportJobDataSourceOverrideProperties,
);
export interface AssetBundleExportJobDataSetOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobDataSetPropertyToOverride[];
}
export const AssetBundleExportJobDataSetOverrideProperties = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    Properties: AssetBundleExportJobDataSetPropertyToOverrideList,
  }),
).annotations({
  identifier: "AssetBundleExportJobDataSetOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobDataSetOverrideProperties>;
export type AssetBundleExportJobDataSetOverridePropertiesList =
  AssetBundleExportJobDataSetOverrideProperties[];
export const AssetBundleExportJobDataSetOverridePropertiesList = S.Array(
  AssetBundleExportJobDataSetOverrideProperties,
);
export interface AssetBundleExportJobThemeOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobThemePropertyToOverride[];
}
export const AssetBundleExportJobThemeOverrideProperties = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    Properties: AssetBundleExportJobThemePropertyToOverrideList,
  }),
).annotations({
  identifier: "AssetBundleExportJobThemeOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobThemeOverrideProperties>;
export type AssetBundleExportJobThemeOverridePropertiesList =
  AssetBundleExportJobThemeOverrideProperties[];
export const AssetBundleExportJobThemeOverridePropertiesList = S.Array(
  AssetBundleExportJobThemeOverrideProperties,
);
export interface AssetBundleExportJobAnalysisOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobAnalysisPropertyToOverride[];
}
export const AssetBundleExportJobAnalysisOverrideProperties = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    Properties: AssetBundleExportJobAnalysisPropertyToOverrideList,
  }),
).annotations({
  identifier: "AssetBundleExportJobAnalysisOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobAnalysisOverrideProperties>;
export type AssetBundleExportJobAnalysisOverridePropertiesList =
  AssetBundleExportJobAnalysisOverrideProperties[];
export const AssetBundleExportJobAnalysisOverridePropertiesList = S.Array(
  AssetBundleExportJobAnalysisOverrideProperties,
);
export interface AssetBundleExportJobDashboardOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobDashboardPropertyToOverride[];
}
export const AssetBundleExportJobDashboardOverrideProperties = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    Properties: AssetBundleExportJobDashboardPropertyToOverrideList,
  }),
).annotations({
  identifier: "AssetBundleExportJobDashboardOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobDashboardOverrideProperties>;
export type AssetBundleExportJobDashboardOverridePropertiesList =
  AssetBundleExportJobDashboardOverrideProperties[];
export const AssetBundleExportJobDashboardOverridePropertiesList = S.Array(
  AssetBundleExportJobDashboardOverrideProperties,
);
export interface AssetBundleExportJobFolderOverrideProperties {
  Arn: string;
  Properties: AssetBundleExportJobFolderPropertyToOverride[];
}
export const AssetBundleExportJobFolderOverrideProperties = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    Properties: AssetBundleExportJobFolderPropertyToOverrideList,
  }),
).annotations({
  identifier: "AssetBundleExportJobFolderOverrideProperties",
}) as any as S.Schema<AssetBundleExportJobFolderOverrideProperties>;
export type AssetBundleExportJobFolderOverridePropertiesList =
  AssetBundleExportJobFolderOverrideProperties[];
export const AssetBundleExportJobFolderOverridePropertiesList = S.Array(
  AssetBundleExportJobFolderOverrideProperties,
);
export interface AssetBundleImportJobResourceIdOverrideConfiguration {
  PrefixForAllResources?: string;
}
export const AssetBundleImportJobResourceIdOverrideConfiguration = S.suspend(
  () => S.Struct({ PrefixForAllResources: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleImportJobResourceIdOverrideConfiguration",
}) as any as S.Schema<AssetBundleImportJobResourceIdOverrideConfiguration>;
export interface AssetBundleImportJobVPCConnectionOverrideParameters {
  VPCConnectionId: string;
  Name?: string;
  SubnetIds?: string[];
  SecurityGroupIds?: string[];
  DnsResolvers?: string[];
  RoleArn?: string;
}
export const AssetBundleImportJobVPCConnectionOverrideParameters = S.suspend(
  () =>
    S.Struct({
      VPCConnectionId: S.String,
      Name: S.optional(S.String),
      SubnetIds: S.optional(SubnetIdList),
      SecurityGroupIds: S.optional(SecurityGroupIdList),
      DnsResolvers: S.optional(DnsResolverList),
      RoleArn: S.optional(S.String),
    }),
).annotations({
  identifier: "AssetBundleImportJobVPCConnectionOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobVPCConnectionOverrideParameters>;
export type AssetBundleImportJobVPCConnectionOverrideParametersList =
  AssetBundleImportJobVPCConnectionOverrideParameters[];
export const AssetBundleImportJobVPCConnectionOverrideParametersList = S.Array(
  AssetBundleImportJobVPCConnectionOverrideParameters,
);
export interface AssetBundleImportJobRefreshScheduleOverrideParameters {
  DataSetId: string;
  ScheduleId: string;
  StartAfterDateTime?: Date;
}
export const AssetBundleImportJobRefreshScheduleOverrideParameters = S.suspend(
  () =>
    S.Struct({
      DataSetId: S.String,
      ScheduleId: S.String,
      StartAfterDateTime: S.optional(
        S.Date.pipe(T.TimestampFormat("epoch-seconds")),
      ),
    }),
).annotations({
  identifier: "AssetBundleImportJobRefreshScheduleOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobRefreshScheduleOverrideParameters>;
export type AssetBundleImportJobRefreshScheduleOverrideParametersList =
  AssetBundleImportJobRefreshScheduleOverrideParameters[];
export const AssetBundleImportJobRefreshScheduleOverrideParametersList =
  S.Array(AssetBundleImportJobRefreshScheduleOverrideParameters);
export interface AssetBundleImportJobDataSetOverrideParameters {
  DataSetId: string;
  Name?: string;
  DataSetRefreshProperties?: DataSetRefreshProperties;
}
export const AssetBundleImportJobDataSetOverrideParameters = S.suspend(() =>
  S.Struct({
    DataSetId: S.String,
    Name: S.optional(S.String),
    DataSetRefreshProperties: S.optional(DataSetRefreshProperties),
  }),
).annotations({
  identifier: "AssetBundleImportJobDataSetOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobDataSetOverrideParameters>;
export type AssetBundleImportJobDataSetOverrideParametersList =
  AssetBundleImportJobDataSetOverrideParameters[];
export const AssetBundleImportJobDataSetOverrideParametersList = S.Array(
  AssetBundleImportJobDataSetOverrideParameters,
);
export interface AssetBundleImportJobThemeOverrideParameters {
  ThemeId: string;
  Name?: string;
}
export const AssetBundleImportJobThemeOverrideParameters = S.suspend(() =>
  S.Struct({ ThemeId: S.String, Name: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleImportJobThemeOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobThemeOverrideParameters>;
export type AssetBundleImportJobThemeOverrideParametersList =
  AssetBundleImportJobThemeOverrideParameters[];
export const AssetBundleImportJobThemeOverrideParametersList = S.Array(
  AssetBundleImportJobThemeOverrideParameters,
);
export interface AssetBundleImportJobAnalysisOverrideParameters {
  AnalysisId: string;
  Name?: string;
}
export const AssetBundleImportJobAnalysisOverrideParameters = S.suspend(() =>
  S.Struct({ AnalysisId: S.String, Name: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleImportJobAnalysisOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobAnalysisOverrideParameters>;
export type AssetBundleImportJobAnalysisOverrideParametersList =
  AssetBundleImportJobAnalysisOverrideParameters[];
export const AssetBundleImportJobAnalysisOverrideParametersList = S.Array(
  AssetBundleImportJobAnalysisOverrideParameters,
);
export interface AssetBundleImportJobDashboardOverrideParameters {
  DashboardId: string;
  Name?: string;
}
export const AssetBundleImportJobDashboardOverrideParameters = S.suspend(() =>
  S.Struct({ DashboardId: S.String, Name: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleImportJobDashboardOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobDashboardOverrideParameters>;
export type AssetBundleImportJobDashboardOverrideParametersList =
  AssetBundleImportJobDashboardOverrideParameters[];
export const AssetBundleImportJobDashboardOverrideParametersList = S.Array(
  AssetBundleImportJobDashboardOverrideParameters,
);
export interface AssetBundleImportJobFolderOverrideParameters {
  FolderId: string;
  Name?: string;
  ParentFolderArn?: string;
}
export const AssetBundleImportJobFolderOverrideParameters = S.suspend(() =>
  S.Struct({
    FolderId: S.String,
    Name: S.optional(S.String),
    ParentFolderArn: S.optional(S.String),
  }),
).annotations({
  identifier: "AssetBundleImportJobFolderOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobFolderOverrideParameters>;
export type AssetBundleImportJobFolderOverrideParametersList =
  AssetBundleImportJobFolderOverrideParameters[];
export const AssetBundleImportJobFolderOverrideParametersList = S.Array(
  AssetBundleImportJobFolderOverrideParameters,
);
export type AssetBundlePrincipalList = string[];
export const AssetBundlePrincipalList = S.Array(S.String);
export interface AssetBundleResourcePermissions {
  Principals: string[];
  Actions: string[];
}
export const AssetBundleResourcePermissions = S.suspend(() =>
  S.Struct({ Principals: AssetBundlePrincipalList, Actions: ActionList }),
).annotations({
  identifier: "AssetBundleResourcePermissions",
}) as any as S.Schema<AssetBundleResourcePermissions>;
export interface AssetBundleImportJobDataSetOverridePermissions {
  DataSetIds: string[];
  Permissions: AssetBundleResourcePermissions;
}
export const AssetBundleImportJobDataSetOverridePermissions = S.suspend(() =>
  S.Struct({
    DataSetIds: AssetBundleRestrictiveResourceIdList,
    Permissions: AssetBundleResourcePermissions,
  }),
).annotations({
  identifier: "AssetBundleImportJobDataSetOverridePermissions",
}) as any as S.Schema<AssetBundleImportJobDataSetOverridePermissions>;
export type AssetBundleImportJobDataSetOverridePermissionsList =
  AssetBundleImportJobDataSetOverridePermissions[];
export const AssetBundleImportJobDataSetOverridePermissionsList = S.Array(
  AssetBundleImportJobDataSetOverridePermissions,
);
export interface AssetBundleImportJobThemeOverridePermissions {
  ThemeIds: string[];
  Permissions: AssetBundleResourcePermissions;
}
export const AssetBundleImportJobThemeOverridePermissions = S.suspend(() =>
  S.Struct({
    ThemeIds: AssetBundleRestrictiveResourceIdList,
    Permissions: AssetBundleResourcePermissions,
  }),
).annotations({
  identifier: "AssetBundleImportJobThemeOverridePermissions",
}) as any as S.Schema<AssetBundleImportJobThemeOverridePermissions>;
export type AssetBundleImportJobThemeOverridePermissionsList =
  AssetBundleImportJobThemeOverridePermissions[];
export const AssetBundleImportJobThemeOverridePermissionsList = S.Array(
  AssetBundleImportJobThemeOverridePermissions,
);
export interface AssetBundleImportJobAnalysisOverridePermissions {
  AnalysisIds: string[];
  Permissions: AssetBundleResourcePermissions;
}
export const AssetBundleImportJobAnalysisOverridePermissions = S.suspend(() =>
  S.Struct({
    AnalysisIds: AssetBundleRestrictiveResourceIdList,
    Permissions: AssetBundleResourcePermissions,
  }),
).annotations({
  identifier: "AssetBundleImportJobAnalysisOverridePermissions",
}) as any as S.Schema<AssetBundleImportJobAnalysisOverridePermissions>;
export type AssetBundleImportJobAnalysisOverridePermissionsList =
  AssetBundleImportJobAnalysisOverridePermissions[];
export const AssetBundleImportJobAnalysisOverridePermissionsList = S.Array(
  AssetBundleImportJobAnalysisOverridePermissions,
);
export interface AssetBundleImportJobFolderOverridePermissions {
  FolderIds: string[];
  Permissions?: AssetBundleResourcePermissions;
}
export const AssetBundleImportJobFolderOverridePermissions = S.suspend(() =>
  S.Struct({
    FolderIds: AssetBundleRestrictiveResourceIdList,
    Permissions: S.optional(AssetBundleResourcePermissions),
  }),
).annotations({
  identifier: "AssetBundleImportJobFolderOverridePermissions",
}) as any as S.Schema<AssetBundleImportJobFolderOverridePermissions>;
export type AssetBundleImportJobFolderOverridePermissionsList =
  AssetBundleImportJobFolderOverridePermissions[];
export const AssetBundleImportJobFolderOverridePermissionsList = S.Array(
  AssetBundleImportJobFolderOverridePermissions,
);
export interface AssetBundleImportJobVPCConnectionOverrideTags {
  VPCConnectionIds: string[];
  Tags: Tag[];
}
export const AssetBundleImportJobVPCConnectionOverrideTags = S.suspend(() =>
  S.Struct({
    VPCConnectionIds: AssetBundleRestrictiveResourceIdList,
    Tags: TagList,
  }),
).annotations({
  identifier: "AssetBundleImportJobVPCConnectionOverrideTags",
}) as any as S.Schema<AssetBundleImportJobVPCConnectionOverrideTags>;
export type AssetBundleImportJobVPCConnectionOverrideTagsList =
  AssetBundleImportJobVPCConnectionOverrideTags[];
export const AssetBundleImportJobVPCConnectionOverrideTagsList = S.Array(
  AssetBundleImportJobVPCConnectionOverrideTags,
);
export interface AssetBundleImportJobDataSourceOverrideTags {
  DataSourceIds: string[];
  Tags: Tag[];
}
export const AssetBundleImportJobDataSourceOverrideTags = S.suspend(() =>
  S.Struct({
    DataSourceIds: AssetBundleRestrictiveResourceIdList,
    Tags: TagList,
  }),
).annotations({
  identifier: "AssetBundleImportJobDataSourceOverrideTags",
}) as any as S.Schema<AssetBundleImportJobDataSourceOverrideTags>;
export type AssetBundleImportJobDataSourceOverrideTagsList =
  AssetBundleImportJobDataSourceOverrideTags[];
export const AssetBundleImportJobDataSourceOverrideTagsList = S.Array(
  AssetBundleImportJobDataSourceOverrideTags,
);
export interface AssetBundleImportJobDataSetOverrideTags {
  DataSetIds: string[];
  Tags: Tag[];
}
export const AssetBundleImportJobDataSetOverrideTags = S.suspend(() =>
  S.Struct({ DataSetIds: AssetBundleRestrictiveResourceIdList, Tags: TagList }),
).annotations({
  identifier: "AssetBundleImportJobDataSetOverrideTags",
}) as any as S.Schema<AssetBundleImportJobDataSetOverrideTags>;
export type AssetBundleImportJobDataSetOverrideTagsList =
  AssetBundleImportJobDataSetOverrideTags[];
export const AssetBundleImportJobDataSetOverrideTagsList = S.Array(
  AssetBundleImportJobDataSetOverrideTags,
);
export interface AssetBundleImportJobThemeOverrideTags {
  ThemeIds: string[];
  Tags: Tag[];
}
export const AssetBundleImportJobThemeOverrideTags = S.suspend(() =>
  S.Struct({ ThemeIds: AssetBundleRestrictiveResourceIdList, Tags: TagList }),
).annotations({
  identifier: "AssetBundleImportJobThemeOverrideTags",
}) as any as S.Schema<AssetBundleImportJobThemeOverrideTags>;
export type AssetBundleImportJobThemeOverrideTagsList =
  AssetBundleImportJobThemeOverrideTags[];
export const AssetBundleImportJobThemeOverrideTagsList = S.Array(
  AssetBundleImportJobThemeOverrideTags,
);
export interface AssetBundleImportJobAnalysisOverrideTags {
  AnalysisIds: string[];
  Tags: Tag[];
}
export const AssetBundleImportJobAnalysisOverrideTags = S.suspend(() =>
  S.Struct({
    AnalysisIds: AssetBundleRestrictiveResourceIdList,
    Tags: TagList,
  }),
).annotations({
  identifier: "AssetBundleImportJobAnalysisOverrideTags",
}) as any as S.Schema<AssetBundleImportJobAnalysisOverrideTags>;
export type AssetBundleImportJobAnalysisOverrideTagsList =
  AssetBundleImportJobAnalysisOverrideTags[];
export const AssetBundleImportJobAnalysisOverrideTagsList = S.Array(
  AssetBundleImportJobAnalysisOverrideTags,
);
export interface AssetBundleImportJobDashboardOverrideTags {
  DashboardIds: string[];
  Tags: Tag[];
}
export const AssetBundleImportJobDashboardOverrideTags = S.suspend(() =>
  S.Struct({
    DashboardIds: AssetBundleRestrictiveResourceIdList,
    Tags: TagList,
  }),
).annotations({
  identifier: "AssetBundleImportJobDashboardOverrideTags",
}) as any as S.Schema<AssetBundleImportJobDashboardOverrideTags>;
export type AssetBundleImportJobDashboardOverrideTagsList =
  AssetBundleImportJobDashboardOverrideTags[];
export const AssetBundleImportJobDashboardOverrideTagsList = S.Array(
  AssetBundleImportJobDashboardOverrideTags,
);
export interface AssetBundleImportJobFolderOverrideTags {
  FolderIds: string[];
  Tags: Tag[];
}
export const AssetBundleImportJobFolderOverrideTags = S.suspend(() =>
  S.Struct({ FolderIds: AssetBundleRestrictiveResourceIdList, Tags: TagList }),
).annotations({
  identifier: "AssetBundleImportJobFolderOverrideTags",
}) as any as S.Schema<AssetBundleImportJobFolderOverrideTags>;
export type AssetBundleImportJobFolderOverrideTagsList =
  AssetBundleImportJobFolderOverrideTags[];
export const AssetBundleImportJobFolderOverrideTagsList = S.Array(
  AssetBundleImportJobFolderOverrideTags,
);
export interface SnapshotAnonymousUser {
  RowLevelPermissionTags?: SessionTag[];
}
export const SnapshotAnonymousUser = S.suspend(() =>
  S.Struct({ RowLevelPermissionTags: S.optional(SessionTagList) }),
).annotations({
  identifier: "SnapshotAnonymousUser",
}) as any as S.Schema<SnapshotAnonymousUser>;
export type SnapshotAnonymousUserList = SnapshotAnonymousUser[];
export const SnapshotAnonymousUserList = S.Array(SnapshotAnonymousUser);
export type SnapshotFileFormatType = "CSV" | "PDF" | "EXCEL";
export const SnapshotFileFormatType = S.Literal("CSV", "PDF", "EXCEL");
export interface SucceededTopicReviewedAnswer {
  AnswerId?: string;
}
export const SucceededTopicReviewedAnswer = S.suspend(() =>
  S.Struct({ AnswerId: S.optional(S.String) }),
).annotations({
  identifier: "SucceededTopicReviewedAnswer",
}) as any as S.Schema<SucceededTopicReviewedAnswer>;
export type SucceededTopicReviewedAnswers = SucceededTopicReviewedAnswer[];
export const SucceededTopicReviewedAnswers = S.Array(
  SucceededTopicReviewedAnswer,
);
export interface InvalidTopicReviewedAnswer {
  AnswerId?: string;
  Error?: ReviewedAnswerErrorCode;
}
export const InvalidTopicReviewedAnswer = S.suspend(() =>
  S.Struct({
    AnswerId: S.optional(S.String),
    Error: S.optional(ReviewedAnswerErrorCode),
  }),
).annotations({
  identifier: "InvalidTopicReviewedAnswer",
}) as any as S.Schema<InvalidTopicReviewedAnswer>;
export type InvalidTopicReviewedAnswers = InvalidTopicReviewedAnswer[];
export const InvalidTopicReviewedAnswers = S.Array(InvalidTopicReviewedAnswer);
export interface SignupResponse {
  IAMUser?: boolean;
  userLoginName?: string;
  accountName?: string;
  directoryType?: string;
}
export const SignupResponse = S.suspend(() =>
  S.Struct({
    IAMUser: S.optional(S.Boolean),
    userLoginName: S.optional(S.String),
    accountName: S.optional(S.String),
    directoryType: S.optional(S.String),
  }),
).annotations({
  identifier: "SignupResponse",
}) as any as S.Schema<SignupResponse>;
export interface FolderMember {
  MemberId?: string;
  MemberType?: MemberType;
}
export const FolderMember = S.suspend(() =>
  S.Struct({
    MemberId: S.optional(S.String),
    MemberType: S.optional(MemberType),
  }),
).annotations({ identifier: "FolderMember" }) as any as S.Schema<FolderMember>;
export interface AccountSettings {
  AccountName?: string;
  Edition?: Edition;
  DefaultNamespace?: string;
  NotificationEmail?: string;
  PublicSharingEnabled?: boolean;
  TerminationProtectionEnabled?: boolean;
}
export const AccountSettings = S.suspend(() =>
  S.Struct({
    AccountName: S.optional(S.String),
    Edition: S.optional(Edition),
    DefaultNamespace: S.optional(S.String),
    NotificationEmail: S.optional(S.String),
    PublicSharingEnabled: S.optional(S.Boolean),
    TerminationProtectionEnabled: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "AccountSettings",
}) as any as S.Schema<AccountSettings>;
export interface AccountInfo {
  AccountName?: string;
  Edition?: Edition;
  NotificationEmail?: string;
  AuthenticationType?: string;
  AccountSubscriptionStatus?: string;
  IAMIdentityCenterInstanceArn?: string;
}
export const AccountInfo = S.suspend(() =>
  S.Struct({
    AccountName: S.optional(S.String),
    Edition: S.optional(Edition),
    NotificationEmail: S.optional(S.String),
    AuthenticationType: S.optional(S.String),
    AccountSubscriptionStatus: S.optional(S.String),
    IAMIdentityCenterInstanceArn: S.optional(S.String),
  }),
).annotations({ identifier: "AccountInfo" }) as any as S.Schema<AccountInfo>;
export interface AssetBundleExportJobError {
  Arn?: string;
  Type?: string;
  Message?: string;
}
export const AssetBundleExportJobError = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Type: S.optional(S.String),
    Message: S.optional(S.String),
  }),
).annotations({
  identifier: "AssetBundleExportJobError",
}) as any as S.Schema<AssetBundleExportJobError>;
export type AssetBundleExportJobErrorList = AssetBundleExportJobError[];
export const AssetBundleExportJobErrorList = S.Array(AssetBundleExportJobError);
export interface AssetBundleExportJobWarning {
  Arn?: string;
  Message?: string;
}
export const AssetBundleExportJobWarning = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), Message: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleExportJobWarning",
}) as any as S.Schema<AssetBundleExportJobWarning>;
export type AssetBundleExportJobWarningList = AssetBundleExportJobWarning[];
export const AssetBundleExportJobWarningList = S.Array(
  AssetBundleExportJobWarning,
);
export interface AssetBundleImportJobError {
  Arn?: string;
  Type?: string;
  Message?: string;
}
export const AssetBundleImportJobError = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Type: S.optional(S.String),
    Message: S.optional(S.String),
  }),
).annotations({
  identifier: "AssetBundleImportJobError",
}) as any as S.Schema<AssetBundleImportJobError>;
export type AssetBundleImportJobErrorList = AssetBundleImportJobError[];
export const AssetBundleImportJobErrorList = S.Array(AssetBundleImportJobError);
export interface AssetBundleImportSourceDescription {
  Body?: string | redacted.Redacted<string>;
  S3Uri?: string;
}
export const AssetBundleImportSourceDescription = S.suspend(() =>
  S.Struct({ Body: S.optional(SensitiveString), S3Uri: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleImportSourceDescription",
}) as any as S.Schema<AssetBundleImportSourceDescription>;
export interface AssetBundleImportJobWarning {
  Arn?: string;
  Message?: string;
}
export const AssetBundleImportJobWarning = S.suspend(() =>
  S.Struct({ Arn: S.optional(S.String), Message: S.optional(S.String) }),
).annotations({
  identifier: "AssetBundleImportJobWarning",
}) as any as S.Schema<AssetBundleImportJobWarning>;
export type AssetBundleImportJobWarningList = AssetBundleImportJobWarning[];
export const AssetBundleImportJobWarningList = S.Array(
  AssetBundleImportJobWarning,
);
export interface Entity {
  Path?: string;
}
export const Entity = S.suspend(() =>
  S.Struct({ Path: S.optional(S.String) }),
).annotations({ identifier: "Entity" }) as any as S.Schema<Entity>;
export type EntityList = Entity[];
export const EntityList = S.Array(Entity);
export interface DashboardError {
  Type?: DashboardErrorType;
  Message?: string;
  ViolatedEntities?: Entity[];
}
export const DashboardError = S.suspend(() =>
  S.Struct({
    Type: S.optional(DashboardErrorType),
    Message: S.optional(S.String),
    ViolatedEntities: S.optional(EntityList),
  }),
).annotations({
  identifier: "DashboardError",
}) as any as S.Schema<DashboardError>;
export type DashboardErrorList = DashboardError[];
export const DashboardErrorList = S.Array(DashboardError);
export interface SnapshotJobErrorInfo {
  ErrorMessage?: string;
  ErrorType?: string;
}
export const SnapshotJobErrorInfo = S.suspend(() =>
  S.Struct({
    ErrorMessage: S.optional(S.String),
    ErrorType: S.optional(S.String),
  }),
).annotations({
  identifier: "SnapshotJobErrorInfo",
}) as any as S.Schema<SnapshotJobErrorInfo>;
export interface Folder {
  FolderId?: string;
  Arn?: string;
  Name?: string;
  FolderType?: FolderType;
  FolderPath?: string[];
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  SharingModel?: SharingModel;
}
export const Folder = S.suspend(() =>
  S.Struct({
    FolderId: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    FolderType: S.optional(FolderType),
    FolderPath: S.optional(Path),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SharingModel: S.optional(SharingModel),
  }),
).annotations({ identifier: "Folder" }) as any as S.Schema<Folder>;
export interface IAMPolicyAssignment {
  AwsAccountId?: string;
  AssignmentId?: string;
  AssignmentName?: string;
  PolicyArn?: string;
  Identities?: { [key: string]: string[] };
  AssignmentStatus?: AssignmentStatus;
}
export const IAMPolicyAssignment = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.optional(S.String),
    AssignmentId: S.optional(S.String),
    AssignmentName: S.optional(S.String),
    PolicyArn: S.optional(S.String),
    Identities: S.optional(IdentityMap),
    AssignmentStatus: S.optional(AssignmentStatus),
  }),
).annotations({
  identifier: "IAMPolicyAssignment",
}) as any as S.Schema<IAMPolicyAssignment>;
export interface QDataKey {
  QDataKeyArn?: string;
  QDataKeyType?: QDataKeyType;
}
export const QDataKey = S.suspend(() =>
  S.Struct({
    QDataKeyArn: S.optional(S.String),
    QDataKeyType: S.optional(QDataKeyType),
  }),
).annotations({ identifier: "QDataKey" }) as any as S.Schema<QDataKey>;
export interface SelfUpgradeConfiguration {
  SelfUpgradeStatus?: SelfUpgradeStatus;
}
export const SelfUpgradeConfiguration = S.suspend(() =>
  S.Struct({ SelfUpgradeStatus: S.optional(SelfUpgradeStatus) }),
).annotations({
  identifier: "SelfUpgradeConfiguration",
}) as any as S.Schema<SelfUpgradeConfiguration>;
export interface TemplateError {
  Type?: TemplateErrorType;
  Message?: string;
  ViolatedEntities?: Entity[];
}
export const TemplateError = S.suspend(() =>
  S.Struct({
    Type: S.optional(TemplateErrorType),
    Message: S.optional(S.String),
    ViolatedEntities: S.optional(EntityList),
  }),
).annotations({
  identifier: "TemplateError",
}) as any as S.Schema<TemplateError>;
export type TemplateErrorList = TemplateError[];
export const TemplateErrorList = S.Array(TemplateError);
export interface TopicRefreshDetails {
  RefreshArn?: string;
  RefreshId?: string;
  RefreshStatus?: TopicRefreshStatus;
}
export const TopicRefreshDetails = S.suspend(() =>
  S.Struct({
    RefreshArn: S.optional(S.String),
    RefreshId: S.optional(S.String),
    RefreshStatus: S.optional(TopicRefreshStatus),
  }),
).annotations({
  identifier: "TopicRefreshDetails",
}) as any as S.Schema<TopicRefreshDetails>;
export type ActionConnectorErrorType = "INTERNAL_FAILURE";
export const ActionConnectorErrorType = S.Literal("INTERNAL_FAILURE");
export interface ActionConnectorError {
  Message?: string;
  Type?: ActionConnectorErrorType;
}
export const ActionConnectorError = S.suspend(() =>
  S.Struct({
    Message: S.optional(S.String),
    Type: S.optional(ActionConnectorErrorType),
  }),
).annotations({
  identifier: "ActionConnectorError",
}) as any as S.Schema<ActionConnectorError>;
export interface ActionConnectorSummary {
  Arn: string;
  ActionConnectorId: string;
  Type: ActionConnectorType;
  Name: string | redacted.Redacted<string>;
  CreatedTime?: Date;
  LastUpdatedTime: Date;
  Status?: ResourceStatus;
  Error?: ActionConnectorError;
}
export const ActionConnectorSummary = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    ActionConnectorId: S.String,
    Type: ActionConnectorType,
    Name: SensitiveString,
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Status: S.optional(ResourceStatus),
    Error: S.optional(ActionConnectorError),
  }),
).annotations({
  identifier: "ActionConnectorSummary",
}) as any as S.Schema<ActionConnectorSummary>;
export type ActionConnectorSummaryList = ActionConnectorSummary[];
export const ActionConnectorSummaryList = S.Array(ActionConnectorSummary);
export interface AnalysisSummary {
  Arn?: string;
  AnalysisId?: string;
  Name?: string;
  Status?: ResourceStatus;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
}
export const AnalysisSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AnalysisId: S.optional(S.String),
    Name: S.optional(S.String),
    Status: S.optional(ResourceStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "AnalysisSummary",
}) as any as S.Schema<AnalysisSummary>;
export type AnalysisSummaryList = AnalysisSummary[];
export const AnalysisSummaryList = S.Array(AnalysisSummary);
export interface AssetBundleExportJobSummary {
  JobStatus?: AssetBundleExportJobStatus;
  Arn?: string;
  CreatedTime?: Date;
  AssetBundleExportJobId?: string;
  IncludeAllDependencies?: boolean;
  ExportFormat?: AssetBundleExportFormat;
  IncludePermissions?: boolean;
  IncludeTags?: boolean;
}
export const AssetBundleExportJobSummary = S.suspend(() =>
  S.Struct({
    JobStatus: S.optional(AssetBundleExportJobStatus),
    Arn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    AssetBundleExportJobId: S.optional(S.String),
    IncludeAllDependencies: S.optional(S.Boolean),
    ExportFormat: S.optional(AssetBundleExportFormat),
    IncludePermissions: S.optional(S.Boolean),
    IncludeTags: S.optional(S.Boolean),
  }),
).annotations({
  identifier: "AssetBundleExportJobSummary",
}) as any as S.Schema<AssetBundleExportJobSummary>;
export type AssetBundleExportJobSummaryList = AssetBundleExportJobSummary[];
export const AssetBundleExportJobSummaryList = S.Array(
  AssetBundleExportJobSummary,
);
export interface AssetBundleImportJobSummary {
  JobStatus?: AssetBundleImportJobStatus;
  Arn?: string;
  CreatedTime?: Date;
  AssetBundleImportJobId?: string;
  FailureAction?: AssetBundleImportFailureAction;
}
export const AssetBundleImportJobSummary = S.suspend(() =>
  S.Struct({
    JobStatus: S.optional(AssetBundleImportJobStatus),
    Arn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    AssetBundleImportJobId: S.optional(S.String),
    FailureAction: S.optional(AssetBundleImportFailureAction),
  }),
).annotations({
  identifier: "AssetBundleImportJobSummary",
}) as any as S.Schema<AssetBundleImportJobSummary>;
export type AssetBundleImportJobSummaryList = AssetBundleImportJobSummary[];
export const AssetBundleImportJobSummaryList = S.Array(
  AssetBundleImportJobSummary,
);
export interface BrandSummary {
  Arn?: string;
  BrandId?: string;
  BrandName?: string;
  Description?: string;
  BrandStatus?: BrandStatus;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
}
export const BrandSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    BrandId: S.optional(S.String),
    BrandName: S.optional(S.String),
    Description: S.optional(S.String),
    BrandStatus: S.optional(BrandStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({ identifier: "BrandSummary" }) as any as S.Schema<BrandSummary>;
export type BrandSummaryList = BrandSummary[];
export const BrandSummaryList = S.Array(BrandSummary);
export interface DashboardSummary {
  Arn?: string;
  DashboardId?: string;
  Name?: string;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  PublishedVersionNumber?: number;
  LastPublishedTime?: Date;
}
export const DashboardSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DashboardId: S.optional(S.String),
    Name: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    PublishedVersionNumber: S.optional(S.Number),
    LastPublishedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "DashboardSummary",
}) as any as S.Schema<DashboardSummary>;
export type DashboardSummaryList = DashboardSummary[];
export const DashboardSummaryList = S.Array(DashboardSummary);
export interface DashboardVersionSummary {
  Arn?: string;
  CreatedTime?: Date;
  VersionNumber?: number;
  Status?: ResourceStatus;
  SourceEntityArn?: string;
  Description?: string;
}
export const DashboardVersionSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    VersionNumber: S.optional(S.Number),
    Status: S.optional(ResourceStatus),
    SourceEntityArn: S.optional(S.String),
    Description: S.optional(S.String),
  }),
).annotations({
  identifier: "DashboardVersionSummary",
}) as any as S.Schema<DashboardVersionSummary>;
export type DashboardVersionSummaryList = DashboardVersionSummary[];
export const DashboardVersionSummaryList = S.Array(DashboardVersionSummary);
export interface FlowSummary {
  Arn: string;
  FlowId: string;
  Name: string;
  Description?: string;
  CreatedTime: Date;
  CreatedBy?: string;
  LastUpdatedTime?: Date;
  LastUpdatedBy?: string;
  PublishState?: FlowPublishState;
  RunCount?: number;
  UserCount?: number;
  LastPublishedBy?: string;
  LastPublishedAt?: Date;
}
export const FlowSummary = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    FlowId: S.String,
    Name: S.String,
    Description: S.optional(S.String),
    CreatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    CreatedBy: S.optional(S.String),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastUpdatedBy: S.optional(S.String),
    PublishState: S.optional(FlowPublishState),
    RunCount: S.optional(S.Number),
    UserCount: S.optional(S.Number),
    LastPublishedBy: S.optional(S.String),
    LastPublishedAt: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({ identifier: "FlowSummary" }) as any as S.Schema<FlowSummary>;
export type FlowSummaryList = FlowSummary[];
export const FlowSummaryList = S.Array(FlowSummary);
export interface MemberIdArnPair {
  MemberId?: string;
  MemberArn?: string;
}
export const MemberIdArnPair = S.suspend(() =>
  S.Struct({ MemberId: S.optional(S.String), MemberArn: S.optional(S.String) }),
).annotations({
  identifier: "MemberIdArnPair",
}) as any as S.Schema<MemberIdArnPair>;
export type FolderMemberList = MemberIdArnPair[];
export const FolderMemberList = S.Array(MemberIdArnPair);
export interface FolderSummary {
  Arn?: string;
  FolderId?: string;
  Name?: string;
  FolderType?: FolderType;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  SharingModel?: SharingModel;
}
export const FolderSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    FolderId: S.optional(S.String),
    Name: S.optional(S.String),
    FolderType: S.optional(FolderType),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    SharingModel: S.optional(SharingModel),
  }),
).annotations({
  identifier: "FolderSummary",
}) as any as S.Schema<FolderSummary>;
export type FolderSummaryList = FolderSummary[];
export const FolderSummaryList = S.Array(FolderSummary);
export interface IAMPolicyAssignmentSummary {
  AssignmentName?: string;
  AssignmentStatus?: AssignmentStatus;
}
export const IAMPolicyAssignmentSummary = S.suspend(() =>
  S.Struct({
    AssignmentName: S.optional(S.String),
    AssignmentStatus: S.optional(AssignmentStatus),
  }),
).annotations({
  identifier: "IAMPolicyAssignmentSummary",
}) as any as S.Schema<IAMPolicyAssignmentSummary>;
export type IAMPolicyAssignmentSummaryList = IAMPolicyAssignmentSummary[];
export const IAMPolicyAssignmentSummaryList = S.Array(
  IAMPolicyAssignmentSummary,
);
export interface ActiveIAMPolicyAssignment {
  AssignmentName?: string;
  PolicyArn?: string;
}
export const ActiveIAMPolicyAssignment = S.suspend(() =>
  S.Struct({
    AssignmentName: S.optional(S.String),
    PolicyArn: S.optional(S.String),
  }),
).annotations({
  identifier: "ActiveIAMPolicyAssignment",
}) as any as S.Schema<ActiveIAMPolicyAssignment>;
export type ActiveIAMPolicyAssignmentList = ActiveIAMPolicyAssignment[];
export const ActiveIAMPolicyAssignmentList = S.Array(ActiveIAMPolicyAssignment);
export interface AuthorizedTargetsByService {
  Service?: ServiceType;
  AuthorizedTargets?: string[];
}
export const AuthorizedTargetsByService = S.suspend(() =>
  S.Struct({
    Service: S.optional(ServiceType),
    AuthorizedTargets: S.optional(AuthorizedTargetsList),
  }),
).annotations({
  identifier: "AuthorizedTargetsByService",
}) as any as S.Schema<AuthorizedTargetsByService>;
export type AuthorizedTargetsByServices = AuthorizedTargetsByService[];
export const AuthorizedTargetsByServices = S.Array(AuthorizedTargetsByService);
export type SelfUpgradeRequestDetailList = SelfUpgradeRequestDetail[];
export const SelfUpgradeRequestDetailList = S.Array(SelfUpgradeRequestDetail);
export interface TemplateSummary {
  Arn?: string;
  TemplateId?: string;
  Name?: string;
  LatestVersionNumber?: number;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
}
export const TemplateSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    TemplateId: S.optional(S.String),
    Name: S.optional(S.String),
    LatestVersionNumber: S.optional(S.Number),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "TemplateSummary",
}) as any as S.Schema<TemplateSummary>;
export type TemplateSummaryList = TemplateSummary[];
export const TemplateSummaryList = S.Array(TemplateSummary);
export interface TemplateVersionSummary {
  Arn?: string;
  VersionNumber?: number;
  CreatedTime?: Date;
  Status?: ResourceStatus;
  Description?: string;
}
export const TemplateVersionSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionNumber: S.optional(S.Number),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(ResourceStatus),
    Description: S.optional(S.String),
  }),
).annotations({
  identifier: "TemplateVersionSummary",
}) as any as S.Schema<TemplateVersionSummary>;
export type TemplateVersionSummaryList = TemplateVersionSummary[];
export const TemplateVersionSummaryList = S.Array(TemplateVersionSummary);
export interface ThemeSummary {
  Arn?: string;
  Name?: string;
  ThemeId?: string;
  LatestVersionNumber?: number;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
}
export const ThemeSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    ThemeId: S.optional(S.String),
    LatestVersionNumber: S.optional(S.Number),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({ identifier: "ThemeSummary" }) as any as S.Schema<ThemeSummary>;
export type ThemeSummaryList = ThemeSummary[];
export const ThemeSummaryList = S.Array(ThemeSummary);
export interface ThemeVersionSummary {
  VersionNumber?: number;
  Arn?: string;
  Description?: string;
  CreatedTime?: Date;
  Status?: ResourceStatus;
}
export const ThemeVersionSummary = S.suspend(() =>
  S.Struct({
    VersionNumber: S.optional(S.Number),
    Arn: S.optional(S.String),
    Description: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Status: S.optional(ResourceStatus),
  }),
).annotations({
  identifier: "ThemeVersionSummary",
}) as any as S.Schema<ThemeVersionSummary>;
export type ThemeVersionSummaryList = ThemeVersionSummary[];
export const ThemeVersionSummaryList = S.Array(ThemeVersionSummary);
export interface TopicRefreshScheduleSummary {
  DatasetId?: string;
  DatasetArn?: string;
  DatasetName?: string;
  RefreshSchedule?: TopicRefreshSchedule;
}
export const TopicRefreshScheduleSummary = S.suspend(() =>
  S.Struct({
    DatasetId: S.optional(S.String),
    DatasetArn: S.optional(S.String),
    DatasetName: S.optional(S.String),
    RefreshSchedule: S.optional(TopicRefreshSchedule),
  }),
).annotations({
  identifier: "TopicRefreshScheduleSummary",
}) as any as S.Schema<TopicRefreshScheduleSummary>;
export type TopicRefreshScheduleSummaries = TopicRefreshScheduleSummary[];
export const TopicRefreshScheduleSummaries = S.Array(
  TopicRefreshScheduleSummary,
);
export interface Slot {
  SlotId?: string;
  VisualId?: string;
}
export const Slot = S.suspend(() =>
  S.Struct({ SlotId: S.optional(S.String), VisualId: S.optional(S.String) }),
).annotations({ identifier: "Slot" }) as any as S.Schema<Slot>;
export type Slots = Slot[];
export const Slots = S.Array(Slot);
export interface TopicTemplate {
  TemplateType?: string;
  Slots?: Slot[];
}
export const TopicTemplate = S.suspend(() =>
  S.Struct({ TemplateType: S.optional(S.String), Slots: S.optional(Slots) }),
).annotations({
  identifier: "TopicTemplate",
}) as any as S.Schema<TopicTemplate>;
export interface TopicReviewedAnswer {
  Arn?: string;
  AnswerId: string;
  DatasetArn: string;
  Question: string;
  Mir?: TopicIR;
  PrimaryVisual?: TopicVisual;
  Template?: TopicTemplate;
}
export const TopicReviewedAnswer = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AnswerId: S.String,
    DatasetArn: S.String,
    Question: S.String,
    Mir: S.optional(TopicIR),
    PrimaryVisual: S.optional(TopicVisual),
    Template: S.optional(TopicTemplate),
  }),
).annotations({
  identifier: "TopicReviewedAnswer",
}) as any as S.Schema<TopicReviewedAnswer>;
export type TopicReviewedAnswers = TopicReviewedAnswer[];
export const TopicReviewedAnswers = S.Array(TopicReviewedAnswer);
export interface TopicSummary {
  Arn?: string;
  TopicId?: string;
  Name?: string;
  UserExperienceVersion?: TopicUserExperienceVersion;
}
export const TopicSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    TopicId: S.optional(S.String),
    Name: S.optional(S.String),
    UserExperienceVersion: S.optional(TopicUserExperienceVersion),
  }),
).annotations({ identifier: "TopicSummary" }) as any as S.Schema<TopicSummary>;
export type TopicSummaries = TopicSummary[];
export const TopicSummaries = S.Array(TopicSummary);
export type NetworkInterfaceStatus =
  | "CREATING"
  | "AVAILABLE"
  | "CREATION_FAILED"
  | "UPDATING"
  | "UPDATE_FAILED"
  | "DELETING"
  | "DELETED"
  | "DELETION_FAILED"
  | "DELETION_SCHEDULED"
  | "ATTACHMENT_FAILED_ROLLBACK_FAILED";
export const NetworkInterfaceStatus = S.Literal(
  "CREATING",
  "AVAILABLE",
  "CREATION_FAILED",
  "UPDATING",
  "UPDATE_FAILED",
  "DELETING",
  "DELETED",
  "DELETION_FAILED",
  "DELETION_SCHEDULED",
  "ATTACHMENT_FAILED_ROLLBACK_FAILED",
);
export interface NetworkInterface {
  SubnetId?: string;
  AvailabilityZone?: string;
  ErrorMessage?: string;
  Status?: NetworkInterfaceStatus;
  NetworkInterfaceId?: string;
}
export const NetworkInterface = S.suspend(() =>
  S.Struct({
    SubnetId: S.optional(S.String),
    AvailabilityZone: S.optional(S.String),
    ErrorMessage: S.optional(S.String),
    Status: S.optional(NetworkInterfaceStatus),
    NetworkInterfaceId: S.optional(S.String),
  }),
).annotations({
  identifier: "NetworkInterface",
}) as any as S.Schema<NetworkInterface>;
export type NetworkInterfaceList = NetworkInterface[];
export const NetworkInterfaceList = S.Array(NetworkInterface);
export interface VPCConnectionSummary {
  VPCConnectionId?: string;
  Arn?: string;
  Name?: string;
  VPCId?: string;
  SecurityGroupIds?: string[];
  DnsResolvers?: string[];
  Status?: VPCConnectionResourceStatus;
  AvailabilityStatus?: VPCConnectionAvailabilityStatus;
  NetworkInterfaces?: NetworkInterface[];
  RoleArn?: string;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
}
export const VPCConnectionSummary = S.suspend(() =>
  S.Struct({
    VPCConnectionId: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    VPCId: S.optional(S.String),
    SecurityGroupIds: S.optional(SecurityGroupIdList),
    DnsResolvers: S.optional(StringList),
    Status: S.optional(VPCConnectionResourceStatus),
    AvailabilityStatus: S.optional(VPCConnectionAvailabilityStatus),
    NetworkInterfaces: S.optional(NetworkInterfaceList),
    RoleArn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "VPCConnectionSummary",
}) as any as S.Schema<VPCConnectionSummary>;
export type VPCConnectionSummaryList = VPCConnectionSummary[];
export const VPCConnectionSummaryList = S.Array(VPCConnectionSummary);
export interface AssetBundleCloudFormationOverridePropertyConfiguration {
  ResourceIdOverrideConfiguration?: AssetBundleExportJobResourceIdOverrideConfiguration;
  VPCConnections?: AssetBundleExportJobVPCConnectionOverrideProperties[];
  RefreshSchedules?: AssetBundleExportJobRefreshScheduleOverrideProperties[];
  DataSources?: AssetBundleExportJobDataSourceOverrideProperties[];
  DataSets?: AssetBundleExportJobDataSetOverrideProperties[];
  Themes?: AssetBundleExportJobThemeOverrideProperties[];
  Analyses?: AssetBundleExportJobAnalysisOverrideProperties[];
  Dashboards?: AssetBundleExportJobDashboardOverrideProperties[];
  Folders?: AssetBundleExportJobFolderOverrideProperties[];
}
export const AssetBundleCloudFormationOverridePropertyConfiguration = S.suspend(
  () =>
    S.Struct({
      ResourceIdOverrideConfiguration: S.optional(
        AssetBundleExportJobResourceIdOverrideConfiguration,
      ),
      VPCConnections: S.optional(
        AssetBundleExportJobVPCConnectionOverridePropertiesList,
      ),
      RefreshSchedules: S.optional(
        AssetBundleExportJobRefreshScheduleOverridePropertiesList,
      ),
      DataSources: S.optional(
        AssetBundleExportJobDataSourceOverridePropertiesList,
      ),
      DataSets: S.optional(AssetBundleExportJobDataSetOverridePropertiesList),
      Themes: S.optional(AssetBundleExportJobThemeOverridePropertiesList),
      Analyses: S.optional(AssetBundleExportJobAnalysisOverridePropertiesList),
      Dashboards: S.optional(
        AssetBundleExportJobDashboardOverridePropertiesList,
      ),
      Folders: S.optional(AssetBundleExportJobFolderOverridePropertiesList),
    }),
).annotations({
  identifier: "AssetBundleCloudFormationOverridePropertyConfiguration",
}) as any as S.Schema<AssetBundleCloudFormationOverridePropertyConfiguration>;
export interface AssetBundleImportJobOverrideTags {
  VPCConnections?: AssetBundleImportJobVPCConnectionOverrideTags[];
  DataSources?: AssetBundleImportJobDataSourceOverrideTags[];
  DataSets?: AssetBundleImportJobDataSetOverrideTags[];
  Themes?: AssetBundleImportJobThemeOverrideTags[];
  Analyses?: AssetBundleImportJobAnalysisOverrideTags[];
  Dashboards?: AssetBundleImportJobDashboardOverrideTags[];
  Folders?: AssetBundleImportJobFolderOverrideTags[];
}
export const AssetBundleImportJobOverrideTags = S.suspend(() =>
  S.Struct({
    VPCConnections: S.optional(
      AssetBundleImportJobVPCConnectionOverrideTagsList,
    ),
    DataSources: S.optional(AssetBundleImportJobDataSourceOverrideTagsList),
    DataSets: S.optional(AssetBundleImportJobDataSetOverrideTagsList),
    Themes: S.optional(AssetBundleImportJobThemeOverrideTagsList),
    Analyses: S.optional(AssetBundleImportJobAnalysisOverrideTagsList),
    Dashboards: S.optional(AssetBundleImportJobDashboardOverrideTagsList),
    Folders: S.optional(AssetBundleImportJobFolderOverrideTagsList),
  }),
).annotations({
  identifier: "AssetBundleImportJobOverrideTags",
}) as any as S.Schema<AssetBundleImportJobOverrideTags>;
export interface SnapshotUserConfiguration {
  AnonymousUsers?: SnapshotAnonymousUser[];
}
export const SnapshotUserConfiguration = S.suspend(() =>
  S.Struct({ AnonymousUsers: S.optional(SnapshotAnonymousUserList) }),
).annotations({
  identifier: "SnapshotUserConfiguration",
}) as any as S.Schema<SnapshotUserConfiguration>;
export type SessionTagKeyList = string[];
export const SessionTagKeyList = S.Array(S.String);
export interface AssetBundleResourceLinkSharingConfiguration {
  Permissions?: AssetBundleResourcePermissions;
}
export const AssetBundleResourceLinkSharingConfiguration = S.suspend(() =>
  S.Struct({ Permissions: S.optional(AssetBundleResourcePermissions) }),
).annotations({
  identifier: "AssetBundleResourceLinkSharingConfiguration",
}) as any as S.Schema<AssetBundleResourceLinkSharingConfiguration>;
export interface BatchDeleteTopicReviewedAnswerResponse {
  TopicId?: string;
  TopicArn?: string;
  SucceededAnswers?: SucceededTopicReviewedAnswer[];
  InvalidAnswers?: InvalidTopicReviewedAnswer[];
  RequestId?: string;
  Status?: number;
}
export const BatchDeleteTopicReviewedAnswerResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    SucceededAnswers: S.optional(SucceededTopicReviewedAnswers),
    InvalidAnswers: S.optional(InvalidTopicReviewedAnswers),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "BatchDeleteTopicReviewedAnswerResponse",
}) as any as S.Schema<BatchDeleteTopicReviewedAnswerResponse>;
export interface CreateAccountCustomizationResponse {
  Arn?: string;
  AwsAccountId?: string;
  Namespace?: string;
  AccountCustomization?: AccountCustomization;
  RequestId?: string;
  Status?: number;
}
export const CreateAccountCustomizationResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AwsAccountId: S.optional(S.String),
    Namespace: S.optional(S.String),
    AccountCustomization: S.optional(AccountCustomization),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateAccountCustomizationResponse",
}) as any as S.Schema<CreateAccountCustomizationResponse>;
export interface CreateAccountSubscriptionResponse {
  SignupResponse?: SignupResponse;
  Status?: number;
  RequestId?: string;
}
export const CreateAccountSubscriptionResponse = S.suspend(() =>
  S.Struct({
    SignupResponse: S.optional(SignupResponse),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateAccountSubscriptionResponse",
}) as any as S.Schema<CreateAccountSubscriptionResponse>;
export interface CreateCustomPermissionsResponse {
  Status?: number;
  Arn?: string;
  RequestId?: string;
}
export const CreateCustomPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number),
    Arn: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateCustomPermissionsResponse",
}) as any as S.Schema<CreateCustomPermissionsResponse>;
export interface CreateFolderMembershipResponse {
  Status?: number;
  FolderMember?: FolderMember;
  RequestId?: string;
}
export const CreateFolderMembershipResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number),
    FolderMember: S.optional(FolderMember),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateFolderMembershipResponse",
}) as any as S.Schema<CreateFolderMembershipResponse>;
export interface CreateGroupResponse {
  Group?: Group;
  RequestId?: string;
  Status?: number;
}
export const CreateGroupResponse = S.suspend(() =>
  S.Struct({
    Group: S.optional(Group),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateGroupResponse",
}) as any as S.Schema<CreateGroupResponse>;
export interface CreateGroupMembershipResponse {
  GroupMember?: GroupMember;
  RequestId?: string;
  Status?: number;
}
export const CreateGroupMembershipResponse = S.suspend(() =>
  S.Struct({
    GroupMember: S.optional(GroupMember),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateGroupMembershipResponse",
}) as any as S.Schema<CreateGroupMembershipResponse>;
export interface CreateIAMPolicyAssignmentResponse {
  AssignmentName?: string;
  AssignmentId?: string;
  AssignmentStatus?: AssignmentStatus;
  PolicyArn?: string;
  Identities?: { [key: string]: string[] };
  RequestId?: string;
  Status?: number;
}
export const CreateIAMPolicyAssignmentResponse = S.suspend(() =>
  S.Struct({
    AssignmentName: S.optional(S.String),
    AssignmentId: S.optional(S.String),
    AssignmentStatus: S.optional(AssignmentStatus),
    PolicyArn: S.optional(S.String),
    Identities: S.optional(IdentityMap),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateIAMPolicyAssignmentResponse",
}) as any as S.Schema<CreateIAMPolicyAssignmentResponse>;
export interface CreateTemplateAliasResponse {
  TemplateAlias?: TemplateAlias;
  Status?: number;
  RequestId?: string;
}
export const CreateTemplateAliasResponse = S.suspend(() =>
  S.Struct({
    TemplateAlias: S.optional(TemplateAlias),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateTemplateAliasResponse",
}) as any as S.Schema<CreateTemplateAliasResponse>;
export interface CreateThemeAliasResponse {
  ThemeAlias?: ThemeAlias;
  Status?: number;
  RequestId?: string;
}
export const CreateThemeAliasResponse = S.suspend(() =>
  S.Struct({
    ThemeAlias: S.optional(ThemeAlias),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateThemeAliasResponse",
}) as any as S.Schema<CreateThemeAliasResponse>;
export interface CreateTopicRefreshScheduleResponse {
  TopicId?: string;
  TopicArn?: string;
  DatasetArn?: string;
  Status?: number;
  RequestId?: string;
}
export const CreateTopicRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    DatasetArn: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateTopicRefreshScheduleResponse",
}) as any as S.Schema<CreateTopicRefreshScheduleResponse>;
export interface DescribeAccountSettingsResponse {
  AccountSettings?: AccountSettings;
  RequestId?: string;
  Status?: number;
}
export const DescribeAccountSettingsResponse = S.suspend(() =>
  S.Struct({
    AccountSettings: S.optional(AccountSettings),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeAccountSettingsResponse",
}) as any as S.Schema<DescribeAccountSettingsResponse>;
export interface DescribeAccountSubscriptionResponse {
  AccountInfo?: AccountInfo;
  Status?: number;
  RequestId?: string;
}
export const DescribeAccountSubscriptionResponse = S.suspend(() =>
  S.Struct({
    AccountInfo: S.optional(AccountInfo),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeAccountSubscriptionResponse",
}) as any as S.Schema<DescribeAccountSubscriptionResponse>;
export interface DescribeAssetBundleExportJobResponse {
  JobStatus?: AssetBundleExportJobStatus;
  DownloadUrl?: string | redacted.Redacted<string>;
  Errors?: AssetBundleExportJobError[];
  Arn?: string;
  CreatedTime?: Date;
  AssetBundleExportJobId?: string;
  AwsAccountId?: string;
  ResourceArns?: string[];
  IncludeAllDependencies?: boolean;
  ExportFormat?: AssetBundleExportFormat;
  CloudFormationOverridePropertyConfiguration?: AssetBundleCloudFormationOverridePropertyConfiguration;
  RequestId?: string;
  Status?: number;
  IncludePermissions?: boolean;
  IncludeTags?: boolean;
  ValidationStrategy?: AssetBundleExportJobValidationStrategy;
  Warnings?: AssetBundleExportJobWarning[];
  IncludeFolderMemberships?: boolean;
  IncludeFolderMembers?: IncludeFolderMembers;
}
export const DescribeAssetBundleExportJobResponse = S.suspend(() =>
  S.Struct({
    JobStatus: S.optional(AssetBundleExportJobStatus),
    DownloadUrl: S.optional(SensitiveString),
    Errors: S.optional(AssetBundleExportJobErrorList),
    Arn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    AssetBundleExportJobId: S.optional(S.String),
    AwsAccountId: S.optional(S.String),
    ResourceArns: S.optional(AssetBundleResourceArns),
    IncludeAllDependencies: S.optional(S.Boolean),
    ExportFormat: S.optional(AssetBundleExportFormat),
    CloudFormationOverridePropertyConfiguration: S.optional(
      AssetBundleCloudFormationOverridePropertyConfiguration,
    ),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    IncludePermissions: S.optional(S.Boolean),
    IncludeTags: S.optional(S.Boolean),
    ValidationStrategy: S.optional(AssetBundleExportJobValidationStrategy),
    Warnings: S.optional(AssetBundleExportJobWarningList),
    IncludeFolderMemberships: S.optional(S.Boolean),
    IncludeFolderMembers: S.optional(IncludeFolderMembers),
  }),
).annotations({
  identifier: "DescribeAssetBundleExportJobResponse",
}) as any as S.Schema<DescribeAssetBundleExportJobResponse>;
export interface AssetBundleImportJobDataSourceCredentialPair {
  Username: string;
  Password: string;
}
export const AssetBundleImportJobDataSourceCredentialPair = S.suspend(() =>
  S.Struct({ Username: S.String, Password: S.String }),
).annotations({
  identifier: "AssetBundleImportJobDataSourceCredentialPair",
}) as any as S.Schema<AssetBundleImportJobDataSourceCredentialPair>;
export interface AssetBundleImportJobDataSourceCredentials {
  CredentialPair?: AssetBundleImportJobDataSourceCredentialPair;
  SecretArn?: string;
}
export const AssetBundleImportJobDataSourceCredentials = S.suspend(() =>
  S.Struct({
    CredentialPair: S.optional(AssetBundleImportJobDataSourceCredentialPair),
    SecretArn: S.optional(S.String),
  }),
).annotations({
  identifier: "AssetBundleImportJobDataSourceCredentials",
}) as any as S.Schema<AssetBundleImportJobDataSourceCredentials>;
export interface AssetBundleImportJobDataSourceOverrideParameters {
  DataSourceId: string;
  Name?: string;
  DataSourceParameters?: DataSourceParameters;
  VpcConnectionProperties?: VpcConnectionProperties;
  SslProperties?: SslProperties;
  Credentials?: AssetBundleImportJobDataSourceCredentials;
}
export const AssetBundleImportJobDataSourceOverrideParameters = S.suspend(() =>
  S.Struct({
    DataSourceId: S.String,
    Name: S.optional(S.String),
    DataSourceParameters: S.optional(DataSourceParameters),
    VpcConnectionProperties: S.optional(VpcConnectionProperties),
    SslProperties: S.optional(SslProperties),
    Credentials: S.optional(AssetBundleImportJobDataSourceCredentials),
  }),
).annotations({
  identifier: "AssetBundleImportJobDataSourceOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobDataSourceOverrideParameters>;
export type AssetBundleImportJobDataSourceOverrideParametersList =
  AssetBundleImportJobDataSourceOverrideParameters[];
export const AssetBundleImportJobDataSourceOverrideParametersList = S.Array(
  AssetBundleImportJobDataSourceOverrideParameters,
);
export interface AssetBundleImportJobOverrideParameters {
  ResourceIdOverrideConfiguration?: AssetBundleImportJobResourceIdOverrideConfiguration;
  VPCConnections?: AssetBundleImportJobVPCConnectionOverrideParameters[];
  RefreshSchedules?: AssetBundleImportJobRefreshScheduleOverrideParameters[];
  DataSources?: AssetBundleImportJobDataSourceOverrideParameters[];
  DataSets?: AssetBundleImportJobDataSetOverrideParameters[];
  Themes?: AssetBundleImportJobThemeOverrideParameters[];
  Analyses?: AssetBundleImportJobAnalysisOverrideParameters[];
  Dashboards?: AssetBundleImportJobDashboardOverrideParameters[];
  Folders?: AssetBundleImportJobFolderOverrideParameters[];
}
export const AssetBundleImportJobOverrideParameters = S.suspend(() =>
  S.Struct({
    ResourceIdOverrideConfiguration: S.optional(
      AssetBundleImportJobResourceIdOverrideConfiguration,
    ),
    VPCConnections: S.optional(
      AssetBundleImportJobVPCConnectionOverrideParametersList,
    ),
    RefreshSchedules: S.optional(
      AssetBundleImportJobRefreshScheduleOverrideParametersList,
    ),
    DataSources: S.optional(
      AssetBundleImportJobDataSourceOverrideParametersList,
    ),
    DataSets: S.optional(AssetBundleImportJobDataSetOverrideParametersList),
    Themes: S.optional(AssetBundleImportJobThemeOverrideParametersList),
    Analyses: S.optional(AssetBundleImportJobAnalysisOverrideParametersList),
    Dashboards: S.optional(AssetBundleImportJobDashboardOverrideParametersList),
    Folders: S.optional(AssetBundleImportJobFolderOverrideParametersList),
  }),
).annotations({
  identifier: "AssetBundleImportJobOverrideParameters",
}) as any as S.Schema<AssetBundleImportJobOverrideParameters>;
export interface AssetBundleImportJobDataSourceOverridePermissions {
  DataSourceIds: string[];
  Permissions: AssetBundleResourcePermissions;
}
export const AssetBundleImportJobDataSourceOverridePermissions = S.suspend(() =>
  S.Struct({
    DataSourceIds: AssetBundleRestrictiveResourceIdList,
    Permissions: AssetBundleResourcePermissions,
  }),
).annotations({
  identifier: "AssetBundleImportJobDataSourceOverridePermissions",
}) as any as S.Schema<AssetBundleImportJobDataSourceOverridePermissions>;
export type AssetBundleImportJobDataSourceOverridePermissionsList =
  AssetBundleImportJobDataSourceOverridePermissions[];
export const AssetBundleImportJobDataSourceOverridePermissionsList = S.Array(
  AssetBundleImportJobDataSourceOverridePermissions,
);
export interface AssetBundleImportJobDashboardOverridePermissions {
  DashboardIds: string[];
  Permissions?: AssetBundleResourcePermissions;
  LinkSharingConfiguration?: AssetBundleResourceLinkSharingConfiguration;
}
export const AssetBundleImportJobDashboardOverridePermissions = S.suspend(() =>
  S.Struct({
    DashboardIds: AssetBundleRestrictiveResourceIdList,
    Permissions: S.optional(AssetBundleResourcePermissions),
    LinkSharingConfiguration: S.optional(
      AssetBundleResourceLinkSharingConfiguration,
    ),
  }),
).annotations({
  identifier: "AssetBundleImportJobDashboardOverridePermissions",
}) as any as S.Schema<AssetBundleImportJobDashboardOverridePermissions>;
export type AssetBundleImportJobDashboardOverridePermissionsList =
  AssetBundleImportJobDashboardOverridePermissions[];
export const AssetBundleImportJobDashboardOverridePermissionsList = S.Array(
  AssetBundleImportJobDashboardOverridePermissions,
);
export interface AssetBundleImportJobOverridePermissions {
  DataSources?: AssetBundleImportJobDataSourceOverridePermissions[];
  DataSets?: AssetBundleImportJobDataSetOverridePermissions[];
  Themes?: AssetBundleImportJobThemeOverridePermissions[];
  Analyses?: AssetBundleImportJobAnalysisOverridePermissions[];
  Dashboards?: AssetBundleImportJobDashboardOverridePermissions[];
  Folders?: AssetBundleImportJobFolderOverridePermissions[];
}
export const AssetBundleImportJobOverridePermissions = S.suspend(() =>
  S.Struct({
    DataSources: S.optional(
      AssetBundleImportJobDataSourceOverridePermissionsList,
    ),
    DataSets: S.optional(AssetBundleImportJobDataSetOverridePermissionsList),
    Themes: S.optional(AssetBundleImportJobThemeOverridePermissionsList),
    Analyses: S.optional(AssetBundleImportJobAnalysisOverridePermissionsList),
    Dashboards: S.optional(
      AssetBundleImportJobDashboardOverridePermissionsList,
    ),
    Folders: S.optional(AssetBundleImportJobFolderOverridePermissionsList),
  }),
).annotations({
  identifier: "AssetBundleImportJobOverridePermissions",
}) as any as S.Schema<AssetBundleImportJobOverridePermissions>;
export interface DescribeAssetBundleImportJobResponse {
  JobStatus?: AssetBundleImportJobStatus;
  Errors?: AssetBundleImportJobError[];
  RollbackErrors?: AssetBundleImportJobError[];
  Arn?: string;
  CreatedTime?: Date;
  AssetBundleImportJobId?: string;
  AwsAccountId?: string;
  AssetBundleImportSource?: AssetBundleImportSourceDescription;
  OverrideParameters?: AssetBundleImportJobOverrideParameters;
  FailureAction?: AssetBundleImportFailureAction;
  RequestId?: string;
  Status?: number;
  OverridePermissions?: AssetBundleImportJobOverridePermissions;
  OverrideTags?: AssetBundleImportJobOverrideTags;
  OverrideValidationStrategy?: AssetBundleImportJobOverrideValidationStrategy;
  Warnings?: AssetBundleImportJobWarning[];
}
export const DescribeAssetBundleImportJobResponse = S.suspend(() =>
  S.Struct({
    JobStatus: S.optional(AssetBundleImportJobStatus),
    Errors: S.optional(AssetBundleImportJobErrorList),
    RollbackErrors: S.optional(AssetBundleImportJobErrorList),
    Arn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    AssetBundleImportJobId: S.optional(S.String),
    AwsAccountId: S.optional(S.String),
    AssetBundleImportSource: S.optional(AssetBundleImportSourceDescription),
    OverrideParameters: S.optional(AssetBundleImportJobOverrideParameters),
    FailureAction: S.optional(AssetBundleImportFailureAction),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    OverridePermissions: S.optional(AssetBundleImportJobOverridePermissions),
    OverrideTags: S.optional(AssetBundleImportJobOverrideTags),
    OverrideValidationStrategy: S.optional(
      AssetBundleImportJobOverrideValidationStrategy,
    ),
    Warnings: S.optional(AssetBundleImportJobWarningList),
  }),
).annotations({
  identifier: "DescribeAssetBundleImportJobResponse",
}) as any as S.Schema<DescribeAssetBundleImportJobResponse>;
export interface DescribeCustomPermissionsResponse {
  Status?: number;
  CustomPermissions?: CustomPermissions;
  RequestId?: string;
}
export const DescribeCustomPermissionsResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number),
    CustomPermissions: S.optional(CustomPermissions),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeCustomPermissionsResponse",
}) as any as S.Schema<DescribeCustomPermissionsResponse>;
export interface DescribeDashboardDefinitionResponse {
  DashboardId?: string;
  Errors?: DashboardError[];
  Name?: string;
  ResourceStatus?: ResourceStatus;
  ThemeArn?: string;
  Definition?: DashboardVersionDefinition;
  Status?: number;
  RequestId?: string;
  DashboardPublishOptions?: DashboardPublishOptions;
}
export const DescribeDashboardDefinitionResponse = S.suspend(() =>
  S.Struct({
    DashboardId: S.optional(S.String),
    Errors: S.optional(DashboardErrorList),
    Name: S.optional(S.String),
    ResourceStatus: S.optional(ResourceStatus),
    ThemeArn: S.optional(S.String),
    Definition: S.optional(DashboardVersionDefinition),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    DashboardPublishOptions: S.optional(DashboardPublishOptions),
  }),
).annotations({
  identifier: "DescribeDashboardDefinitionResponse",
}) as any as S.Schema<DescribeDashboardDefinitionResponse>;
export interface DescribeFolderResponse {
  Status?: number;
  Folder?: Folder;
  RequestId?: string;
}
export const DescribeFolderResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Folder: S.optional(Folder),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeFolderResponse",
}) as any as S.Schema<DescribeFolderResponse>;
export interface DescribeIAMPolicyAssignmentResponse {
  IAMPolicyAssignment?: IAMPolicyAssignment;
  RequestId?: string;
  Status?: number;
}
export const DescribeIAMPolicyAssignmentResponse = S.suspend(() =>
  S.Struct({
    IAMPolicyAssignment: S.optional(IAMPolicyAssignment),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeIAMPolicyAssignmentResponse",
}) as any as S.Schema<DescribeIAMPolicyAssignmentResponse>;
export interface DescribeKeyRegistrationResponse {
  AwsAccountId?: string;
  KeyRegistration?: RegisteredCustomerManagedKey[];
  QDataKey?: QDataKey;
  RequestId?: string;
  Status?: number;
}
export const DescribeKeyRegistrationResponse = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.optional(S.String),
    KeyRegistration: S.optional(KeyRegistration),
    QDataKey: S.optional(QDataKey),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number),
  }),
).annotations({
  identifier: "DescribeKeyRegistrationResponse",
}) as any as S.Schema<DescribeKeyRegistrationResponse>;
export interface DescribeSelfUpgradeConfigurationResponse {
  SelfUpgradeConfiguration?: SelfUpgradeConfiguration;
  RequestId?: string;
  Status?: number;
}
export const DescribeSelfUpgradeConfigurationResponse = S.suspend(() =>
  S.Struct({
    SelfUpgradeConfiguration: S.optional(SelfUpgradeConfiguration),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeSelfUpgradeConfigurationResponse",
}) as any as S.Schema<DescribeSelfUpgradeConfigurationResponse>;
export interface DescribeTemplateDefinitionResponse {
  Name?: string;
  TemplateId?: string;
  Errors?: TemplateError[];
  ResourceStatus?: ResourceStatus;
  ThemeArn?: string;
  Definition?: TemplateVersionDefinition;
  Status?: number;
  RequestId?: string;
}
export const DescribeTemplateDefinitionResponse = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    TemplateId: S.optional(S.String),
    Errors: S.optional(TemplateErrorList),
    ResourceStatus: S.optional(ResourceStatus),
    ThemeArn: S.optional(S.String),
    Definition: S.optional(TemplateVersionDefinition),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeTemplateDefinitionResponse",
}) as any as S.Schema<DescribeTemplateDefinitionResponse>;
export interface DescribeTopicRefreshResponse {
  RefreshDetails?: TopicRefreshDetails;
  RequestId?: string;
  Status?: number;
}
export const DescribeTopicRefreshResponse = S.suspend(() =>
  S.Struct({
    RefreshDetails: S.optional(TopicRefreshDetails),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeTopicRefreshResponse",
}) as any as S.Schema<DescribeTopicRefreshResponse>;
export interface DescribeUserResponse {
  User?: User;
  RequestId?: string;
  Status?: number;
}
export const DescribeUserResponse = S.suspend(() =>
  S.Struct({
    User: S.optional(User),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeUserResponse",
}) as any as S.Schema<DescribeUserResponse>;
export interface GetIdentityContextResponse {
  Status: number;
  RequestId: string;
  Context?: string;
}
export const GetIdentityContextResponse = S.suspend(() =>
  S.Struct({
    Status: S.Number.pipe(T.HttpResponseCode()),
    RequestId: S.String,
    Context: S.optional(S.String),
  }),
).annotations({
  identifier: "GetIdentityContextResponse",
}) as any as S.Schema<GetIdentityContextResponse>;
export interface ListActionConnectorsResponse {
  ActionConnectorSummaries: ActionConnectorSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListActionConnectorsResponse = S.suspend(() =>
  S.Struct({
    ActionConnectorSummaries: ActionConnectorSummaryList,
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListActionConnectorsResponse",
}) as any as S.Schema<ListActionConnectorsResponse>;
export interface ListAnalysesResponse {
  AnalysisSummaryList?: AnalysisSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListAnalysesResponse = S.suspend(() =>
  S.Struct({
    AnalysisSummaryList: S.optional(AnalysisSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListAnalysesResponse",
}) as any as S.Schema<ListAnalysesResponse>;
export interface ListAssetBundleExportJobsResponse {
  AssetBundleExportJobSummaryList?: AssetBundleExportJobSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListAssetBundleExportJobsResponse = S.suspend(() =>
  S.Struct({
    AssetBundleExportJobSummaryList: S.optional(
      AssetBundleExportJobSummaryList,
    ),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListAssetBundleExportJobsResponse",
}) as any as S.Schema<ListAssetBundleExportJobsResponse>;
export interface ListAssetBundleImportJobsResponse {
  AssetBundleImportJobSummaryList?: AssetBundleImportJobSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListAssetBundleImportJobsResponse = S.suspend(() =>
  S.Struct({
    AssetBundleImportJobSummaryList: S.optional(
      AssetBundleImportJobSummaryList,
    ),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListAssetBundleImportJobsResponse",
}) as any as S.Schema<ListAssetBundleImportJobsResponse>;
export interface ListBrandsResponse {
  NextToken?: string;
  Brands?: BrandSummary[];
}
export const ListBrandsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    Brands: S.optional(BrandSummaryList),
  }),
).annotations({
  identifier: "ListBrandsResponse",
}) as any as S.Schema<ListBrandsResponse>;
export interface ListDashboardsResponse {
  DashboardSummaryList?: DashboardSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListDashboardsResponse = S.suspend(() =>
  S.Struct({
    DashboardSummaryList: S.optional(DashboardSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListDashboardsResponse",
}) as any as S.Schema<ListDashboardsResponse>;
export interface ListDashboardVersionsResponse {
  DashboardVersionSummaryList?: DashboardVersionSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListDashboardVersionsResponse = S.suspend(() =>
  S.Struct({
    DashboardVersionSummaryList: S.optional(DashboardVersionSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListDashboardVersionsResponse",
}) as any as S.Schema<ListDashboardVersionsResponse>;
export interface ListFlowsOutput {
  FlowSummaryList?: FlowSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListFlowsOutput = S.suspend(() =>
  S.Struct({
    FlowSummaryList: S.optional(FlowSummaryList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListFlowsOutput",
}) as any as S.Schema<ListFlowsOutput>;
export interface ListFolderMembersResponse {
  Status?: number;
  FolderMemberList?: MemberIdArnPair[];
  NextToken?: string;
  RequestId?: string;
}
export const ListFolderMembersResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    FolderMemberList: S.optional(FolderMemberList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListFolderMembersResponse",
}) as any as S.Schema<ListFolderMembersResponse>;
export interface ListFoldersResponse {
  Status?: number;
  FolderSummaryList?: FolderSummary[];
  NextToken?: string;
  RequestId?: string;
}
export const ListFoldersResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    FolderSummaryList: S.optional(FolderSummaryList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListFoldersResponse",
}) as any as S.Schema<ListFoldersResponse>;
export interface ListIAMPolicyAssignmentsResponse {
  IAMPolicyAssignments?: IAMPolicyAssignmentSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListIAMPolicyAssignmentsResponse = S.suspend(() =>
  S.Struct({
    IAMPolicyAssignments: S.optional(IAMPolicyAssignmentSummaryList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListIAMPolicyAssignmentsResponse",
}) as any as S.Schema<ListIAMPolicyAssignmentsResponse>;
export interface ListIAMPolicyAssignmentsForUserResponse {
  ActiveAssignments?: ActiveIAMPolicyAssignment[];
  RequestId?: string;
  NextToken?: string;
  Status?: number;
}
export const ListIAMPolicyAssignmentsForUserResponse = S.suspend(() =>
  S.Struct({
    ActiveAssignments: S.optional(ActiveIAMPolicyAssignmentList),
    RequestId: S.optional(S.String),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListIAMPolicyAssignmentsForUserResponse",
}) as any as S.Schema<ListIAMPolicyAssignmentsForUserResponse>;
export interface ListIdentityPropagationConfigsResponse {
  Services?: AuthorizedTargetsByService[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListIdentityPropagationConfigsResponse = S.suspend(() =>
  S.Struct({
    Services: S.optional(AuthorizedTargetsByServices),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListIdentityPropagationConfigsResponse",
}) as any as S.Schema<ListIdentityPropagationConfigsResponse>;
export interface ListSelfUpgradesResponse {
  SelfUpgradeRequestDetails?: SelfUpgradeRequestDetail[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListSelfUpgradesResponse = S.suspend(() =>
  S.Struct({
    SelfUpgradeRequestDetails: S.optional(SelfUpgradeRequestDetailList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListSelfUpgradesResponse",
}) as any as S.Schema<ListSelfUpgradesResponse>;
export interface ListTemplatesResponse {
  TemplateSummaryList?: TemplateSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListTemplatesResponse = S.suspend(() =>
  S.Struct({
    TemplateSummaryList: S.optional(TemplateSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListTemplatesResponse",
}) as any as S.Schema<ListTemplatesResponse>;
export interface ListTemplateVersionsResponse {
  TemplateVersionSummaryList?: TemplateVersionSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListTemplateVersionsResponse = S.suspend(() =>
  S.Struct({
    TemplateVersionSummaryList: S.optional(TemplateVersionSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListTemplateVersionsResponse",
}) as any as S.Schema<ListTemplateVersionsResponse>;
export interface ListThemesResponse {
  ThemeSummaryList?: ThemeSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListThemesResponse = S.suspend(() =>
  S.Struct({
    ThemeSummaryList: S.optional(ThemeSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListThemesResponse",
}) as any as S.Schema<ListThemesResponse>;
export interface ListThemeVersionsResponse {
  ThemeVersionSummaryList?: ThemeVersionSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const ListThemeVersionsResponse = S.suspend(() =>
  S.Struct({
    ThemeVersionSummaryList: S.optional(ThemeVersionSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListThemeVersionsResponse",
}) as any as S.Schema<ListThemeVersionsResponse>;
export interface ListTopicRefreshSchedulesResponse {
  TopicId?: string;
  TopicArn?: string;
  RefreshSchedules?: TopicRefreshScheduleSummary[];
  Status?: number;
  RequestId?: string;
}
export const ListTopicRefreshSchedulesResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    RefreshSchedules: S.optional(TopicRefreshScheduleSummaries),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListTopicRefreshSchedulesResponse",
}) as any as S.Schema<ListTopicRefreshSchedulesResponse>;
export interface ListTopicReviewedAnswersResponse {
  TopicId?: string;
  TopicArn?: string;
  Answers?: TopicReviewedAnswer[];
  Status?: number;
  RequestId?: string;
}
export const ListTopicReviewedAnswersResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    Answers: S.optional(TopicReviewedAnswers),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "ListTopicReviewedAnswersResponse",
}) as any as S.Schema<ListTopicReviewedAnswersResponse>;
export interface ListTopicsResponse {
  TopicsSummaries?: TopicSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListTopicsResponse = S.suspend(() =>
  S.Struct({
    TopicsSummaries: S.optional(TopicSummaries),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListTopicsResponse",
}) as any as S.Schema<ListTopicsResponse>;
export interface ListVPCConnectionsResponse {
  VPCConnectionSummaries?: VPCConnectionSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListVPCConnectionsResponse = S.suspend(() =>
  S.Struct({
    VPCConnectionSummaries: S.optional(VPCConnectionSummaryList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListVPCConnectionsResponse",
}) as any as S.Schema<ListVPCConnectionsResponse>;
export interface SearchActionConnectorsResponse {
  NextToken?: string;
  RequestId?: string;
  Status?: number;
  ActionConnectorSummaries?: ActionConnectorSummary[];
}
export const SearchActionConnectorsResponse = S.suspend(() =>
  S.Struct({
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    ActionConnectorSummaries: S.optional(ActionConnectorSummaryList),
  }),
).annotations({
  identifier: "SearchActionConnectorsResponse",
}) as any as S.Schema<SearchActionConnectorsResponse>;
export interface SearchAnalysesResponse {
  AnalysisSummaryList?: AnalysisSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const SearchAnalysesResponse = S.suspend(() =>
  S.Struct({
    AnalysisSummaryList: S.optional(AnalysisSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "SearchAnalysesResponse",
}) as any as S.Schema<SearchAnalysesResponse>;
export interface SearchDashboardsResponse {
  DashboardSummaryList?: DashboardSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const SearchDashboardsResponse = S.suspend(() =>
  S.Struct({
    DashboardSummaryList: S.optional(DashboardSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "SearchDashboardsResponse",
}) as any as S.Schema<SearchDashboardsResponse>;
export type RowLevelPermissionDataSetMap = {
  [key: string]: RowLevelPermissionDataSet;
};
export const RowLevelPermissionDataSetMap = S.Record({
  key: S.String,
  value: RowLevelPermissionDataSet,
});
export interface DataSetSummary {
  Arn?: string;
  DataSetId?: string;
  Name?: string;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  ImportMode?: DataSetImportMode;
  RowLevelPermissionDataSet?: RowLevelPermissionDataSet;
  RowLevelPermissionDataSetMap?: { [key: string]: RowLevelPermissionDataSet };
  RowLevelPermissionTagConfigurationApplied?: boolean;
  ColumnLevelPermissionRulesApplied?: boolean;
  UseAs?: DataSetUseAs;
}
export const DataSetSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSetId: S.optional(S.String),
    Name: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    ImportMode: S.optional(DataSetImportMode),
    RowLevelPermissionDataSet: S.optional(RowLevelPermissionDataSet),
    RowLevelPermissionDataSetMap: S.optional(RowLevelPermissionDataSetMap),
    RowLevelPermissionTagConfigurationApplied: S.optional(S.Boolean),
    ColumnLevelPermissionRulesApplied: S.optional(S.Boolean),
    UseAs: S.optional(DataSetUseAs),
  }),
).annotations({
  identifier: "DataSetSummary",
}) as any as S.Schema<DataSetSummary>;
export type DataSetSummaryList = DataSetSummary[];
export const DataSetSummaryList = S.Array(DataSetSummary);
export interface SearchDataSetsResponse {
  DataSetSummaries?: DataSetSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const SearchDataSetsResponse = S.suspend(() =>
  S.Struct({
    DataSetSummaries: S.optional(DataSetSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "SearchDataSetsResponse",
}) as any as S.Schema<SearchDataSetsResponse>;
export interface SearchFlowsOutput {
  FlowSummaryList: FlowSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const SearchFlowsOutput = S.suspend(() =>
  S.Struct({
    FlowSummaryList: FlowSummaryList,
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "SearchFlowsOutput",
}) as any as S.Schema<SearchFlowsOutput>;
export interface SearchFoldersResponse {
  Status?: number;
  FolderSummaryList?: FolderSummary[];
  NextToken?: string;
  RequestId?: string;
}
export const SearchFoldersResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    FolderSummaryList: S.optional(FolderSummaryList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "SearchFoldersResponse",
}) as any as S.Schema<SearchFoldersResponse>;
export interface SearchGroupsResponse {
  GroupList?: Group[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const SearchGroupsResponse = S.suspend(() =>
  S.Struct({
    GroupList: S.optional(GroupList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "SearchGroupsResponse",
}) as any as S.Schema<SearchGroupsResponse>;
export interface SearchTopicsResponse {
  TopicSummaryList?: TopicSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const SearchTopicsResponse = S.suspend(() =>
  S.Struct({
    TopicSummaryList: S.optional(TopicSummaries),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "SearchTopicsResponse",
}) as any as S.Schema<SearchTopicsResponse>;
export interface StartAssetBundleExportJobRequest {
  AwsAccountId: string;
  AssetBundleExportJobId: string;
  ResourceArns: string[];
  IncludeAllDependencies?: boolean;
  ExportFormat: AssetBundleExportFormat;
  CloudFormationOverridePropertyConfiguration?: AssetBundleCloudFormationOverridePropertyConfiguration;
  IncludePermissions?: boolean;
  IncludeTags?: boolean;
  ValidationStrategy?: AssetBundleExportJobValidationStrategy;
  IncludeFolderMemberships?: boolean;
  IncludeFolderMembers?: IncludeFolderMembers;
}
export const StartAssetBundleExportJobRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssetBundleExportJobId: S.String,
    ResourceArns: AssetBundleResourceArns,
    IncludeAllDependencies: S.optional(S.Boolean),
    ExportFormat: AssetBundleExportFormat,
    CloudFormationOverridePropertyConfiguration: S.optional(
      AssetBundleCloudFormationOverridePropertyConfiguration,
    ),
    IncludePermissions: S.optional(S.Boolean),
    IncludeTags: S.optional(S.Boolean),
    ValidationStrategy: S.optional(AssetBundleExportJobValidationStrategy),
    IncludeFolderMemberships: S.optional(S.Boolean),
    IncludeFolderMembers: S.optional(IncludeFolderMembers),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/asset-bundle-export-jobs/export",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartAssetBundleExportJobRequest",
}) as any as S.Schema<StartAssetBundleExportJobRequest>;
export type SnapshotFileSheetSelectionScope =
  | "ALL_VISUALS"
  | "SELECTED_VISUALS";
export const SnapshotFileSheetSelectionScope = S.Literal(
  "ALL_VISUALS",
  "SELECTED_VISUALS",
);
export type SnapshotFileSheetSelectionVisualIdList = string[];
export const SnapshotFileSheetSelectionVisualIdList = S.Array(S.String);
export interface UpdateFlowPermissionsOutput {
  Status?: number;
  Arn: string;
  Permissions: Permission[];
  RequestId: string;
  FlowId: string;
}
export const UpdateFlowPermissionsOutput = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    Arn: S.String,
    Permissions: PermissionsList,
    RequestId: S.String,
    FlowId: S.String,
  }),
).annotations({
  identifier: "UpdateFlowPermissionsOutput",
}) as any as S.Schema<UpdateFlowPermissionsOutput>;
export interface UpdateIpRestrictionResponse {
  AwsAccountId?: string;
  RequestId?: string;
  Status?: number;
}
export const UpdateIpRestrictionResponse = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "UpdateIpRestrictionResponse",
}) as any as S.Schema<UpdateIpRestrictionResponse>;
export interface Sheet {
  SheetId?: string;
  Name?: string;
  Images?: SheetImage[];
}
export const Sheet = S.suspend(() =>
  S.Struct({
    SheetId: S.optional(S.String),
    Name: S.optional(S.String),
    Images: S.optional(SheetImageList),
  }),
).annotations({ identifier: "Sheet" }) as any as S.Schema<Sheet>;
export type SheetList = Sheet[];
export const SheetList = S.Array(Sheet);
export interface DashboardVersion {
  CreatedTime?: Date;
  Errors?: DashboardError[];
  VersionNumber?: number;
  Status?: ResourceStatus;
  Arn?: string;
  SourceEntityArn?: string;
  DataSetArns?: string[];
  Description?: string;
  ThemeArn?: string;
  Sheets?: Sheet[];
}
export const DashboardVersion = S.suspend(() =>
  S.Struct({
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Errors: S.optional(DashboardErrorList),
    VersionNumber: S.optional(S.Number),
    Status: S.optional(ResourceStatus),
    Arn: S.optional(S.String),
    SourceEntityArn: S.optional(S.String),
    DataSetArns: S.optional(DataSetArnsList),
    Description: S.optional(S.String),
    ThemeArn: S.optional(S.String),
    Sheets: S.optional(SheetList),
  }),
).annotations({
  identifier: "DashboardVersion",
}) as any as S.Schema<DashboardVersion>;
export interface SnapshotAnonymousUserRedacted {
  RowLevelPermissionTagKeys?: string[];
}
export const SnapshotAnonymousUserRedacted = S.suspend(() =>
  S.Struct({ RowLevelPermissionTagKeys: S.optional(SessionTagKeyList) }),
).annotations({
  identifier: "SnapshotAnonymousUserRedacted",
}) as any as S.Schema<SnapshotAnonymousUserRedacted>;
export type SnapshotAnonymousUserRedactedList = SnapshotAnonymousUserRedacted[];
export const SnapshotAnonymousUserRedactedList = S.Array(
  SnapshotAnonymousUserRedacted,
);
export interface SnapshotFileSheetSelection {
  SheetId: string;
  SelectionScope: SnapshotFileSheetSelectionScope;
  VisualIds?: string[];
}
export const SnapshotFileSheetSelection = S.suspend(() =>
  S.Struct({
    SheetId: S.String,
    SelectionScope: SnapshotFileSheetSelectionScope,
    VisualIds: S.optional(SnapshotFileSheetSelectionVisualIdList),
  }),
).annotations({
  identifier: "SnapshotFileSheetSelection",
}) as any as S.Schema<SnapshotFileSheetSelection>;
export type SnapshotFileSheetSelectionList = SnapshotFileSheetSelection[];
export const SnapshotFileSheetSelectionList = S.Array(
  SnapshotFileSheetSelection,
);
export interface SnapshotFile {
  SheetSelections: SnapshotFileSheetSelection[];
  FormatType: SnapshotFileFormatType;
}
export const SnapshotFile = S.suspend(() =>
  S.Struct({
    SheetSelections: SnapshotFileSheetSelectionList,
    FormatType: SnapshotFileFormatType,
  }),
).annotations({ identifier: "SnapshotFile" }) as any as S.Schema<SnapshotFile>;
export type SnapshotFileList = SnapshotFile[];
export const SnapshotFileList = S.Array(SnapshotFile);
export interface S3BucketConfiguration {
  BucketName: string;
  BucketPrefix: string;
  BucketRegion: string;
}
export const S3BucketConfiguration = S.suspend(() =>
  S.Struct({
    BucketName: S.String,
    BucketPrefix: S.String,
    BucketRegion: S.String,
  }),
).annotations({
  identifier: "S3BucketConfiguration",
}) as any as S.Schema<S3BucketConfiguration>;
export interface SnapshotS3DestinationConfiguration {
  BucketConfiguration: S3BucketConfiguration;
}
export const SnapshotS3DestinationConfiguration = S.suspend(() =>
  S.Struct({ BucketConfiguration: S3BucketConfiguration }),
).annotations({
  identifier: "SnapshotS3DestinationConfiguration",
}) as any as S.Schema<SnapshotS3DestinationConfiguration>;
export interface SnapshotJobResultErrorInfo {
  ErrorMessage?: string;
  ErrorType?: string;
}
export const SnapshotJobResultErrorInfo = S.suspend(() =>
  S.Struct({
    ErrorMessage: S.optional(S.String),
    ErrorType: S.optional(S.String),
  }),
).annotations({
  identifier: "SnapshotJobResultErrorInfo",
}) as any as S.Schema<SnapshotJobResultErrorInfo>;
export type SnapshotJobResultErrorInfoList = SnapshotJobResultErrorInfo[];
export const SnapshotJobResultErrorInfoList = S.Array(
  SnapshotJobResultErrorInfo,
);
export interface SnapshotJobS3Result {
  S3DestinationConfiguration?: SnapshotS3DestinationConfiguration;
  S3Uri?: string | redacted.Redacted<string>;
  ErrorInfo?: SnapshotJobResultErrorInfo[];
}
export const SnapshotJobS3Result = S.suspend(() =>
  S.Struct({
    S3DestinationConfiguration: S.optional(SnapshotS3DestinationConfiguration),
    S3Uri: S.optional(SensitiveString),
    ErrorInfo: S.optional(SnapshotJobResultErrorInfoList),
  }),
).annotations({
  identifier: "SnapshotJobS3Result",
}) as any as S.Schema<SnapshotJobS3Result>;
export type SnapshotJobS3ResultList = SnapshotJobS3Result[];
export const SnapshotJobS3ResultList = S.Array(SnapshotJobS3Result);
export interface SnapshotJobResultFileGroup {
  Files?: SnapshotFile[];
  S3Results?: SnapshotJobS3Result[];
}
export const SnapshotJobResultFileGroup = S.suspend(() =>
  S.Struct({
    Files: S.optional(SnapshotFileList),
    S3Results: S.optional(SnapshotJobS3ResultList),
  }),
).annotations({
  identifier: "SnapshotJobResultFileGroup",
}) as any as S.Schema<SnapshotJobResultFileGroup>;
export type SnapshotJobResultFileGroupList = SnapshotJobResultFileGroup[];
export const SnapshotJobResultFileGroupList = S.Array(
  SnapshotJobResultFileGroup,
);
export interface RegisteredUserSnapshotJobResult {
  FileGroups?: SnapshotJobResultFileGroup[];
}
export const RegisteredUserSnapshotJobResult = S.suspend(() =>
  S.Struct({ FileGroups: S.optional(SnapshotJobResultFileGroupList) }),
).annotations({
  identifier: "RegisteredUserSnapshotJobResult",
}) as any as S.Schema<RegisteredUserSnapshotJobResult>;
export type RegisteredUserSnapshotJobResultList =
  RegisteredUserSnapshotJobResult[];
export const RegisteredUserSnapshotJobResultList = S.Array(
  RegisteredUserSnapshotJobResult,
);
export interface OutputColumn {
  Name?: string;
  Id?: string;
  Description?: string | redacted.Redacted<string>;
  Type?: ColumnDataType;
  SubType?: ColumnDataSubType;
}
export const OutputColumn = S.suspend(() =>
  S.Struct({
    Name: S.optional(S.String),
    Id: S.optional(S.String),
    Description: S.optional(SensitiveString),
    Type: S.optional(ColumnDataType),
    SubType: S.optional(ColumnDataSubType),
  }),
).annotations({ identifier: "OutputColumn" }) as any as S.Schema<OutputColumn>;
export type OutputColumnList = OutputColumn[];
export const OutputColumnList = S.Array(OutputColumn);
export interface TemplateVersion {
  CreatedTime?: Date;
  Errors?: TemplateError[];
  VersionNumber?: number;
  Status?: ResourceStatus;
  DataSetConfigurations?: DataSetConfiguration[];
  Description?: string;
  SourceEntityArn?: string;
  ThemeArn?: string;
  Sheets?: Sheet[];
}
export const TemplateVersion = S.suspend(() =>
  S.Struct({
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Errors: S.optional(TemplateErrorList),
    VersionNumber: S.optional(S.Number),
    Status: S.optional(ResourceStatus),
    DataSetConfigurations: S.optional(DataSetConfigurationList),
    Description: S.optional(S.String),
    SourceEntityArn: S.optional(S.String),
    ThemeArn: S.optional(S.String),
    Sheets: S.optional(SheetList),
  }),
).annotations({
  identifier: "TemplateVersion",
}) as any as S.Schema<TemplateVersion>;
export interface AnonymousUserDashboardVisualEmbeddingConfiguration {
  InitialDashboardVisualId: DashboardVisualId;
}
export const AnonymousUserDashboardVisualEmbeddingConfiguration = S.suspend(
  () => S.Struct({ InitialDashboardVisualId: DashboardVisualId }),
).annotations({
  identifier: "AnonymousUserDashboardVisualEmbeddingConfiguration",
}) as any as S.Schema<AnonymousUserDashboardVisualEmbeddingConfiguration>;
export type ThemeErrorType = "INTERNAL_FAILURE";
export const ThemeErrorType = S.Literal("INTERNAL_FAILURE");
export interface AnalysisError {
  Type?: AnalysisErrorType;
  Message?: string;
  ViolatedEntities?: Entity[];
}
export const AnalysisError = S.suspend(() =>
  S.Struct({
    Type: S.optional(AnalysisErrorType),
    Message: S.optional(S.String),
    ViolatedEntities: S.optional(EntityList),
  }),
).annotations({
  identifier: "AnalysisError",
}) as any as S.Schema<AnalysisError>;
export type AnalysisErrorList = AnalysisError[];
export const AnalysisErrorList = S.Array(AnalysisError);
export interface Analysis {
  AnalysisId?: string;
  Arn?: string;
  Name?: string;
  Status?: ResourceStatus;
  Errors?: AnalysisError[];
  DataSetArns?: string[];
  ThemeArn?: string;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  Sheets?: Sheet[];
}
export const Analysis = S.suspend(() =>
  S.Struct({
    AnalysisId: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Status: S.optional(ResourceStatus),
    Errors: S.optional(AnalysisErrorList),
    DataSetArns: S.optional(DataSetArnsList),
    ThemeArn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Sheets: S.optional(SheetList),
  }),
).annotations({ identifier: "Analysis" }) as any as S.Schema<Analysis>;
export type ExceptionResourceType =
  | "USER"
  | "GROUP"
  | "NAMESPACE"
  | "ACCOUNT_SETTINGS"
  | "IAMPOLICY_ASSIGNMENT"
  | "DATA_SOURCE"
  | "DATA_SET"
  | "VPC_CONNECTION"
  | "INGESTION";
export const ExceptionResourceType = S.Literal(
  "USER",
  "GROUP",
  "NAMESPACE",
  "ACCOUNT_SETTINGS",
  "IAMPOLICY_ASSIGNMENT",
  "DATA_SOURCE",
  "DATA_SET",
  "VPC_CONNECTION",
  "INGESTION",
);
export interface Dashboard {
  DashboardId?: string;
  Arn?: string;
  Name?: string;
  Version?: DashboardVersion;
  CreatedTime?: Date;
  LastPublishedTime?: Date;
  LastUpdatedTime?: Date;
  LinkEntities?: string[];
}
export const Dashboard = S.suspend(() =>
  S.Struct({
    DashboardId: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Version: S.optional(DashboardVersion),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastPublishedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    LinkEntities: S.optional(LinkEntityArnList),
  }),
).annotations({ identifier: "Dashboard" }) as any as S.Schema<Dashboard>;
export interface SnapshotUserConfigurationRedacted {
  AnonymousUsers?: SnapshotAnonymousUserRedacted[];
}
export const SnapshotUserConfigurationRedacted = S.suspend(() =>
  S.Struct({ AnonymousUsers: S.optional(SnapshotAnonymousUserRedactedList) }),
).annotations({
  identifier: "SnapshotUserConfigurationRedacted",
}) as any as S.Schema<SnapshotUserConfigurationRedacted>;
export interface DataSet {
  Arn?: string;
  DataSetId?: string;
  Name?: string;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  PhysicalTableMap?: { [key: string]: PhysicalTable };
  LogicalTableMap?: { [key: string]: LogicalTable };
  OutputColumns?: OutputColumn[];
  ImportMode?: DataSetImportMode;
  ConsumedSpiceCapacityInBytes?: number;
  ColumnGroups?: ColumnGroup[];
  FieldFolders?: { [key: string]: FieldFolder };
  RowLevelPermissionDataSet?: RowLevelPermissionDataSet;
  RowLevelPermissionTagConfiguration?: RowLevelPermissionTagConfiguration;
  ColumnLevelPermissionRules?: ColumnLevelPermissionRule[];
  DataSetUsageConfiguration?: DataSetUsageConfiguration;
  DatasetParameters?: DatasetParameter[];
  PerformanceConfiguration?: PerformanceConfiguration;
  UseAs?: DataSetUseAs;
  DataPrepConfiguration?: DataPrepConfiguration;
  SemanticModelConfiguration?: SemanticModelConfiguration;
}
export const DataSet = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSetId: S.optional(S.String),
    Name: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    PhysicalTableMap: S.optional(PhysicalTableMap),
    LogicalTableMap: S.optional(LogicalTableMap),
    OutputColumns: S.optional(OutputColumnList),
    ImportMode: S.optional(DataSetImportMode),
    ConsumedSpiceCapacityInBytes: S.optional(S.Number),
    ColumnGroups: S.optional(ColumnGroupList),
    FieldFolders: S.optional(FieldFolderMap),
    RowLevelPermissionDataSet: S.optional(RowLevelPermissionDataSet),
    RowLevelPermissionTagConfiguration: S.optional(
      RowLevelPermissionTagConfiguration,
    ),
    ColumnLevelPermissionRules: S.optional(ColumnLevelPermissionRuleList),
    DataSetUsageConfiguration: S.optional(DataSetUsageConfiguration),
    DatasetParameters: S.optional(DatasetParameterList),
    PerformanceConfiguration: S.optional(PerformanceConfiguration),
    UseAs: S.optional(DataSetUseAs),
    DataPrepConfiguration: S.optional(DataPrepConfiguration),
    SemanticModelConfiguration: S.optional(SemanticModelConfiguration),
  }),
).annotations({ identifier: "DataSet" }) as any as S.Schema<DataSet>;
export interface Template {
  Arn?: string;
  Name?: string;
  Version?: TemplateVersion;
  TemplateId?: string;
  LastUpdatedTime?: Date;
  CreatedTime?: Date;
}
export const Template = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    Version: S.optional(TemplateVersion),
    TemplateId: S.optional(S.String),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
  }),
).annotations({ identifier: "Template" }) as any as S.Schema<Template>;
export interface VPCConnection {
  VPCConnectionId?: string;
  Arn?: string;
  Name?: string;
  VPCId?: string;
  SecurityGroupIds?: string[];
  DnsResolvers?: string[];
  Status?: VPCConnectionResourceStatus;
  AvailabilityStatus?: VPCConnectionAvailabilityStatus;
  NetworkInterfaces?: NetworkInterface[];
  RoleArn?: string;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
}
export const VPCConnection = S.suspend(() =>
  S.Struct({
    VPCConnectionId: S.optional(S.String),
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    VPCId: S.optional(S.String),
    SecurityGroupIds: S.optional(SecurityGroupIdList),
    DnsResolvers: S.optional(StringList),
    Status: S.optional(VPCConnectionResourceStatus),
    AvailabilityStatus: S.optional(VPCConnectionAvailabilityStatus),
    NetworkInterfaces: S.optional(NetworkInterfaceList),
    RoleArn: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "VPCConnection",
}) as any as S.Schema<VPCConnection>;
export interface DataSourceSummary {
  Arn?: string;
  DataSourceId?: string;
  Name?: string;
  Type?: DataSourceType;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
}
export const DataSourceSummary = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSourceId: S.optional(S.String),
    Name: S.optional(S.String),
    Type: S.optional(DataSourceType),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
  }),
).annotations({
  identifier: "DataSourceSummary",
}) as any as S.Schema<DataSourceSummary>;
export type DataSourceSummaryList = DataSourceSummary[];
export const DataSourceSummaryList = S.Array(DataSourceSummary);
export interface FailedKeyRegistrationEntry {
  KeyArn?: string;
  Message: string;
  StatusCode: number;
  SenderFault: boolean;
}
export const FailedKeyRegistrationEntry = S.suspend(() =>
  S.Struct({
    KeyArn: S.optional(S.String),
    Message: S.String,
    StatusCode: S.Number,
    SenderFault: S.Boolean,
  }),
).annotations({
  identifier: "FailedKeyRegistrationEntry",
}) as any as S.Schema<FailedKeyRegistrationEntry>;
export type FailedKeyRegistrationEntries = FailedKeyRegistrationEntry[];
export const FailedKeyRegistrationEntries = S.Array(FailedKeyRegistrationEntry);
export interface SuccessfulKeyRegistrationEntry {
  KeyArn: string;
  StatusCode: number;
}
export const SuccessfulKeyRegistrationEntry = S.suspend(() =>
  S.Struct({ KeyArn: S.String, StatusCode: S.Number }),
).annotations({
  identifier: "SuccessfulKeyRegistrationEntry",
}) as any as S.Schema<SuccessfulKeyRegistrationEntry>;
export type SuccessfulKeyRegistrationEntries = SuccessfulKeyRegistrationEntry[];
export const SuccessfulKeyRegistrationEntries = S.Array(
  SuccessfulKeyRegistrationEntry,
);
export interface ThemeError {
  Type?: ThemeErrorType;
  Message?: string;
}
export const ThemeError = S.suspend(() =>
  S.Struct({ Type: S.optional(ThemeErrorType), Message: S.optional(S.String) }),
).annotations({ identifier: "ThemeError" }) as any as S.Schema<ThemeError>;
export type ThemeErrorList = ThemeError[];
export const ThemeErrorList = S.Array(ThemeError);
export interface AnonymousUserDashboardFeatureConfigurations {
  SharedView?: SharedViewConfigurations;
}
export const AnonymousUserDashboardFeatureConfigurations = S.suspend(() =>
  S.Struct({ SharedView: S.optional(SharedViewConfigurations) }),
).annotations({
  identifier: "AnonymousUserDashboardFeatureConfigurations",
}) as any as S.Schema<AnonymousUserDashboardFeatureConfigurations>;
export type SnapshotS3DestinationConfigurationList =
  SnapshotS3DestinationConfiguration[];
export const SnapshotS3DestinationConfigurationList = S.Array(
  SnapshotS3DestinationConfiguration,
);
export interface CreateDashboardRequest {
  AwsAccountId: string;
  DashboardId: string;
  Name: string;
  Parameters?: Parameters;
  Permissions?: ResourcePermission[];
  SourceEntity?: DashboardSourceEntity;
  Tags?: Tag[];
  VersionDescription?: string;
  DashboardPublishOptions?: DashboardPublishOptions;
  ThemeArn?: string;
  Definition?: DashboardVersionDefinition;
  ValidationStrategy?: ValidationStrategy;
  FolderArns?: string[];
  LinkSharingConfiguration?: LinkSharingConfiguration;
  LinkEntities?: string[];
}
export const CreateDashboardRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    Name: S.String,
    Parameters: S.optional(Parameters),
    Permissions: S.optional(ResourcePermissionList),
    SourceEntity: S.optional(DashboardSourceEntity),
    Tags: S.optional(TagList),
    VersionDescription: S.optional(S.String),
    DashboardPublishOptions: S.optional(DashboardPublishOptions),
    ThemeArn: S.optional(S.String),
    Definition: S.optional(DashboardVersionDefinition),
    ValidationStrategy: S.optional(ValidationStrategy),
    FolderArns: S.optional(FolderArnList),
    LinkSharingConfiguration: S.optional(LinkSharingConfiguration),
    LinkEntities: S.optional(LinkEntityArnList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateDashboardRequest",
}) as any as S.Schema<CreateDashboardRequest>;
export interface CreateDataSourceRequest {
  AwsAccountId: string;
  DataSourceId: string;
  Name: string;
  Type: DataSourceType;
  DataSourceParameters?: DataSourceParameters;
  Credentials?: DataSourceCredentials;
  Permissions?: ResourcePermission[];
  VpcConnectionProperties?: VpcConnectionProperties;
  SslProperties?: SslProperties;
  Tags?: Tag[];
  FolderArns?: string[];
}
export const CreateDataSourceRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSourceId: S.String,
    Name: S.String,
    Type: DataSourceType,
    DataSourceParameters: S.optional(DataSourceParameters),
    Credentials: S.optional(DataSourceCredentials),
    Permissions: S.optional(ResourcePermissionList),
    VpcConnectionProperties: S.optional(VpcConnectionProperties),
    SslProperties: S.optional(SslProperties),
    Tags: S.optional(TagList),
    FolderArns: S.optional(FolderArnList),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/accounts/{AwsAccountId}/data-sources" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateDataSourceRequest",
}) as any as S.Schema<CreateDataSourceRequest>;
export interface CreateRefreshScheduleRequest {
  DataSetId: string;
  AwsAccountId: string;
  Schedule: RefreshSchedule;
}
export const CreateRefreshScheduleRequest = S.suspend(() =>
  S.Struct({
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    Schedule: RefreshSchedule,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-schedules",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateRefreshScheduleRequest",
}) as any as S.Schema<CreateRefreshScheduleRequest>;
export interface DescribeAnalysisResponse {
  Analysis?: Analysis;
  Status?: number;
  RequestId?: string;
}
export const DescribeAnalysisResponse = S.suspend(() =>
  S.Struct({
    Analysis: S.optional(Analysis),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeAnalysisResponse",
}) as any as S.Schema<DescribeAnalysisResponse>;
export interface DescribeAnalysisDefinitionResponse {
  AnalysisId?: string;
  Name?: string;
  Errors?: AnalysisError[];
  ResourceStatus?: ResourceStatus;
  ThemeArn?: string;
  Definition?: AnalysisDefinition;
  Status?: number;
  RequestId?: string;
}
export const DescribeAnalysisDefinitionResponse = S.suspend(() =>
  S.Struct({
    AnalysisId: S.optional(S.String),
    Name: S.optional(S.String),
    Errors: S.optional(AnalysisErrorList),
    ResourceStatus: S.optional(ResourceStatus),
    ThemeArn: S.optional(S.String),
    Definition: S.optional(AnalysisDefinition),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeAnalysisDefinitionResponse",
}) as any as S.Schema<DescribeAnalysisDefinitionResponse>;
export interface DescribeDashboardResponse {
  Dashboard?: Dashboard;
  Status?: number;
  RequestId?: string;
}
export const DescribeDashboardResponse = S.suspend(() =>
  S.Struct({
    Dashboard: S.optional(Dashboard),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeDashboardResponse",
}) as any as S.Schema<DescribeDashboardResponse>;
export interface SnapshotFileGroup {
  Files?: SnapshotFile[];
}
export const SnapshotFileGroup = S.suspend(() =>
  S.Struct({ Files: S.optional(SnapshotFileList) }),
).annotations({
  identifier: "SnapshotFileGroup",
}) as any as S.Schema<SnapshotFileGroup>;
export type SnapshotFileGroupList = SnapshotFileGroup[];
export const SnapshotFileGroupList = S.Array(SnapshotFileGroup);
export interface SnapshotDestinationConfiguration {
  S3Destinations?: SnapshotS3DestinationConfiguration[];
}
export const SnapshotDestinationConfiguration = S.suspend(() =>
  S.Struct({
    S3Destinations: S.optional(SnapshotS3DestinationConfigurationList),
  }),
).annotations({
  identifier: "SnapshotDestinationConfiguration",
}) as any as S.Schema<SnapshotDestinationConfiguration>;
export interface SnapshotConfiguration {
  FileGroups: SnapshotFileGroup[];
  DestinationConfiguration?: SnapshotDestinationConfiguration;
  Parameters?: Parameters;
}
export const SnapshotConfiguration = S.suspend(() =>
  S.Struct({
    FileGroups: SnapshotFileGroupList,
    DestinationConfiguration: S.optional(SnapshotDestinationConfiguration),
    Parameters: S.optional(Parameters),
  }),
).annotations({
  identifier: "SnapshotConfiguration",
}) as any as S.Schema<SnapshotConfiguration>;
export interface DescribeDashboardSnapshotJobResponse {
  AwsAccountId?: string;
  DashboardId?: string;
  SnapshotJobId?: string;
  UserConfiguration?: SnapshotUserConfigurationRedacted;
  SnapshotConfiguration?: SnapshotConfiguration;
  Arn?: string;
  JobStatus?: SnapshotJobStatus;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  RequestId?: string;
  Status?: number;
}
export const DescribeDashboardSnapshotJobResponse = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.optional(S.String),
    DashboardId: S.optional(S.String),
    SnapshotJobId: S.optional(S.String),
    UserConfiguration: S.optional(SnapshotUserConfigurationRedacted),
    SnapshotConfiguration: S.optional(SnapshotConfiguration),
    Arn: S.optional(S.String),
    JobStatus: S.optional(SnapshotJobStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number),
  }),
).annotations({
  identifier: "DescribeDashboardSnapshotJobResponse",
}) as any as S.Schema<DescribeDashboardSnapshotJobResponse>;
export interface DescribeDataSetResponse {
  DataSet?: DataSet;
  RequestId?: string;
  Status?: number;
}
export const DescribeDataSetResponse = S.suspend(() =>
  S.Struct({
    DataSet: S.optional(DataSet),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeDataSetResponse",
}) as any as S.Schema<DescribeDataSetResponse>;
export interface DescribeDataSourceResponse {
  DataSource?: DataSource;
  RequestId?: string;
  Status?: number;
}
export const DescribeDataSourceResponse = S.suspend(() =>
  S.Struct({
    DataSource: S.optional(DataSource),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeDataSourceResponse",
}) as any as S.Schema<DescribeDataSourceResponse>;
export interface DescribeIngestionResponse {
  Ingestion?: Ingestion;
  RequestId?: string;
  Status?: number;
}
export const DescribeIngestionResponse = S.suspend(() =>
  S.Struct({
    Ingestion: S.optional(Ingestion),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeIngestionResponse",
}) as any as S.Schema<DescribeIngestionResponse>;
export interface DescribeNamespaceResponse {
  Namespace?: NamespaceInfoV2;
  RequestId?: string;
  Status?: number;
}
export const DescribeNamespaceResponse = S.suspend(() =>
  S.Struct({
    Namespace: S.optional(NamespaceInfoV2),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeNamespaceResponse",
}) as any as S.Schema<DescribeNamespaceResponse>;
export interface DescribeTemplateResponse {
  Template?: Template;
  Status?: number;
  RequestId?: string;
}
export const DescribeTemplateResponse = S.suspend(() =>
  S.Struct({
    Template: S.optional(Template),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeTemplateResponse",
}) as any as S.Schema<DescribeTemplateResponse>;
export interface DescribeVPCConnectionResponse {
  VPCConnection?: VPCConnection;
  RequestId?: string;
  Status?: number;
}
export const DescribeVPCConnectionResponse = S.suspend(() =>
  S.Struct({
    VPCConnection: S.optional(VPCConnection),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number),
  }),
).annotations({
  identifier: "DescribeVPCConnectionResponse",
}) as any as S.Schema<DescribeVPCConnectionResponse>;
export interface ListDataSetsResponse {
  DataSetSummaries?: DataSetSummary[];
  NextToken?: string;
  RequestId?: string;
  Status?: number;
}
export const ListDataSetsResponse = S.suspend(() =>
  S.Struct({
    DataSetSummaries: S.optional(DataSetSummaryList),
    NextToken: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "ListDataSetsResponse",
}) as any as S.Schema<ListDataSetsResponse>;
export interface PredictQAResultsResponse {
  PrimaryResult?: QAResult;
  AdditionalResults?: QAResult[];
  RequestId?: string;
  Status?: number;
}
export const PredictQAResultsResponse = S.suspend(() =>
  S.Struct({
    PrimaryResult: S.optional(QAResult),
    AdditionalResults: S.optional(QAResults),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "PredictQAResultsResponse",
}) as any as S.Schema<PredictQAResultsResponse>;
export interface SearchDataSourcesResponse {
  DataSourceSummaries?: DataSourceSummary[];
  NextToken?: string;
  Status?: number;
  RequestId?: string;
}
export const SearchDataSourcesResponse = S.suspend(() =>
  S.Struct({
    DataSourceSummaries: S.optional(DataSourceSummaryList),
    NextToken: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "SearchDataSourcesResponse",
}) as any as S.Schema<SearchDataSourcesResponse>;
export interface StartAssetBundleExportJobResponse {
  Arn?: string;
  AssetBundleExportJobId?: string;
  RequestId?: string;
  Status?: number;
}
export const StartAssetBundleExportJobResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AssetBundleExportJobId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "StartAssetBundleExportJobResponse",
}) as any as S.Schema<StartAssetBundleExportJobResponse>;
export interface UpdateKeyRegistrationResponse {
  FailedKeyRegistration?: FailedKeyRegistrationEntry[];
  SuccessfulKeyRegistration?: SuccessfulKeyRegistrationEntry[];
  RequestId?: string;
}
export const UpdateKeyRegistrationResponse = S.suspend(() =>
  S.Struct({
    FailedKeyRegistration: S.optional(FailedKeyRegistrationEntries),
    SuccessfulKeyRegistration: S.optional(SuccessfulKeyRegistrationEntries),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "UpdateKeyRegistrationResponse",
}) as any as S.Schema<UpdateKeyRegistrationResponse>;
export interface ThemeVersion {
  VersionNumber?: number;
  Arn?: string;
  Description?: string;
  BaseThemeId?: string;
  CreatedTime?: Date;
  Configuration?: ThemeConfiguration;
  Errors?: ThemeError[];
  Status?: ResourceStatus;
}
export const ThemeVersion = S.suspend(() =>
  S.Struct({
    VersionNumber: S.optional(S.Number),
    Arn: S.optional(S.String),
    Description: S.optional(S.String),
    BaseThemeId: S.optional(S.String),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    Configuration: S.optional(ThemeConfiguration),
    Errors: S.optional(ThemeErrorList),
    Status: S.optional(ResourceStatus),
  }),
).annotations({ identifier: "ThemeVersion" }) as any as S.Schema<ThemeVersion>;
export interface AnonymousUserDashboardEmbeddingConfiguration {
  InitialDashboardId: string;
  EnabledFeatures?: AnonymousUserDashboardEmbeddingConfigurationEnabledFeature[];
  DisabledFeatures?: AnonymousUserDashboardEmbeddingConfigurationDisabledFeature[];
  FeatureConfigurations?: AnonymousUserDashboardFeatureConfigurations;
}
export const AnonymousUserDashboardEmbeddingConfiguration = S.suspend(() =>
  S.Struct({
    InitialDashboardId: S.String,
    EnabledFeatures: S.optional(
      AnonymousUserDashboardEmbeddingConfigurationEnabledFeatures,
    ),
    DisabledFeatures: S.optional(
      AnonymousUserDashboardEmbeddingConfigurationDisabledFeatures,
    ),
    FeatureConfigurations: S.optional(
      AnonymousUserDashboardFeatureConfigurations,
    ),
  }),
).annotations({
  identifier: "AnonymousUserDashboardEmbeddingConfiguration",
}) as any as S.Schema<AnonymousUserDashboardEmbeddingConfiguration>;
export interface ReadBasicAuthConnectionMetadata {
  BaseEndpoint: string;
  Username: string | redacted.Redacted<string>;
}
export const ReadBasicAuthConnectionMetadata = S.suspend(() =>
  S.Struct({ BaseEndpoint: S.String, Username: SensitiveString }),
).annotations({
  identifier: "ReadBasicAuthConnectionMetadata",
}) as any as S.Schema<ReadBasicAuthConnectionMetadata>;
export interface ReadAPIKeyConnectionMetadata {
  BaseEndpoint: string;
  Email?: string | redacted.Redacted<string>;
}
export const ReadAPIKeyConnectionMetadata = S.suspend(() =>
  S.Struct({ BaseEndpoint: S.String, Email: S.optional(SensitiveString) }),
).annotations({
  identifier: "ReadAPIKeyConnectionMetadata",
}) as any as S.Schema<ReadAPIKeyConnectionMetadata>;
export interface ReadNoneConnectionMetadata {
  BaseEndpoint: string;
}
export const ReadNoneConnectionMetadata = S.suspend(() =>
  S.Struct({ BaseEndpoint: S.String }),
).annotations({
  identifier: "ReadNoneConnectionMetadata",
}) as any as S.Schema<ReadNoneConnectionMetadata>;
export interface ReadIamConnectionMetadata {
  RoleArn: string;
  SourceArn: string;
}
export const ReadIamConnectionMetadata = S.suspend(() =>
  S.Struct({ RoleArn: S.String, SourceArn: S.String }),
).annotations({
  identifier: "ReadIamConnectionMetadata",
}) as any as S.Schema<ReadIamConnectionMetadata>;
export interface Theme {
  Arn?: string;
  Name?: string;
  ThemeId?: string;
  Version?: ThemeVersion;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  Type?: ThemeType;
}
export const Theme = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    Name: S.optional(S.String),
    ThemeId: S.optional(S.String),
    Version: S.optional(ThemeVersion),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Type: S.optional(ThemeType),
  }),
).annotations({ identifier: "Theme" }) as any as S.Schema<Theme>;
export interface AnonymousUserEmbeddingExperienceConfiguration {
  Dashboard?: AnonymousUserDashboardEmbeddingConfiguration;
  DashboardVisual?: AnonymousUserDashboardVisualEmbeddingConfiguration;
  QSearchBar?: AnonymousUserQSearchBarEmbeddingConfiguration;
  GenerativeQnA?: AnonymousUserGenerativeQnAEmbeddingConfiguration;
}
export const AnonymousUserEmbeddingExperienceConfiguration = S.suspend(() =>
  S.Struct({
    Dashboard: S.optional(AnonymousUserDashboardEmbeddingConfiguration),
    DashboardVisual: S.optional(
      AnonymousUserDashboardVisualEmbeddingConfiguration,
    ),
    QSearchBar: S.optional(AnonymousUserQSearchBarEmbeddingConfiguration),
    GenerativeQnA: S.optional(AnonymousUserGenerativeQnAEmbeddingConfiguration),
  }),
).annotations({
  identifier: "AnonymousUserEmbeddingExperienceConfiguration",
}) as any as S.Schema<AnonymousUserEmbeddingExperienceConfiguration>;
export interface CreateDashboardResponse {
  Arn?: string;
  VersionArn?: string;
  DashboardId?: string;
  CreationStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const CreateDashboardResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionArn: S.optional(S.String),
    DashboardId: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateDashboardResponse",
}) as any as S.Schema<CreateDashboardResponse>;
export interface CreateDataSourceResponse {
  Arn?: string;
  DataSourceId?: string;
  CreationStatus?: ResourceStatus;
  RequestId?: string;
  Status?: number;
}
export const CreateDataSourceResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSourceId: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateDataSourceResponse",
}) as any as S.Schema<CreateDataSourceResponse>;
export interface CreateRefreshScheduleResponse {
  Status?: number;
  RequestId?: string;
  ScheduleId?: string;
  Arn?: string;
}
export const CreateRefreshScheduleResponse = S.suspend(() =>
  S.Struct({
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
    ScheduleId: S.optional(S.String),
    Arn: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateRefreshScheduleResponse",
}) as any as S.Schema<CreateRefreshScheduleResponse>;
export interface CreateTemplateRequest {
  AwsAccountId: string;
  TemplateId: string;
  Name?: string;
  Permissions?: ResourcePermission[];
  SourceEntity?: TemplateSourceEntity;
  Tags?: Tag[];
  VersionDescription?: string;
  Definition?: TemplateVersionDefinition;
  ValidationStrategy?: ValidationStrategy;
}
export const CreateTemplateRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TemplateId: S.String.pipe(T.HttpLabel("TemplateId")),
    Name: S.optional(S.String),
    Permissions: S.optional(ResourcePermissionList),
    SourceEntity: S.optional(TemplateSourceEntity),
    Tags: S.optional(TagList),
    VersionDescription: S.optional(S.String),
    Definition: S.optional(TemplateVersionDefinition),
    ValidationStrategy: S.optional(ValidationStrategy),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/templates/{TemplateId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateTemplateRequest",
}) as any as S.Schema<CreateTemplateRequest>;
export interface CreateThemeRequest {
  AwsAccountId: string;
  ThemeId: string;
  Name: string;
  BaseThemeId: string;
  VersionDescription?: string;
  Configuration: ThemeConfiguration;
  Permissions?: ResourcePermission[];
  Tags?: Tag[];
}
export const CreateThemeRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ThemeId: S.String.pipe(T.HttpLabel("ThemeId")),
    Name: S.String,
    BaseThemeId: S.String,
    VersionDescription: S.optional(S.String),
    Configuration: ThemeConfiguration,
    Permissions: S.optional(ResourcePermissionList),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/themes/{ThemeId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateThemeRequest",
}) as any as S.Schema<CreateThemeRequest>;
export interface DescribeThemeResponse {
  Theme?: Theme;
  Status?: number;
  RequestId?: string;
}
export const DescribeThemeResponse = S.suspend(() =>
  S.Struct({
    Theme: S.optional(Theme),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "DescribeThemeResponse",
}) as any as S.Schema<DescribeThemeResponse>;
export interface GenerateEmbedUrlForAnonymousUserRequest {
  AwsAccountId: string;
  SessionLifetimeInMinutes?: number;
  Namespace: string;
  SessionTags?: SessionTag[];
  AuthorizedResourceArns: string[];
  ExperienceConfiguration: AnonymousUserEmbeddingExperienceConfiguration;
  AllowedDomains?: string[];
}
export const GenerateEmbedUrlForAnonymousUserRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    SessionLifetimeInMinutes: S.optional(S.Number),
    Namespace: S.String,
    SessionTags: S.optional(SessionTagList),
    AuthorizedResourceArns: ArnList,
    ExperienceConfiguration: AnonymousUserEmbeddingExperienceConfiguration,
    AllowedDomains: S.optional(StringList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/embed-url/anonymous-user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GenerateEmbedUrlForAnonymousUserRequest",
}) as any as S.Schema<GenerateEmbedUrlForAnonymousUserRequest>;
export interface PutDataSetRefreshPropertiesRequest {
  AwsAccountId: string;
  DataSetId: string;
  DataSetRefreshProperties: DataSetRefreshProperties;
}
export const PutDataSetRefreshPropertiesRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String.pipe(T.HttpLabel("DataSetId")),
    DataSetRefreshProperties: DataSetRefreshProperties,
  }).pipe(
    T.all(
      T.Http({
        method: "PUT",
        uri: "/accounts/{AwsAccountId}/data-sets/{DataSetId}/refresh-properties",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "PutDataSetRefreshPropertiesRequest",
}) as any as S.Schema<PutDataSetRefreshPropertiesRequest>;
export interface StartAssetBundleImportJobRequest {
  AwsAccountId: string;
  AssetBundleImportJobId: string;
  AssetBundleImportSource: AssetBundleImportSource;
  OverrideParameters?: AssetBundleImportJobOverrideParameters;
  FailureAction?: AssetBundleImportFailureAction;
  OverridePermissions?: AssetBundleImportJobOverridePermissions;
  OverrideTags?: AssetBundleImportJobOverrideTags;
  OverrideValidationStrategy?: AssetBundleImportJobOverrideValidationStrategy;
}
export const StartAssetBundleImportJobRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AssetBundleImportJobId: S.String,
    AssetBundleImportSource: AssetBundleImportSource,
    OverrideParameters: S.optional(AssetBundleImportJobOverrideParameters),
    FailureAction: S.optional(AssetBundleImportFailureAction),
    OverridePermissions: S.optional(AssetBundleImportJobOverridePermissions),
    OverrideTags: S.optional(AssetBundleImportJobOverrideTags),
    OverrideValidationStrategy: S.optional(
      AssetBundleImportJobOverrideValidationStrategy,
    ),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/asset-bundle-import-jobs/import",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartAssetBundleImportJobRequest",
}) as any as S.Schema<StartAssetBundleImportJobRequest>;
export interface StartDashboardSnapshotJobRequest {
  AwsAccountId: string;
  DashboardId: string;
  SnapshotJobId: string;
  UserConfiguration?: SnapshotUserConfiguration;
  SnapshotConfiguration: SnapshotConfiguration;
}
export const StartDashboardSnapshotJobRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DashboardId: S.String.pipe(T.HttpLabel("DashboardId")),
    SnapshotJobId: S.String,
    UserConfiguration: S.optional(SnapshotUserConfiguration),
    SnapshotConfiguration: SnapshotConfiguration,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/dashboards/{DashboardId}/snapshot-jobs",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "StartDashboardSnapshotJobRequest",
}) as any as S.Schema<StartDashboardSnapshotJobRequest>;
export interface CreateTopicReviewedAnswer {
  AnswerId: string;
  DatasetArn: string;
  Question: string;
  Mir?: TopicIR;
  PrimaryVisual?: TopicVisual;
  Template?: TopicTemplate;
}
export const CreateTopicReviewedAnswer = S.suspend(() =>
  S.Struct({
    AnswerId: S.String,
    DatasetArn: S.String,
    Question: S.String,
    Mir: S.optional(TopicIR),
    PrimaryVisual: S.optional(TopicVisual),
    Template: S.optional(TopicTemplate),
  }),
).annotations({
  identifier: "CreateTopicReviewedAnswer",
}) as any as S.Schema<CreateTopicReviewedAnswer>;
export type CreateTopicReviewedAnswers = CreateTopicReviewedAnswer[];
export const CreateTopicReviewedAnswers = S.Array(CreateTopicReviewedAnswer);
export interface ReadAuthorizationCodeGrantDetails {
  ClientId: string;
  TokenEndpoint: string;
  AuthorizationEndpoint: string;
}
export const ReadAuthorizationCodeGrantDetails = S.suspend(() =>
  S.Struct({
    ClientId: S.String,
    TokenEndpoint: S.String,
    AuthorizationEndpoint: S.String,
  }),
).annotations({
  identifier: "ReadAuthorizationCodeGrantDetails",
}) as any as S.Schema<ReadAuthorizationCodeGrantDetails>;
export interface ReadClientCredentialsGrantDetails {
  ClientId: string;
  TokenEndpoint: string;
}
export const ReadClientCredentialsGrantDetails = S.suspend(() =>
  S.Struct({ ClientId: S.String, TokenEndpoint: S.String }),
).annotations({
  identifier: "ReadClientCredentialsGrantDetails",
}) as any as S.Schema<ReadClientCredentialsGrantDetails>;
export interface BatchCreateTopicReviewedAnswerRequest {
  AwsAccountId: string;
  TopicId: string;
  Answers: CreateTopicReviewedAnswer[];
}
export const BatchCreateTopicReviewedAnswerRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String.pipe(T.HttpLabel("TopicId")),
    Answers: CreateTopicReviewedAnswers,
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/topics/{TopicId}/batch-create-reviewed-answers",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "BatchCreateTopicReviewedAnswerRequest",
}) as any as S.Schema<BatchCreateTopicReviewedAnswerRequest>;
export interface CreateActionConnectorRequest {
  AwsAccountId: string;
  ActionConnectorId: string;
  Name: string | redacted.Redacted<string>;
  Type: ActionConnectorType;
  AuthenticationConfig: AuthConfig;
  Description?: string | redacted.Redacted<string>;
  Permissions?: ResourcePermission[];
  VpcConnectionArn?: string;
  Tags?: Tag[];
}
export const CreateActionConnectorRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    ActionConnectorId: S.String,
    Name: SensitiveString,
    Type: ActionConnectorType,
    AuthenticationConfig: AuthConfig,
    Description: S.optional(SensitiveString),
    Permissions: S.optional(ResourcePermissionList),
    VpcConnectionArn: S.optional(S.String),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/action-connectors",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateActionConnectorRequest",
}) as any as S.Schema<CreateActionConnectorRequest>;
export interface CreateTemplateResponse {
  Arn?: string;
  VersionArn?: string;
  TemplateId?: string;
  CreationStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const CreateTemplateResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionArn: S.optional(S.String),
    TemplateId: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateTemplateResponse",
}) as any as S.Schema<CreateTemplateResponse>;
export interface CreateThemeResponse {
  Arn?: string;
  VersionArn?: string;
  ThemeId?: string;
  CreationStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const CreateThemeResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    VersionArn: S.optional(S.String),
    ThemeId: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateThemeResponse",
}) as any as S.Schema<CreateThemeResponse>;
export type ReadAuthorizationCodeGrantCredentialsDetails = {
  ReadAuthorizationCodeGrantDetails: ReadAuthorizationCodeGrantDetails;
};
export const ReadAuthorizationCodeGrantCredentialsDetails = S.Union(
  S.Struct({
    ReadAuthorizationCodeGrantDetails: ReadAuthorizationCodeGrantDetails,
  }),
);
export type ReadClientCredentialsDetails = {
  ReadClientCredentialsGrantDetails: ReadClientCredentialsGrantDetails;
};
export const ReadClientCredentialsDetails = S.Union(
  S.Struct({
    ReadClientCredentialsGrantDetails: ReadClientCredentialsGrantDetails,
  }),
);
export interface GenerateEmbedUrlForAnonymousUserResponse {
  EmbedUrl: string | redacted.Redacted<string>;
  Status: number;
  RequestId: string;
  AnonymousUserArn: string;
}
export const GenerateEmbedUrlForAnonymousUserResponse = S.suspend(() =>
  S.Struct({
    EmbedUrl: SensitiveString,
    Status: S.Number.pipe(T.HttpResponseCode()),
    RequestId: S.String,
    AnonymousUserArn: S.String,
  }),
).annotations({
  identifier: "GenerateEmbedUrlForAnonymousUserResponse",
}) as any as S.Schema<GenerateEmbedUrlForAnonymousUserResponse>;
export interface GenerateEmbedUrlForRegisteredUserRequest {
  AwsAccountId: string;
  SessionLifetimeInMinutes?: number;
  UserArn: string;
  ExperienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration;
  AllowedDomains?: string[];
}
export const GenerateEmbedUrlForRegisteredUserRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    SessionLifetimeInMinutes: S.optional(S.Number),
    UserArn: S.String,
    ExperienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration,
    AllowedDomains: S.optional(StringList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/embed-url/registered-user",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "GenerateEmbedUrlForRegisteredUserRequest",
}) as any as S.Schema<GenerateEmbedUrlForRegisteredUserRequest>;
export interface PutDataSetRefreshPropertiesResponse {
  RequestId?: string;
  Status?: number;
}
export const PutDataSetRefreshPropertiesResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "PutDataSetRefreshPropertiesResponse",
}) as any as S.Schema<PutDataSetRefreshPropertiesResponse>;
export interface StartAssetBundleImportJobResponse {
  Arn?: string;
  AssetBundleImportJobId?: string;
  RequestId?: string;
  Status?: number;
}
export const StartAssetBundleImportJobResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AssetBundleImportJobId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "StartAssetBundleImportJobResponse",
}) as any as S.Schema<StartAssetBundleImportJobResponse>;
export interface StartDashboardSnapshotJobResponse {
  Arn?: string;
  SnapshotJobId?: string;
  RequestId?: string;
  Status?: number;
}
export const StartDashboardSnapshotJobResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    SnapshotJobId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "StartDashboardSnapshotJobResponse",
}) as any as S.Schema<StartDashboardSnapshotJobResponse>;
export interface AnonymousUserSnapshotJobResult {
  FileGroups?: SnapshotJobResultFileGroup[];
}
export const AnonymousUserSnapshotJobResult = S.suspend(() =>
  S.Struct({ FileGroups: S.optional(SnapshotJobResultFileGroupList) }),
).annotations({
  identifier: "AnonymousUserSnapshotJobResult",
}) as any as S.Schema<AnonymousUserSnapshotJobResult>;
export type AnonymousUserSnapshotJobResultList =
  AnonymousUserSnapshotJobResult[];
export const AnonymousUserSnapshotJobResultList = S.Array(
  AnonymousUserSnapshotJobResult,
);
export interface ReadAuthorizationCodeGrantMetadata {
  BaseEndpoint: string;
  RedirectUrl: string;
  ReadAuthorizationCodeGrantCredentialsDetails?: ReadAuthorizationCodeGrantCredentialsDetails;
  AuthorizationCodeGrantCredentialsSource?: AuthorizationCodeGrantCredentialsSource;
}
export const ReadAuthorizationCodeGrantMetadata = S.suspend(() =>
  S.Struct({
    BaseEndpoint: S.String,
    RedirectUrl: S.String,
    ReadAuthorizationCodeGrantCredentialsDetails: S.optional(
      ReadAuthorizationCodeGrantCredentialsDetails,
    ),
    AuthorizationCodeGrantCredentialsSource: S.optional(
      AuthorizationCodeGrantCredentialsSource,
    ),
  }),
).annotations({
  identifier: "ReadAuthorizationCodeGrantMetadata",
}) as any as S.Schema<ReadAuthorizationCodeGrantMetadata>;
export interface ReadClientCredentialsGrantMetadata {
  BaseEndpoint: string;
  ReadClientCredentialsDetails?: ReadClientCredentialsDetails;
  ClientCredentialsSource?: ClientCredentialsSource;
}
export const ReadClientCredentialsGrantMetadata = S.suspend(() =>
  S.Struct({
    BaseEndpoint: S.String,
    ReadClientCredentialsDetails: S.optional(ReadClientCredentialsDetails),
    ClientCredentialsSource: S.optional(ClientCredentialsSource),
  }),
).annotations({
  identifier: "ReadClientCredentialsGrantMetadata",
}) as any as S.Schema<ReadClientCredentialsGrantMetadata>;
export interface SnapshotJobResult {
  AnonymousUsers?: AnonymousUserSnapshotJobResult[];
  RegisteredUsers?: RegisteredUserSnapshotJobResult[];
}
export const SnapshotJobResult = S.suspend(() =>
  S.Struct({
    AnonymousUsers: S.optional(AnonymousUserSnapshotJobResultList),
    RegisteredUsers: S.optional(RegisteredUserSnapshotJobResultList),
  }),
).annotations({
  identifier: "SnapshotJobResult",
}) as any as S.Schema<SnapshotJobResult>;
export type ReadAuthenticationMetadata =
  | { AuthorizationCodeGrantMetadata: ReadAuthorizationCodeGrantMetadata }
  | { ClientCredentialsGrantMetadata: ReadClientCredentialsGrantMetadata }
  | { BasicAuthConnectionMetadata: ReadBasicAuthConnectionMetadata }
  | { ApiKeyConnectionMetadata: ReadAPIKeyConnectionMetadata }
  | { NoneConnectionMetadata: ReadNoneConnectionMetadata }
  | { IamConnectionMetadata: ReadIamConnectionMetadata };
export const ReadAuthenticationMetadata = S.Union(
  S.Struct({
    AuthorizationCodeGrantMetadata: ReadAuthorizationCodeGrantMetadata,
  }),
  S.Struct({
    ClientCredentialsGrantMetadata: ReadClientCredentialsGrantMetadata,
  }),
  S.Struct({ BasicAuthConnectionMetadata: ReadBasicAuthConnectionMetadata }),
  S.Struct({ ApiKeyConnectionMetadata: ReadAPIKeyConnectionMetadata }),
  S.Struct({ NoneConnectionMetadata: ReadNoneConnectionMetadata }),
  S.Struct({ IamConnectionMetadata: ReadIamConnectionMetadata }),
);
export interface BatchCreateTopicReviewedAnswerResponse {
  TopicId?: string;
  TopicArn?: string;
  SucceededAnswers?: SucceededTopicReviewedAnswer[];
  InvalidAnswers?: InvalidTopicReviewedAnswer[];
  Status?: number;
  RequestId?: string;
}
export const BatchCreateTopicReviewedAnswerResponse = S.suspend(() =>
  S.Struct({
    TopicId: S.optional(S.String),
    TopicArn: S.optional(S.String),
    SucceededAnswers: S.optional(SucceededTopicReviewedAnswers),
    InvalidAnswers: S.optional(InvalidTopicReviewedAnswers),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "BatchCreateTopicReviewedAnswerResponse",
}) as any as S.Schema<BatchCreateTopicReviewedAnswerResponse>;
export interface CreateActionConnectorResponse {
  Arn?: string;
  CreationStatus?: ResourceStatus;
  ActionConnectorId?: string;
  RequestId?: string;
  Status?: number;
}
export const CreateActionConnectorResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    ActionConnectorId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateActionConnectorResponse",
}) as any as S.Schema<CreateActionConnectorResponse>;
export interface CreateBrandRequest {
  AwsAccountId: string;
  BrandId: string;
  BrandDefinition?: BrandDefinition;
  Tags?: Tag[];
}
export const CreateBrandRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    BrandId: S.String.pipe(T.HttpLabel("BrandId")),
    BrandDefinition: S.optional(BrandDefinition),
    Tags: S.optional(TagList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/brands/{BrandId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateBrandRequest",
}) as any as S.Schema<CreateBrandRequest>;
export interface CreateTopicRequest {
  AwsAccountId: string;
  TopicId: string;
  Topic: TopicDetails;
  Tags?: Tag[];
  FolderArns?: string[];
  CustomInstructions?: CustomInstructions;
}
export const CreateTopicRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    TopicId: S.String,
    Topic: TopicDetails,
    Tags: S.optional(TagList),
    FolderArns: S.optional(FolderArnList),
    CustomInstructions: S.optional(CustomInstructions),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/accounts/{AwsAccountId}/topics" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateTopicRequest",
}) as any as S.Schema<CreateTopicRequest>;
export interface DescribeBrandResponse {
  RequestId?: string;
  BrandDetail?: BrandDetail;
  BrandDefinition?: BrandDefinition;
}
export const DescribeBrandResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    BrandDetail: S.optional(BrandDetail),
    BrandDefinition: S.optional(BrandDefinition),
  }),
).annotations({
  identifier: "DescribeBrandResponse",
}) as any as S.Schema<DescribeBrandResponse>;
export interface DescribeDashboardSnapshotJobResultResponse {
  Arn?: string;
  JobStatus?: SnapshotJobStatus;
  CreatedTime?: Date;
  LastUpdatedTime?: Date;
  Result?: SnapshotJobResult;
  ErrorInfo?: SnapshotJobErrorInfo;
  RequestId?: string;
  Status?: number;
}
export const DescribeDashboardSnapshotJobResultResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    JobStatus: S.optional(SnapshotJobStatus),
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.optional(
      S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    ),
    Result: S.optional(SnapshotJobResult),
    ErrorInfo: S.optional(SnapshotJobErrorInfo),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeDashboardSnapshotJobResultResponse",
}) as any as S.Schema<DescribeDashboardSnapshotJobResultResponse>;
export interface GenerateEmbedUrlForRegisteredUserResponse {
  EmbedUrl: string | redacted.Redacted<string>;
  Status: number;
  RequestId: string;
}
export const GenerateEmbedUrlForRegisteredUserResponse = S.suspend(() =>
  S.Struct({
    EmbedUrl: SensitiveString,
    Status: S.Number.pipe(T.HttpResponseCode()),
    RequestId: S.String,
  }),
).annotations({
  identifier: "GenerateEmbedUrlForRegisteredUserResponse",
}) as any as S.Schema<GenerateEmbedUrlForRegisteredUserResponse>;
export interface ReadAuthConfig {
  AuthenticationType: ConnectionAuthType;
  AuthenticationMetadata: ReadAuthenticationMetadata;
}
export const ReadAuthConfig = S.suspend(() =>
  S.Struct({
    AuthenticationType: ConnectionAuthType,
    AuthenticationMetadata: ReadAuthenticationMetadata,
  }),
).annotations({
  identifier: "ReadAuthConfig",
}) as any as S.Schema<ReadAuthConfig>;
export interface ActionConnector {
  Arn: string;
  ActionConnectorId: string;
  Type: ActionConnectorType;
  Name: string | redacted.Redacted<string>;
  CreatedTime?: Date;
  LastUpdatedTime: Date;
  Status?: ResourceStatus;
  Error?: ActionConnectorError;
  Description?: string | redacted.Redacted<string>;
  AuthenticationConfig?: ReadAuthConfig;
  EnabledActions?: string[];
  VpcConnectionArn?: string;
}
export const ActionConnector = S.suspend(() =>
  S.Struct({
    Arn: S.String,
    ActionConnectorId: S.String,
    Type: ActionConnectorType,
    Name: SensitiveString,
    CreatedTime: S.optional(S.Date.pipe(T.TimestampFormat("epoch-seconds"))),
    LastUpdatedTime: S.Date.pipe(T.TimestampFormat("epoch-seconds")),
    Status: S.optional(ResourceStatus),
    Error: S.optional(ActionConnectorError),
    Description: S.optional(SensitiveString),
    AuthenticationConfig: S.optional(ReadAuthConfig),
    EnabledActions: S.optional(ActionIdList),
    VpcConnectionArn: S.optional(S.String),
  }),
).annotations({
  identifier: "ActionConnector",
}) as any as S.Schema<ActionConnector>;
export interface CreateBrandResponse {
  RequestId?: string;
  BrandDetail?: BrandDetail;
  BrandDefinition?: BrandDefinition;
}
export const CreateBrandResponse = S.suspend(() =>
  S.Struct({
    RequestId: S.optional(S.String),
    BrandDetail: S.optional(BrandDetail),
    BrandDefinition: S.optional(BrandDefinition),
  }),
).annotations({
  identifier: "CreateBrandResponse",
}) as any as S.Schema<CreateBrandResponse>;
export interface CreateDataSetRequest {
  AwsAccountId: string;
  DataSetId: string;
  Name: string;
  PhysicalTableMap: { [key: string]: PhysicalTable };
  LogicalTableMap?: { [key: string]: LogicalTable };
  ImportMode: DataSetImportMode;
  ColumnGroups?: ColumnGroup[];
  FieldFolders?: { [key: string]: FieldFolder };
  Permissions?: ResourcePermission[];
  RowLevelPermissionDataSet?: RowLevelPermissionDataSet;
  RowLevelPermissionTagConfiguration?: RowLevelPermissionTagConfiguration;
  ColumnLevelPermissionRules?: ColumnLevelPermissionRule[];
  Tags?: Tag[];
  DataSetUsageConfiguration?: DataSetUsageConfiguration;
  DatasetParameters?: DatasetParameter[];
  FolderArns?: string[];
  PerformanceConfiguration?: PerformanceConfiguration;
  UseAs?: DataSetUseAs;
  DataPrepConfiguration?: DataPrepConfiguration;
  SemanticModelConfiguration?: SemanticModelConfiguration;
}
export const CreateDataSetRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    DataSetId: S.String,
    Name: S.String,
    PhysicalTableMap: PhysicalTableMap,
    LogicalTableMap: S.optional(LogicalTableMap),
    ImportMode: DataSetImportMode,
    ColumnGroups: S.optional(ColumnGroupList),
    FieldFolders: S.optional(FieldFolderMap),
    Permissions: S.optional(ResourcePermissionList),
    RowLevelPermissionDataSet: S.optional(RowLevelPermissionDataSet),
    RowLevelPermissionTagConfiguration: S.optional(
      RowLevelPermissionTagConfiguration,
    ),
    ColumnLevelPermissionRules: S.optional(ColumnLevelPermissionRuleList),
    Tags: S.optional(TagList),
    DataSetUsageConfiguration: S.optional(DataSetUsageConfiguration),
    DatasetParameters: S.optional(DatasetParameterList),
    FolderArns: S.optional(FolderArnList),
    PerformanceConfiguration: S.optional(PerformanceConfiguration),
    UseAs: S.optional(DataSetUseAs),
    DataPrepConfiguration: S.optional(DataPrepConfiguration),
    SemanticModelConfiguration: S.optional(SemanticModelConfiguration),
  }).pipe(
    T.all(
      T.Http({ method: "POST", uri: "/accounts/{AwsAccountId}/data-sets" }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateDataSetRequest",
}) as any as S.Schema<CreateDataSetRequest>;
export interface CreateTopicResponse {
  Arn?: string;
  TopicId?: string;
  RefreshArn?: string;
  RequestId?: string;
  Status?: number;
}
export const CreateTopicResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    TopicId: S.optional(S.String),
    RefreshArn: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateTopicResponse",
}) as any as S.Schema<CreateTopicResponse>;
export interface DescribeActionConnectorResponse {
  ActionConnector?: ActionConnector;
  RequestId?: string;
  Status?: number;
}
export const DescribeActionConnectorResponse = S.suspend(() =>
  S.Struct({
    ActionConnector: S.optional(ActionConnector),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "DescribeActionConnectorResponse",
}) as any as S.Schema<DescribeActionConnectorResponse>;
export interface CreateDataSetResponse {
  Arn?: string;
  DataSetId?: string;
  IngestionArn?: string;
  IngestionId?: string;
  RequestId?: string;
  Status?: number;
}
export const CreateDataSetResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    DataSetId: S.optional(S.String),
    IngestionArn: S.optional(S.String),
    IngestionId: S.optional(S.String),
    RequestId: S.optional(S.String),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
  }),
).annotations({
  identifier: "CreateDataSetResponse",
}) as any as S.Schema<CreateDataSetResponse>;
export interface CreateAnalysisRequest {
  AwsAccountId: string;
  AnalysisId: string;
  Name: string;
  Parameters?: Parameters;
  Permissions?: ResourcePermission[];
  SourceEntity?: AnalysisSourceEntity;
  ThemeArn?: string;
  Tags?: Tag[];
  Definition?: AnalysisDefinition;
  ValidationStrategy?: ValidationStrategy;
  FolderArns?: string[];
}
export const CreateAnalysisRequest = S.suspend(() =>
  S.Struct({
    AwsAccountId: S.String.pipe(T.HttpLabel("AwsAccountId")),
    AnalysisId: S.String.pipe(T.HttpLabel("AnalysisId")),
    Name: S.String,
    Parameters: S.optional(Parameters),
    Permissions: S.optional(ResourcePermissionList),
    SourceEntity: S.optional(AnalysisSourceEntity),
    ThemeArn: S.optional(S.String),
    Tags: S.optional(TagList),
    Definition: S.optional(AnalysisDefinition),
    ValidationStrategy: S.optional(ValidationStrategy),
    FolderArns: S.optional(FolderArnList),
  }).pipe(
    T.all(
      T.Http({
        method: "POST",
        uri: "/accounts/{AwsAccountId}/analyses/{AnalysisId}",
      }),
      svc,
      auth,
      proto,
      ver,
      rules,
    ),
  ),
).annotations({
  identifier: "CreateAnalysisRequest",
}) as any as S.Schema<CreateAnalysisRequest>;
export interface CreateAnalysisResponse {
  Arn?: string;
  AnalysisId?: string;
  CreationStatus?: ResourceStatus;
  Status?: number;
  RequestId?: string;
}
export const CreateAnalysisResponse = S.suspend(() =>
  S.Struct({
    Arn: S.optional(S.String),
    AnalysisId: S.optional(S.String),
    CreationStatus: S.optional(ResourceStatus),
    Status: S.optional(S.Number).pipe(T.HttpResponseCode()),
    RequestId: S.optional(S.String),
  }),
).annotations({
  identifier: "CreateAnalysisResponse",
}) as any as S.Schema<CreateAnalysisResponse>;

//# Errors
export class AccessDeniedException extends S.TaggedError<AccessDeniedException>()(
  "AccessDeniedException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withAuthError) {}
export class ConflictException extends S.TaggedError<ConflictException>()(
  "ConflictException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withConflictError) {}
export class InternalFailureException extends S.TaggedError<InternalFailureException>()(
  "InternalFailureException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withServerError) {}
export class ConcurrentUpdatingException extends S.TaggedError<ConcurrentUpdatingException>()(
  "ConcurrentUpdatingException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withServerError) {}
export class InvalidParameterValueException extends S.TaggedError<InvalidParameterValueException>()(
  "InvalidParameterValueException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class ResourceNotFoundException extends S.TaggedError<ResourceNotFoundException>()(
  "ResourceNotFoundException",
  {
    Message: S.optional(S.String),
    ResourceType: S.optional(ExceptionResourceType),
    RequestId: S.optional(S.String),
  },
).pipe(C.withBadRequestError) {}
export class InvalidNextTokenException extends S.TaggedError<InvalidNextTokenException>()(
  "InvalidNextTokenException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class InvalidParameterException extends S.TaggedError<InvalidParameterException>()(
  "InvalidParameterException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class InternalServerException extends S.TaggedError<InternalServerException>()(
  "InternalServerException",
  { Message: S.String },
).pipe(C.withServerError) {}
export class DomainNotWhitelistedException extends S.TaggedError<DomainNotWhitelistedException>()(
  "DomainNotWhitelistedException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withAuthError) {}
export class InvalidDataSetParameterValueException extends S.TaggedError<InvalidDataSetParameterValueException>()(
  "InvalidDataSetParameterValueException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class CustomerManagedKeyUnavailableException extends S.TaggedError<CustomerManagedKeyUnavailableException>()(
  "CustomerManagedKeyUnavailableException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class LimitExceededException extends S.TaggedError<LimitExceededException>()(
  "LimitExceededException",
  {
    Message: S.optional(S.String),
    ResourceType: S.optional(ExceptionResourceType),
    RequestId: S.optional(S.String),
  },
).pipe(C.withConflictError) {}
export class ThrottlingException extends S.TaggedError<ThrottlingException>()(
  "ThrottlingException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withThrottlingError) {}
export class ResourceExistsException extends S.TaggedError<ResourceExistsException>()(
  "ResourceExistsException",
  {
    Message: S.optional(S.String),
    ResourceType: S.optional(ExceptionResourceType),
    RequestId: S.optional(S.String),
  },
).pipe(C.withConflictError) {}
export class ResourceUnavailableException extends S.TaggedError<ResourceUnavailableException>()(
  "ResourceUnavailableException",
  {
    Message: S.optional(S.String),
    ResourceType: S.optional(ExceptionResourceType),
    RequestId: S.optional(S.String),
  },
).pipe(C.withServerError) {}
export class PreconditionNotMetException extends S.TaggedError<PreconditionNotMetException>()(
  "PreconditionNotMetException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class InvalidRequestException extends S.TaggedError<InvalidRequestException>()(
  "InvalidRequestException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class IdentityTypeNotSupportedException extends S.TaggedError<IdentityTypeNotSupportedException>()(
  "IdentityTypeNotSupportedException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withAuthError) {}
export class QuickSightUserNotFoundException extends S.TaggedError<QuickSightUserNotFoundException>()(
  "QuickSightUserNotFoundException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class UnsupportedUserEditionException extends S.TaggedError<UnsupportedUserEditionException>()(
  "UnsupportedUserEditionException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withAuthError) {}
export class SessionLifetimeInMinutesInvalidException extends S.TaggedError<SessionLifetimeInMinutesInvalidException>()(
  "SessionLifetimeInMinutesInvalidException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withBadRequestError) {}
export class UnsupportedPricingPlanException extends S.TaggedError<UnsupportedPricingPlanException>()(
  "UnsupportedPricingPlanException",
  { Message: S.optional(S.String), RequestId: S.optional(S.String) },
).pipe(C.withAuthError) {}

//# Operations
/**
 * Describes a SPICE ingestion.
 */
export const describeIngestion: (
  input: DescribeIngestionRequest,
) => effect.Effect<
  DescribeIngestionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIngestionRequest,
  output: DescribeIngestionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the current namespace.
 */
export const describeNamespace: (
  input: DescribeNamespaceRequest,
) => effect.Effect<
  DescribeNamespaceResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeNamespaceRequest,
  output: DescribeNamespaceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Describes the self-upgrade configuration for a Quick Suite account.
 */
export const describeSelfUpgradeConfiguration: (
  input: DescribeSelfUpgradeConfigurationRequest,
) => effect.Effect<
  DescribeSelfUpgradeConfigurationResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeSelfUpgradeConfigurationRequest,
  output: DescribeSelfUpgradeConfigurationResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Lists all brands in an Quick Sight account.
 */
export const listBrands: {
  (
    input: ListBrandsRequest,
  ): effect.Effect<
    ListBrandsResponse,
    | AccessDeniedException
    | InternalServerException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListBrandsRequest,
  ) => stream.Stream<
    ListBrandsResponse,
    | AccessDeniedException
    | InternalServerException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListBrandsRequest,
  ) => stream.Stream<
    BrandSummary,
    | AccessDeniedException
    | InternalServerException
    | InvalidRequestException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListBrandsRequest,
  output: ListBrandsResponse,
  errors: [
    AccessDeniedException,
    InternalServerException,
    InvalidRequestException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Brands",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Describes a dataset. This operation doesn't support datasets that include uploaded
 * files as a source.
 */
export const describeDataSet: (
  input: DescribeDataSetRequest,
) => effect.Effect<
  DescribeDataSetResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataSetRequest,
  output: DescribeDataSetResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes a data source.
 */
export const describeDataSource: (
  input: DescribeDataSourceRequest,
) => effect.Effect<
  DescribeDataSourceResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataSourceRequest,
  output: DescribeDataSourceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes an existing IAM policy assignment, as specified by the
 * assignment name.
 */
export const describeIAMPolicyAssignment: (
  input: DescribeIAMPolicyAssignmentRequest,
) => effect.Effect<
  DescribeIAMPolicyAssignmentResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidNextTokenException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIAMPolicyAssignmentRequest,
  output: DescribeIAMPolicyAssignmentResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists all of the datasets belonging to the current Amazon Web Services account in an
 * Amazon Web Services Region.
 *
 * The permissions resource is
 * `arn:aws:quicksight:region:aws-account-id:dataset/*`.
 */
export const listDataSets: {
  (
    input: ListDataSetsRequest,
  ): effect.Effect<
    ListDataSetsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDataSetsRequest,
  ) => stream.Stream<
    ListDataSetsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataSetsRequest,
  ) => stream.Stream<
    DataSetSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataSetsRequest,
  output: ListDataSetsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataSetSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Predicts existing visuals or generates new visuals to answer a given query.
 *
 * This API uses trusted identity propagation to ensure that an end user is authenticated and receives the embed URL that is specific to that user. The IAM Identity Center application that the user has logged into needs to have trusted Identity Propagation enabled for Quick Suite with the scope value set to `quicksight:read`. Before you use this action, make sure that you have configured the relevant Quick Suite resource and permissions.
 *
 * We recommend enabling the `QSearchStatus` API to unlock the full potential of `PredictQnA`. When `QSearchStatus` is enabled, it first checks the specified dashboard for any existing visuals that match the question. If no matching visuals are found, `PredictQnA` uses generative Q&A to provide an answer. To update the `QSearchStatus`, see UpdateQuickSightQSearchConfiguration.
 */
export const predictQAResults: (
  input: PredictQAResultsRequest,
) => effect.Effect<
  PredictQAResultsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PredictQAResultsRequest,
  output: PredictQAResultsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
}));
/**
 * Use the `SearchDataSources` operation to search for data sources that
 * belong to an account.
 */
export const searchDataSources: {
  (
    input: SearchDataSourcesRequest,
  ): effect.Effect<
    SearchDataSourcesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchDataSourcesRequest,
  ) => stream.Stream<
    SearchDataSourcesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchDataSourcesRequest,
  ) => stream.Stream<
    DataSourceSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchDataSourcesRequest,
  output: SearchDataSourcesResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataSourceSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Updates a customer managed key in a Quick Sight account.
 */
export const updateKeyRegistration: (
  input: UpdateKeyRegistrationRequest,
) => effect.Effect<
  UpdateKeyRegistrationResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateKeyRegistrationRequest,
  output: UpdateKeyRegistrationResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
}));
/**
 * Updates a data source.
 */
export const updateDataSource: (
  input: UpdateDataSourceRequest,
) => effect.Effect<
  UpdateDataSourceResponse,
  | AccessDeniedException
  | ConflictException
  | CustomerManagedKeyUnavailableException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataSourceRequest,
  output: UpdateDataSourceResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    CustomerManagedKeyUnavailableException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes all customer managed key registrations in a Quick Sight account.
 */
export const describeKeyRegistration: (
  input: DescribeKeyRegistrationRequest,
) => effect.Effect<
  DescribeKeyRegistrationResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeKeyRegistrationRequest,
  output: DescribeKeyRegistrationResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
}));
/**
 * Describes the status of a topic refresh.
 */
export const describeTopicRefresh: (
  input: DescribeTopicRefreshRequest,
) => effect.Effect<
  DescribeTopicRefreshResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTopicRefreshRequest,
  output: DescribeTopicRefreshResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists flows in an Amazon Web Services account.
 */
export const listFlows: {
  (
    input: ListFlowsInput,
  ): effect.Effect<
    ListFlowsOutput,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListFlowsInput,
  ) => stream.Stream<
    ListFlowsOutput,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFlowsInput,
  ) => stream.Stream<
    FlowSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFlowsInput,
  output: ListFlowsOutput,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FlowSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all services and authorized targets that the Quick Sight IAM Identity Center application can access.
 *
 * This operation is only supported for Quick Sight accounts that use IAM Identity Center.
 */
export const listIdentityPropagationConfigs: (
  input: ListIdentityPropagationConfigsRequest,
) => effect.Effect<
  ListIdentityPropagationConfigsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListIdentityPropagationConfigsRequest,
  output: ListIdentityPropagationConfigsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists all reviewed answers for a Q Topic.
 */
export const listTopicReviewedAnswers: (
  input: ListTopicReviewedAnswersRequest,
) => effect.Effect<
  ListTopicReviewedAnswersResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListTopicReviewedAnswersRequest,
  output: ListTopicReviewedAnswersResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Search for the flows in an Amazon Web Services account.
 */
export const searchFlows: {
  (
    input: SearchFlowsInput,
  ): effect.Effect<
    SearchFlowsOutput,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchFlowsInput,
  ) => stream.Stream<
    SearchFlowsOutput,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchFlowsInput,
  ) => stream.Stream<
    FlowSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchFlowsInput,
  output: SearchFlowsOutput,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FlowSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Updates permissions against principals on a flow.
 */
export const updateFlowPermissions: (
  input: UpdateFlowPermissionsInput,
) => effect.Effect<
  UpdateFlowPermissionsOutput,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateFlowPermissionsInput,
  output: UpdateFlowPermissionsOutput,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
}));
/**
 * Updates the content and status of IP rules. Traffic from a source is allowed when the source satisfies either the `IpRestrictionRule`, `VpcIdRestrictionRule`, or `VpcEndpointIdRestrictionRule`. To use this operation, you must provide the entire map of rules. You can use the `DescribeIpRestriction` operation to get the current rule map.
 */
export const updateIpRestriction: (
  input: UpdateIpRestrictionRequest,
) => effect.Effect<
  UpdateIpRestrictionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateIpRestrictionRequest,
  output: UpdateIpRestrictionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Unapplies a custom permissions profile from an account.
 */
export const deleteAccountCustomPermission: (
  input: DeleteAccountCustomPermissionRequest,
) => effect.Effect<
  DeleteAccountCustomPermissionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAccountCustomPermissionRequest,
  output: DeleteAccountCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Hard deletes an action connector, making it unrecoverable. This operation removes the connector and all its associated configurations. Any resources currently using this action connector will no longer be able to perform actions through it.
 */
export const deleteActionConnector: (
  input: DeleteActionConnectorRequest,
) => effect.Effect<
  DeleteActionConnectorResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteActionConnectorRequest,
  output: DeleteActionConnectorResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a dataset.
 */
export const deleteDataSet: (
  input: DeleteDataSetRequest,
) => effect.Effect<
  DeleteDataSetResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataSetRequest,
  output: DeleteDataSetResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes the dataset refresh properties of the dataset.
 */
export const deleteDataSetRefreshProperties: (
  input: DeleteDataSetRefreshPropertiesRequest,
) => effect.Effect<
  DeleteDataSetRefreshPropertiesResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataSetRefreshPropertiesRequest,
  output: DeleteDataSetRefreshPropertiesResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes the data source permanently. This operation breaks all the datasets that
 * reference the deleted data source.
 */
export const deleteDataSource: (
  input: DeleteDataSourceRequest,
) => effect.Effect<
  DeleteDataSourceResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDataSourceRequest,
  output: DeleteDataSourceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes all access scopes and authorized targets that are associated with a service from the Quick Sight IAM Identity Center application.
 *
 * This operation is only supported for Quick Sight accounts that use IAM Identity Center.
 */
export const deleteIdentityPropagationConfig: (
  input: DeleteIdentityPropagationConfigRequest,
) => effect.Effect<
  DeleteIdentityPropagationConfigResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIdentityPropagationConfigRequest,
  output: DeleteIdentityPropagationConfigResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a refresh schedule from a dataset.
 */
export const deleteRefreshSchedule: (
  input: DeleteRefreshScheduleRequest,
) => effect.Effect<
  DeleteRefreshScheduleResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRefreshScheduleRequest,
  output: DeleteRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a topic.
 */
export const deleteTopic: (
  input: DeleteTopicRequest,
) => effect.Effect<
  DeleteTopicResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTopicRequest,
  output: DeleteTopicResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the custom permissions profile that is applied to an account.
 */
export const describeAccountCustomPermission: (
  input: DescribeAccountCustomPermissionRequest,
) => effect.Effect<
  DescribeAccountCustomPermissionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAccountCustomPermissionRequest,
  output: DescribeAccountCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves the permissions configuration for an action connector, showing which users, groups, and namespaces have access and what operations they can perform.
 */
export const describeActionConnectorPermissions: (
  input: DescribeActionConnectorPermissionsRequest,
) => effect.Effect<
  DescribeActionConnectorPermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeActionConnectorPermissionsRequest,
  output: DescribeActionConnectorPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes an existing dashboard QA configuration.
 */
export const describeDashboardsQAConfiguration: (
  input: DescribeDashboardsQAConfigurationRequest,
) => effect.Effect<
  DescribeDashboardsQAConfigurationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDashboardsQAConfigurationRequest,
  output: DescribeDashboardsQAConfigurationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the permissions on a dataset.
 *
 * The permissions resource is
 * `arn:aws:quicksight:region:aws-account-id:dataset/data-set-id`.
 */
export const describeDataSetPermissions: (
  input: DescribeDataSetPermissionsRequest,
) => effect.Effect<
  DescribeDataSetPermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataSetPermissionsRequest,
  output: DescribeDataSetPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the resource permissions for a data source.
 */
export const describeDataSourcePermissions: (
  input: DescribeDataSourcePermissionsRequest,
) => effect.Effect<
  DescribeDataSourcePermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataSourcePermissionsRequest,
  output: DescribeDataSourcePermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes a Amazon Q Business application that is linked to an Quick Sight account.
 */
export const describeDefaultQBusinessApplication: (
  input: DescribeDefaultQBusinessApplicationRequest,
) => effect.Effect<
  DescribeDefaultQBusinessApplicationResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDefaultQBusinessApplicationRequest,
  output: DescribeDefaultQBusinessApplicationResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Provides a summary and status of IP rules.
 */
export const describeIpRestriction: (
  input: DescribeIpRestrictionRequest,
) => effect.Effect<
  DescribeIpRestrictionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeIpRestrictionRequest,
  output: DescribeIpRestrictionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes a personalization configuration.
 */
export const describeQPersonalizationConfiguration: (
  input: DescribeQPersonalizationConfigurationRequest,
) => effect.Effect<
  DescribeQPersonalizationConfigurationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeQPersonalizationConfigurationRequest,
  output: DescribeQPersonalizationConfigurationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the state of a Quick Sight Q Search configuration.
 */
export const describeQuickSightQSearchConfiguration: (
  input: DescribeQuickSightQSearchConfigurationRequest,
) => effect.Effect<
  DescribeQuickSightQSearchConfigurationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeQuickSightQSearchConfigurationRequest,
  output: DescribeQuickSightQSearchConfigurationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Provides a summary of a refresh schedule.
 */
export const describeRefreshSchedule: (
  input: DescribeRefreshScheduleRequest,
) => effect.Effect<
  DescribeRefreshScheduleResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeRefreshScheduleRequest,
  output: DescribeRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes a topic.
 */
export const describeTopic: (
  input: DescribeTopicRequest,
) => effect.Effect<
  DescribeTopicResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTopicRequest,
  output: DescribeTopicResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the permissions of a topic.
 */
export const describeTopicPermissions: (
  input: DescribeTopicPermissionsRequest,
) => effect.Effect<
  DescribeTopicPermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTopicPermissionsRequest,
  output: DescribeTopicPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves the metadata of a flow, not including its definition specifying the steps.
 */
export const getFlowMetadata: (
  input: GetFlowMetadataInput,
) => effect.Effect<
  GetFlowMetadataOutput,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetFlowMetadataInput,
  output: GetFlowMetadataOutput,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
}));
/**
 * Get permissions for a flow.
 */
export const getFlowPermissions: (
  input: GetFlowPermissionsInput,
) => effect.Effect<
  GetFlowPermissionsOutput,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetFlowPermissionsInput,
  output: GetFlowPermissionsOutput,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
}));
/**
 * Lists the refresh schedules of a dataset. Each dataset can have up to 5 schedules.
 */
export const listRefreshSchedules: (
  input: ListRefreshSchedulesRequest,
) => effect.Effect<
  ListRefreshSchedulesResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListRefreshSchedulesRequest,
  output: ListRefreshSchedulesResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists the tags assigned to a resource.
 */
export const listTagsForResource: (
  input: ListTagsForResourceRequest,
) => effect.Effect<
  ListTagsForResourceResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListTagsForResourceRequest,
  output: ListTagsForResourceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Assigns one or more tags (key-value pairs) to the specified Amazon Quick Sight
 * resource.
 *
 * Tags can help you organize and categorize your resources. You can also use them to
 * scope user permissions, by granting a user permission to access or change only resources
 * with certain tag values. You can use the `TagResource` operation with a
 * resource that already has tags. If you specify a new tag key for the resource, this tag
 * is appended to the list of tags associated with the resource. If you specify a tag key
 * that is already associated with the resource, the new tag value that you specify
 * replaces the previous value for that tag.
 *
 * You can associate as many as 50 tags with a resource. Amazon Quick Sight supports
 * tagging on data set, data source, dashboard, template, topic, and user.
 *
 * Tagging for Amazon Quick Sight works in a similar way to tagging for other Amazon Web Services services, except for the following:
 *
 * - Tags are used to track costs for users in Amazon Quick Sight. You can't
 * tag other resources that Amazon Quick Sight costs are based on, such as storage
 * capacoty (SPICE), session usage, alert consumption, or reporting units.
 *
 * - Amazon Quick Sight doesn't currently support the tag editor for Resource Groups.
 */
export const tagResource: (
  input: TagResourceRequest,
) => effect.Effect<
  TagResourceResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: TagResourceRequest,
  output: TagResourceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Removes a tag or tags from a resource.
 */
export const untagResource: (
  input: UntagResourceRequest,
) => effect.Effect<
  UntagResourceResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UntagResourceRequest,
  output: UntagResourceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Applies a custom permissions profile to an account.
 */
export const updateAccountCustomPermission: (
  input: UpdateAccountCustomPermissionRequest,
) => effect.Effect<
  UpdateAccountCustomPermissionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAccountCustomPermissionRequest,
  output: UpdateAccountCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates an existing action connector with new configuration details, authentication settings, or enabled actions.
 * You can modify the connector's name, description, authentication configuration, and which actions are enabled. For more information,
 * https://docs.aws.amazon.com/quicksuite/latest/userguide/quick-action-auth.html.
 */
export const updateActionConnector: (
  input: UpdateActionConnectorRequest,
) => effect.Effect<
  UpdateActionConnectorResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateActionConnectorRequest,
  output: UpdateActionConnectorResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a Dashboard QA configuration.
 */
export const updateDashboardsQAConfiguration: (
  input: UpdateDashboardsQAConfigurationRequest,
) => effect.Effect<
  UpdateDashboardsQAConfigurationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDashboardsQAConfigurationRequest,
  output: UpdateDashboardsQAConfigurationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the permissions on a dataset.
 *
 * The permissions resource is
 * `arn:aws:quicksight:region:aws-account-id:dataset/data-set-id`.
 */
export const updateDataSetPermissions: (
  input: UpdateDataSetPermissionsRequest,
) => effect.Effect<
  UpdateDataSetPermissionsResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataSetPermissionsRequest,
  output: UpdateDataSetPermissionsResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the permissions to a data source.
 */
export const updateDataSourcePermissions: (
  input: UpdateDataSourcePermissionsRequest,
) => effect.Effect<
  UpdateDataSourcePermissionsResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataSourcePermissionsRequest,
  output: UpdateDataSourcePermissionsResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a Amazon Q Business application that is linked to a Quick Sight account.
 */
export const updateDefaultQBusinessApplication: (
  input: UpdateDefaultQBusinessApplicationRequest,
) => effect.Effect<
  UpdateDefaultQBusinessApplicationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDefaultQBusinessApplicationRequest,
  output: UpdateDefaultQBusinessApplicationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Adds or updates services and authorized targets to configure what the Quick Sight IAM Identity Center application can access.
 *
 * This operation is only supported for Quick Sight accounts using IAM Identity Center
 */
export const updateIdentityPropagationConfig: (
  input: UpdateIdentityPropagationConfigRequest,
) => effect.Effect<
  UpdateIdentityPropagationConfigResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateIdentityPropagationConfigRequest,
  output: UpdateIdentityPropagationConfigResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the state of a Quick Sight Q Search configuration.
 */
export const updateQuickSightQSearchConfiguration: (
  input: UpdateQuickSightQSearchConfigurationRequest,
) => effect.Effect<
  UpdateQuickSightQSearchConfigurationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQuickSightQSearchConfigurationRequest,
  output: UpdateQuickSightQSearchConfigurationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the SPICE capacity configuration for a Quick Sight account.
 */
export const updateSPICECapacityConfiguration: (
  input: UpdateSPICECapacityConfigurationRequest,
) => effect.Effect<
  UpdateSPICECapacityConfigurationResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSPICECapacityConfigurationRequest,
  output: UpdateSPICECapacityConfigurationResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes reviewed answers for Q Topic.
 */
export const batchDeleteTopicReviewedAnswer: (
  input: BatchDeleteTopicReviewedAnswerRequest,
) => effect.Effect<
  BatchDeleteTopicReviewedAnswerResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchDeleteTopicReviewedAnswerRequest,
  output: BatchDeleteTopicReviewedAnswerResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a linked Amazon Q Business application from an Quick Sight account
 */
export const deleteDefaultQBusinessApplication: (
  input: DeleteDefaultQBusinessApplicationRequest,
) => effect.Effect<
  DeleteDefaultQBusinessApplicationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDefaultQBusinessApplicationRequest,
  output: DeleteDefaultQBusinessApplicationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists all action connectors in the specified Amazon Web Services account. Returns summary information for each connector including its name, type, creation time, and status.
 */
export const listActionConnectors: {
  (
    input: ListActionConnectorsRequest,
  ): effect.Effect<
    ListActionConnectorsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListActionConnectorsRequest,
  ) => stream.Stream<
    ListActionConnectorsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListActionConnectorsRequest,
  ) => stream.Stream<
    ActionConnectorSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListActionConnectorsRequest,
  output: ListActionConnectorsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ActionConnectorSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the
 * IAM policy assignments in the current Amazon Quick Sight
 * account.
 */
export const listIAMPolicyAssignments: {
  (
    input: ListIAMPolicyAssignmentsRequest,
  ): effect.Effect<
    ListIAMPolicyAssignmentsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListIAMPolicyAssignmentsRequest,
  ) => stream.Stream<
    ListIAMPolicyAssignmentsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListIAMPolicyAssignmentsRequest,
  ) => stream.Stream<
    IAMPolicyAssignmentSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListIAMPolicyAssignmentsRequest,
  output: ListIAMPolicyAssignmentsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "IAMPolicyAssignments",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all of the topics within an account.
 */
export const listTopics: {
  (
    input: ListTopicsRequest,
  ): effect.Effect<
    ListTopicsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTopicsRequest,
  ) => stream.Stream<
    ListTopicsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTopicsRequest,
  ) => stream.Stream<
    unknown,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTopicsRequest,
  output: ListTopicsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for action connectors in the specified Amazon Web Services account using filters. You can search by connector name, type, or user permissions.
 */
export const searchActionConnectors: {
  (
    input: SearchActionConnectorsRequest,
  ): effect.Effect<
    SearchActionConnectorsResponse,
    | AccessDeniedException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchActionConnectorsRequest,
  ) => stream.Stream<
    SearchActionConnectorsResponse,
    | AccessDeniedException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchActionConnectorsRequest,
  ) => stream.Stream<
    ActionConnectorSummary,
    | AccessDeniedException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchActionConnectorsRequest,
  output: SearchActionConnectorsResponse,
  errors: [
    AccessDeniedException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ActionConnectorSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Use the `SearchDataSets` operation to search for datasets that belong to an
 * account.
 */
export const searchDataSets: {
  (
    input: SearchDataSetsRequest,
  ): effect.Effect<
    SearchDataSetsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchDataSetsRequest,
  ) => stream.Stream<
    SearchDataSetsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchDataSetsRequest,
  ) => stream.Stream<
    DataSetSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchDataSetsRequest,
  output: SearchDataSetsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataSetSummaries",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists data sources in current Amazon Web Services Region that belong to this Amazon Web Services account.
 */
export const listDataSources: {
  (
    input: ListDataSourcesRequest,
  ): effect.Effect<
    ListDataSourcesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDataSourcesRequest,
  ) => stream.Stream<
    ListDataSourcesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDataSourcesRequest,
  ) => stream.Stream<
    DataSource,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDataSourcesRequest,
  output: ListDataSourcesResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DataSources",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all of
 * the IAM policy assignments, including the Amazon
 * Resource Names
 * (ARNs),
 * for the IAM policies assigned to the specified user and
 * group,
 * or groups that the user belongs to.
 */
export const listIAMPolicyAssignmentsForUser: {
  (
    input: ListIAMPolicyAssignmentsForUserRequest,
  ): effect.Effect<
    ListIAMPolicyAssignmentsForUserResponse,
    | AccessDeniedException
    | ConcurrentUpdatingException
    | InternalFailureException
    | InvalidParameterValueException
    | ResourceExistsException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListIAMPolicyAssignmentsForUserRequest,
  ) => stream.Stream<
    ListIAMPolicyAssignmentsForUserResponse,
    | AccessDeniedException
    | ConcurrentUpdatingException
    | InternalFailureException
    | InvalidParameterValueException
    | ResourceExistsException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListIAMPolicyAssignmentsForUserRequest,
  ) => stream.Stream<
    ActiveIAMPolicyAssignment,
    | AccessDeniedException
    | ConcurrentUpdatingException
    | InternalFailureException
    | InvalidParameterValueException
    | ResourceExistsException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListIAMPolicyAssignmentsForUserRequest,
  output: ListIAMPolicyAssignmentsForUserResponse,
  errors: [
    AccessDeniedException,
    ConcurrentUpdatingException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ActiveAssignments",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Deletes an existing IAM policy assignment.
 */
export const deleteIAMPolicyAssignment: (
  input: DeleteIAMPolicyAssignmentRequest,
) => effect.Effect<
  DeleteIAMPolicyAssignmentResponse,
  | AccessDeniedException
  | ConcurrentUpdatingException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteIAMPolicyAssignmentRequest,
  output: DeleteIAMPolicyAssignmentResponse,
  errors: [
    AccessDeniedException,
    ConcurrentUpdatingException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates an existing IAM policy assignment. This operation updates only
 * the optional parameter or parameters that are specified in the request. This overwrites
 * all of the users included in `Identities`.
 */
export const updateIAMPolicyAssignment: (
  input: UpdateIAMPolicyAssignmentRequest,
) => effect.Effect<
  UpdateIAMPolicyAssignmentResponse,
  | AccessDeniedException
  | ConcurrentUpdatingException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateIAMPolicyAssignmentRequest,
  output: UpdateIAMPolicyAssignmentResponse,
  errors: [
    AccessDeniedException,
    ConcurrentUpdatingException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists all of the refresh schedules for a topic.
 */
export const listTopicRefreshSchedules: (
  input: ListTopicRefreshSchedulesRequest,
) => effect.Effect<
  ListTopicRefreshSchedulesResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListTopicRefreshSchedulesRequest,
  output: ListTopicRefreshSchedulesResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates and starts a new SPICE ingestion for a dataset. You can manually refresh datasets in
 * an Enterprise edition account 32 times in a 24-hour period. You can manually refresh
 * datasets in a Standard edition account 8 times in a 24-hour period. Each 24-hour period
 * is measured starting 24 hours before the current date and time.
 *
 * Any ingestions operating on tagged datasets inherit the same tags automatically for use in
 * access control. For an example, see How do I create an IAM policy to control access to Amazon EC2 resources using
 * tags? in the Amazon Web Services Knowledge Center. Tags are visible on the tagged dataset, but not on the ingestion resource.
 */
export const createIngestion: (
  input: CreateIngestionRequest,
) => effect.Effect<
  CreateIngestionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIngestionRequest,
  output: CreateIngestionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a topic refresh schedule.
 */
export const deleteTopicRefreshSchedule: (
  input: DeleteTopicRefreshScheduleRequest,
) => effect.Effect<
  DeleteTopicRefreshScheduleResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTopicRefreshScheduleRequest,
  output: DeleteTopicRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a topic refresh schedule.
 */
export const describeTopicRefreshSchedule: (
  input: DescribeTopicRefreshScheduleRequest,
) => effect.Effect<
  DescribeTopicRefreshScheduleResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTopicRefreshScheduleRequest,
  output: DescribeTopicRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a topic.
 */
export const updateTopic: (
  input: UpdateTopicRequest,
) => effect.Effect<
  UpdateTopicResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTopicRequest,
  output: UpdateTopicResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a topic refresh schedule.
 */
export const updateTopicRefreshSchedule: (
  input: UpdateTopicRefreshScheduleRequest,
) => effect.Effect<
  UpdateTopicRefreshScheduleResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTopicRefreshScheduleRequest,
  output: UpdateTopicRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates Amazon Quick Sight customizations. Currently, you can add a custom default theme by using the
 * `CreateAccountCustomization` or `UpdateAccountCustomization`
 * API operation. To further customize Amazon Quick Sight by removing Amazon Quick Sight
 * sample assets and videos for all new users, see Customizing Quick Sight in the *Amazon Quick Sight User Guide.*
 *
 * You can create customizations for your Amazon Web Services account or, if you specify a namespace, for
 * a Quick Sight namespace instead. Customizations that apply to a namespace always override
 * customizations that apply to an Amazon Web Services account. To find out which customizations apply, use
 * the `DescribeAccountCustomization` API operation.
 *
 * Before you use the `CreateAccountCustomization` API operation to add a theme
 * as the namespace default, make sure that you first share the theme with the namespace.
 * If you don't share it with the namespace, the theme isn't visible to your users
 * even if you make it the default theme.
 * To check if the theme is shared, view the current permissions by using the
 *
 * DescribeThemePermissions
 *
 * API operation.
 * To share the theme, grant permissions by using the
 *
 * UpdateThemePermissions
 *
 * API operation.
 */
export const createAccountCustomization: (
  input: CreateAccountCustomizationRequest,
) => effect.Effect<
  CreateAccountCustomizationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAccountCustomizationRequest,
  output: CreateAccountCustomizationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Creates a topic refresh schedule.
 */
export const createTopicRefreshSchedule: (
  input: CreateTopicRefreshScheduleRequest,
) => effect.Effect<
  CreateTopicRefreshScheduleResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTopicRefreshScheduleRequest,
  output: CreateTopicRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Cancels an ongoing ingestion of data into SPICE.
 */
export const cancelIngestion: (
  input: CancelIngestionRequest,
) => effect.Effect<
  CancelIngestionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CancelIngestionRequest,
  output: CancelIngestionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates an assignment with one specified IAM policy, identified by its
 * Amazon Resource Name (ARN). This policy assignment is attached to the specified groups
 * or users of Amazon Quick Sight. Assignment names are unique per Amazon Web Services
 * account. To avoid overwriting rules in other namespaces, use assignment names that are
 * unique.
 */
export const createIAMPolicyAssignment: (
  input: CreateIAMPolicyAssignmentRequest,
) => effect.Effect<
  CreateIAMPolicyAssignmentResponse,
  | AccessDeniedException
  | ConcurrentUpdatingException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateIAMPolicyAssignmentRequest,
  output: CreateIAMPolicyAssignmentResponse,
  errors: [
    AccessDeniedException,
    ConcurrentUpdatingException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Lists the history of SPICE ingestions for a dataset. Limited to 5 TPS per user and 25 TPS per account.
 */
export const listIngestions: {
  (
    input: ListIngestionsRequest,
  ): effect.Effect<
    ListIngestionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceExistsException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListIngestionsRequest,
  ) => stream.Stream<
    ListIngestionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceExistsException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListIngestionsRequest,
  ) => stream.Stream<
    Ingestion,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceExistsException
    | ResourceNotFoundException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListIngestionsRequest,
  output: ListIngestionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Ingestions",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Creates a data source.
 */
export const createDataSource: (
  input: CreateDataSourceRequest,
) => effect.Effect<
  CreateDataSourceResponse,
  | AccessDeniedException
  | ConflictException
  | CustomerManagedKeyUnavailableException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDataSourceRequest,
  output: CreateDataSourceResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    CustomerManagedKeyUnavailableException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the customizations associated with the provided Amazon Web Services account and Amazon
 * Quick Sight namespace. The Quick Sight console evaluates which
 * customizations to apply by running this API operation with the `Resolved` flag
 * included.
 *
 * To determine what customizations display when you run this command, it can help to
 * visualize the relationship of the entities involved.
 *
 * - `Amazon Web Services account` - The Amazon Web Services account exists at the top of the hierarchy.
 * It has the potential to use all of the Amazon Web Services Regions and Amazon Web Services Services. When you
 * subscribe to Quick Sight, you choose one Amazon Web Services Region to use as your home Region.
 * That's where your free SPICE capacity is located. You can use Quick Sight in any
 * supported Amazon Web Services Region.
 *
 * - `Amazon Web Services Region` - You can sign in to Quick Sight in any Amazon Web Services Region. If
 * you have a user directory, it resides in us-east-1, which is US East (N.
 * Virginia). Generally speaking, these users have access to Quick Sight in any
 * Amazon Web Services Region, unless they are constrained to a namespace.
 *
 * To run the command in a different Amazon Web Services Region, you change your Region settings.
 * If you're using the CLI, you can use one of the following options:
 *
 * - Use command line options.
 *
 * - Use named profiles.
 *
 * - Run `aws configure` to change your default Amazon Web Services Region. Use
 * Enter to key the same settings for your keys. For more information, see
 * Configuring the CLI.
 *
 * - `Namespace` - A Quick Sight namespace is a partition that contains
 * users and assets (data sources, datasets, dashboards, and so on). To access
 * assets that are in a specific namespace, users and groups must also be part of
 * the same namespace. People who share a namespace are completely isolated from
 * users and assets in other namespaces, even if they are in the same Amazon Web Services account
 * and Amazon Web Services Region.
 *
 * - `Applied customizations` - Quick Sight customizations can apply to an Amazon Web Services account or to a namespace.
 * Settings that you apply to a namespace override settings that you apply to an
 * Amazon Web Services account.
 */
export const describeAccountCustomization: (
  input: DescribeAccountCustomizationRequest,
) => effect.Effect<
  DescribeAccountCustomizationResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAccountCustomizationRequest,
  output: DescribeAccountCustomizationResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates Amazon Quick Sight customizations. Currently, the only customization that you can use is a theme.
 *
 * You can use customizations for your Amazon Web Services account or, if you specify a namespace, for a
 * Quick Sight namespace instead. Customizations that apply to a namespace override
 * customizations that apply to an Amazon Web Services account. To find out which customizations apply, use
 * the `DescribeAccountCustomization` API operation.
 */
export const updateAccountCustomization: (
  input: UpdateAccountCustomizationRequest,
) => effect.Effect<
  UpdateAccountCustomizationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAccountCustomizationRequest,
  output: UpdateAccountCustomizationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates the Amazon Quick Sight settings in your Amazon Web Services account.
 */
export const updateAccountSettings: (
  input: UpdateAccountSettingsRequest,
) => effect.Effect<
  UpdateAccountSettingsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAccountSettingsRequest,
  output: UpdateAccountSettingsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates a personalization configuration.
 */
export const updateQPersonalizationConfiguration: (
  input: UpdateQPersonalizationConfigurationRequest,
) => effect.Effect<
  UpdateQPersonalizationConfigurationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateQPersonalizationConfigurationRequest,
  output: UpdateQPersonalizationConfigurationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Describes the settings that were used when your Quick Sight subscription was first
 * created in this Amazon Web Services account.
 */
export const describeAccountSettings: (
  input: DescribeAccountSettingsRequest,
) => effect.Effect<
  DescribeAccountSettingsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAccountSettingsRequest,
  output: DescribeAccountSettingsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Use the DescribeAccountSubscription operation to receive a description of an Quick Sight account's subscription. A successful API call returns an `AccountInfo` object that includes an account's name, subscription status, authentication type, edition, and notification email address.
 */
export const describeAccountSubscription: (
  input: DescribeAccountSubscriptionRequest,
) => effect.Effect<
  DescribeAccountSubscriptionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAccountSubscriptionRequest,
  output: DescribeAccountSubscriptionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Describes a custom permissions profile.
 */
export const describeCustomPermissions: (
  input: DescribeCustomPermissionsRequest,
) => effect.Effect<
  DescribeCustomPermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeCustomPermissionsRequest,
  output: DescribeCustomPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Returns information about a user, given the user name.
 */
export const describeUser: (
  input: DescribeUserRequest,
) => effect.Effect<
  DescribeUserResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeUserRequest,
  output: DescribeUserResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves the identity context for a Quick Sight user in a specified namespace, allowing you to obtain identity tokens that can be used with identity-enhanced IAM role sessions to call identity-aware APIs.
 *
 * Currently, you can call the following APIs with identity-enhanced Credentials
 *
 * - StartDashboardSnapshotJob
 *
 * - DescribeDashboardSnapshotJob
 *
 * - DescribeDashboardSnapshotJobResult
 *
 * **Supported Authentication Methods**
 *
 * This API supports Quick Sight native users, IAM federated users, and Active Directory users. For Quick Sight users authenticated by Amazon Web Services Identity Center, see Identity Center documentation on identity-enhanced IAM role sessions.
 *
 * **Getting Identity-Enhanced Credentials**
 *
 * To obtain identity-enhanced credentials, follow these steps:
 *
 * - Call the GetIdentityContext API to retrieve an identity token for the specified user.
 *
 * - Use the identity token with the STS AssumeRole API to obtain identity-enhanced IAM role session credentials.
 *
 * **Usage with STS AssumeRole**
 *
 * The identity token returned by this API should be used with the STS AssumeRole API to obtain credentials for an identity-enhanced IAM role session. When calling AssumeRole, include the identity token in the `ProvidedContexts` parameter with `ProviderArn` set to `arn:aws:iam::aws:contextProvider/QuickSight` and `ContextAssertion` set to the identity token received from this API.
 *
 * The assumed role must allow the `sts:SetContext` action in addition to `sts:AssumeRole` in its trust relationship policy. The trust policy should include both actions for the principal that will be assuming the role.
 */
export const getIdentityContext: (
  input: GetIdentityContextRequest,
) => effect.Effect<
  GetIdentityContextResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetIdentityContextRequest,
  output: GetIdentityContextResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * (Enterprise edition only) Creates a new namespace for you to use with Amazon Quick Sight.
 *
 * A namespace allows you to isolate the Quick Sight users and groups that are registered
 * for that namespace. Users that access the namespace can share assets only with other
 * users or groups in the same namespace. They can't see users and groups in other
 * namespaces. You can create a namespace after your Amazon Web Services account is subscribed to
 * Quick Sight. The namespace must be unique within the Amazon Web Services account. By default, there is a
 * limit of 100 namespaces per Amazon Web Services account. To increase your limit, create a ticket with
 * Amazon Web Services Support.
 */
export const createNamespace: (
  input: CreateNamespaceRequest,
) => effect.Effect<
  CreateNamespaceResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceExistsException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateNamespaceRequest,
  output: CreateNamespaceResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceExistsException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Use `CreateRoleMembership` to add an existing Quick Sight group to an existing role.
 */
export const createRoleMembership: (
  input: CreateRoleMembershipRequest,
) => effect.Effect<
  CreateRoleMembershipResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRoleMembershipRequest,
  output: CreateRoleMembershipResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * This API permanently deletes all Quick Sight customizations for the specified Amazon Web Services account and namespace. When you delete account customizations:
 *
 * - All customizations are removed including themes, branding, and visual settings
 *
 * - This action cannot be undone through the API
 *
 * - Users will see default Quick Sight styling after customizations are deleted
 *
 * **Before proceeding:** Ensure you have backups of any custom themes or branding elements you may want to recreate.
 *
 * Deletes all Amazon Quick Sight customizations for the specified Amazon Web Services account and Quick Sight namespace.
 */
export const deleteAccountCustomization: (
  input: DeleteAccountCustomizationRequest,
) => effect.Effect<
  DeleteAccountCustomizationResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAccountCustomizationRequest,
  output: DeleteAccountCustomizationResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Deleting your Quick Sight account subscription has permanent, irreversible consequences across all Amazon Web Services regions:
 *
 * - Global deletion  Running this operation from any single region will delete your Quick Sight account and all data in every Amazon Web Services region where you have Quick Sight resources.
 *
 * - Complete data loss  All dashboards, analyses, datasets, data sources, and custom visuals will be permanently deleted across all regions.
 *
 * - Embedded content failure  All embedded dashboards and visuals in your applications will immediately stop working and display errors to end users.
 *
 * - Shared resources removed  All shared dashboards, folders, and resources will become inaccessible to other users and external recipients.
 *
 * - User access terminated  All Quick Sight users in your account will lose access immediately, including authors, readers, and administrators.
 *
 * - **No recovery possible**  Once deleted, your Quick Sight account and all associated data cannot be restored.
 *
 * Consider exporting critical dashboards and data before proceeding with account deletion.
 *
 * Use the `DeleteAccountSubscription` operation to delete an Quick Sight account. This operation will result in an error message if you have configured your account termination protection settings to `True`. To change this setting and delete your account, call the `UpdateAccountSettings` API and set the value of the `TerminationProtectionEnabled` parameter to `False`, then make another call to the `DeleteAccountSubscription` API.
 */
export const deleteAccountSubscription: (
  input: DeleteAccountSubscriptionRequest,
) => effect.Effect<
  DeleteAccountSubscriptionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAccountSubscriptionRequest,
  output: DeleteAccountSubscriptionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a custom permissions profile.
 */
export const deleteCustomPermissions: (
  input: DeleteCustomPermissionsRequest,
) => effect.Effect<
  DeleteCustomPermissionsResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceExistsException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteCustomPermissionsRequest,
  output: DeleteCustomPermissionsResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceExistsException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Removes a user group from Amazon Quick Sight.
 */
export const deleteGroup: (
  input: DeleteGroupRequest,
) => effect.Effect<
  DeleteGroupResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteGroupRequest,
  output: DeleteGroupResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Removes a user from a group so that the user is no longer a member of the group.
 */
export const deleteGroupMembership: (
  input: DeleteGroupMembershipRequest,
) => effect.Effect<
  DeleteGroupMembershipResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteGroupMembershipRequest,
  output: DeleteGroupMembershipResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a namespace and the users and groups that are associated with the namespace.
 * This is an asynchronous process. Assets including dashboards, analyses, datasets and data sources are not
 * deleted. To delete these assets, you use the API operations for the relevant asset.
 */
export const deleteNamespace: (
  input: DeleteNamespaceRequest,
) => effect.Effect<
  DeleteNamespaceResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteNamespaceRequest,
  output: DeleteNamespaceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Removes custom permissions from the role.
 */
export const deleteRoleCustomPermission: (
  input: DeleteRoleCustomPermissionRequest,
) => effect.Effect<
  DeleteRoleCustomPermissionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRoleCustomPermissionRequest,
  output: DeleteRoleCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Removes a group from a role.
 */
export const deleteRoleMembership: (
  input: DeleteRoleMembershipRequest,
) => effect.Effect<
  DeleteRoleMembershipResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteRoleMembershipRequest,
  output: DeleteRoleMembershipResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Deletes the Amazon Quick Sight user that is associated with the identity of the
 * IAM user or role that's making the call. The IAM user
 * isn't deleted as a result of this call.
 */
export const deleteUser: (
  input: DeleteUserRequest,
) => effect.Effect<
  DeleteUserResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserRequest,
  output: DeleteUserResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a user identified by its principal ID.
 */
export const deleteUserByPrincipalId: (
  input: DeleteUserByPrincipalIdRequest,
) => effect.Effect<
  DeleteUserByPrincipalIdResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserByPrincipalIdRequest,
  output: DeleteUserByPrincipalIdResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a custom permissions profile from a user.
 */
export const deleteUserCustomPermission: (
  input: DeleteUserCustomPermissionRequest,
) => effect.Effect<
  DeleteUserCustomPermissionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteUserCustomPermissionRequest,
  output: DeleteUserCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Describes the refresh properties of a dataset.
 */
export const describeDataSetRefreshProperties: (
  input: DescribeDataSetRefreshPropertiesRequest,
) => effect.Effect<
  DescribeDataSetRefreshPropertiesResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDataSetRefreshPropertiesRequest,
  output: DescribeDataSetRefreshPropertiesResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Returns an Amazon Quick Sight group's description and Amazon Resource Name (ARN).
 */
export const describeGroup: (
  input: DescribeGroupRequest,
) => effect.Effect<
  DescribeGroupResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeGroupRequest,
  output: DescribeGroupResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Use the `DescribeGroupMembership` operation to determine if a user is a
 * member of the specified group. If the user exists and is a member of the specified
 * group, an associated `GroupMember` object is returned.
 */
export const describeGroupMembership: (
  input: DescribeGroupMembershipRequest,
) => effect.Effect<
  DescribeGroupMembershipResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeGroupMembershipRequest,
  output: DescribeGroupMembershipResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Describes all custom permissions that are mapped to a role.
 */
export const describeRoleCustomPermission: (
  input: DescribeRoleCustomPermissionRequest,
) => effect.Effect<
  DescribeRoleCustomPermissionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeRoleCustomPermissionRequest,
  output: DescribeRoleCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Returns a list of all the custom permissions profiles.
 */
export const listCustomPermissions: {
  (
    input: ListCustomPermissionsRequest,
  ): effect.Effect<
    ListCustomPermissionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListCustomPermissionsRequest,
  ) => stream.Stream<
    ListCustomPermissionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListCustomPermissionsRequest,
  ) => stream.Stream<
    CustomPermissions,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListCustomPermissionsRequest,
  output: ListCustomPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "CustomPermissionsList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the Amazon Quick Sight groups that an Amazon Quick Sight user is a member of.
 */
export const listUserGroups: {
  (
    input: ListUserGroupsRequest,
  ): effect.Effect<
    ListUserGroupsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUserGroupsRequest,
  ) => stream.Stream<
    ListUserGroupsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUserGroupsRequest,
  ) => stream.Stream<
    Group,
    | AccessDeniedException
    | InternalFailureException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUserGroupsRequest,
  output: ListUserGroupsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "GroupList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Creates an Amazon Quick Sight user whose identity is associated with the Identity and Access Management (IAM) identity or role specified in the request. When you register a new user from the Quick Sight API, Quick Sight generates a registration URL. The user accesses this registration URL to create their account. Quick Sight doesn't send a registration email to users who are registered from the Quick Sight API. If you want new users to receive a registration email, then add those users in the Quick Sight console. For more information on registering a new user in the Quick Sight console, see Inviting users to access Quick Sight.
 */
export const registerUser: (
  input: RegisterUserRequest,
) => effect.Effect<
  RegisterUserResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceExistsException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RegisterUserRequest,
  output: RegisterUserResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceExistsException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates a custom permissions profile.
 */
export const updateCustomPermissions: (
  input: UpdateCustomPermissionsRequest,
) => effect.Effect<
  UpdateCustomPermissionsResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateCustomPermissionsRequest,
  output: UpdateCustomPermissionsResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Changes a group description.
 */
export const updateGroup: (
  input: UpdateGroupRequest,
) => effect.Effect<
  UpdateGroupResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateGroupRequest,
  output: UpdateGroupResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates a refresh schedule for a dataset.
 */
export const updateRefreshSchedule: (
  input: UpdateRefreshScheduleRequest,
) => effect.Effect<
  UpdateRefreshScheduleResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRefreshScheduleRequest,
  output: UpdateRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the custom permissions that are associated with a role.
 */
export const updateRoleCustomPermission: (
  input: UpdateRoleCustomPermissionRequest,
) => effect.Effect<
  UpdateRoleCustomPermissionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateRoleCustomPermissionRequest,
  output: UpdateRoleCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates an Amazon Quick Sight user.
 */
export const updateUser: (
  input: UpdateUserRequest,
) => effect.Effect<
  UpdateUserResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserRequest,
  output: UpdateUserResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates a custom permissions profile for a user.
 */
export const updateUserCustomPermission: (
  input: UpdateUserCustomPermissionRequest,
) => effect.Effect<
  UpdateUserCustomPermissionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateUserCustomPermissionRequest,
  output: UpdateUserCustomPermissionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Creates an Amazon Quick Sight account, or subscribes to Amazon Quick Sight Q.
 *
 * The Amazon Web Services Region for the account is derived from what is configured in the
 * CLI or SDK.
 *
 * Before you use this operation, make sure that you can connect to an existing Amazon Web Services account. If you don't have an Amazon Web Services account, see Sign
 * up for Amazon Web Services in the Amazon Quick Sight User
 * Guide. The person who signs up for Amazon Quick Sight needs to have the
 * correct Identity and Access Management (IAM) permissions. For more information,
 * see IAM Policy Examples for Amazon Quick Sight in the
 * *Amazon Quick Sight User Guide*.
 *
 * If your IAM policy includes both the `Subscribe` and
 * `CreateAccountSubscription` actions, make sure that both actions are set
 * to `Allow`. If either action is set to `Deny`, the
 * `Deny` action prevails and your API call fails.
 *
 * You can't pass an existing IAM role to access other Amazon Web Services services using this API operation. To pass your existing IAM role to
 * Amazon Quick Sight, see Passing IAM roles to Amazon Quick Sight in the
 * *Amazon Quick Sight User Guide*.
 *
 * You can't set default resource access on the new account from the Amazon Quick Sight
 * API. Instead, add default resource access from the Amazon Quick Sight console. For more
 * information about setting default resource access to Amazon Web Services services, see
 * Setting default resource
 * access to Amazon Web Services services in the Amazon Quick Sight
 * User Guide.
 */
export const createAccountSubscription: (
  input: CreateAccountSubscriptionRequest,
) => effect.Effect<
  CreateAccountSubscriptionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceExistsException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAccountSubscriptionRequest,
  output: CreateAccountSubscriptionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceExistsException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Creates a custom permissions profile.
 */
export const createCustomPermissions: (
  input: CreateCustomPermissionsRequest,
) => effect.Effect<
  CreateCustomPermissionsResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceExistsException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateCustomPermissionsRequest,
  output: CreateCustomPermissionsResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceExistsException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Use the `CreateGroup` operation to create a group in Quick Sight. You can create up to 10,000 groups in a namespace. If you want to create more than 10,000 groups in a namespace, contact Amazon Web Services Support.
 *
 * The permissions resource is
 * arn:aws:quicksight::**:group/default/**
 * .
 *
 * The response is a group object.
 */
export const createGroup: (
  input: CreateGroupRequest,
) => effect.Effect<
  CreateGroupResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceExistsException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateGroupRequest,
  output: CreateGroupResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceExistsException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Adds an Amazon Quick Sight user to an Amazon Quick Sight group.
 */
export const createGroupMembership: (
  input: CreateGroupMembershipRequest,
) => effect.Effect<
  CreateGroupMembershipResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateGroupMembershipRequest,
  output: CreateGroupMembershipResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Lists all self-upgrade requests for a Quick Suite account.
 */
export const listSelfUpgrades: (
  input: ListSelfUpgradesRequest,
) => effect.Effect<
  ListSelfUpgradesResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidNextTokenException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListSelfUpgradesRequest,
  output: ListSelfUpgradesResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Use the `SearchGroups` operation to search groups in a specified Quick Sight namespace using the supplied filters.
 */
export const searchGroups: {
  (
    input: SearchGroupsRequest,
  ): effect.Effect<
    SearchGroupsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchGroupsRequest,
  ) => stream.Stream<
    SearchGroupsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchGroupsRequest,
  ) => stream.Stream<
    Group,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchGroupsRequest,
  output: SearchGroupsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "GroupList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists member users in a group.
 */
export const listGroupMemberships: {
  (
    input: ListGroupMembershipsRequest,
  ): effect.Effect<
    ListGroupMembershipsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListGroupMembershipsRequest,
  ) => stream.Stream<
    ListGroupMembershipsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListGroupMembershipsRequest,
  ) => stream.Stream<
    GroupMember,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListGroupMembershipsRequest,
  output: ListGroupMembershipsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "GroupMemberList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all user groups in Amazon Quick Sight.
 */
export const listGroups: {
  (
    input: ListGroupsRequest,
  ): effect.Effect<
    ListGroupsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListGroupsRequest,
  ) => stream.Stream<
    ListGroupsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListGroupsRequest,
  ) => stream.Stream<
    Group,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListGroupsRequest,
  output: ListGroupsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "GroupList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists the namespaces for the specified Amazon Web Services account. This operation doesn't list deleted namespaces.
 */
export const listNamespaces: {
  (
    input: ListNamespacesRequest,
  ): effect.Effect<
    ListNamespacesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListNamespacesRequest,
  ) => stream.Stream<
    ListNamespacesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListNamespacesRequest,
  ) => stream.Stream<
    NamespaceInfoV2,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListNamespacesRequest,
  output: ListNamespacesResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Namespaces",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all groups that are associated with a role.
 */
export const listRoleMemberships: {
  (
    input: ListRoleMembershipsRequest,
  ): effect.Effect<
    ListRoleMembershipsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | LimitExceededException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListRoleMembershipsRequest,
  ) => stream.Stream<
    ListRoleMembershipsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | LimitExceededException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListRoleMembershipsRequest,
  ) => stream.Stream<
    string,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | LimitExceededException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListRoleMembershipsRequest,
  output: ListRoleMembershipsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "MembersList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Returns a list of all of the Amazon Quick Sight users belonging to this account.
 */
export const listUsers: {
  (
    input: ListUsersRequest,
  ): effect.Effect<
    ListUsersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListUsersRequest,
  ) => stream.Stream<
    ListUsersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListUsersRequest,
  ) => stream.Stream<
    User,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | PreconditionNotMetException
    | ResourceNotFoundException
    | ResourceUnavailableException
    | ThrottlingException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListUsersRequest,
  output: ListUsersResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "UserList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Updates a self-upgrade request for a Quick Suite user by approving, denying, or verifying the request.
 */
export const updateSelfUpgrade: (
  input: UpdateSelfUpgradeRequest,
) => effect.Effect<
  UpdateSelfUpgradeResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidNextTokenException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSelfUpgradeRequest,
  output: UpdateSelfUpgradeResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Updates the self-upgrade configuration for a Quick Suite account.
 */
export const updateSelfUpgradeConfiguration: (
  input: UpdateSelfUpgradeConfigurationRequest,
) => effect.Effect<
  UpdateSelfUpgradeConfigurationResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ResourceUnavailableException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateSelfUpgradeConfigurationRequest,
  output: UpdateSelfUpgradeConfigurationResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ResourceUnavailableException,
    ThrottlingException,
  ],
}));
/**
 * Creates a refresh schedule for a dataset. You can create up to 5 different schedules for a single dataset.
 */
export const createRefreshSchedule: (
  input: CreateRefreshScheduleRequest,
) => effect.Effect<
  CreateRefreshScheduleResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateRefreshScheduleRequest,
  output: CreateRefreshScheduleResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates an Quick Suite application with a token exchange grant. This operation only supports Quick Suite applications that are registered with IAM Identity Center.
 */
export const updateApplicationWithTokenExchangeGrant: (
  input: UpdateApplicationWithTokenExchangeGrantRequest,
) => effect.Effect<
  UpdateApplicationWithTokenExchangeGrantResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | InvalidRequestException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateApplicationWithTokenExchangeGrantRequest,
  output: UpdateApplicationWithTokenExchangeGrantResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    InvalidRequestException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * This API permanently deletes the specified Quick Sight brand. When you delete a brand:
 *
 * - The brand and all its associated branding elements are permanently removed
 *
 * - Any applications or dashboards using this brand will revert to default styling
 *
 * - This action cannot be undone through the API
 *
 * **Before proceeding:** Verify that the brand is no longer needed and consider the impact on any applications currently using this brand.
 *
 * Deletes an Quick Sight brand.
 */
export const deleteBrand: (
  input: DeleteBrandRequest,
) => effect.Effect<
  DeleteBrandResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteBrandRequest,
  output: DeleteBrandResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Deletes a brand assignment.
 */
export const deleteBrandAssignment: (
  input: DeleteBrandAssignmentRequest,
) => effect.Effect<
  DeleteBrandAssignmentResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteBrandAssignmentRequest,
  output: DeleteBrandAssignmentResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes a brand assignment.
 */
export const describeBrandAssignment: (
  input: DescribeBrandAssignmentRequest,
) => effect.Effect<
  DescribeBrandAssignmentResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeBrandAssignmentRequest,
  output: DescribeBrandAssignmentResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the published version of the brand.
 */
export const describeBrandPublishedVersion: (
  input: DescribeBrandPublishedVersionRequest,
) => effect.Effect<
  DescribeBrandPublishedVersionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeBrandPublishedVersionRequest,
  output: DescribeBrandPublishedVersionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a brand.
 */
export const updateBrand: (
  input: UpdateBrandRequest,
) => effect.Effect<
  UpdateBrandResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateBrandRequest,
  output: UpdateBrandResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates a brand assignment.
 */
export const updateBrandAssignment: (
  input: UpdateBrandAssignmentRequest,
) => effect.Effect<
  UpdateBrandAssignmentResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateBrandAssignmentRequest,
  output: UpdateBrandAssignmentResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Updates the published version of a brand.
 */
export const updateBrandPublishedVersion: (
  input: UpdateBrandPublishedVersionRequest,
) => effect.Effect<
  UpdateBrandPublishedVersionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateBrandPublishedVersionRequest,
  output: UpdateBrandPublishedVersionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes an existing export job.
 *
 * Poll job descriptions after a job starts to know the status of the job. When a job
 * succeeds, a URL is provided to download the exported assets' data from. Download URLs
 * are valid for five minutes after they are generated. You can call the
 * `DescribeAssetBundleExportJob` API for a new download URL as needed.
 *
 * Job descriptions are available for 14 days after the job starts.
 */
export const describeAssetBundleExportJob: (
  input: DescribeAssetBundleExportJobRequest,
) => effect.Effect<
  DescribeAssetBundleExportJobResponse,
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAssetBundleExportJobRequest,
  output: DescribeAssetBundleExportJobResponse,
  errors: [
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates or updates the dataset refresh properties for the dataset.
 */
export const putDataSetRefreshProperties: (
  input: PutDataSetRefreshPropertiesRequest,
) => effect.Effect<
  PutDataSetRefreshPropertiesResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: PutDataSetRefreshPropertiesRequest,
  output: PutDataSetRefreshPropertiesResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Starts an Asset Bundle import job.
 *
 * An Asset Bundle import job imports specified Amazon Quick Sight assets into an Amazon Quick
 * Sight account. You can also choose to import a naming prefix and specified configuration
 * overrides. The assets that are contained in the bundle file that you provide are used to
 * create or update a new or existing asset in your Amazon Quick Sight account. Each Amazon
 * Quick Sight account can run up to 5 import jobs concurrently.
 *
 * The API caller must have the necessary `"create"`, `"describe"`,
 * and `"update"` permissions in their IAM role to access each
 * resource type that is contained in the bundle file before the resources can be
 * imported.
 */
export const startAssetBundleImportJob: (
  input: StartAssetBundleImportJobRequest,
) => effect.Effect<
  StartAssetBundleImportJobResponse,
  | AccessDeniedException
  | ConflictException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartAssetBundleImportJobRequest,
  output: StartAssetBundleImportJobResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * This API controls public sharing settings for your entire Quick Sight account, affecting
 * data security and access. When you enable public sharing:
 *
 * - Dashboards can be shared publicly
 *
 * - This setting affects your entire Amazon Web Services account and all Quick Sight
 * users
 *
 * **Before proceeding:** Ensure you understand the
 * security implications and have proper IAM permissions
 * configured.
 *
 * Use the `UpdatePublicSharingSettings` operation to turn on or turn off the
 * public sharing settings of an Amazon Quick Sight dashboard.
 *
 * To use this operation, turn on session capacity pricing for your Amazon Quick Sight
 * account.
 *
 * Before you can turn on public sharing on your account, make sure to give public
 * sharing permissions to an administrative user in the Identity and Access Management (IAM) console. For more information on using IAM with Amazon
 * Quick Sight, see Using Quick Suite with IAM in the Amazon Quick Sight
 * User Guide.
 */
export const updatePublicSharingSettings: (
  input: UpdatePublicSharingSettingsRequest,
) => effect.Effect<
  UpdatePublicSharingSettingsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedPricingPlanException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdatePublicSharingSettingsRequest,
  output: UpdatePublicSharingSettingsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedPricingPlanException,
  ],
}));
/**
 * Describes a theme.
 */
export const describeTheme: (
  input: DescribeThemeRequest,
) => effect.Effect<
  DescribeThemeResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeThemeRequest,
  output: DescribeThemeResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Provides a summary for a dashboard.
 */
export const describeDashboard: (
  input: DescribeDashboardRequest,
) => effect.Effect<
  DescribeDashboardResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDashboardRequest,
  output: DescribeDashboardResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes an existing snapshot job.
 *
 * Poll job descriptions after a job starts to know the status of the job. For information on available status codes, see `JobStatus`.
 *
 * **Registered user support**
 *
 * This API can be called as before to get status of a job started by the same Quick Sight user.
 *
 * **Possible error scenarios**
 *
 * Request will fail with an Access Denied error in the following scenarios:
 *
 * - The credentials have expired.
 *
 * - Job has been started by a different user.
 *
 * - Impersonated Quick Sight user doesn't have access to the specified dashboard in the job.
 */
export const describeDashboardSnapshotJob: (
  input: DescribeDashboardSnapshotJobRequest,
) => effect.Effect<
  DescribeDashboardSnapshotJobResponse,
  | AccessDeniedException
  | InternalFailureException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDashboardSnapshotJobRequest,
  output: DescribeDashboardSnapshotJobResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes a VPC connection.
 */
export const describeVPCConnection: (
  input: DescribeVPCConnectionRequest,
) => effect.Effect<
  DescribeVPCConnectionResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeVPCConnectionRequest,
  output: DescribeVPCConnectionResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes a folder.
 */
export const describeFolder: (
  input: DescribeFolderRequest,
) => effect.Effect<
  DescribeFolderResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeFolderRequest,
  output: DescribeFolderResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Removes an asset, such as a dashboard, analysis, or dataset, from a folder.
 */
export const deleteFolderMembership: (
  input: DeleteFolderMembershipRequest,
) => effect.Effect<
  DeleteFolderMembershipResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteFolderMembershipRequest,
  output: DeleteFolderMembershipResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes a theme.
 */
export const deleteTheme: (
  input: DeleteThemeRequest,
) => effect.Effect<
  DeleteThemeResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteThemeRequest,
  output: DeleteThemeResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes a VPC connection.
 */
export const deleteVPCConnection: (
  input: DeleteVPCConnectionRequest,
) => effect.Effect<
  DeleteVPCConnectionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteVPCConnectionRequest,
  output: DeleteVPCConnectionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes the read and write permissions for a theme.
 */
export const describeThemePermissions: (
  input: DescribeThemePermissionsRequest,
) => effect.Effect<
  DescribeThemePermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeThemePermissionsRequest,
  output: DescribeThemePermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Starts an asynchronous job that runs an existing dashboard schedule and sends the dashboard snapshot through email.
 *
 * Only one job can run simultaneously in a given schedule. Repeated requests are skipped with a `202` HTTP status code.
 *
 * For more information, see Scheduling and sending Amazon Quick Sight reports by email and Configuring email report settings for a Amazon Quick Sight dashboard in the *Amazon Quick Sight User Guide*.
 */
export const startDashboardSnapshotJobSchedule: (
  input: StartDashboardSnapshotJobScheduleRequest,
) => effect.Effect<
  StartDashboardSnapshotJobScheduleResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartDashboardSnapshotJobScheduleRequest,
  output: StartDashboardSnapshotJobScheduleResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the permissions for an action connector by granting or revoking access for specific users and groups. You can control who can view, use, or manage the action connector.
 */
export const updateActionConnectorPermissions: (
  input: UpdateActionConnectorPermissionsRequest,
) => effect.Effect<
  UpdateActionConnectorPermissionsResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateActionConnectorPermissionsRequest,
  output: UpdateActionConnectorPermissionsResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the linked analyses on a dashboard.
 */
export const updateDashboardLinks: (
  input: UpdateDashboardLinksRequest,
) => effect.Effect<
  UpdateDashboardLinksResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDashboardLinksRequest,
  output: UpdateDashboardLinksResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates permissions of a folder.
 */
export const updateFolderPermissions: (
  input: UpdateFolderPermissionsRequest,
) => effect.Effect<
  UpdateFolderPermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateFolderPermissionsRequest,
  output: UpdateFolderPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the resource permissions for a theme. Permissions apply to the action to grant or
 * revoke permissions on, for example `"quicksight:DescribeTheme"`.
 *
 * Theme permissions apply in groupings. Valid groupings include the following for the three
 * levels of permissions, which are user, owner, or no permissions:
 *
 * - User
 *
 * - `"quicksight:DescribeTheme"`
 *
 * - `"quicksight:DescribeThemeAlias"`
 *
 * - `"quicksight:ListThemeAliases"`
 *
 * - `"quicksight:ListThemeVersions"`
 *
 * - Owner
 *
 * - `"quicksight:DescribeTheme"`
 *
 * - `"quicksight:DescribeThemeAlias"`
 *
 * - `"quicksight:ListThemeAliases"`
 *
 * - `"quicksight:ListThemeVersions"`
 *
 * - `"quicksight:DeleteTheme"`
 *
 * - `"quicksight:UpdateTheme"`
 *
 * - `"quicksight:CreateThemeAlias"`
 *
 * - `"quicksight:DeleteThemeAlias"`
 *
 * - `"quicksight:UpdateThemeAlias"`
 *
 * - `"quicksight:UpdateThemePermissions"`
 *
 * - `"quicksight:DescribeThemePermissions"`
 *
 * - To specify no permissions, omit the permissions list.
 */
export const updateThemePermissions: (
  input: UpdateThemePermissionsRequest,
) => effect.Effect<
  UpdateThemePermissionsResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateThemePermissionsRequest,
  output: UpdateThemePermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the permissions of a topic.
 */
export const updateTopicPermissions: (
  input: UpdateTopicPermissionsRequest,
) => effect.Effect<
  UpdateTopicPermissionsResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTopicPermissionsRequest,
  output: UpdateTopicPermissionsResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates a VPC connection.
 */
export const updateVPCConnection: (
  input: UpdateVPCConnectionRequest,
) => effect.Effect<
  UpdateVPCConnectionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateVPCConnectionRequest,
  output: UpdateVPCConnectionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes a dashboard.
 */
export const deleteDashboard: (
  input: DeleteDashboardRequest,
) => effect.Effect<
  DeleteDashboardResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteDashboardRequest,
  output: DeleteDashboardResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes a template.
 */
export const deleteTemplate: (
  input: DeleteTemplateRequest,
) => effect.Effect<
  DeleteTemplateResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTemplateRequest,
  output: DeleteTemplateResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes the version of the theme that the specified theme alias points to.
 * If you provide a specific alias, you delete the version of the theme
 * that the alias points to.
 */
export const deleteThemeAlias: (
  input: DeleteThemeAliasRequest,
) => effect.Effect<
  DeleteThemeAliasResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteThemeAliasRequest,
  output: DeleteThemeAliasResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes read and write permissions on a template.
 */
export const describeTemplatePermissions: (
  input: DescribeTemplatePermissionsRequest,
) => effect.Effect<
  DescribeTemplatePermissionsResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTemplatePermissionsRequest,
  output: DescribeTemplatePermissionsResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes the alias for a theme.
 */
export const describeThemeAlias: (
  input: DescribeThemeAliasRequest,
) => effect.Effect<
  DescribeThemeAliasResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeThemeAliasRequest,
  output: DescribeThemeAliasResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the read and write permissions for an analysis.
 */
export const updateAnalysisPermissions: (
  input: UpdateAnalysisPermissionsRequest,
) => effect.Effect<
  UpdateAnalysisPermissionsResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAnalysisPermissionsRequest,
  output: UpdateAnalysisPermissionsResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates a dashboard in an Amazon Web Services account.
 *
 * Updating a Dashboard creates a new dashboard version but does not immediately
 * publish the new version. You can update the published version of a dashboard by
 * using the
 * UpdateDashboardPublishedVersion
 * API operation.
 */
export const updateDashboard: (
  input: UpdateDashboardRequest,
) => effect.Effect<
  UpdateDashboardResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDashboardRequest,
  output: UpdateDashboardResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates read and write permissions on a dashboard.
 */
export const updateDashboardPermissions: (
  input: UpdateDashboardPermissionsRequest,
) => effect.Effect<
  UpdateDashboardPermissionsResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDashboardPermissionsRequest,
  output: UpdateDashboardPermissionsResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the published version of a dashboard.
 */
export const updateDashboardPublishedVersion: (
  input: UpdateDashboardPublishedVersionRequest,
) => effect.Effect<
  UpdateDashboardPublishedVersionResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDashboardPublishedVersionRequest,
  output: UpdateDashboardPublishedVersionResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the resource permissions for a template.
 */
export const updateTemplatePermissions: (
  input: UpdateTemplatePermissionsRequest,
) => effect.Effect<
  UpdateTemplatePermissionsResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTemplatePermissionsRequest,
  output: UpdateTemplatePermissionsResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes read and write permissions for a dashboard.
 */
export const describeDashboardPermissions: (
  input: DescribeDashboardPermissionsRequest,
) => effect.Effect<
  DescribeDashboardPermissionsResponse,
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDashboardPermissionsRequest,
  output: DescribeDashboardPermissionsResponse,
  errors: [
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes an analysis from Amazon Quick Sight. You can optionally include a recovery window during
 * which you can restore the analysis. If you don't specify a recovery window value, the
 * operation defaults to 30 days. Amazon Quick Sight attaches a `DeletionTime` stamp to
 * the response that specifies the end of the recovery window. At the end of the recovery
 * window, Amazon Quick Sight deletes the analysis permanently.
 *
 * At any time before recovery window ends, you can use the `RestoreAnalysis`
 * API operation to remove the `DeletionTime` stamp and cancel the deletion of
 * the analysis. The analysis remains visible in the API until it's deleted, so you can
 * describe it but you can't make a template from it.
 *
 * An analysis that's scheduled for deletion isn't accessible in the Amazon Quick Sight console.
 * To access it in the console, restore it. Deleting an analysis doesn't delete the
 * dashboards that you publish from it.
 */
export const deleteAnalysis: (
  input: DeleteAnalysisRequest,
) => effect.Effect<
  DeleteAnalysisResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteAnalysisRequest,
  output: DeleteAnalysisResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Provides a summary of the metadata for an analysis.
 */
export const describeAnalysis: (
  input: DescribeAnalysisRequest,
) => effect.Effect<
  DescribeAnalysisResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAnalysisRequest,
  output: DescribeAnalysisResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes an existing import job.
 *
 * Poll job descriptions after starting a job to know when it has succeeded or failed. Job
 * descriptions are available for 14 days after job starts.
 */
export const describeAssetBundleImportJob: (
  input: DescribeAssetBundleImportJobRequest,
) => effect.Effect<
  DescribeAssetBundleImportJobResponse,
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAssetBundleImportJobRequest,
  output: DescribeAssetBundleImportJobResponse,
  errors: [
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes the item that the specified template alias points to. If you provide a specific
 * alias, you delete the version of the template that the alias points to.
 */
export const deleteTemplateAlias: (
  input: DeleteTemplateAliasRequest,
) => effect.Effect<
  DeleteTemplateAliasResponse,
  | ConflictException
  | InternalFailureException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteTemplateAliasRequest,
  output: DeleteTemplateAliasResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the template alias of a template.
 */
export const updateTemplateAlias: (
  input: UpdateTemplateAliasRequest,
) => effect.Effect<
  UpdateTemplateAliasResponse,
  | ConflictException
  | InternalFailureException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTemplateAliasRequest,
  output: UpdateTemplateAliasResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes the template alias for a template.
 */
export const describeTemplateAlias: (
  input: DescribeTemplateAliasRequest,
) => effect.Effect<
  DescribeTemplateAliasResponse,
  | InternalFailureException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTemplateAliasRequest,
  output: DescribeTemplateAliasResponse,
  errors: [
    InternalFailureException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Provides the read and write permissions for an analysis.
 */
export const describeAnalysisPermissions: (
  input: DescribeAnalysisPermissionsRequest,
) => effect.Effect<
  DescribeAnalysisPermissionsResponse,
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAnalysisPermissionsRequest,
  output: DescribeAnalysisPermissionsResponse,
  errors: [
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Lists Amazon Quick Sight analyses that exist in the specified Amazon Web Services account.
 */
export const listAnalyses: {
  (
    input: ListAnalysesRequest,
  ): effect.Effect<
    ListAnalysesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAnalysesRequest,
  ) => stream.Stream<
    ListAnalysesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAnalysesRequest,
  ) => stream.Stream<
    AnalysisSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAnalysesRequest,
  output: ListAnalysesResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AnalysisSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all asset bundle export jobs that have been taken place in the last 14 days. Jobs
 * created more than 14 days ago are deleted forever and are not returned. If you are using
 * the same job ID for multiple jobs, `ListAssetBundleExportJobs` only returns the
 * most recent job that uses the repeated job ID.
 */
export const listAssetBundleExportJobs: {
  (
    input: ListAssetBundleExportJobsRequest,
  ): effect.Effect<
    ListAssetBundleExportJobsResponse,
    | AccessDeniedException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAssetBundleExportJobsRequest,
  ) => stream.Stream<
    ListAssetBundleExportJobsResponse,
    | AccessDeniedException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAssetBundleExportJobsRequest,
  ) => stream.Stream<
    AssetBundleExportJobSummary,
    | AccessDeniedException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAssetBundleExportJobsRequest,
  output: ListAssetBundleExportJobsResponse,
  errors: [
    AccessDeniedException,
    InvalidNextTokenException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AssetBundleExportJobSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all asset bundle import jobs that have taken place in the last 14 days. Jobs
 * created more than 14 days ago are deleted forever and are not returned. If you are using
 * the same job ID for multiple jobs, `ListAssetBundleImportJobs` only returns the
 * most recent job that uses the repeated job ID.
 */
export const listAssetBundleImportJobs: {
  (
    input: ListAssetBundleImportJobsRequest,
  ): effect.Effect<
    ListAssetBundleImportJobsResponse,
    | AccessDeniedException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListAssetBundleImportJobsRequest,
  ) => stream.Stream<
    ListAssetBundleImportJobsResponse,
    | AccessDeniedException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListAssetBundleImportJobsRequest,
  ) => stream.Stream<
    AssetBundleImportJobSummary,
    | AccessDeniedException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListAssetBundleImportJobsRequest,
  output: ListAssetBundleImportJobsResponse,
  errors: [
    AccessDeniedException,
    InvalidNextTokenException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AssetBundleImportJobSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists dashboards in an Amazon Web Services account.
 */
export const listDashboards: {
  (
    input: ListDashboardsRequest,
  ): effect.Effect<
    ListDashboardsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDashboardsRequest,
  ) => stream.Stream<
    ListDashboardsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDashboardsRequest,
  ) => stream.Stream<
    DashboardSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDashboardsRequest,
  output: ListDashboardsResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DashboardSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all the versions of the dashboards in the Amazon Quick Sight subscription.
 */
export const listDashboardVersions: {
  (
    input: ListDashboardVersionsRequest,
  ): effect.Effect<
    ListDashboardVersionsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListDashboardVersionsRequest,
  ) => stream.Stream<
    ListDashboardVersionsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListDashboardVersionsRequest,
  ) => stream.Stream<
    DashboardVersionSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListDashboardVersionsRequest,
  output: ListDashboardVersionsResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DashboardVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List all assets (`DASHBOARD`, `ANALYSIS`, and `DATASET`) in a folder.
 */
export const listFolderMembers: {
  (
    input: ListFolderMembersRequest,
  ): effect.Effect<
    ListFolderMembersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListFolderMembersRequest,
  ) => stream.Stream<
    ListFolderMembersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFolderMembersRequest,
  ) => stream.Stream<
    MemberIdArnPair,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFolderMembersRequest,
  output: ListFolderMembersResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FolderMemberList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all folders in an account.
 */
export const listFolders: {
  (
    input: ListFoldersRequest,
  ): effect.Effect<
    ListFoldersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListFoldersRequest,
  ) => stream.Stream<
    ListFoldersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFoldersRequest,
  ) => stream.Stream<
    FolderSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFoldersRequest,
  output: ListFoldersResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FolderSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all the templates in the current Amazon Quick Sight account.
 */
export const listTemplates: {
  (
    input: ListTemplatesRequest,
  ): effect.Effect<
    ListTemplatesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTemplatesRequest,
  ) => stream.Stream<
    ListTemplatesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTemplatesRequest,
  ) => stream.Stream<
    TemplateSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTemplatesRequest,
  output: ListTemplatesResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TemplateSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all the versions of the templates in the current Amazon Quick Sight account.
 */
export const listTemplateVersions: {
  (
    input: ListTemplateVersionsRequest,
  ): effect.Effect<
    ListTemplateVersionsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTemplateVersionsRequest,
  ) => stream.Stream<
    ListTemplateVersionsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTemplateVersionsRequest,
  ) => stream.Stream<
    TemplateVersionSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTemplateVersionsRequest,
  output: ListTemplateVersionsResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TemplateVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all the themes in the current Amazon Web Services account.
 */
export const listThemes: {
  (
    input: ListThemesRequest,
  ): effect.Effect<
    ListThemesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListThemesRequest,
  ) => stream.Stream<
    ListThemesResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListThemesRequest,
  ) => stream.Stream<
    ThemeSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListThemesRequest,
  output: ListThemesResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ThemeSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all the versions of the themes in the current Amazon Web Services account.
 */
export const listThemeVersions: {
  (
    input: ListThemeVersionsRequest,
  ): effect.Effect<
    ListThemeVersionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListThemeVersionsRequest,
  ) => stream.Stream<
    ListThemeVersionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListThemeVersionsRequest,
  ) => stream.Stream<
    ThemeVersionSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListThemeVersionsRequest,
  output: ListThemeVersionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "ThemeVersionSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all of the VPC connections in the current set Amazon Web Services Region of an
 * Amazon Web Services account.
 */
export const listVPCConnections: {
  (
    input: ListVPCConnectionsRequest,
  ): effect.Effect<
    ListVPCConnectionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListVPCConnectionsRequest,
  ) => stream.Stream<
    ListVPCConnectionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListVPCConnectionsRequest,
  ) => stream.Stream<
    unknown,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListVPCConnectionsRequest,
  output: ListVPCConnectionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for analyses that belong to the user specified in the filter.
 *
 * This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.
 */
export const searchAnalyses: {
  (
    input: SearchAnalysesRequest,
  ): effect.Effect<
    SearchAnalysesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchAnalysesRequest,
  ) => stream.Stream<
    SearchAnalysesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchAnalysesRequest,
  ) => stream.Stream<
    AnalysisSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchAnalysesRequest,
  output: SearchAnalysesResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "AnalysisSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for dashboards that belong to a user.
 *
 * This operation is eventually consistent. The results are best effort and may not
 * reflect very recent updates and changes.
 */
export const searchDashboards: {
  (
    input: SearchDashboardsRequest,
  ): effect.Effect<
    SearchDashboardsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchDashboardsRequest,
  ) => stream.Stream<
    SearchDashboardsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchDashboardsRequest,
  ) => stream.Stream<
    DashboardSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchDashboardsRequest,
  output: SearchDashboardsResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "DashboardSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Searches for any Q topic that exists in an Quick Suite account.
 */
export const searchTopics: {
  (
    input: SearchTopicsRequest,
  ): effect.Effect<
    SearchTopicsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchTopicsRequest,
  ) => stream.Stream<
    SearchTopicsResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchTopicsRequest,
  ) => stream.Stream<
    TopicSummary,
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchTopicsRequest,
  output: SearchTopicsResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TopicSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Describes permissions for a folder.
 */
export const describeFolderPermissions: {
  (
    input: DescribeFolderPermissionsRequest,
  ): effect.Effect<
    DescribeFolderPermissionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: DescribeFolderPermissionsRequest,
  ) => stream.Stream<
    DescribeFolderPermissionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: DescribeFolderPermissionsRequest,
  ) => stream.Stream<
    ResourcePermission,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeFolderPermissionsRequest,
  output: DescribeFolderPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Permissions",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Describes the folder resolved permissions. Permissions consists of both folder direct permissions and the inherited permissions from the ancestor folders.
 */
export const describeFolderResolvedPermissions: {
  (
    input: DescribeFolderResolvedPermissionsRequest,
  ): effect.Effect<
    DescribeFolderResolvedPermissionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: DescribeFolderResolvedPermissionsRequest,
  ) => stream.Stream<
    DescribeFolderResolvedPermissionsResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: DescribeFolderResolvedPermissionsRequest,
  ) => stream.Stream<
    ResourcePermission,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: DescribeFolderResolvedPermissionsRequest,
  output: DescribeFolderResolvedPermissionsResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Permissions",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * List all folders that a resource is a member of.
 */
export const listFoldersForResource: {
  (
    input: ListFoldersForResourceRequest,
  ): effect.Effect<
    ListFoldersForResourceResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListFoldersForResourceRequest,
  ) => stream.Stream<
    ListFoldersForResourceResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListFoldersForResourceRequest,
  ) => stream.Stream<
    Arn,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListFoldersForResourceRequest,
  output: ListFoldersForResourceResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "Folders",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Lists all the aliases of a theme.
 */
export const listThemeAliases: (
  input: ListThemeAliasesRequest,
) => effect.Effect<
  ListThemeAliasesResponse,
  | ConflictException
  | InternalFailureException
  | InvalidNextTokenException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: ListThemeAliasesRequest,
  output: ListThemeAliasesResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Lists all the aliases of a template.
 */
export const listTemplateAliases: {
  (
    input: ListTemplateAliasesRequest,
  ): effect.Effect<
    ListTemplateAliasesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: ListTemplateAliasesRequest,
  ) => stream.Stream<
    ListTemplateAliasesResponse,
    | InternalFailureException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: ListTemplateAliasesRequest,
  ) => stream.Stream<
    TemplateAlias,
    | InternalFailureException
    | InvalidNextTokenException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: ListTemplateAliasesRequest,
  output: ListTemplateAliasesResponse,
  errors: [
    InternalFailureException,
    InvalidNextTokenException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "TemplateAliasList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Starts an Asset Bundle export job.
 *
 * An Asset Bundle export job exports specified Amazon Quick Sight assets. You can also choose to
 * export any asset dependencies in the same job. Export jobs run asynchronously and can be
 * polled with a `DescribeAssetBundleExportJob` API call. When a job is
 * successfully completed, a download URL that contains the exported assets is returned. The
 * URL is valid for 5 minutes and can be refreshed with a
 * `DescribeAssetBundleExportJob` API call. Each Amazon Quick Sight account can
 * run up to 5 export jobs concurrently.
 *
 * The API caller must have the necessary permissions in their IAM role to
 * access each resource before the resources can be exported.
 */
export const startAssetBundleExportJob: (
  input: StartAssetBundleExportJobRequest,
) => effect.Effect<
  StartAssetBundleExportJobResponse,
  | AccessDeniedException
  | ConflictException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartAssetBundleExportJobRequest,
  output: StartAssetBundleExportJobResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates a dataset. This operation doesn't support datasets that include uploaded files
 * as a source. Partial updates are not supported by this operation.
 */
export const updateDataSet: (
  input: UpdateDataSetRequest,
) => effect.Effect<
  UpdateDataSetResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidDataSetParameterValueException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateDataSetRequest,
  output: UpdateDataSetResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidDataSetParameterValueException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Describes a template's metadata.
 */
export const describeTemplate: (
  input: DescribeTemplateRequest,
) => effect.Effect<
  DescribeTemplateResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTemplateRequest,
  output: DescribeTemplateResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates a template alias for a template.
 */
export const createTemplateAlias: (
  input: CreateTemplateAliasRequest,
) => effect.Effect<
  CreateTemplateAliasResponse,
  | ConflictException
  | InternalFailureException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTemplateAliasRequest,
  output: CreateTemplateAliasResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Provides a detailed description of the definition of a dashboard.
 *
 * If you do not need to know details about the content of a dashboard, for instance
 * if you are trying to check the status of a recently created or updated dashboard,
 * use the
 * `DescribeDashboard`
 * instead.
 */
export const describeDashboardDefinition: (
  input: DescribeDashboardDefinitionRequest,
) => effect.Effect<
  DescribeDashboardDefinitionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDashboardDefinitionRequest,
  output: DescribeDashboardDefinitionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Provides a detailed description of the definition of a template.
 *
 * If you do not need to know details about the content of a template, for instance if you
 * are trying to check the status of a recently created or updated template, use the
 *
 * `DescribeTemplate`
 * instead.
 */
export const describeTemplateDefinition: (
  input: DescribeTemplateDefinitionRequest,
) => effect.Effect<
  DescribeTemplateDefinitionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeTemplateDefinitionRequest,
  output: DescribeTemplateDefinitionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates an empty shared folder.
 */
export const createFolder: (
  input: CreateFolderRequest,
) => effect.Effect<
  CreateFolderResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateFolderRequest,
  output: CreateFolderResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates a new VPC connection.
 */
export const createVPCConnection: (
  input: CreateVPCConnectionRequest,
) => effect.Effect<
  CreateVPCConnectionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateVPCConnectionRequest,
  output: CreateVPCConnectionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates the name of a folder.
 */
export const updateFolder: (
  input: UpdateFolderRequest,
) => effect.Effect<
  UpdateFolderResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateFolderRequest,
  output: UpdateFolderResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates a theme.
 */
export const updateTheme: (
  input: UpdateThemeRequest,
) => effect.Effect<
  UpdateThemeResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateThemeRequest,
  output: UpdateThemeResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates an analysis in Amazon Quick Sight
 */
export const updateAnalysis: (
  input: UpdateAnalysisRequest,
) => effect.Effect<
  UpdateAnalysisResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateAnalysisRequest,
  output: UpdateAnalysisResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates a template from an existing Amazon Quick Sight analysis or another template.
 */
export const updateTemplate: (
  input: UpdateTemplateRequest,
) => effect.Effect<
  UpdateTemplateResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateTemplateRequest,
  output: UpdateTemplateResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Updates an alias of a theme.
 */
export const updateThemeAlias: (
  input: UpdateThemeAliasRequest,
) => effect.Effect<
  UpdateThemeAliasResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: UpdateThemeAliasRequest,
  output: UpdateThemeAliasResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates a theme alias for a theme.
 */
export const createThemeAlias: (
  input: CreateThemeAliasRequest,
) => effect.Effect<
  CreateThemeAliasResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateThemeAliasRequest,
  output: CreateThemeAliasResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Adds an asset, such as a dashboard, analysis, or dataset into a folder.
 */
export const createFolderMembership: (
  input: CreateFolderMembershipRequest,
) => effect.Effect<
  CreateFolderMembershipResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateFolderMembershipRequest,
  output: CreateFolderMembershipResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Provides a detailed description of the definition of an analysis.
 *
 * If you do not need to know details about the content of an Analysis, for instance if you
 * are trying to check the status of a recently created or updated Analysis, use the
 *
 * `DescribeAnalysis`
 * instead.
 */
export const describeAnalysisDefinition: (
  input: DescribeAnalysisDefinitionRequest,
) => effect.Effect<
  DescribeAnalysisDefinitionResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeAnalysisDefinitionRequest,
  output: DescribeAnalysisDefinitionResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates a dashboard from either a template or directly with a
 * `DashboardDefinition`. To first create a template, see the
 * CreateTemplate
 * API operation.
 *
 * A dashboard is an entity in Amazon Quick Sight that identifies Amazon Quick Sight
 * reports, created from analyses. You can share Amazon Quick Sight dashboards. With the
 * right permissions, you can create scheduled email reports from them. If you have the
 * correct permissions, you can create a dashboard from a template that exists in a
 * different Amazon Web Services account.
 */
export const createDashboard: (
  input: CreateDashboardRequest,
) => effect.Effect<
  CreateDashboardResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDashboardRequest,
  output: CreateDashboardResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Deletes an empty folder.
 */
export const deleteFolder: (
  input: DeleteFolderRequest,
) => effect.Effect<
  DeleteFolderResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DeleteFolderRequest,
  output: DeleteFolderResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Restores an analysis.
 */
export const restoreAnalysis: (
  input: RestoreAnalysisRequest,
) => effect.Effect<
  RestoreAnalysisResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: RestoreAnalysisRequest,
  output: RestoreAnalysisResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Searches the subfolders in a folder.
 */
export const searchFolders: {
  (
    input: SearchFoldersRequest,
  ): effect.Effect<
    SearchFoldersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  pages: (
    input: SearchFoldersRequest,
  ) => stream.Stream<
    SearchFoldersResponse,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
  items: (
    input: SearchFoldersRequest,
  ) => stream.Stream<
    FolderSummary,
    | AccessDeniedException
    | InternalFailureException
    | InvalidNextTokenException
    | InvalidParameterValueException
    | InvalidRequestException
    | ResourceNotFoundException
    | ThrottlingException
    | UnsupportedUserEditionException
    | CommonErrors,
    Credentials | Region | HttpClient.HttpClient
  >;
} = /*@__PURE__*/ /*#__PURE__*/ API.makePaginated(() => ({
  input: SearchFoldersRequest,
  output: SearchFoldersResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidNextTokenException,
    InvalidParameterValueException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
  pagination: {
    inputToken: "NextToken",
    outputToken: "NextToken",
    items: "FolderSummaryList",
    pageSize: "MaxResults",
  } as const,
}));
/**
 * Creates a template either from a `TemplateDefinition` or from an existing Quick Sight analysis or template. You can use the resulting
 * template to create additional dashboards, templates, or analyses.
 *
 * A *template* is an entity in Quick Sight that encapsulates the metadata
 * required to create an analysis and that you can use to create s dashboard. A template adds
 * a layer of abstraction by using placeholders to replace the dataset associated with the
 * analysis. You can use templates to create dashboards by replacing dataset placeholders
 * with datasets that follow the same schema that was used to create the source analysis
 * and template.
 */
export const createTemplate: (
  input: CreateTemplateRequest,
) => effect.Effect<
  CreateTemplateResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTemplateRequest,
  output: CreateTemplateResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates a theme.
 *
 * A *theme* is set of configuration options for color and layout.
 * Themes apply to analyses and dashboards. For more information, see Using
 * Themes in Amazon Quick Sight in the *Amazon Quick Sight User Guide*.
 */
export const createTheme: (
  input: CreateThemeRequest,
) => effect.Effect<
  CreateThemeResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateThemeRequest,
  output: CreateThemeResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Generates a session URL and authorization code that you can use to embed the Amazon
 * Amazon Quick Sight console in your web server code. Use
 * `GetSessionEmbedUrl` where you want to provide an authoring portal that
 * allows users to create data sources, datasets, analyses, and dashboards. The users who
 * access an embedded Amazon Quick Sight console need belong to the author or admin security
 * cohort. If you want to restrict permissions to some of these features, add a custom
 * permissions profile to the user with the
 * UpdateUser
 * API operation. Use
 * RegisterUser
 * API operation to add a new user with a custom
 * permission profile attached. For more information, see the following sections in the
 * *Amazon Quick Suite User Guide*:
 *
 * - Embedding
 * Analytics
 *
 * - Customizing Access to the Amazon Quick Suite Console
 */
export const getSessionEmbedUrl: (
  input: GetSessionEmbedUrlRequest,
) => effect.Effect<
  GetSessionEmbedUrlResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | QuickSightUserNotFoundException
  | ResourceExistsException
  | ResourceNotFoundException
  | SessionLifetimeInMinutesInvalidException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetSessionEmbedUrlRequest,
  output: GetSessionEmbedUrlResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    QuickSightUserNotFoundException,
    ResourceExistsException,
    ResourceNotFoundException,
    SessionLifetimeInMinutesInvalidException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Generates a temporary session URL and authorization code(bearer token) that you can
 * use to embed an Amazon Quick Sight read-only dashboard in your website or application.
 * Before you use this command, make sure that you have configured the dashboards and
 * permissions.
 *
 * Currently, you can use `GetDashboardEmbedURL` only from the server, not
 * from the user's browser. The following rules apply to the generated URL:
 *
 * - They must be used together.
 *
 * - They can be used one time only.
 *
 * - They are valid for 5 minutes after you run this command.
 *
 * - You are charged only when the URL is used or there is interaction with Quick Suite.
 *
 * - The resulting user session is valid for 15 minutes (default) up to 10 hours
 * (maximum). You can use the optional `SessionLifetimeInMinutes`
 * parameter to customize session duration.
 *
 * For more information, see Embedding Analytics
 * Using GetDashboardEmbedUrl in the Amazon Quick Suite User
 * Guide.
 *
 * For more information about the high-level steps for embedding and for an interactive
 * demo of the ways you can customize embedding, visit the Amazon Quick Suite
 * Developer Portal.
 */
export const getDashboardEmbedUrl: (
  input: GetDashboardEmbedUrlRequest,
) => effect.Effect<
  GetDashboardEmbedUrlResponse,
  | AccessDeniedException
  | DomainNotWhitelistedException
  | IdentityTypeNotSupportedException
  | InternalFailureException
  | InvalidParameterValueException
  | QuickSightUserNotFoundException
  | ResourceExistsException
  | ResourceNotFoundException
  | SessionLifetimeInMinutesInvalidException
  | ThrottlingException
  | UnsupportedPricingPlanException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GetDashboardEmbedUrlRequest,
  output: GetDashboardEmbedUrlResponse,
  errors: [
    AccessDeniedException,
    DomainNotWhitelistedException,
    IdentityTypeNotSupportedException,
    InternalFailureException,
    InvalidParameterValueException,
    QuickSightUserNotFoundException,
    ResourceExistsException,
    ResourceNotFoundException,
    SessionLifetimeInMinutesInvalidException,
    ThrottlingException,
    UnsupportedPricingPlanException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Generates an embed URL that you can use to embed an Amazon Quick Suite dashboard or
 * visual in your website, without having to register any reader users. Before you use this
 * action, make sure that you have configured the dashboards and permissions.
 *
 * The following rules apply to the generated URL:
 *
 * - It contains a temporary bearer token. It is valid for 5 minutes after it is
 * generated. Once redeemed within this period, it cannot be re-used again.
 *
 * - The URL validity period should not be confused with the actual session
 * lifetime that can be customized using the
 * SessionLifetimeInMinutes
 * parameter. The resulting user
 * session is valid for 15 minutes (minimum) to 10 hours (maximum). The default
 * session duration is 10 hours.
 *
 * - You are charged only when the URL is used or there is interaction with Amazon Quick Suite.
 *
 * For more information, see Embedded Analytics in
 * the *Amazon Quick Suite User Guide*.
 *
 * For more information about the high-level steps for embedding and for an interactive
 * demo of the ways you can customize embedding, visit the Amazon Quick Suite
 * Developer Portal.
 */
export const generateEmbedUrlForAnonymousUser: (
  input: GenerateEmbedUrlForAnonymousUserRequest,
) => effect.Effect<
  GenerateEmbedUrlForAnonymousUserResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | SessionLifetimeInMinutesInvalidException
  | ThrottlingException
  | UnsupportedPricingPlanException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GenerateEmbedUrlForAnonymousUserRequest,
  output: GenerateEmbedUrlForAnonymousUserResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    SessionLifetimeInMinutesInvalidException,
    ThrottlingException,
    UnsupportedPricingPlanException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Starts an asynchronous job that generates a snapshot of a dashboard's output. You can request one or several of the following format configurations in each API call.
 *
 * - 1 Paginated PDF
 *
 * - 1 Excel workbook that includes up to 5 table or pivot table visuals
 *
 * - 5 CSVs from table or pivot table visuals
 *
 * The status of a submitted job can be polled with the `DescribeDashboardSnapshotJob` API. When you call the `DescribeDashboardSnapshotJob` API, check the `JobStatus` field in the response. Once the job reaches a `COMPLETED` or `FAILED` status, use the `DescribeDashboardSnapshotJobResult` API to obtain the URLs for the generated files. If the job fails, the `DescribeDashboardSnapshotJobResult` API returns detailed information about the error that occurred.
 *
 * **StartDashboardSnapshotJob API throttling**
 *
 * Quick Sight utilizes API throttling to create a more consistent user experience within a time span for customers when they call the `StartDashboardSnapshotJob`. By default, 12 jobs can run simlutaneously in one Amazon Web Services account and users can submit up 10 API requests per second before an account is throttled. If an overwhelming number of API requests are made by the same user in a short period of time, Quick Sight throttles the API calls to maintin an optimal experience and reliability for all Quick Sight users.
 *
 * **Common throttling scenarios**
 *
 * The following list provides information about the most commin throttling scenarios that can occur.
 *
 * - **A large number of `SnapshotExport` API jobs are running simultaneously on an Amazon Web Services account.** When a new `StartDashboardSnapshotJob` is created and there are already 12 jobs with the `RUNNING` status, the new job request fails and returns a `LimitExceededException` error. Wait for a current job to comlpete before you resubmit the new job.
 *
 * - **A large number of API requests are submitted on an Amazon Web Services account.** When a user makes more than 10 API calls to the Quick Sight API in one second, a `ThrottlingException` is returned.
 *
 * If your use case requires a higher throttling limit, contact your account admin or Amazon Web ServicesSupport to explore options to tailor a more optimal expereince for your account.
 *
 * **Best practices to handle throttling**
 *
 * If your use case projects high levels of API traffic, try to reduce the degree of frequency and parallelism of API calls as much as you can to avoid throttling. You can also perform a timing test to calculate an estimate for the total processing time of your projected load that stays within the throttling limits of the Quick Sight APIs. For example, if your projected traffic is 100 snapshot jobs before 12:00 PM per day, start 12 jobs in parallel and measure the amount of time it takes to proccess all 12 jobs. Once you obtain the result, multiply the duration by 9, for example `(12 minutes * 9 = 108 minutes)`. Use the new result to determine the latest time at which the jobs need to be started to meet your target deadline.
 *
 * The time that it takes to process a job can be impacted by the following factors:
 *
 * - The dataset type (Direct Query or SPICE).
 *
 * - The size of the dataset.
 *
 * - The complexity of the calculated fields that are used in the dashboard.
 *
 * - The number of visuals that are on a sheet.
 *
 * - The types of visuals that are on the sheet.
 *
 * - The number of formats and snapshots that are requested in the job configuration.
 *
 * - The size of the generated snapshots.
 *
 * **Registered user support**
 *
 * You can generate snapshots for registered Quick Sight users by using the Snapshot Job APIs with identity-enhanced IAM role session credentials. This approach allows you to create snapshots on behalf of specific Quick Sight users while respecting their row-level security (RLS), column-level security (CLS), dynamic default parameters and dashboard parameter/filter settings.
 *
 * To generate snapshots for registered Quick Sight users, you need to:
 *
 * - Obtain identity-enhanced IAM role session credentials from Amazon Web Services Security Token Service (STS).
 *
 * - Use these credentials to call the Snapshot Job APIs.
 *
 * Identity-enhanced credentials are credentials that contain information about the end user (e.g., registered Quick Sight user).
 *
 * If your Quick Sight users are backed by Amazon Web Services Identity Center, then you need to set up a trusted token issuer. Then, getting identity-enhanced IAM credentials for a Quick Sight user will look like the following:
 *
 * - Authenticate user with your OIDC compliant Identity Provider. You should get auth tokens back.
 *
 * - Use the OIDC API, CreateTokenWithIAM, to exchange auth tokens to IAM tokens. One of the resulted tokens will be identity token.
 *
 * - Call STS AssumeRole API as you normally would, but provide an extra `ProvidedContexts` parameter in the API request. The list of contexts must have a single trusted context assertion. The `ProviderArn` should be `arn:aws:iam::aws:contextProvider/IdentityCenter` while `ContextAssertion` will be the identity token you received in response from CreateTokenWithIAM
 *
 * For more details, see IdC documentation on Identity-enhanced IAM role sessions.
 *
 * To obtain Identity-enhanced credentials for Quick Sight native users, IAM federated users, or Active Directory users, follow the steps below:
 *
 * - Call Quick Sight GetIdentityContext API to get identity token.
 *
 * - Call STS AssumeRole API as you normally would, but provide extra `ProvidedContexts` parameter in the API request. The list of contexts must have a single trusted context assertion. The `ProviderArn` should be `arn:aws:iam::aws:contextProvider/QuickSight` while `ContextAssertion` will be the identity token you received in response from GetIdentityContext
 *
 * After obtaining the identity-enhanced IAM role session credentials, you can use them to start a job, describe the job and describe job result. You can use the same credentials as long as they haven't expired. All API requests made with these credentials are considered to be made by the impersonated Quick Sight user.
 *
 * When using identity-enhanced session credentials, set the UserConfiguration request attribute to null. Otherwise, the request will be invalid.
 *
 * **Possible error scenarios**
 *
 * The request fails with an Access Denied error in the following scenarios:
 *
 * - The credentials have expired.
 *
 * - The impersonated Quick Sight user doesn't have access to the specified dashboard.
 *
 * - The impersonated Quick Sight user is restricted from exporting data in the selected formats. For more information about export restrictions, see Customizing access to Amazon Quick Sight capabilities.
 */
export const startDashboardSnapshotJob: (
  input: StartDashboardSnapshotJobRequest,
) => effect.Effect<
  StartDashboardSnapshotJobResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedPricingPlanException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: StartDashboardSnapshotJobRequest,
  output: StartDashboardSnapshotJobResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedPricingPlanException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Generates an embed URL that you can use to embed an Amazon Quick Sight experience in
 * your website. This action can be used for any type of user that is registered in an
 * Amazon Quick Sight account that uses IAM Identity Center for authentication. This API
 * requires identity-enhanced IAM Role sessions for the authenticated
 * user that the API call is being made for.
 *
 * This API uses trusted identity
 * propagation to ensure that an end user is authenticated and receives the
 * embed URL that is specific to that user. The IAM Identity Center application that the
 * user has logged into needs to have trusted Identity Propagation enabled for Amazon Quick Sight with the scope
 * value set to `quicksight:read`. Before you use this action, make sure that
 * you have configured the relevant Amazon Quick Sight resource and permissions.
 */
export const generateEmbedUrlForRegisteredUserWithIdentity: (
  input: GenerateEmbedUrlForRegisteredUserWithIdentityRequest,
) => effect.Effect<
  GenerateEmbedUrlForRegisteredUserWithIdentityResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | QuickSightUserNotFoundException
  | ResourceNotFoundException
  | SessionLifetimeInMinutesInvalidException
  | ThrottlingException
  | UnsupportedPricingPlanException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GenerateEmbedUrlForRegisteredUserWithIdentityRequest,
  output: GenerateEmbedUrlForRegisteredUserWithIdentityResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    QuickSightUserNotFoundException,
    ResourceNotFoundException,
    SessionLifetimeInMinutesInvalidException,
    ThrottlingException,
    UnsupportedPricingPlanException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates new reviewed answers for a Q Topic.
 */
export const batchCreateTopicReviewedAnswer: (
  input: BatchCreateTopicReviewedAnswerRequest,
) => effect.Effect<
  BatchCreateTopicReviewedAnswerResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: BatchCreateTopicReviewedAnswerRequest,
  output: BatchCreateTopicReviewedAnswerResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates an action connector that enables Amazon Quick Sight to connect to external services and perform actions.
 * Action connectors support various authentication methods and can be configured with specific actions from supported connector types
 * like Amazon S3, Salesforce, JIRA.
 */
export const createActionConnector: (
  input: CreateActionConnectorRequest,
) => effect.Effect<
  CreateActionConnectorResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceExistsException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateActionConnectorRequest,
  output: CreateActionConnectorResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceExistsException,
    ThrottlingException,
  ],
}));
/**
 * Describes a brand.
 */
export const describeBrand: (
  input: DescribeBrandRequest,
) => effect.Effect<
  DescribeBrandResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeBrandRequest,
  output: DescribeBrandResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Describes the result of an existing snapshot job that has finished running.
 *
 * A finished snapshot job will return a `COMPLETED` or `FAILED` status when you poll the job with a `DescribeDashboardSnapshotJob` API call.
 *
 * If the job has not finished running, this operation returns a message that says `Dashboard Snapshot Job with id has not reached a terminal state.`.
 *
 * **Registered user support**
 *
 * This API can be called as before to get the result of a job started by the same Quick Sight user. The result for the user will be returned in `RegisteredUsers` response attribute. The attribute will contain a list with at most one object in it.
 *
 * **Possible error scenarios**
 *
 * The request fails with an Access Denied error in the following scenarios:
 *
 * - The credentials have expired.
 *
 * - The job was started by a different user.
 *
 * - The registered user doesn't have access to the specified dashboard.
 *
 * The request succeeds but the job fails in the following scenarios:
 *
 * - `DASHBOARD_ACCESS_DENIED` - The registered user lost access to the dashboard.
 *
 * - `CAPABILITY_RESTRICTED` - The registered user is restricted from exporting data in **all** selected formats.
 *
 * The request succeeds but the response contains an error code in the following scenarios:
 *
 * - `CAPABILITY_RESTRICTED` - The registered user is restricted from exporting data in **some** selected formats.
 *
 * - `RLS_CHANGED` - Row-level security settings have changed. Re-run the job with current settings.
 *
 * - `CLS_CHANGED` - Column-level security settings have changed. Re-run the job with current settings.
 *
 * - `DATASET_DELETED` - The dataset has been deleted. Verify the dataset exists before re-running the job.
 */
export const describeDashboardSnapshotJobResult: (
  input: DescribeDashboardSnapshotJobResultRequest,
) => effect.Effect<
  DescribeDashboardSnapshotJobResultResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | PreconditionNotMetException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeDashboardSnapshotJobResultRequest,
  output: DescribeDashboardSnapshotJobResultResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    PreconditionNotMetException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Generates an embed URL that you can use to embed an Amazon Quick Suite experience
 * in your website. This action can be used for any type of user registered in an Amazon Quick Suite account. Before you use this action, make sure that you have
 * configured the relevant Amazon Quick Suite resource and permissions.
 *
 * The following rules apply to the generated URL:
 *
 * - It contains a temporary bearer token. It is valid for 5 minutes after it is
 * generated. Once redeemed within this period, it cannot be re-used again.
 *
 * - The URL validity period should not be confused with the actual session
 * lifetime that can be customized using the
 * SessionLifetimeInMinutes
 * parameter.
 *
 * The resulting user session is valid for 15 minutes (minimum) to 10 hours
 * (maximum). The default session duration is 10 hours.
 *
 * - You are charged only when the URL is used or there is interaction with Amazon Quick Suite.
 *
 * For more information, see Embedded Analytics in
 * the *Amazon Quick Suite User Guide*.
 *
 * For more information about the high-level steps for embedding and for an interactive
 * demo of the ways you can customize embedding, visit the Amazon Quick Suite
 * Developer Portal.
 */
export const generateEmbedUrlForRegisteredUser: (
  input: GenerateEmbedUrlForRegisteredUserRequest,
) => effect.Effect<
  GenerateEmbedUrlForRegisteredUserResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | QuickSightUserNotFoundException
  | ResourceNotFoundException
  | SessionLifetimeInMinutesInvalidException
  | ThrottlingException
  | UnsupportedPricingPlanException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: GenerateEmbedUrlForRegisteredUserRequest,
  output: GenerateEmbedUrlForRegisteredUserResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    QuickSightUserNotFoundException,
    ResourceNotFoundException,
    SessionLifetimeInMinutesInvalidException,
    ThrottlingException,
    UnsupportedPricingPlanException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates an Quick Sight brand.
 */
export const createBrand: (
  input: CreateBrandRequest,
) => effect.Effect<
  CreateBrandResponse,
  | AccessDeniedException
  | ConflictException
  | InternalServerException
  | InvalidRequestException
  | LimitExceededException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateBrandRequest,
  output: CreateBrandResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalServerException,
    InvalidRequestException,
    LimitExceededException,
    ThrottlingException,
  ],
}));
/**
 * Creates a new Q topic.
 */
export const createTopic: (
  input: CreateTopicRequest,
) => effect.Effect<
  CreateTopicResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateTopicRequest,
  output: CreateTopicResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Retrieves detailed information about an action connector, including its configuration, authentication settings, enabled actions, and current status.
 */
export const describeActionConnector: (
  input: DescribeActionConnectorRequest,
) => effect.Effect<
  DescribeActionConnectorResponse,
  | AccessDeniedException
  | InternalFailureException
  | InvalidParameterValueException
  | ResourceNotFoundException
  | ThrottlingException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: DescribeActionConnectorRequest,
  output: DescribeActionConnectorResponse,
  errors: [
    AccessDeniedException,
    InternalFailureException,
    InvalidParameterValueException,
    ResourceNotFoundException,
    ThrottlingException,
  ],
}));
/**
 * Creates a dataset. This operation doesn't support datasets that include uploaded files
 * as a source.
 */
export const createDataSet: (
  input: CreateDataSetRequest,
) => effect.Effect<
  CreateDataSetResponse,
  | AccessDeniedException
  | ConflictException
  | InternalFailureException
  | InvalidDataSetParameterValueException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateDataSetRequest,
  output: CreateDataSetResponse,
  errors: [
    AccessDeniedException,
    ConflictException,
    InternalFailureException,
    InvalidDataSetParameterValueException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
/**
 * Creates an analysis in Amazon Quick Sight. Analyses can be created either from a template or from an `AnalysisDefinition`.
 */
export const createAnalysis: (
  input: CreateAnalysisRequest,
) => effect.Effect<
  CreateAnalysisResponse,
  | ConflictException
  | InternalFailureException
  | InvalidParameterValueException
  | LimitExceededException
  | ResourceExistsException
  | ResourceNotFoundException
  | ThrottlingException
  | UnsupportedUserEditionException
  | CommonErrors,
  Credentials | Region | HttpClient.HttpClient
> = /*@__PURE__*/ /*#__PURE__*/ API.make(() => ({
  input: CreateAnalysisRequest,
  output: CreateAnalysisResponse,
  errors: [
    ConflictException,
    InternalFailureException,
    InvalidParameterValueException,
    LimitExceededException,
    ResourceExistsException,
    ResourceNotFoundException,
    ThrottlingException,
    UnsupportedUserEditionException,
  ],
}));
