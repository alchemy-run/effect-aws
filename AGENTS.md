Generate a new client with a script like
bun generate --sdk s3

To run the s3 tests:
bun test:local ./test/services/s3.test.ts

To run all service tests:
bun test:local ./test/services/

To run the Protocol tests:
bun test:protocols

To run a single protocol test suite:
bun vitest run ./test/protocols/aws-json-1.0.test.ts

If it is unclear what the XML format for an AWS API is, look up the AWS API reference for that operation.

When asked to explore the smithy models, use `bun -e` to evaluate inline Javascript that loads the JSON in aws-models/models/{service}/{version}.json. the models are too big to load into context. Stick to boring async APIs when using bun -e. Don't bother writing effect just to load, parse and explore JSON files. Use ESM syntax always.

Protocol tests must import and use generated request/output classes from ./src/services/*.ts. instead of re-defining them.

We aim to be 1:1 with smithy - all smithy traits make their way into generated code as traits piped to a schema.

The root API client is in [src/api.ts](./src/api.ts).
Which makes use of [request-builder](./src/request-builder.ts) and [response-parser](./src/response-parser.ts).
Protocols are implemented in src/protocols/*.ts.
Protocol tests are in test/protocols/*.test.ts.
Service tests are in test/services/*.test.ts.
Services are generated by [scripts/generate-clients.ts](./scripts/generate-clients.ts) and live in [src/services/](./src/services/).
Smithy traits are implemented in [src/traits.ts](./src/traits.ts).

:::warning
Do not use random suffixes for the names of test resources. They must be deterministic. random names create mess
:::

Style:
Prefer const arrow functions over function declarations. Avoid return statements if everythign can be inlined with Effect.gen and pipe (e.g. use Effect.retry and Schedule over while loops and sleeps)

Commits:
Use conventional commits (e.g. `feat:`, `fix:`, `chore:`, `refactor:`, `docs:`, `test:`)

# Testing

Use `import { expect } from "@effect/vitest"` for assertions in service tests. Do NOT use `Effect.fail(new Error(...))` for assertions - use `expect` from `@effect/vitest` instead.

Example of the correct pattern:
```typescript
import { expect } from "@effect/vitest";
import { Effect } from "effect";
import { test } from "../test.ts";

test("example test", Effect.gen(function* () {
  const result = yield* someOperation();
  
  // ✅ Good - use expect for assertions
  expect(result.value).toBeDefined();
  expect(result.count).toEqual(3);
  expect(result.name).toBe("expected-name");
  
  // ❌ Bad - don't use Effect.fail for assertions
  // if (!result.value) {
  //   return yield* Effect.fail(new Error("Expected value to be defined"));
  // }
}));
```

# Finding Missing Errors

Use the `find:errors` script to discover undocumented or incorrectly named error codes in AWS APIs. It uses an AI agent to systematically probe AWS operations with various inputs and automatically records any newly discovered errors.

```bash
bun find:errors "<prompt>"
```

The prompt is a single string describing what to explore. The more specific the prompt, the better the agent can target edge cases. Examples:

```bash
# Explore a service broadly
bun find:errors "explore S3 errors"

# Focus on state-based errors by creating resources first
bun find:errors "create S3 buckets with objects then try to delete them to find state conflict errors"

# Test resource dependencies
bun find:errors "set up EC2 VPCs with dependent resources and try to delete them"

# Test already-exists scenarios
bun find:errors "create SQS queues then try creating them again"

# Test cross-region behavior
bun find:errors "test S3 bucket creation with different regions and LocationConstraint values"

# Test validation edge cases
bun find:errors "test DynamoDB with invalid table names and missing required fields"
```

By default, the script runs against LocalStack. To run against real AWS (requires credentials):

```bash
LIVE=1 bun find:errors "discover S3 errors"
```

The agent will:
1. List available operations for the target service
2. Examine input schemas and currently defined errors
3. Create resources to trigger state-based errors (e.g., create a bucket, then try to create it again)
4. Test with non-existent resources and invalid inputs
5. Test region-specific behavior
6. Automatically record discovered errors to `spec/{service}.json`
7. Clean up any resources it created

Discovered errors are saved to spec files (e.g., `spec/s3.json`) which can be used to patch generated clients.

# External References

1. [Smithy Docs](./smithy/docs/source-2.0/)
2. [AWS Smithy Models](./aws-models/models/)
3. [AWS SDK JS V3](./aws-sdk-js-v3/)
